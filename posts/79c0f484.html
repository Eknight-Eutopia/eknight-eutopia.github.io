<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>LKM编程 | Small Utopia</title><meta name="author" content="Eutopia"><meta name="copyright" content="Eutopia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LKM编程Chapter 1. Introduction1.1. What Is A Kernel Module?Linux系统内核：宏内核（与微内核相对），使用内核模块实现动态模块的加载运行。     简介 优点 缺点    宏内核 将进程调度核心功能，驱动程序，网络协议、文件系统都放入内核态 效率高 一个出错就崩溃   微内核 只将核心功能放在内核态，其他放在用户态以进程形式运行 驱动程序出错">
<meta property="og:type" content="article">
<meta property="og:title" content="LKM编程">
<meta property="og:url" content="https://eknight-eutopia.github.io/posts/79c0f484.html">
<meta property="og:site_name" content="Small Utopia">
<meta property="og:description" content="LKM编程Chapter 1. Introduction1.1. What Is A Kernel Module?Linux系统内核：宏内核（与微内核相对），使用内核模块实现动态模块的加载运行。     简介 优点 缺点    宏内核 将进程调度核心功能，驱动程序，网络协议、文件系统都放入内核态 效率高 一个出错就崩溃   微内核 只将核心功能放在内核态，其他放在用户态以进程形式运行 驱动程序出错">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://eknight-eutopia.github.io/img/cover/default_cover%20(27).jpg">
<meta property="article:published_time" content="2024-01-03T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-22T11:18:43.398Z">
<meta property="article:author" content="Eutopia">
<meta property="article:tag" content="内核模块">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eknight-eutopia.github.io/img/cover/default_cover%20(27).jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://eknight-eutopia.github.io/posts/79c0f484.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b2bb076b3ca994b59d55f4681f7e3427";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LKM编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-22 19:18:43'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-post"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/sitetime"><i class="fa-fw fas fa-time"></i><span> 时间轴</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Small Utopia</span></a><a class="nav-page-title" href="/"><span class="site-name">LKM编程</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-post"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/sitetime"><i class="fa-fw fas fa-time"></i><span> 时间轴</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">LKM编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-03T16:00:00.000Z" title="发表于 2024-01-04 00:00:00">2024-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-22T11:18:43.398Z" title="更新于 2024-10-22 19:18:43">2024-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>55分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="LKM编程"><a href="#LKM编程" class="headerlink" title="LKM编程"></a>LKM编程</h1><h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1. Introduction"></a>Chapter 1. Introduction</h2><h3 id="1-1-What-Is-A-Kernel-Module"><a href="#1-1-What-Is-A-Kernel-Module" class="headerlink" title="1.1. What Is A Kernel Module?"></a>1.1. What Is A Kernel Module?</h3><p><strong>Linux系统内核：</strong>宏内核（与微内核相对），使用内核模块实现动态模块的加载运行。</p>
<table>
<thead>
<tr>
<th></th>
<th>简介</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>宏内核</td>
<td>将进程调度核心功能，驱动程序，网络协议、文件系统都放入内核态</td>
<td>效率高</td>
<td>一个出错就崩溃</td>
</tr>
<tr>
<td>微内核</td>
<td>只将核心功能放在内核态，其他放在用户态以进程形式运行</td>
<td>驱动程序出错不影响内核运行</td>
<td>效率低</td>
</tr>
</tbody></table>
<p><strong>LKM：</strong>用于扩展内核的功能，运行在内核态，为ELF二进制文件，如果不使用内核模块，会导致需要给内核添加功能时只能重新编译整个内核，不是很方便。</p>
<h3 id="1-2-How-Do-Modules-Get-Into-The-Kernel"><a href="#1-2-How-Do-Modules-Get-Into-The-Kernel" class="headerlink" title="1.2. How Do Modules Get Into The Kernel?"></a>1.2. How Do Modules Get Into The Kernel?</h3><p>使用<code>lsmod</code>命令查看已经加载到内核的模块（<code>/proc/modules</code>）。</p>
<p>使用<code>modprobe</code>命令加载指定模块到内核（自动查询模块的依赖关系进行加载<code>/lib/modules/version/kernel/*/*.ko</code>）</p>
<p>使用<code>insmod</code>命令加载模块到内核，不会查询依赖关系（<code>modprobe</code>调用该命令）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insmod /lib/modules/2.6.11/kernel/fs/fat/fat.ko</span><br><span class="line">insmod /lib/modules/2.6.11/kernel/fs/msdos/msdos.ko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">modprobe msdos</span><br></pre></td></tr></table></figure>

<p><strong>华为路由器LKM列表</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@debian-mips:~# lsmod</span><br><span class="line">Module                  Size  Used by</span><br><span class="line">msdos                   7642  0 </span><br><span class="line">fat                    54395  1 msdos</span><br><span class="line">ipv6                  312786  12 </span><br><span class="line">loop                   13153  0 </span><br><span class="line">mtdchar                 7769  0 </span><br><span class="line">cfi_cmdset_0001        26278  1 </span><br><span class="line">cfi_probe               3224  0 </span><br><span class="line">gen_probe               2353  1 cfi_probe</span><br><span class="line">sg                     30552  0 </span><br><span class="line">uhci_hcd               26706  0 </span><br><span class="line">cfi_util                4778  2 cfi_cmdset_0001,cfi_probe</span><br><span class="line">ehci_hcd               49012  0 </span><br><span class="line">physmap                 2637  0 </span><br><span class="line">sr_mod                 16338  0 </span><br><span class="line">i2c_piix4               5936  0 </span><br><span class="line">mtd                    18073  6 mtdchar,cfi_cmdset_0001,physmap</span><br><span class="line">8139too                20824  0 </span><br><span class="line">psmouse                53122  0 </span><br><span class="line">usbcore               152780  3 uhci_hcd,ehci_hcd</span><br><span class="line">chipreg                 1474  2 cfi_probe,physmap</span><br><span class="line">cdrom                  38519  1 sr_mod</span><br><span class="line">i2c_core               18515  1 i2c_piix4</span><br><span class="line">8139cp                 20460  0 </span><br><span class="line">serio_raw               4416  0 </span><br><span class="line">map_funcs               1034  1 physmap</span><br><span class="line">evdev                   8808  0 </span><br><span class="line">nls_base                6015  2 fat,usbcore</span><br></pre></td></tr></table></figure>



<h2 id="Chapter2-Hello-World"><a href="#Chapter2-Hello-World" class="headerlink" title="Chapter2.Hello World"></a>Chapter2.Hello World</h2><h3 id="2-1-Hello-World-part-1-The-Simplest-Module"><a href="#2-1-Hello-World-part-1-The-Simplest-Module" class="headerlink" title="2.1. Hello, World (part 1): The Simplest Module"></a>2.1. Hello, World (part 1): The Simplest Module</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-1.c - The simplest kernel module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello world 1.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * A non 0 return means init_module failed; module can&#x27;t be loaded. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye world 1.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>必须至少有两个函数:一个名为<code>init module()</code>的“开始”(初始化)函数，它在模块被<code>insmod</code>时被调用;一个名为<code>cleanup module()</code>的“结束”(清理)函数，它在模块被<code>rmmod</code>之前被调用。</p>
<p>在内核版本2.3后可以不这么命名加载时入口函数为使用<code>module_init</code>指定入口函数，卸载时使用<code>module_exit</code>指定卸载函数。</p>
<p>【报错】：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo insmod ./hello-1.ko                                     </span><br><span class="line">insmod: ERROR: could not insert module ./hello-1.ko: Invalid module format</span><br><span class="line">~/Documents/LKM/writeup/code                                   Py base 09:24:36</span><br><span class="line">❯ sudo dmesg | grep modules</span><br><span class="line">[  715.059773] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line">[ 1165.465487] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line"></span><br><span class="line">❯ sudo insmod ./hello-1.ko                                     </span><br><span class="line">insmod: ERROR: could not insert module ./hello-1.ko: Invalid module format</span><br><span class="line">~/Documents/LKM/writeup/code                                   Py base 09:24:36</span><br><span class="line">❯ sudo dmesg | grep modules</span><br><span class="line">[  715.059773] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">solution 注：如果重装的不是<span class="built_in">uname</span> -r显示的版本，需要指定</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt remove --purge linux-headers-*</span><br><span class="line">sudo apt autoremove &amp;&amp; sudo apt autoclean</span><br><span class="line">sudo apt install linux-headers-generic</span><br></pre></td></tr></table></figure>



<h4 id="2-1-1-PrintK（）"><a href="#2-1-1-PrintK（）" class="headerlink" title="2.1.1 PrintK（）"></a>2.1.1 PrintK（）</h4><p>注：打印函数与Printf函数不同（应用程序可以调用C标准库，但内核函数一般调用自己提供的函数）</p>
<p>printk函数可以用来进行内核调试，其可以打印信息到终端或日志中，打印信息分为几个等级。</p>
<p>【附：除Printk外的一些打印内核信息的函数】</p>
<p><img src="/images/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240104200604418.png" alt="image-20240104200604418"></p>
<h3 id="2-2-编译内核模块"><a href="#2-2-编译内核模块" class="headerlink" title="2.2 编译内核模块"></a>2.2 编译内核模块</h3><p>使用Makefile进行编译</p>
<p>Makefile：指定内核源码，编译参数，编译平台</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hello-1.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>编译生成*.ko文件，即为内核模块。</p>
<p><img src="/images/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240104171023339.png" alt="image-20240104171023339"></p>
<p>使用<code>modinfo hello-1.ko</code>查看模块信息。</p>
<p><img src="/images/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240104171137803.png" alt="image-20240104171137803"></p>
<p>加载模块到内核<code>insmod ./hello-1.ko</code></p>
<h4 id="模块的加载流程"><a href="#模块的加载流程" class="headerlink" title="模块的加载流程"></a>模块的加载流程</h4><ul>
<li>驱动程序注册设备，创建系统信息（<code>/sys/class/xxx</code>）</li>
<li>注册设备使用的是模块文件名，要带.ko后缀</li>
<li>当操作已插入内核的模块时，只需使用模块名</li>
<li>udev|mdev根据注册的设备信息，创建设备节点（<code>/dev/xxx</code>）</li>
<li>所有设备节点信息存储在<code>/proc/devices</code></li>
<li>加载后会输出模块内的加载信息，通过<code>dmesg</code>查看</li>
</ul>
<h4 id="init-module系统调用流程"><a href="#init-module系统调用流程" class="headerlink" title="init_module系统调用流程"></a>init_module系统调用流程</h4><ul>
<li>不依赖C库。链接&#x2F;重定位自己完成</li>
<li>Kernel&#x2F;module.c&#x2F;init_module</li>
<li>拷贝到内核：copy_module_from_user</li>
<li>地址空间分配：layout_and_allocate</li>
<li>符号解析：simplify_symbols</li>
<li>重定位:apply_relocations</li>
<li>执行：complete_formation</li>
</ul>
<h3 id="2-3-Hello-World-part-2"><a href="#2-3-Hello-World-part-2" class="headerlink" title="2.3 Hello World (part 2)"></a>2.3 Hello World (part 2)</h3><p>可以使用<code>module_init(hello_2_init);</code> <code>module_exit(hello_2_exit);</code>函数指定入口函数和退出函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-2.c - Demonstrating the module_init() and module_exit() macros.</span></span><br><span class="line"><span class="comment"> *  This is preferred over using init_module() and cleanup_module().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_2_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 2\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_2_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_2_init);</span><br><span class="line">module_exit(hello_2_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Hello-World-part-3-init-and-exit宏定义"><a href="#2-4-Hello-World-part-3-init-and-exit宏定义" class="headerlink" title="2.4 Hello World (part 3):  __init and _exit宏定义"></a>2.4 Hello World (part 3):  __init and _exit宏定义</h3><p>__init宏导致一旦内置驱动程序的init函数完成，init函数就会被丢弃并释放其内存（对Loadable modules无效）</p>
<p>__exit宏导致函数遗漏，（对Loadable Modules无效）内置驱动程序不需要cleanup函数，但Loadable Modules需要。</p>
<p>以下代码定义了init, initdata, exit宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-3.c - Illustrating the __init, __initdata and __exit macros.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello3_data __initdata = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_3_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world %d\n&quot;</span>, hello3_data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_3_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 3\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_3_init);</span><br><span class="line">module_exit(hello_3_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>修改Makefile，编译加载内核，查看记录信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 2774.912662] Hello, world 3</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Hello-World-part-4-Licensing-and-Module-Documentation"><a href="#2-5-Hello-World-part-4-Licensing-and-Module-Documentation" class="headerlink" title="2.5 Hello World (part 4): Licensing and Module Documentation"></a>2.5 Hello World (part 4): Licensing and Module Documentation</h3><ul>
<li>Licensing：使用<code>MODULE_LICENSE()</code>宏定义。<code>GPL</code>代表模块开源免费</li>
<li>Description：使用<code>MODULE_DESCRIPTION</code>宏定义。描述模块用于做什么。</li>
<li>Author：使用<code>MODULE_AUTHOR</code>宏定义。描述作者</li>
<li>支持设备：<code>MODULE_SUPPORTED_DEVICE()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-4.c - Demonstrates module documentation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_AUTHOR <span class="string">&quot;Peter Jay Salzman &lt;p@dirac.org&gt;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_DESC   <span class="string">&quot;A sample driver&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_hello_4</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 4\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">cleanup_hello_4</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 4\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_hello_4);</span><br><span class="line">module_exit(cleanup_hello_4);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  You can use strings, like this:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Get rid of taint message by declaring code as GPL. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Or with defines, like this:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_AUTHOR(DRIVER_AUTHOR);	<span class="comment">/* Who wrote this module? */</span></span><br><span class="line">MODULE_DESCRIPTION(DRIVER_DESC);	<span class="comment">/* What does this module do */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  This module uses /dev/testdevice.  The MODULE_SUPPORTED_DEVICE macro might</span></span><br><span class="line"><span class="comment"> *  be used in the future to help automatic configuration of modules, but is </span></span><br><span class="line"><span class="comment"> *  currently unused other than for documentation purposes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_SUPPORTED_DEVICE(<span class="string">&quot;testdevice&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-6-向内核模块传递命令行参数"><a href="#2-6-向内核模块传递命令行参数" class="headerlink" title="2.6 向内核模块传递命令行参数"></a>2.6 向内核模块传递命令行参数</h3><p>需要将要传入参数的变量声明为全局变量，并且使用module_param()宏定义。运行时，insmod会将命令行参数传入。<code>./insmod mymodule.ko myvariable=5**</code></p>
<p>module_param()宏接受3个参数：变量名，类型，对应文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myint = <span class="number">3</span>;</span><br><span class="line">module_param(myint, <span class="type">int</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>数组变量格式稍有不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myintarray[<span class="number">2</span>];</span><br><span class="line">module_param_array(myintarray, <span class="type">int</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* not interested in count */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> myshortarray[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">module_parm_array(myshortarray, <span class="type">short</span>, , <span class="number">0</span>); <span class="comment">/* put count into &quot;count&quot; variable */</span></span><br></pre></td></tr></table></figure>

<p><code>MODULE_PARM_DESC()</code>记录模块接受的参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  hello-5.c - Demonstrates command line argument passing to a module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Peter Jay Salzman&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">short</span> <span class="type">int</span> myshort = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myint = <span class="number">420</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">int</span> mylong = <span class="number">9999</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mystring = <span class="string">&quot;blah&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myintArray[<span class="number">2</span>] = &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> arr_argc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * module_param(foo, int, 0000)</span></span><br><span class="line"><span class="comment"> * The first param is the parameters name</span></span><br><span class="line"><span class="comment"> * The second param is it&#x27;s data type</span></span><br><span class="line"><span class="comment"> * The final argument is the permissions bits, </span></span><br><span class="line"><span class="comment"> * for exposing parameters in sysfs (if non-zero) at a later stage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">module_param(myshort, <span class="type">short</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);</span><br><span class="line">MODULE_PARM_DESC(myshort, <span class="string">&quot;A short integer&quot;</span>);</span><br><span class="line">module_param(myint, <span class="type">int</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">MODULE_PARM_DESC(myint, <span class="string">&quot;An integer&quot;</span>);</span><br><span class="line">module_param(mylong, <span class="type">long</span>, S_IRUSR);</span><br><span class="line">MODULE_PARM_DESC(mylong, <span class="string">&quot;A long integer&quot;</span>);</span><br><span class="line">module_param(mystring, charp, <span class="number">0000</span>);</span><br><span class="line">MODULE_PARM_DESC(mystring, <span class="string">&quot;A character string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * module_param_array(name, type, num, perm);</span></span><br><span class="line"><span class="comment"> * The first param is the parameter&#x27;s (in this case the array&#x27;s) name</span></span><br><span class="line"><span class="comment"> * The second param is the data type of the elements of the array</span></span><br><span class="line"><span class="comment"> * The third argument is a pointer to the variable that will store the number </span></span><br><span class="line"><span class="comment"> * of elements of the array initialized by the user at module loading time</span></span><br><span class="line"><span class="comment"> * The fourth argument is the permission bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">module_param_array(myintArray, <span class="type">int</span>, &amp;arr_argc, <span class="number">0000</span>);</span><br><span class="line">MODULE_PARM_DESC(myintArray, <span class="string">&quot;An array of integers&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_5_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 5\n=============\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;myshort is a short integer: %hd\n&quot;</span>, myshort);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;myint is an integer: %d\n&quot;</span>, myint);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;mylong is a long integer: %ld\n&quot;</span>, mylong);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;mystring is a string: %s\n&quot;</span>, mystring);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span> myintArray / <span class="keyword">sizeof</span> (<span class="type">int</span>)); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;myintArray[%d] = %d\n&quot;</span>, i, myintArray[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;got %d arguments for myintArray.\n&quot;</span>, arr_argc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_5_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 5\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_5_init);</span><br><span class="line">module_exit(hello_5_exit);</span><br></pre></td></tr></table></figure>

<p>编译生成的模块<code>hello_5</code>基本信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">modinfo hello-5.ko</span><br><span class="line">filename:       /home/bronya/Documents/LKM/writeup/code/hello-5.ko</span><br><span class="line">author:         Peter Jay Salzman</span><br><span class="line">license:        GPL</span><br><span class="line">srcversion:     A704327C32F7F311666C13C</span><br><span class="line">depends:        </span><br><span class="line">retpoline:      Y</span><br><span class="line">name:           hello_5</span><br><span class="line">vermagic:       6.2.0-37-generic SMP preempt mod_unload modversions </span><br><span class="line">parm:           myshort:A short integer (short)</span><br><span class="line">parm:           myint:An integer (int)</span><br><span class="line">parm:           mylong:A long integer (long)</span><br><span class="line">parm:           mystring:A character string (charp)</span><br><span class="line">parm:           myintArray:An array of integers (array of int)</span><br></pre></td></tr></table></figure>

<p>加载模块显示信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[ 4659.140006] hello_5: unknown parameter &#x27;mybyte&#x27; ignored</span><br><span class="line">[ 4659.140047] Hello, world 5</span><br><span class="line">               =============</span><br><span class="line">[ 4659.140048] myshort is a short integer: 1</span><br><span class="line">[ 4659.140049] myint is an integer: 420</span><br><span class="line">[ 4659.140049] mylong is a long integer: 9999</span><br><span class="line">[ 4659.140050] mystring is a string: bebop</span><br><span class="line">[ 4659.140050] myintArray[0] = -1</span><br><span class="line">[ 4659.140051] myintArray[1] = -1</span><br><span class="line">[ 4659.140051] got 1 arguments for myintArray.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-7-多文件编译模块"><a href="#2-7-多文件编译模块" class="headerlink" title="2.7 多文件编译模块"></a>2.7 多文件编译模块</h3><p>可以将内核模块分为多个源文件</p>
<p>例：一个模块分为start，stop，将入口函数和退出函数分离</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  start.c - Illustration of multi filed modules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world - this is the kernel speaking\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  stop.c - Illustration of multi filed modules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Short is the life of a kernel module\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Makefile</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hello-1.o</span><br><span class="line">obj-m += hello-2.o</span><br><span class="line">obj-m += hello-3.o</span><br><span class="line">obj-m += hello-4.o</span><br><span class="line">obj-m += hello-5.o</span><br><span class="line">obj-m += startstop.o</span><br><span class="line">startstop-objs := start.o stop.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(<span class="built_in">shell</span> pwd)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(<span class="built_in">shell</span> pwd)</span> clean</span><br></pre></td></tr></table></figure>

<h3 id="2-8-重新编译内核"><a href="#2-8-重新编译内核" class="headerlink" title="2.8 重新编译内核"></a>2.8 重新编译内核</h3><p>有利于版本的匹配以及内核模块的动态装载以及强制卸载。此处不再详细描述。想了解的读者可以参考原文（<a target="_blank" rel="noopener" href="https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN380%EF%BC%89">https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN380）</a></p>
<h2 id="Chapter-3-初步知识"><a href="#Chapter-3-初步知识" class="headerlink" title="Chapter 3 初步知识"></a>Chapter 3 初步知识</h2><h3 id="3-1-模块与程序"><a href="#3-1-模块与程序" class="headerlink" title="3.1 模块与程序"></a>3.1 模块与程序</h3><h4 id="3-1-1-模块如何开始与结束"><a href="#3-1-1-模块如何开始与结束" class="headerlink" title="3.1.1 模块如何开始与结束"></a>3.1.1 模块如何开始与结束</h4><ul>
<li>程序通常使用main()函数作为入口函数，在执行完所有指令后退出。</li>
<li>内核模块使用module__init指定入口函数。初始化操作向内核提供了模块的函数，当内核需要调用模块函数时才会真正执行模块中代码；模块结束使用module_exit，是init操作的反向操作。</li>
</ul>
<h4 id="3-1-2-模块可以调用的函数"><a href="#3-1-2-模块可以调用的函数" class="headerlink" title="3.1.2  模块可以调用的函数"></a>3.1.2  模块可以调用的函数</h4><p>程序可以调用标准C语言库，例如<code>printf()</code>。</p>
<p>内核模块只能调用内核实现的函数，因为模块的目标文件的符号由insmod解析。符号的定义来自于内核本身，导致能够调用的函数只能是由内核提供的，即系统调用（write，ioctl，read）。内核到处的符号可以参见<code>/proc/kallsyms</code>。</p>
<p>库函数运行在用户空间，向开发者提供了系统调用更方便的接口（库函数仍然需要调用系统调用实现）。系统调用运行在内核态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>gcc -Wall -o test test.c</code>编译，<code>strace ./hello</code>可以看到输出最后有<code>write(1, &quot;hello&quot;, 5hello)</code>为printf使用的系统调用。</p>
<p><code>man 2 write</code>：查看write函数的使用说明，2代表系统调用（kill(), read()）；3代表库函数</p>
<p>可以使用模块来替代内核的系统调用，基于此可以实现插入后门或木马等操作。</p>
<h4 id="3-1-3-用户空间与内核空间"><a href="#3-1-3-用户空间与内核空间" class="headerlink" title="3.1.3 用户空间与内核空间"></a>3.1.3 用户空间与内核空间</h4><p>内核态与用户态的转换</p>
<h4 id="3-1-4-命名空间"><a href="#3-1-4-命名空间" class="headerlink" title="3.1.4 命名空间"></a>3.1.4 命名空间</h4><p>开发者自己开发的变量名不能与其他开发者的冲突，因此会有命名空间来避免（C++有<code>std::</code>，C里这里只提到了要多注意，应该是没有）</p>
<p>当写内核模块时，由于内核模块会被加载到整个内核，因此更需要进行命名管理。最好的方式是将所有变量声明为static且使用合适的前缀命名变量。习惯上，Linux内核变量名一般为小写形式。（还可以定义一个符号表，后面会提到）</p>
<h4 id="3-1-5-代码空间"><a href="#3-1-5-代码空间" class="headerlink" title="3.1.5 代码空间"></a>3.1.5 代码空间</h4><p>内存管理是十分复杂的问题。这里只探究写内核模块需要考虑的问题</p>
<p>每开启一个新进程，内核会为其分配一个真实的物理内存，内存在进程看来为虚拟内存，从0x00000000开始，不同进程的内存地址（0xbffff978）对应的实际地址并不相同。每个进程的虚拟内存与实际内存之间存在着特定偏移。且不同进程无法访问其他进程的内存地址。</p>
<p>内核也有自己的代码空间。由于内核模块是加载到内核中使用，其会与内核共享代码空间。因此如果内核模块内存错误，内核也会出现内存错误。</p>
<p>以上为针对宏内核操作系统，微内核操作系统每个模块有独立的代码空间（GNU Hurd， QNX Neutrino）。</p>
<h4 id="3-1-6-Device-Drivers"><a href="#3-1-6-Device-Drivers" class="headerlink" title="3.1.6 Device Drivers"></a>3.1.6 Device Drivers</h4><p>一类模块是设备驱动程序，为硬件提供功能。在unix系统中，每一个硬件都由&#x2F;dev中的文件表示。设备驱动程序可以代表用户程序与硬件进行通信。例如es1370.o声卡驱动程序可以将&#x2F;dev&#x2F;sound连接到Ensoniq IS1370声卡。用户空间的程序可以直接使用&#x2F;dev&#x2F;sound不需要考虑声卡类型。</p>
<h5 id="3-1-6-1-Major-and-Minor-Numbers"><a href="#3-1-6-1-Major-and-Minor-Numbers" class="headerlink" title="3.1.6.1 Major and Minor Numbers"></a>3.1.6.1 Major and Minor Numbers</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ ls -l /dev/sda[1-3]</span><br><span class="line">brw-rw---- 1 root disk 8, 1  1月  5 09:11 /dev/sda1</span><br><span class="line">brw-rw---- 1 root disk 8, 2  1月  5 09:11 /dev/sda2</span><br><span class="line">brw-rw---- 1 root disk 8, 3  1月  5 09:11 /dev/sda3</span><br></pre></td></tr></table></figure>

<p>上图表示了硬盘的前三个分区，其中由逗号分隔的数字前面的为Major Number，后面为Minor Number。Major Number表示哪一个设备驱动访问该硬件，每一个设备驱动都有特定的major number。</p>
<p>Minor Number用来分别同一驱动控制的不同设备。</p>
<p>设备分为两类：字符设备和块设备。块设备有一个缓冲区存放请求（可以对请求进行排序）存储设备；字符设备则没有缓冲区。可以通过查看ls -l中第一个字符为’b’还是’c’来分辨。</p>
<p>可以通过查阅<code>/usr/src/linux/Documentation/devices.txt</code>来了解major number对应的设备</p>
<h2 id="Chapter-4-字符设备文件"><a href="#Chapter-4-字符设备文件" class="headerlink" title="Chapter 4 字符设备文件"></a>Chapter 4 字符设备文件</h2><h3 id="4-1-字符设备驱动程序"><a href="#4-1-字符设备驱动程序" class="headerlink" title="4.1 字符设备驱动程序"></a>4.1 字符设备驱动程序</h3><h4 id="4-1-1-file-operations-结构体"><a href="#4-1-1-file-operations-结构体" class="headerlink" title="4.1.1 file_operations 结构体"></a>4.1.1 file_operations 结构体</h4><p>提供了设备驱动程序对设备的多种操作函数的地址，操作函数定义在内核模块中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	 <span class="type">loff_t</span>(*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	 <span class="type">ssize_t</span>(*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line">	 <span class="type">ssize_t</span>(*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>,</span><br><span class="line">			      <span class="type">loff_t</span>);</span><br><span class="line">	<span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">	<span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dentry *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*readv) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>,</span><br><span class="line">			  <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*writev) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>,</span><br><span class="line">			   <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*sendfile) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">read_actor_t</span>,</span><br><span class="line">			     <span class="type">void</span> __user *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>,</span><br><span class="line">			     <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>改进</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc extension</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	read: device_read,</span><br><span class="line">	write: device_write,</span><br><span class="line">	open: device_open,</span><br><span class="line">	release: device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C99 way</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	.read = device_read,</span><br><span class="line">	.write = device_write,</span><br><span class="line">	.open = device_open,</span><br><span class="line">	.release = device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-1-2-file结构体"><a href="#4-1-2-file结构体" class="headerlink" title="4.1.2 file结构体"></a>4.1.2 file结构体</h4><p>每个设备在内核中由file结构体表示。该结构是内核水平的结构体，不会再用户空间出现。与glibc定义的FILE结构体不同。另外，其代表的是抽象的打开file，而不是硬盘上的file文件（使用inode结构体表示）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * f_&#123;lock,count,pos_lock&#125; members can be highly contended and share</span></span><br><span class="line"><span class="comment"> * the same cacheline. f_&#123;lock,mode&#125; are very frequently used together</span></span><br><span class="line"><span class="comment"> * and so share the same cacheline as well. The read-mostly</span></span><br><span class="line"><span class="comment"> * f_&#123;path,inode,op&#125; are kept on a separate cacheline.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">f_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">f_rcuhead</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> 		f_iocb_flags;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		f_flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	*<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="type">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-1-3-Registering-A-Device"><a href="#4-1-3-Registering-A-Device" class="headerlink" title="4.1.3 Registering A Device"></a>4.1.3 Registering A Device</h4><p>添加一个驱动需要向内核进行注册。该操作会向其分配一个major number（没有minor number因为其只与驱动有关，与内核无关）。使用<code>register_chrdev</code>函数 (<code>linux/fs.h</code>) 进行注册</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> file_operations *fops)</span>;</span><br><span class="line"><span class="comment">// 返回值为负表明注册失败</span></span><br></pre></td></tr></table></figure>

<p><code>unsigned int major</code>: 请求的major number</p>
<p><code>char *name</code>: 设备驱动的名字，会保存在<code>/proc/devices</code>中。</p>
<p><code>struct file_operations *fops</code>： 是<code>file_operations</code>表的指针</p>
<p>注：为了保证请求的<code>major number</code>不与已有的设备驱动冲突，可以 1）查看<code>/Documentation/devices.txt</code>；2）传入<code>major number</code> 0.会返回动态分配的<code>major number</code>。缺点是不能提前新建驱动文件。可以手动创建或构造脚本，或者使用<code>mknod</code>命令自动创建</p>
<p>注：存在一种方式自动创建设备<code>class_create()</code>，Linux内核提供一组函数，可以用来在模块加载的时候自动在&#x2F;dev目录下创建相应的设备节点，并在卸载模块时删除该节点，当然前提条件是用户空间移植了<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/373517974">udev</a>（一个用户空间程序）。内核中定义了<code>struct class</code>结构体，顾名思义，一个<code>struct class</code>结构体类型变量对应一个类，内核同时提供了<code>class_create()</code>函数，可以用它来创建一个类，这个类存放在sysfs下，一旦创建好后，再调用<code>device_create()</code>函数来在&#x2F;dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应<code>device_create()</code>函数，去&#x2F;sysfs下寻找对应的类从而创建设备节点。i</p>
<h4 id="4-1-4-Unregistering-A-Device"><a href="#4-1-4-Unregistering-A-Device" class="headerlink" title="4.1.4 Unregistering A Device"></a>4.1.4 Unregistering A Device</h4><p>我们不能让root用户需要需要使用内核模块时将其卸载。如果设备驱动文件被一个进程打开然后将其内核模块卸载，使用该文件会造成对原内核模块对应的内存地址的访问，但由于内存地址已发生改变，会导致意想不到的结果。</p>
<p>一般情况下，可以让函数返回负值来禁用某功能，不过<code>cleaup_module</code>无法实现因为其为<code>void</code>函数。不过，存在一个计数器来记录多少进程在占用模块。通过<code>/proc/modules</code>的第三个参数即可。若不为零，则无法卸载（该操作内核已实现）</p>
<p>可以使用以下函数来改变计数器值：</p>
<p><code>try_module_get(THIS_MODULE)</code>: 增加计数</p>
<p><code>module_put(THIS_MODULE)</code>： 减少计数</p>
<h4 id="4-1-5-chardev-c"><a href="#4-1-5-chardev-c" class="headerlink" title="4.1.5 chardev.c"></a>4.1.5 chardev.c</h4><p>以下代码创建了一个字符类设备驱动<code>chardev</code>。该设备文件可以记录设备文件被读取的次数。无法写入该设备文件，不过会记录此行为并告知用户该行为不受支持。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  chardev.c: Creates a read-only char device that says how many times</span></span><br><span class="line"><span class="comment"> *  you&#x27;ve read from the dev file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span>	<span class="comment">/* for put_user */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  Prototypes - this would normally go in a .h file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;chardev&quot;</span>	<span class="comment">/* Dev name as it appears in /proc/devices   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 80		<span class="comment">/* Max length of the message from the device */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Global variables are declared as static, so are global within the file. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Major;		<span class="comment">/* Major number assigned to our device driver */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Device_Open = <span class="number">0</span>;	<span class="comment">/* Is device open?  </span></span><br><span class="line"><span class="comment">				 * Used to prevent multiple access to device */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> msg[BUF_LEN];	<span class="comment">/* The msg the device will give when asked */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *msg_Ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	.read = device_read,</span><br><span class="line">	.write = device_write,</span><br><span class="line">	.open = device_open,</span><br><span class="line">	.release = device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called when the module is loaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Major = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;fops);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Major &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	  printk(KERN_ALERT <span class="string">&quot;Registering char device failed with %d\n&quot;</span>, Major);</span><br><span class="line">	  <span class="keyword">return</span> Major;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;I was assigned major number %d. To talk to\n&quot;</span>, Major);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;the driver, create a dev file with\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;&#x27;mknod /dev/%s c %d 0&#x27;.\n&quot;</span>, DEVICE_NAME, Major);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Try various minor numbers. Try to cat and echo to\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;the device file.\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Remove the device file and module when done.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called when the module is unloaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Unregister the device </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ret = unregister_chrdev(Major, DEVICE_NAME);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		printk(KERN_ALERT <span class="string">&quot;Error in unregister_chrdev: %d\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process tries to open the device file, like</span></span><br><span class="line"><span class="comment"> * &quot;cat /dev/mycharfile&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Device_Open)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	Device_Open++;</span><br><span class="line">	<span class="built_in">sprintf</span>(msg, <span class="string">&quot;I already told you %d times Hello world!\n&quot;</span>, counter++);</span><br><span class="line">	msg_Ptr = msg;</span><br><span class="line">	try_module_get(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process closes the device file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	Device_Open--;		<span class="comment">/* We&#x27;re now ready for our next caller */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Decrement the usage count, or else once you opened the file, you&#x27;ll</span></span><br><span class="line"><span class="comment">	 * never get get rid of the module. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	module_put(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process, which already opened the dev file, attempts to</span></span><br><span class="line"><span class="comment"> * read from it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *filp,	<span class="comment">/* see include/linux/fs.h   */</span></span></span><br><span class="line"><span class="params">			   <span class="type">char</span> *buffer,	<span class="comment">/* buffer to fill with data */</span></span></span><br><span class="line"><span class="params">			   <span class="type">size_t</span> length,	<span class="comment">/* length of the buffer     */</span></span></span><br><span class="line"><span class="params">			   <span class="type">loff_t</span> * offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of bytes actually written to the buffer </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we&#x27;re at the end of the message, </span></span><br><span class="line"><span class="comment">	 * return 0 signifying end of file </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (*msg_Ptr == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Actually put the data into the buffer </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (length &amp;&amp; *msg_Ptr) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* </span></span><br><span class="line"><span class="comment">		 * The buffer is in the user data segment, not the kernel </span></span><br><span class="line"><span class="comment">		 * segment so &quot;*&quot; assignment won&#x27;t work.  We have to use </span></span><br><span class="line"><span class="comment">		 * put_user which copies data from the kernel data segment to</span></span><br><span class="line"><span class="comment">		 * the user data segment. </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		put_user(*(msg_Ptr++), buffer++);</span><br><span class="line"></span><br><span class="line">		length--;</span><br><span class="line">		bytes_read++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Most read functions return the number of bytes put into the buffer</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * Called when a process writes to dev file: echo &quot;hi&quot; &gt; /dev/hello </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> *buff, <span class="type">size_t</span> len, <span class="type">loff_t</span> * off)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;Sorry, this operation isn&#x27;t supported.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到成功装载模块，<code>major number506</code>。</p>
<p><img src="/images/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240114145543938.png" alt="image-20240114145543938"></p>
<p>使用<code>mknod</code>命令创建新设备驱动文件，读取内容，可以看到次数发生改变。无写入权限。</p>
<p><img src="/images/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240114145523551.png" alt="image-20240114145523551"></p>
<h4 id="4-1-6-兼容多个版本的内核模块"><a href="#4-1-6-兼容多个版本的内核模块" class="headerlink" title="4.1.6 兼容多个版本的内核模块"></a>4.1.6 兼容多个版本的内核模块</h4><p><strong>内核暴露给进程的系统调用在各个版本之间基本一致。可能会加入新的系统调用，但是旧的调用的行为会保持不变（向后兼容）。</strong>不过有一些系统版本（奇数：开发版）会有改变。</p>
<p>为了适应不同版本，需要编写条件编译指令。将<code>LINUX_VERSION_CODE</code>与<code>KERNEL_VERSION</code>进行比较。如果内核版本为<code>a.b.c</code>，宏的值应为<code>$2^&#123;16&#125;a+2^&#123;8&#125;b+c$</code></p>
<h2 id="Chapter-5-The-proc-File-System"><a href="#Chapter-5-The-proc-File-System" class="headerlink" title="Chapter 5. The &#x2F;proc File System"></a>Chapter 5. The &#x2F;proc File System</h2><h3 id="5-1-The-proc-File-System"><a href="#5-1-The-proc-File-System" class="headerlink" title="5.1 The &#x2F;proc File System"></a>5.1 The &#x2F;proc File System</h3><p>在Linux系统中，内核和内核模块有一种另外的方式与进程通信——&#x2F;proc 文件系统。&#x2F;proc文件系统最初的设计是为了方便访问进程信息，现在它被内核广泛调用来获取信息。</p>
<p>使用&#x2F;proc文件系统的方法与设备驱动程序相似，使用&#x2F;proc文件所需信息创建一个结构体，包括指向处理函数的指针。然后<code>init_module</code>注册该结构，<code>cleanup_module</code>注销。</p>
<p>为避免冲突，使用<code>proc_register_dynamic</code>来让内核决定<code>inode number</code>，与普通的文件系统不同，<code>/proc</code>文件系统位于内存中。在正常情况下，<code>inode number</code>是指向文件在磁盘位置的指针。<code>inode</code>包含文件的基本信息，例如权限，硬盘位置指针。</p>
<p>在以下代码中，打开&#x2F;关闭文件并不会调用函数，因此不会放入<code>try_module_get</code>和<code>try_module_put</code>函数，如果文件被打开时模块被删除，那么会导致内存访问越界。</p>
<p>当使用<code>proc_create</code>函数加载模块时，将创建<code>/proc/helloworld</code>返回值是一个结构体<code>struct proc_dir_entry</code>，并且该结构体会用于配置<code>/proc/helloworld</code>，例如文件拥有者。若返回空，则表明创建失败。</p>
<p>每当文件<code>/proc/helloworld</code>被读取时，函数<code>procfs_read</code>会被调用。有两个参数比较重要<code>buffer： 返回给读取文件应用进程的内容</code>, <code>offset： 当前文件的位置</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  procfs1.c -  create a &quot;file&quot; in /proc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span>	<span class="comment">/* Necessary because we use the proc fs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len, temp;</span><br><span class="line"><span class="type">char</span> *msg;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_proc</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; temp)</span><br><span class="line">		count = temp;</span><br><span class="line">	temp = temp-count;</span><br><span class="line"></span><br><span class="line">	raw_copy_to_user(buf, msg, count);</span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">		temp = len;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">proc_fops</span> =</span> &#123;</span><br><span class="line">	.proc_read = read_proc</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_new_proc_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*create a file named world, and read attribute to this file using proc_fops*/</span></span><br><span class="line">	proc_create(<span class="string">&quot;world&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br><span class="line">	msg = <span class="string">&quot;hello world\n&quot;</span>;		<span class="comment">/*file content*/</span></span><br><span class="line">	len = <span class="built_in">strlen</span>(msg);</span><br><span class="line">	temp = len;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;1.len=%d&quot;</span>, len);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;proc initialized&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">proc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	create_new_proc_entry();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_cleanup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Inside cleanup_module\n&quot;</span>);</span><br><span class="line">	remove_proc_entry(<span class="string">&quot;world&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">module_init(proc_init);</span><br><span class="line">module_exit(proc_cleanup);</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：</p>
<p><img src="/images/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240115091551536.png" alt="image-20240115091551536"></p>
<h3 id="5-2-读写-proc文件"><a href="#5-2-读写-proc文件" class="headerlink" title="5.2 读写&#x2F;proc文件"></a>5.2 读写&#x2F;proc文件</h3><p>文件写入使用<code>copy_from_user</code>或<code>get_user</code>读取用户输入，与read不同。</p>
<p>使用<code>copy_from_user</code>或<code>get_user</code>函数的原因为Linux系统内存是分段的，指针指向内存地址不是实际内存上特定地址，而是一个内存段上的地址。内核有一个内存段，其他每个进程都有一个内存段。</p>
<p>每个进程都只能访问他自己的内存段，因此当编写作为进程运行的一般程序时，不需要担心此问题。当编写内核模块时，一般情况下系统会自动让你访问内核的内存段。然而，当内存缓冲区的内容需要在进程与内核之间传递时，内核函数会接受一个指向进程内存段的指针。<code>put_user</code>和<code>get_user</code>可以让你成功访问这些内存地址。不过这两个函数一次只能处理一个字符，可以使用<code>copy_to_user</code>和<code>copy_from_user</code>来处理字符串。由于buffer位于内和空间，因此对于写入操作而言你需要引入用户空间的数据，即只能使用<code>copy_from_user</code>函数，而读取操作因为数据本身就在内核态，可以不使用<code>copy_to_user</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  procfs2.c -  create a &quot;file&quot; in /proc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span>	<span class="comment">/* Necessary because we use the proc fs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span>	<span class="comment">/* for copy_from_user */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_MAX_SIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_NAME         <span class="string">&quot;bufferlk&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The buffer used to store character for this module</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> procfs_buffer[PROCFS_MAX_SIZE];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> procfs_buffer_size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * This function is called then the /proc file is read</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_proc</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;procfile_read (/proc/%s) called\n&quot;</span>, PROCFS_NAME);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Read data: %s&quot;</span>, procfs_buffer);</span><br><span class="line">    <span class="keyword">if</span> (*offp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* we have finished to read, return 0 */</span></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* fill the buffer, return the buffer size*/</span></span><br><span class="line">        copy_to_user(buf, procfs_buffer, procfs_buffer_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function is called with the /proc file is written</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_proc</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">		   <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* get buffer size */</span></span><br><span class="line">	procfs_buffer_size = count;</span><br><span class="line">	<span class="keyword">if</span> (procfs_buffer_size &gt; PROCFS_MAX_SIZE ) &#123;</span><br><span class="line">		procfs_buffer_size = PROCFS_MAX_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* write data to the buffer */</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> ( copy_from_user(procfs_buffer, buffer, procfs_buffer_size) ) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Write data: %s&quot;</span>, procfs_buffer);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> procfs_buffer_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">proc_fops</span> =</span> &#123;</span><br><span class="line">    .proc_read = read_proc,</span><br><span class="line">    .proc_write = write_proc,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *This function is called when the module is loaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* create the /proc file */</span></span><br><span class="line">	proc_create(PROCFS_NAME, <span class="number">0644</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;/proc/%s created\n&quot;</span>, PROCFS_NAME);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">/* everything is ok */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *This function is called when the module is unloaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	remove_proc_entry(PROCFS_NAME, <span class="literal">NULL</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;/proc/%s removed\n&quot;</span>, PROCFS_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita_Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>写入并读取内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo sh -c &#x27;echo &quot;I LOVE YOU&quot; &gt; /proc/bufferlk&#x27;</span><br><span class="line">❯ cat /proc/bufferlk</span><br></pre></td></tr></table></figure>

<p>![截图 2024-01-15 10-34-28](&#x2F;images&#x2F;2024-1-4-LKM编程学习.assets&#x2F;截图 2024-01-15 10-34-28.png)</p>
<h3 id="5-3-Manage-proc-file-with-standard-filesystem"><a href="#5-3-Manage-proc-file-with-standard-filesystem" class="headerlink" title="5.3 Manage &#x2F;proc file with standard filesystem"></a>5.3 Manage &#x2F;proc file with standard filesystem</h3><p>还可以使用inode来管理&#x2F;proc文件，好处是可以使用一些高级函数，例如权限。</p>
<p>Linux系统中，对于文件系统注册有一套标准的方法。因为每一个文件系统都有它自己的操作函数来管理inode和文件操作，需要一个结构体来指向这些函数，结构体<code>struct inode_operations</code>，该结构体包含<code>proc_ops</code>。</p>
<p>文件操作与inode操作的区别在于，文件操作处理文件本身，而inode操作处理引用文件的方式，例如创建到该文件的链接。</p>
<p>还有个函数<code>module_permission</code>。当进程要对&#x2F;proc文件进行操作时会先调用此函数，查看是否有权限来进行操作。</p>
<p>注：内核的read和write函数的作用与正常程序相反，read函数用于输出，write函数用于输入。因为如果进程要从内核中读取数据，内核需要输出，写入数据时，内核是接受数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * procfs3.c </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/minmax.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_MAX_SIZE 2048UL </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_ENTRY_FILENAME <span class="string">&quot;buffer2k&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">our_proc_file</span>;</span> </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> procfs_buffer[PROCFS_MAX_SIZE]; </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> procfs_buffer_size = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (*offset || procfs_buffer_size == <span class="number">0</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;procfs_read: END\n&quot;</span>); </span><br><span class="line">        *offset = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    procfs_buffer_size = min(procfs_buffer_size, length); </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buffer, procfs_buffer, procfs_buffer_size)) </span><br><span class="line">        <span class="keyword">return</span> -EFAULT; </span><br><span class="line">    *offset += procfs_buffer_size; </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;procfs_read: read %lu bytes\n&quot;</span>, procfs_buffer_size); </span><br><span class="line">    <span class="keyword">return</span> procfs_buffer_size; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> len, <span class="type">loff_t</span> *off)</span> </span><br><span class="line">&#123; </span><br><span class="line">    procfs_buffer_size = min(PROCFS_MAX_SIZE, len); </span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(procfs_buffer, buffer, procfs_buffer_size)) </span><br><span class="line">        <span class="keyword">return</span> -EFAULT; </span><br><span class="line">    *off += procfs_buffer_size; </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;procfs_write: write %lu bytes\n&quot;</span>, procfs_buffer_size); </span><br><span class="line">    <span class="keyword">return</span> procfs_buffer_size; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">procfs_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    try_module_get(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">procfs_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    module_put(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123; </span><br><span class="line">    .proc_read = procfs_read, </span><br><span class="line">    .proc_write = procfs_write, </span><br><span class="line">    .proc_open = procfs_open, </span><br><span class="line">    .proc_release = procfs_close, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123; </span><br><span class="line">    .read = procfs_read, </span><br><span class="line">    .write = procfs_write, </span><br><span class="line">    .open = procfs_open, </span><br><span class="line">    .release = procfs_close, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs3_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    our_proc_file = proc_create(PROCFS_ENTRY_FILENAME, <span class="number">0644</span>, <span class="literal">NULL</span>, </span><br><span class="line">                                &amp;file_ops_4_our_proc_file); </span><br><span class="line">    <span class="keyword">if</span> (our_proc_file == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;Error: Could not initialize /proc/%s\n&quot;</span>, </span><br><span class="line">                 PROCFS_ENTRY_FILENAME); </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    &#125; </span><br><span class="line">    proc_set_size(our_proc_file, <span class="number">80</span>); </span><br><span class="line">    proc_set_user(our_proc_file, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID); </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s created\n&quot;</span>, PROCFS_ENTRY_FILENAME); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs3_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    remove_proc_entry(PROCFS_ENTRY_FILENAME, <span class="literal">NULL</span>); </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROCFS_ENTRY_FILENAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(procfs3_init); </span><br><span class="line">module_exit(procfs3_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240115143522039.png" alt="image-20240115143522039"></p>
<h3 id="5-4-Manage-proc-file-with-seq-file"><a href="#5-4-Manage-proc-file-with-seq-file" class="headerlink" title="5.4 Manage &#x2F;proc file with seq_file"></a>5.4 Manage &#x2F;proc file with seq_file</h3><p>前面的构建&#x2F;proc文件过程比较复杂。因此为了更方便的写&#x2F;proc文件，提供了<code>seq_file</code>api用于格式化&#x2F;proc文件。<code>seq_file</code>根据时序分为三个函数: <code>start()</code>, <code>next()</code>, <code>stop()</code>。当用户读取&#x2F;proc文件时，<code>seq_file</code>会新建一个时序。</p>
<p>时序以<code>start()</code>为开始。如果返回值不为空，则继续调用<code>next()</code>函数。该函数为一个迭代器，可以遍历所有的数据。每次<code>next()</code>函数调用，都会调用<code>show()</code>函数。<code>show()</code>函数会在用户读取的缓冲区中写入数据值。当函数返回空值后结束循环。然后<code>stop()</code>函数被调用。<code>stop()</code>函数调用结束后，会继续调用<code>start()</code>函数，直到<code>start()</code>函数返回空值结束。</p>
<p><img src="/images/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/lkmpg-for-ht1x-1705301053942-4.svg" alt="lkmpg-for-ht1x"></p>
<p>注：<code>seq_file</code>为<code>proc_ops</code>提供了基本的函数，例如<code>seq_read</code>, <code>seq_lseek</code>等。但是没有写入的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * procfs4.c -  create a &quot;file&quot; in /proc </span></span><br><span class="line"><span class="comment"> * This program uses the seq_file library to manage the /proc file. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* We are doing kernel work */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span> <span class="comment">/* Necessary because we use proc fs */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span> <span class="comment">/* for seq_file */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_NAME <span class="string">&quot;iter&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called at the beginning of a sequence. </span></span><br><span class="line"><span class="comment"> * ie, when: </span></span><br><span class="line"><span class="comment"> *   - the /proc file is read (first time) </span></span><br><span class="line"><span class="comment"> *   - after the function stop (end of sequence) </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">my_seq_start</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">loff_t</span> *pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> counter = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* beginning a new sequence? */</span> </span><br><span class="line">    <span class="keyword">if</span> (*pos == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">/* yes =&gt; return a non null value to begin the sequence */</span> </span><br><span class="line">        <span class="keyword">return</span> &amp;counter; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* no =&gt; it is the end of the sequence, return end to stop reading */</span> </span><br><span class="line">    *pos = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called after the beginning of a sequence. </span></span><br><span class="line"><span class="comment"> * It is called until the return is NULL (this ends the sequence). </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">my_seq_next</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *tmp_v = (<span class="type">unsigned</span> <span class="type">long</span> *)v; </span><br><span class="line">    (*tmp_v)++; </span><br><span class="line">    (*pos)++; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called at the end of a sequence. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_seq_stop</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* nothing to do, we use a static value in start() */</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called for each &quot;step&quot; of a sequence. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_seq_show</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">loff_t</span> *spos = (<span class="type">loff_t</span> *)v; </span><br><span class="line"> </span><br><span class="line">    seq_printf(s, <span class="string">&quot;%Ld\n&quot;</span>, *spos); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure gather &quot;function&quot; to manage the sequence */</span> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">my_seq_ops</span> =</span> &#123; </span><br><span class="line">    .start = my_seq_start, </span><br><span class="line">    .next = my_seq_next, </span><br><span class="line">    .stop = my_seq_stop, </span><br><span class="line">    .show = my_seq_show, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called when the /proc file is open. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> seq_open(file, &amp;my_seq_ops); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure gather &quot;function&quot; that manage the /proc file */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">my_file_ops</span> =</span> &#123; </span><br><span class="line">    .proc_open = my_open, </span><br><span class="line">    .proc_read = seq_read, </span><br><span class="line">    .proc_lseek = seq_lseek, </span><br><span class="line">    .proc_release = seq_release, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_file_ops</span> =</span> &#123; </span><br><span class="line">    .open = my_open, </span><br><span class="line">    .read = seq_read, </span><br><span class="line">    .llseek = seq_lseek, </span><br><span class="line">    .release = seq_release, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs4_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">entry</span>;</span> </span><br><span class="line"> </span><br><span class="line">    entry = proc_create(PROC_NAME, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;my_file_ops); </span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;Error: Could not initialize /proc/%s\n&quot;</span>, PROC_NAME); </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs4_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    remove_proc_entry(PROC_NAME, <span class="literal">NULL</span>); </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROC_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(procfs4_init); </span><br><span class="line">module_exit(procfs4_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Chapter-6-Interacting-with-your-module"><a href="#Chapter-6-Interacting-with-your-module" class="headerlink" title="Chapter 6 Interacting with your module"></a>Chapter 6 Interacting with your module</h2><p><code>sysfs</code>可以实现在用户空间通过在模块中读取或设置变量与运行的内核进行交互。查看系统的<code>sysfs</code>目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /sys</span><br></pre></td></tr></table></figure>

<p><img src="/images/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240115145741324.png" alt="image-20240115145741324"></p>
<p>可以在文件系统中以常规文件的形式为kobjects导出属性。Sysfs将文件I&#x2F;O操作转发给为属性定义的方法，提供了提供了读写内核属性的方法。</p>
<p>一个属性的简单定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span> </span><br><span class="line">    <span class="type">char</span> *name; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> </span><br><span class="line">    <span class="type">umode_t</span> mode; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfs_create_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">sysfs_remove_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>;</span><br></pre></td></tr></table></figure>

<p>例如，设备驱动模型定义了<code>device_attribute</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span> </span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, </span><br><span class="line">                    <span class="type">char</span> *buf); </span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, </span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>;</span><br></pre></td></tr></table></figure>

<p>为了读写attributes，show()和store()方法必须声明定义。一般情况下include&#x2F;linux&#x2F;sysfs.h提供了便捷的宏用来简化定义。</p>
<p>以下为一个hello world模块，通过sysfs实现了创建一个可以访问的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * hello-sysfs.c sysfs example </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kobject.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sysfs.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">mymodule</span>;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* the variable you want to be able to change */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myvariable = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">myvariable_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, </span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> kobj_attribute *attr, <span class="type">char</span> *buf)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d\n&quot;</span>, myvariable); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">myvariable_store</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, </span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> kobj_attribute *attr, <span class="type">char</span> *buf, </span></span><br><span class="line"><span class="params">                                <span class="type">size_t</span> count)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%du&quot;</span>, &amp;myvariable); </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_attribute</span> <span class="title">myvariable_attribute</span> =</span> </span><br><span class="line">    __ATTR(myvariable, <span class="number">0660</span>, myvariable_show, (<span class="type">void</span> *)myvariable_store); </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mymodule_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;mymodule: initialised\n&quot;</span>); </span><br><span class="line"> </span><br><span class="line">    mymodule = kobject_create_and_add(<span class="string">&quot;mymodule&quot;</span>, kernel_kobj); </span><br><span class="line">    <span class="keyword">if</span> (!mymodule) </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line"> </span><br><span class="line">    error = sysfs_create_file(mymodule, &amp;myvariable_attribute.attr); </span><br><span class="line">    <span class="keyword">if</span> (error) &#123; </span><br><span class="line">        pr_info(<span class="string">&quot;failed to create the myvariable file &quot;</span> </span><br><span class="line">                <span class="string">&quot;in /sys/kernel/mymodule\n&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> error; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mymodule_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;mymodule: Exit success\n&quot;</span>); </span><br><span class="line">    kobject_put(mymodule); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(mymodule_init); </span><br><span class="line">module_exit(mymodule_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>效果图如下，成功实现对sys文件下模块的变量的读写。</p>
<p><img src="/images/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240115150838900.png" alt="image-20240115150838900"></p>
<p>以上情况下，使用了kobject来创建sysfs下的目录，并与其下的属性文件进行信息交互。<strong>kobject</strong>起初用于统一内核代码的简单方法，用于管理引用计数对象，目前时将设备驱动与sysfs接口联系在一起的粘合剂。</p>
<h2 id="Chapter-7-Talking-To-Device-Files"><a href="#Chapter-7-Talking-To-Device-Files" class="headerlink" title="Chapter 7. Talking To Device Files"></a>Chapter 7. Talking To Device Files</h2><h3 id="7-1-Talking-to-Device-Files-write-and-IOCTLS"><a href="#7-1-Talking-to-Device-Files-write-and-IOCTLS" class="headerlink" title="7.1 Talking to Device Files (write and IOCTLS)"></a>7.1 Talking to Device Files (write and IOCTLS)</h3><p>设备文件（&#x2F;dev目录包含了所有linux中使用的外部设备，但是不包含外部设备的驱动信息，外舍驱动在&#x2F;kernel&#x2F;drivers）代表了物理设备。大多数的设备既有输入也有输出，因此需要一些方法令内核中的设备驱动从进程中获取输出发送给设备，通过打开设备文件并写入实现。下面例子实现了device_write。</p>
<p>当然只有这些写入操作还不够，假设有场景需要串口与解调器通信，可以通过读写设备文件实现消息的接受与发送，<strong>但是应该如何与串口本身通信是一个问题</strong>，例如波特率等配置信息。</p>
<p>Unix系统提供了<code>ioctl（Input Output Control）</code>函数，每个设备都有自己的ioctl命令，可以读取（从进程发送信息到内核），写入（从内核返回信息到进程）等。</p>
<p><code>ioctl</code>函数有三个参数：合适的设备文件描述符，<code>ioctl</code>数，参数（long型）可以强制转换来传递任何内容。可以传递结构体指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * ioctl.c </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ioctl_arg</span> &#123;</span> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> val; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Documentation/userspace-api/ioctl/ioctl-number.rst */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;\x66&#x27;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALSET _IOW(IOC_MAGIC, 0, struct ioctl_arg) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALGET _IOR(IOC_MAGIC, 1, struct ioctl_arg) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALGET_NUM _IOR(IOC_MAGIC, 2, int) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALSET_NUM _IOW(IOC_MAGIC, 3, int) </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VAL_MAXNR 3 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_NAME <span class="string">&quot;ioctltest&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> test_ioctl_major = <span class="number">0</span>; </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> num_of_dev = <span class="number">1</span>; </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">test_ioctl_cdev</span>;</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ioctl_num = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> &#123;</span> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="type">rwlock_t</span> lock; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">test_ioctl_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, </span></span><br><span class="line"><span class="params">                             <span class="type">unsigned</span> <span class="type">long</span> arg)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span> =</span> filp-&gt;private_data; </span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ioctl_arg</span> <span class="title">data</span>;</span> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data)); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALSET: </span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;data, (<span class="type">int</span> __user *)arg, <span class="keyword">sizeof</span>(data))) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> done; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        pr_alert(<span class="string">&quot;IOCTL set val:%x .\n&quot;</span>, data.val); </span><br><span class="line">        write_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        ioctl_data-&gt;val = data.val; </span><br><span class="line">        write_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALGET: </span><br><span class="line">        read_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        val = ioctl_data-&gt;val; </span><br><span class="line">        read_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        data.val = val; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user((<span class="type">int</span> __user *)arg, &amp;data, <span class="keyword">sizeof</span>(data))) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> done; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALGET_NUM: </span><br><span class="line">        retval = __put_user(ioctl_num, (<span class="type">int</span> __user *)arg); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALSET_NUM: </span><br><span class="line">        ioctl_num = arg; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        retval = -ENOTTY; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">done: </span><br><span class="line">    <span class="keyword">return</span> retval; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">test_ioctl_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, </span></span><br><span class="line"><span class="params">                               <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span> =</span> filp-&gt;private_data; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="type">int</span> retval; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    read_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">    val = ioctl_data-&gt;val; </span><br><span class="line">    read_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; count; i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(&amp;buf[i], &amp;val, <span class="number">1</span>)) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> out; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    retval = count; </span><br><span class="line">out: </span><br><span class="line">    <span class="keyword">return</span> retval; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_ioctl_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_alert(<span class="string">&quot;%s call.\n&quot;</span>, __func__); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;private_data) &#123; </span><br><span class="line">        kfree(filp-&gt;private_data); </span><br><span class="line">        filp-&gt;private_data = <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_ioctl_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span>;</span> </span><br><span class="line"> </span><br><span class="line">    pr_alert(<span class="string">&quot;%s call.\n&quot;</span>, __func__); </span><br><span class="line">    ioctl_data = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> test_ioctl_data), GFP_KERNEL); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ioctl_data == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line"> </span><br><span class="line">    rwlock_init(&amp;ioctl_data-&gt;lock); </span><br><span class="line">    ioctl_data-&gt;val = <span class="number">0xFF</span>; </span><br><span class="line">    filp-&gt;private_data = ioctl_data; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123; </span><br><span class="line">    .owner = THIS_MODULE, </span><br><span class="line">    .open = test_ioctl_open, </span><br><span class="line">    .release = test_ioctl_close, </span><br><span class="line">    .read = test_ioctl_read, </span><br><span class="line">    .unlocked_ioctl = test_ioctl_ioctl, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ioctl_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">dev_t</span> dev; </span><br><span class="line">    <span class="type">int</span> alloc_ret = <span class="number">-1</span>; </span><br><span class="line">    <span class="type">int</span> cdev_ret = <span class="number">-1</span>; </span><br><span class="line">    alloc_ret = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, num_of_dev, DRIVER_NAME); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (alloc_ret) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    test_ioctl_major = MAJOR(dev); </span><br><span class="line">    cdev_init(&amp;test_ioctl_cdev, &amp;fops); </span><br><span class="line">    cdev_ret = cdev_add(&amp;test_ioctl_cdev, dev, num_of_dev); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (cdev_ret) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    pr_alert(<span class="string">&quot;%s driver(major: %d) installed.\n&quot;</span>, DRIVER_NAME, </span><br><span class="line">             test_ioctl_major); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">error: </span><br><span class="line">    <span class="keyword">if</span> (cdev_ret == <span class="number">0</span>) </span><br><span class="line">        cdev_del(&amp;test_ioctl_cdev); </span><br><span class="line">    <span class="keyword">if</span> (alloc_ret == <span class="number">0</span>) </span><br><span class="line">        unregister_chrdev_region(dev, num_of_dev); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ioctl_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">dev_t</span> dev = MKDEV(test_ioctl_major, <span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line">    cdev_del(&amp;test_ioctl_cdev); </span><br><span class="line">    unregister_chrdev_region(dev, num_of_dev); </span><br><span class="line">    pr_alert(<span class="string">&quot;%s driver removed.\n&quot;</span>, DRIVER_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(ioctl_init); </span><br><span class="line">module_exit(ioctl_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>); </span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is test_ioctl module&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>test_ioctl_ioctl</code>函数有一参数<code>cmd</code>，这个就是<code>ioctl_number</code>，<code>ioctl number</code>编码了major number，ioctl类型，命令和参数。通常使用宏表示(_IO, _IOR, _IOW, _IOWR)。内核与程序都应包含ioctl的头文件。内核模块调用的头文件是<code>chardev.h</code>，程序调用为<code>userspace_ioctl.c</code>。</p>
<p>另外，我们需要注意的是，对共享资源的并发访问将导致竞态条件。。解决方法是使用原子比较与交换(atomic Compare-And-Swap (CAS))。</p>
<p>一个完整的与device file通信的示例</p>
<p><code>char_dev2.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * chardev2.c - Create an input/output character device </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> <span class="comment">/* for get_user and put_user */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/errno.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chardev.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;char_dev&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 80 </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> </span><br><span class="line">    CDEV_NOT_USED = <span class="number">0</span>, </span><br><span class="line">    CDEV_EXCLUSIVE_OPEN = <span class="number">1</span>, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Is the device open right now? Used to prevent concurrent access into </span></span><br><span class="line"><span class="comment"> * the same device </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> already_open = ATOMIC_INIT(CDEV_NOT_USED); </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The message the device will give when asked */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> message[BUF_LEN + <span class="number">1</span>]; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">cls</span>;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This is called whenever a process attempts to open the device file */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;device_open(%p)\n&quot;</span>, file); </span><br><span class="line"> </span><br><span class="line">    try_module_get(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;device_release(%p,%p)\n&quot;</span>, inode, file); </span><br><span class="line"> </span><br><span class="line">    module_put(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called whenever a process which has already opened the </span></span><br><span class="line"><span class="comment"> * device file attempts to read from it. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* see include/linux/fs.h   */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">char</span> __user *buffer, <span class="comment">/* buffer to be filled  */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> length, <span class="comment">/* length of the buffer     */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* Number of bytes actually written to the buffer */</span> </span><br><span class="line">    <span class="type">int</span> bytes_read = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">/* How far did the process reading the message get? Useful if the message </span></span><br><span class="line"><span class="comment">     * is larger than the size of the buffer we get to fill in device_read. </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message_ptr = message; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!*(message_ptr + *offset)) &#123; <span class="comment">/* we are at the end of message */</span> </span><br><span class="line">        *offset = <span class="number">0</span>; <span class="comment">/* reset the offset */</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* signify end of file */</span> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    message_ptr += *offset; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Actually put the data into the buffer */</span> </span><br><span class="line">    <span class="keyword">while</span> (length &amp;&amp; *message_ptr) &#123; </span><br><span class="line">        <span class="comment">/* Because the buffer is in the user data segment, not the kernel </span></span><br><span class="line"><span class="comment">         * data segment, assignment would not work. Instead, we have to </span></span><br><span class="line"><span class="comment">         * use put_user which copies data from the kernel data segment to </span></span><br><span class="line"><span class="comment">         * the user data segment. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        put_user(*(message_ptr++), buffer++); </span><br><span class="line">        length--; </span><br><span class="line">        bytes_read++; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;Read %d bytes, %ld left\n&quot;</span>, bytes_read, length); </span><br><span class="line"> </span><br><span class="line">    *offset += bytes_read; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Read functions are supposed to return the number of bytes actually </span></span><br><span class="line"><span class="comment">     * inserted into the buffer. </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">return</span> bytes_read; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* called when somebody tries to write into our device file. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;device_write(%p,%p,%ld)&quot;</span>, file, buffer, length); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length &amp;&amp; i &lt; BUF_LEN; i++) </span><br><span class="line">        get_user(message[i], buffer + i); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Again, return the number of input characters used. */</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called whenever a process tries to do an ioctl on our </span></span><br><span class="line"><span class="comment"> * device file. We get two extra parameters (additional to the inode and file </span></span><br><span class="line"><span class="comment"> * structures, which all device functions get): the number of the ioctl called </span></span><br><span class="line"><span class="comment"> * and the parameter given to the ioctl function. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the ioctl is write or read/write (meaning output is returned to the </span></span><br><span class="line"><span class="comment"> * calling process), the ioctl call returns the output of this function. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">long</span> </span><br><span class="line"><span class="title function_">device_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* ditto */</span> </span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">int</span> ioctl_num, <span class="comment">/* number and param for ioctl */</span> </span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">long</span> ioctl_param)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="type">long</span> ret = SUCCESS; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* We don&#x27;t want to talk to two processes at the same time. */</span> </span><br><span class="line">    <span class="keyword">if</span> (atomic_cmpxchg(&amp;already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN)) </span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Switch according to the ioctl called */</span> </span><br><span class="line">    <span class="keyword">switch</span> (ioctl_num) &#123; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_SET_MSG: &#123; </span><br><span class="line">        <span class="comment">/* Receive a pointer to a message (in user space) and set that to </span></span><br><span class="line"><span class="comment">         * be the device&#x27;s message. Get the parameter given to ioctl by </span></span><br><span class="line"><span class="comment">         * the process. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="type">char</span> __user *tmp = (<span class="type">char</span> __user *)ioctl_param; </span><br><span class="line">        <span class="type">char</span> ch; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Find the length of the message */</span> </span><br><span class="line">        get_user(ch, tmp); </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; ch &amp;&amp; i &lt; BUF_LEN; i++, tmp++) </span><br><span class="line">            get_user(ch, tmp); </span><br><span class="line"> </span><br><span class="line">        device_write(file, (<span class="type">char</span> __user *)ioctl_param, i, <span class="literal">NULL</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_GET_MSG: &#123; </span><br><span class="line">        <span class="type">loff_t</span> offset = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Give the current message to the calling process - the parameter </span></span><br><span class="line"><span class="comment">         * we got is a pointer, fill it. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        i = device_read(file, (<span class="type">char</span> __user *)ioctl_param, <span class="number">99</span>, &amp;offset); </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Put a zero at the end of the buffer, so it will be properly </span></span><br><span class="line"><span class="comment">         * terminated. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        put_user(<span class="string">&#x27;\0&#x27;</span>, (<span class="type">char</span> __user *)ioctl_param + i); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_GET_NTH_BYTE: </span><br><span class="line">        <span class="comment">/* This ioctl is both input (ioctl_param) and output (the return </span></span><br><span class="line"><span class="comment">         * value of this function). </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        ret = (<span class="type">long</span>)message[ioctl_param]; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* We&#x27;re now ready for our next caller */</span> </span><br><span class="line">    <span class="type">atomic_set</span>(&amp;already_open, CDEV_NOT_USED); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Module Declarations */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure will hold the functions to be called when a process does </span></span><br><span class="line"><span class="comment"> * something to the device we created. Since a pointer to this structure </span></span><br><span class="line"><span class="comment"> * is kept in the devices table, it can&#x27;t be local to init_module. NULL is </span></span><br><span class="line"><span class="comment"> * for unimplemented functions. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123; </span><br><span class="line">    .read = device_read, </span><br><span class="line">    .write = device_write, </span><br><span class="line">    .unlocked_ioctl = device_ioctl, </span><br><span class="line">    .open = device_open, </span><br><span class="line">    .release = device_release, <span class="comment">/* a.k.a. close */</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Initialize the module - Register the character device */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chardev2_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* Register the character device (atleast try) */</span> </span><br><span class="line">    <span class="type">int</span> ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &amp;fops); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Negative values signify an error */</span> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        pr_alert(<span class="string">&quot;%s failed with %d\n&quot;</span>, </span><br><span class="line">                 <span class="string">&quot;Sorry, registering the character device &quot;</span>, ret_val); </span><br><span class="line">        <span class="keyword">return</span> ret_val; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(6, 4, 0) </span></span><br><span class="line">    cls = class_create(DEVICE_FILE_NAME); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    cls = class_create(THIS_MODULE, DEVICE_FILE_NAME); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    device_create(cls, <span class="literal">NULL</span>, MKDEV(MAJOR_NUM, <span class="number">0</span>), <span class="literal">NULL</span>, DEVICE_FILE_NAME); </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;Device created on /dev/%s\n&quot;</span>, DEVICE_FILE_NAME); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Cleanup - unregister the appropriate file from /proc */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chardev2_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    device_destroy(cls, MKDEV(MAJOR_NUM, <span class="number">0</span>)); </span><br><span class="line">    class_destroy(cls); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Unregister the device */</span> </span><br><span class="line">    unregister_chrdev(MAJOR_NUM, DEVICE_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(chardev2_init); </span><br><span class="line">module_exit(chardev2_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>chardev.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * chardev.h - the header file with the ioctl definitions. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The declarations here have to be in a header file, because they need </span></span><br><span class="line"><span class="comment"> * to be known both to the kernel module (in chardev2.c) and the process </span></span><br><span class="line"><span class="comment"> * calling ioctl() (in userspace_ioctl.c). </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHARDEV_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHARDEV_H </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The major device number. We can not rely on dynamic registration </span></span><br><span class="line"><span class="comment"> * any more, because ioctls need to know it. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR_NUM 100 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Set the message of the device driver */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_SET_MSG _IOW(MAJOR_NUM, 0, char *) </span></span><br><span class="line"><span class="comment">/* _IOW means that we are creating an ioctl command number for passing </span></span><br><span class="line"><span class="comment"> * information from a user process to the kernel module. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The first arguments, MAJOR_NUM, is the major device number we are using. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The second argument is the number of the command (there could be several </span></span><br><span class="line"><span class="comment"> * with different meanings). </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The third argument is the type we want to get from the process to the </span></span><br><span class="line"><span class="comment"> * kernel. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Get the message of the device driver */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *) </span></span><br><span class="line"><span class="comment">/* This IOCTL is used for output, to get the message of the device driver. </span></span><br><span class="line"><span class="comment"> * However, we still need the buffer to place the message in to be input, </span></span><br><span class="line"><span class="comment"> * as it is allocated by the process. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Get the n&#x27;th byte of the message */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_GET_NTH_BYTE _IOWR(MAJOR_NUM, 2, int) </span></span><br><span class="line"><span class="comment">/* The IOCTL is used for both input and output. It receives from the user </span></span><br><span class="line"><span class="comment"> * a number, n, and returns message[n]. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The name of the device file */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_FILE_NAME <span class="string">&quot;char_dev&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_PATH <span class="string">&quot;/dev/char_dev&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>userspace_ioctl.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  userspace_ioctl.c - the process to use ioctl&#x27;s to control the kernel module </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  Until now we could have used cat for input and output.  But now </span></span><br><span class="line"><span class="comment"> *  we need to do ioctl&#x27;s, which require writing our own process.  </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* device specifics, such as ioctl numbers and the  </span></span><br><span class="line"><span class="comment"> * major device file. */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../chardev.h&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">/* standard I/O */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* open */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">/* close */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">/* exit */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span> <span class="comment">/* ioctl */</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Functions for the ioctl calls */</span> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_set_msg</span><span class="params">(<span class="type">int</span> file_desc, <span class="type">char</span> *message)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret_val; </span><br><span class="line"> </span><br><span class="line">    ret_val = ioctl(file_desc, IOCTL_SET_MSG, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl_set_msg failed:%d\n&quot;</span>, ret_val); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret_val; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_get_msg</span><span class="params">(<span class="type">int</span> file_desc)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret_val; </span><br><span class="line">    <span class="type">char</span> message[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Warning - this is dangerous because we don&#x27;t tell  </span></span><br><span class="line"><span class="comment">   * the kernel how far it&#x27;s allowed to write, so it  </span></span><br><span class="line"><span class="comment">   * might overflow the buffer. In a real production  </span></span><br><span class="line"><span class="comment">   * program, we would have used two ioctls - one to tell </span></span><br><span class="line"><span class="comment">   * the kernel the buffer length and another to give  </span></span><br><span class="line"><span class="comment">   * it the buffer to fill </span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">    ret_val = ioctl(file_desc, IOCTL_GET_MSG, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl_get_msg failed:%d\n&quot;</span>, ret_val); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_msg message:%s&quot;</span>, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret_val; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_get_nth_byte</span><span class="params">(<span class="type">int</span> file_desc)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i, c; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_nth_byte message:&quot;</span>); </span><br><span class="line"> </span><br><span class="line">    i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">do</span> &#123; </span><br><span class="line">        c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++); </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nioctl_get_nth_byte failed at the %d&#x27;th byte:\n&quot;</span>, i); </span><br><span class="line">            <span class="keyword">return</span> c; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">putchar</span>(c); </span><br><span class="line">    &#125; <span class="keyword">while</span> (c != <span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Main - Call the ioctl functions */</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> file_desc, ret_val; </span><br><span class="line">    <span class="type">char</span> *msg = <span class="string">&quot;Message passed by ioctl\n&quot;</span>; </span><br><span class="line"> </span><br><span class="line">    file_desc = open(DEVICE_PATH, O_RDWR); </span><br><span class="line">    <span class="keyword">if</span> (file_desc &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open device file: %s, error:%d\n&quot;</span>, DEVICE_PATH, </span><br><span class="line">               file_desc); </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    ret_val = ioctl_set_msg(file_desc, msg); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line">    ret_val = ioctl_get_nth_byte(file_desc); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line">    ret_val = ioctl_get_msg(file_desc); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    close(file_desc); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">error: </span><br><span class="line">    close(file_desc); </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240116115744234.png" alt="image-20240116115744234"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://eknight-eutopia.github.io">Eutopia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://eknight-eutopia.github.io/posts/79c0f484.html">https://eknight-eutopia.github.io/posts/79c0f484.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://eknight-eutopia.github.io" target="_blank">Small Utopia</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/">内核模块</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover%20(27).jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/b78b50e.html" title="Linux内核模块"><img class="cover" src="/img/cover/default_cover%20(5).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux内核模块</div></div><div class="info-2"><div class="info-item-1">Linux内核模块GCCGNC C Compiler —&gt; GNU Compiler Collection  包括编译器、链接器、binutils、glibc、头文件 支持多种语言（C、C++、Java、Go）和多种硬件平台（X86、ARM、MIPS、RISC-V）  Clang编译器的构成  Frontend：源码分析、语法检查，输出中间代码 Optimizer：对中间代码进行优化、使其运行更高效 Backend：将中间代码转换为某一个平台的机器代码  编译器的实现  GCC：前端和后端分离，支持多种语言、多个平台。但缺点：前后端耦合高，代码可重用性低。 LLVM（Low Level Virtual Machine）框架：模块化设计，代码可重用性高；中间语言LLVM IR，类C表达，可扩展各种前端、后端；支持C&#x2F;C++&#x2F;Java等语言 使用LLVM框架的编译器： LLVM...</div></div></div></a><a class="pagination-related" href="/posts/34143959.html" title="模糊测试分类"><img class="cover" src="/img/cover/default_cover%20(10).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">模糊测试分类</div></div><div class="info-2"><div class="info-item-1">模糊测试分类根据程序执行反馈的获取情况，可以将模糊测试分为白盒、黑盒和灰盒三类 一、白盒测试白盒测试通过分析被测程序的内部机制和执行被测程序时收集的信息来生成测试用例，白盒测试通常会对程序进行动态污点分析或符号执行以获取精确的程序分析和状态信息。 二、黑盒测试黑盒测试将测试对象当作黑盒，按照指定的规范随机生成测试用例。不提前分析程序内部机制也不接受反馈信息来更新测试用例。 三、灰盒测试灰盒测试的典型特点就是可以使用目标的执行反馈来指导测试用例的生成。  </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/54828bfc.html" title="Kernel Pwn 学习之路(一)"><img class="cover" src="/img/cover/default_cover%20(6).jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-24</div><div class="info-item-2">Kernel Pwn 学习之路(一)</div></div><div class="info-2"><div class="info-item-1">Kernel Pwn 学习之路(一)参考链接：Kernel Pwn 学习之路（一） 1. 前言本文主要介绍Kernel的相关知识以及栈溢出在Kernel中的利用。 2. Kernel简介本部分全文引用了CTF-Wiki的相关内容。 2.1 什么是Kernelkernel也是一个程序，用来管理软件发出的数据I&#x2F;O请求，讲这些要求转译为指令，交给CPU和计算机中的其他组件处理，kernel是现代操作系统最基本的部分。 Kernel最主要的功能有以下两点：  控制并与硬件进行交互 提供application能运行的环境  包括I&#x2F;O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。需要注意的是：kernel的crash通常会引起重启 2.2 Ring 模型intel CPU 将CPU的特权级别分为4个级别：Ring 0， Ring1，… ，Ring3。 Ring0只给OS使用，Ring3所有程序都可以使用，内层Ring可以随便使用外层Ring的资源。提升系统安全性 大多数操作系统只使用了Ring0，Ring3。 2.3 状态切换User...</div></div></div></a><a class="pagination-related" href="/posts/b78b50e.html" title="Linux内核模块"><img class="cover" src="/img/cover/default_cover%20(5).jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-04</div><div class="info-item-2">Linux内核模块</div></div><div class="info-2"><div class="info-item-1">Linux内核模块GCCGNC C Compiler —&gt; GNU Compiler Collection  包括编译器、链接器、binutils、glibc、头文件 支持多种语言（C、C++、Java、Go）和多种硬件平台（X86、ARM、MIPS、RISC-V）  Clang编译器的构成  Frontend：源码分析、语法检查，输出中间代码 Optimizer：对中间代码进行优化、使其运行更高效 Backend：将中间代码转换为某一个平台的机器代码  编译器的实现  GCC：前端和后端分离，支持多种语言、多个平台。但缺点：前后端耦合高，代码可重用性低。 LLVM（Low Level Virtual Machine）框架：模块化设计，代码可重用性高；中间语言LLVM IR，类C表达，可扩展各种前端、后端；支持C&#x2F;C++&#x2F;Java等语言 使用LLVM框架的编译器： LLVM...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LKM%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">LKM编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-1-Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">Chapter 1. Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-What-Is-A-Kernel-Module"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1. What Is A Kernel Module?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-How-Do-Modules-Get-Into-The-Kernel"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2. How Do Modules Get Into The Kernel?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter2-Hello-World"><span class="toc-number">1.2.</span> <span class="toc-text">Chapter2.Hello World</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Hello-World-part-1-The-Simplest-Module"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1. Hello, World (part 1): The Simplest Module</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-PrintK%EF%BC%88%EF%BC%89"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 PrintK（）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 编译内核模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">模块的加载流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-module%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">init_module系统调用流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Hello-World-part-2"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 Hello World (part 2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Hello-World-part-3-init-and-exit%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 Hello World (part 3):  __init and _exit宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Hello-World-part-4-Licensing-and-Module-Documentation"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 Hello World (part 4): Licensing and Module Documentation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%90%91%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E4%BC%A0%E9%80%92%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 向内核模块传递命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E6%A8%A1%E5%9D%97"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7 多文件编译模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8"><span class="toc-number">1.2.8.</span> <span class="toc-text">2.8 重新编译内核</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-%E5%88%9D%E6%AD%A5%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.</span> <span class="toc-text">Chapter 3 初步知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 模块与程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E6%A8%A1%E5%9D%97%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%E4%B8%8E%E7%BB%93%E6%9D%9F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1 模块如何开始与结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E6%A8%A1%E5%9D%97%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2  模块可以调用的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.1.3 用户空间与内核空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">3.1.4 命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-%E4%BB%A3%E7%A0%81%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">3.1.5 代码空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-6-Device-Drivers"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">3.1.6 Device Drivers</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-6-1-Major-and-Minor-Numbers"><span class="toc-number">1.3.1.6.1.</span> <span class="toc-text">3.1.6.1 Major and Minor Numbers</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-4-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">Chapter 4 字符设备文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 字符设备驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-file-operations-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">4.1.1 file_operations 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-file%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">4.1.2 file结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-Registering-A-Device"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">4.1.3 Registering A Device</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-Unregistering-A-Device"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">4.1.4 Unregistering A Device</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-chardev-c"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">4.1.5 chardev.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-6-%E5%85%BC%E5%AE%B9%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">4.1.6 兼容多个版本的内核模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-5-The-proc-File-System"><span class="toc-number">1.5.</span> <span class="toc-text">Chapter 5. The &#x2F;proc File System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-The-proc-File-System"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 The &#x2F;proc File System</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%AF%BB%E5%86%99-proc%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 读写&#x2F;proc文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Manage-proc-file-with-standard-filesystem"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 Manage &#x2F;proc file with standard filesystem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Manage-proc-file-with-seq-file"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 Manage &#x2F;proc file with seq_file</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-6-Interacting-with-your-module"><span class="toc-number">1.6.</span> <span class="toc-text">Chapter 6 Interacting with your module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-7-Talking-To-Device-Files"><span class="toc-number">1.7.</span> <span class="toc-text">Chapter 7. Talking To Device Files</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Talking-to-Device-Files-write-and-IOCTLS"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 Talking to Device Files (write and IOCTLS)</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Eutopia</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: '4c4d7e363cc61fad04a9',
      clientSecret: '93995fa6ff1a993b19e99287b2c362230cb33f11',
      repo: 'eknight-eutopia.github.io',
      owner: 'Eknight-Eutopia',
      admin: ['Eknight-Eutopia'],
      id: '472dccbb89aff6553f03dbeba1c8d62f',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>