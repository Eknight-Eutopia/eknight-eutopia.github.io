<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>V8内存回收机制 | Small Utopia</title><meta name="robots" content="noindex"><meta name="author" content="Eutopia"><meta name="copyright" content="Eutopia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="V8内存回收机制V8 的垃圾回收机制及其历史学习下Client V8的垃圾回收机制：  总结 V8 采用的垃圾回收算法 V8 的垃圾回收机制有哪些创新，分别在哪些时候引入的  V8采用的垃圾回收算法（2019年）内存回收机制的基本组成部分  识别存活&#x2F;已死亡对象 回收死亡对象的内存 整合·分片化内存（可选）   These tasks can be performed in sequen">
<meta property="og:type" content="article">
<meta property="og:title" content="V8内存回收机制">
<meta property="og:url" content="https://eknight-eutopia.github.io/posts/f020ea55.html">
<meta property="og:site_name" content="Small Utopia">
<meta property="og:description" content="V8内存回收机制V8 的垃圾回收机制及其历史学习下Client V8的垃圾回收机制：  总结 V8 采用的垃圾回收算法 V8 的垃圾回收机制有哪些创新，分别在哪些时候引入的  V8采用的垃圾回收算法（2019年）内存回收机制的基本组成部分  识别存活&#x2F;已死亡对象 回收死亡对象的内存 整合·分片化内存（可选）   These tasks can be performed in sequen">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://eknight-eutopia.github.io/img/cover/default_cover%20(30).jpg">
<meta property="article:published_time" content="2025-07-13T16:00:00.000Z">
<meta property="article:modified_time" content="2025-07-25T07:09:55.581Z">
<meta property="article:author" content="Eutopia">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eknight-eutopia.github.io/img/cover/default_cover%20(30).jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://eknight-eutopia.github.io/posts/f020ea55.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b2bb076b3ca994b59d55f4681f7e3427";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'V8内存回收机制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-25 15:09:55'
}</script><link rel="stylesheet" href="/config/css/transparancy.css"><link rel="stylesheet" href="/config/css/edit-icon-anime.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">55</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-blog"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/sitetime"><i class="fa-fw fas fa-hourglass-end"></i><span> 时间轴</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw far fa-paper-plane"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Small Utopia</span></a><a class="nav-page-title" href="/"><span class="site-name">V8内存回收机制</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-blog"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/sitetime"><i class="fa-fw fas fa-hourglass-end"></i><span> 时间轴</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw far fa-paper-plane"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">V8内存回收机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-13T16:00:00.000Z" title="发表于 2025-07-14 00:00:00">2025-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-25T07:09:55.581Z" title="更新于 2025-07-25 15:09:55">2025-07-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/">CTF</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="V8内存回收机制"><a href="#V8内存回收机制" class="headerlink" title="V8内存回收机制"></a>V8内存回收机制</h2><h3 id="V8-的垃圾回收机制及其历史"><a href="#V8-的垃圾回收机制及其历史" class="headerlink" title="V8 的垃圾回收机制及其历史"></a>V8 的垃圾回收机制及其历史</h3><p>学习下Client V8的垃圾回收机制：</p>
<ul>
<li>总结 V8 采用的垃圾回收算法</li>
<li>V8 的垃圾回收机制有哪些创新，分别在哪些时候引入的</li>
</ul>
<h3 id="V8采用的垃圾回收算法（2019年）"><a href="#V8采用的垃圾回收算法（2019年）" class="headerlink" title="V8采用的垃圾回收算法（2019年）"></a>V8采用的垃圾回收算法（2019年）</h3><p>内存回收机制的基本组成部分</p>
<ol>
<li>识别存活&#x2F;已死亡对象</li>
<li>回收死亡对象的内存</li>
<li>整合·分片化内存（可选）</li>
</ol>
<blockquote>
<p>These tasks can be performed in sequence or can be arbitrarily interleaved. A straight-forward approach is to pause JavaScript execution and perform each of these tasks in sequence on the main thread. This can cause jank and latency issues on the main thread, which we’ve talked about in <a target="_blank" rel="noopener" href="https://v8.dev/blog/jank-busters">previous</a> <a target="_blank" rel="noopener" href="https://v8.dev/blog/orinoco">blog posts</a>, as well as reduced program throughput.</p>
</blockquote>
<p>v8垃圾回收机制分为Major GC和Minor GC两种内存回收器</p>
<ul>
<li>Major GC：Mark Compact &amp; Minor Mark Sweep（针对整个堆空间）</li>
<li>Minor GC：Scavenger（针对新生代）</li>
</ul>
<h4 id="Major-GC-Full-Mark-Compact"><a href="#Major-GC-Full-Mark-Compact" class="headerlink" title="Major GC (Full Mark-Compact)"></a>Major GC (Full Mark-Compact)</h4><p>major gc负责从整个堆内存中回收垃圾内存。</p>
<img src="/posts/f020ea55/image-20250716132400706.png" class="" title="image-20250716132400706">

<p>上图为最简单的版本，将Major GC 分为三个阶段: marking, sweeping and compacting，存在很大的延迟，影响性能。</p>
<h5 id="Marking"><a href="#Marking" class="headerlink" title="Marking"></a>Marking</h5><p>通过可达性判断对象是否存活（可达：当前运行状态可引用的对象；不可达：其他所有不被引用对象）</p>
<p>首先从已知对象指针根集合（执行栈、全局对象）开始查找指针对应对象并将其标记为可达，然后递归遍历。</p>
<blockquote>
<p>Figuring out which objects can be collected is an essential part of garbage collection. Garbage collectors do this by using reachability as a proxy for ‘liveness’. This means that any object currently reachable within the runtime must be kept, and any unreachable objects may be collected.</p>
<p>Marking is the process by which reachable objects are found. The GC starts at a set of known objects pointers, called the root set. This includes the execution stack and the global object. It then follows each pointer to a JavaScript object, and marks that object as reachable. The GC follows every pointer in that object, and continues this process recursively, until every object that is reachable in the runtime has been found and marked.</p>
</blockquote>
<h5 id="Sweeping"><a href="#Sweeping" class="headerlink" title="Sweeping"></a>Sweeping</h5><p>将死亡对象（不可达对象）添加到free-lists。每一段内存区域对应一个free-list，方便后续查找死亡对象进行释放以及重新申请内存。</p>
<blockquote>
<p>Sweeping is a process where gaps in memory left by dead objects are added to a data structure called a free-list. Once marking has completed, the GC finds contiguous gaps left by unreachable objects and adds them to the appropriate free-list. Free-lists are separated by the size of the memory chunk for quick lookup. In the future when we want to allocate memory, we just look at the free-list and find an appropriately sized chunk of memory.</p>
</blockquote>
<h5 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h5><p>major会此阶段选择两种策略Evacuate&#x2F;Compact，根据该内存页的分片情况。</p>
<p>Compact策略是将分片比较严重的内存页中的存活对象复制到其他内存页，从而保证该内存页仅剩死亡对象，方便后续的内存回收。</p>
<p>弊端：需要复制大量的存活对象，因此仅当内存页分片比较严重时才会这样做。其他情况则仅做sweeping操作，<strong>（Evacuate？）</strong></p>
<blockquote>
<p>The major GC also chooses to evacuate&#x2F;compact some pages, based on a fragmentation heuristic. You can think of compaction sort of like hard-disk defragmentation on an old PC. We copy surviving objects into other pages that are not currently being compacted (using the free-list for that page). This way, we can make use of the small and scattered gaps within the memory left behind by dead objects. </p>
<p>One potential weakness of a garbage collector which copies surviving objects is that when we allocate a lot of long-living objects, we pay a high cost to copy these objects. This is why we choose to compact only some highly fragmented pages, and just perform sweeping on others, which does not copy surviving objects.</p>
</blockquote>
<h3 id="Generational-layout"><a href="#Generational-layout" class="headerlink" title="Generational layout"></a>Generational layout</h3><p>V8中的堆内存被分为不同的区域，称为“代际”。新生代（分为nursery和intermediate）和老生代。</p>
<p>初始申请对象的堆内存时，将其申请在nursery空间。如果在下一次GC后，该对象仍然标记为存活，则将其<strong>移动</strong>到intermediate区域。如果再一次GC后，该对象仍然存活，则将其<strong>移动</strong>到老生代区域。（基于大部分申请对象的存活周期都比较短的观察）。</p>




<blockquote>
<p>The heap in V8 is split into different regions called <a target="_blank" rel="noopener" href="https://v8.dev/blog/orinoco-parallel-scavenger">generations</a>. There is a young generation (split further into ‘nursery’ and ‘intermediate’ sub-generations), and an old generation. Objects are first allocated into the nursery. If they survive the next GC, they remain in the young generation but are considered ‘intermediate’. If they survive yet another GC, they are moved into the old generation.</p>
<p>The V8 heap is split into generations. Objects are moved through generations when they survive a GC.</p>
<p>In garbage collection there is an important term: “The Generational Hypothesis”. This basically states that most objects die young. In other words, most objects are allocated and then almost immediately become unreachable, from the perspective of the GC. This holds not only for V8 or JavaScript, but for most dynamic languages.</p>
<p>V8’s generational heap layout is designed to exploit this fact about object lifetimes. The GC is a compacting&#x2F;moving GC, which means that it copies objects which survive garbage collection. This seems counterintuitive: copying objects is expensive at GC time. But we know that only a very small percentage of objects actually survive a garbage collection, according to the generational hypothesis. By moving only the objects which survive, every other allocation becomes ‘implicit’ garbage. This means that we only pay a cost (for copying) proportional to the number of surviving objects, not the number of allocations.</p>
</blockquote>
<h3 id="Minor-GC-Scavenger"><a href="#Minor-GC-Scavenger" class="headerlink" title="Minor GC (Scavenger)"></a>Minor GC (Scavenger)</h3><h4 id="Cheney’s-Semispace-Copy"><a href="#Cheney’s-Semispace-Copy" class="headerlink" title="Cheney’s Semispace Copy"></a>Cheney’s Semispace Copy</h4><p>分为三步（Marking，Evacuating，Pointer-updating）</p>
<p>每次gc后存活对象会被迁移到新的内存页。使用”semi-space”设计，一半为全空<strong>（From-Space，intermediate）</strong>，另一半为Nursery区域<strong>（To-Space）</strong>。</p>
<p>在scavenging过程中，需要额外维护一个根集合（<strong>Old-to-young generation references：老生代的指针引用新生代的对象</strong>）。使用write-barriers来维护该集合。（When combined with the stack and globals, we know every reference into the young generation, without the need to trace through the entire old generation.？？？）</p>


<p><strong>Marking：</strong>以调用栈以及old-to-young generation reference作为根集合开始递归搜索并移动。</p>
<h5 id="Write-barriers"><a href="#Write-barriers" class="headerlink" title="Write-barriers"></a>Write-barriers</h5>

<p>具体见[[2025-07-25-Write Barrier.md|Write-barriers]]</p>
<h5 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h5><p>V8使用三色标记法来标记对象，每个对象通过两个标记位和一个标记列表来实现标记，两个标记为标识三种颜色：白色（00）、灰色（10）和黑色（11）。最初所有对象都是白色，当垃圾回收器发现白色物体并将其推送到标记列表时，它会变成灰色。当收集器从标记工作列表弹出对象并访问其所有字段时，灰色对象变为黑色。当不再有灰色对象时，标记完成，所有剩余白色物体都无法到达，可以安全地回收。</p>


<p><strong>Evacuation：</strong>将所有存活对象移动到一段连续内存，可以解决内存分片的问题。然后将两个空间翻转重新开始下一轮gc。</p>


<p>两轮都存活则移动到old-space。</p>
<p><strong>Pointer-Updating：</strong> 最后更新指向移动过的对象的指针。每一个拷贝的对象都会遗留一个forwarding-address来更新原指针指向新地址。</p>
<blockquote>
<p>There are two garbage collectors in V8. The <a target="_blank" rel="noopener" href="https://v8.dev/blog/trash-talk#major-gc"><strong>Major GC (Mark-Compact)</strong></a> collects garbage from the whole heap. The <strong>Minor GC (Scavenger)</strong> collects garbage in the young generation. The major GC is effective at collecting garbage from the whole heap, but the generational hypothesis tells us that newly allocated objects are very likely to need garbage collection.</p>
<p>In the Scavenger, which only collects within the young generation, surviving objects are always evacuated to a new page. V8 uses a ‘semi-space’ design for the young generation. This means that half of the total space is always empty, to allow for this evacuation step. During a scavenge, this initially-empty area is called ‘To-Space’. The area we copy from is called ‘From-Space’. In the worst case, every object could survive the scavenge and we would need to copy every object.</p>
<p>For scavenging, we have an additional set of roots which are the old-to-new references. These are pointers in old-space that refer to objects in the young generation. Rather than tracing the entire heap graph for every scavenge, we use <a target="_blank" rel="noopener" href="https://www.memorymanagement.org/glossary/w.html#term-write-barrier">write barriers</a> to maintain a list of old-to-new references. When combined with the stack and globals, we know every reference into the young generation, without the need to trace through the entire old generation.</p>
<p>The evacuation step moves all surviving objects to a contiguous chunk of memory (within a page). This has the advantage of completing removing fragmentation - gaps left by dead objects. We then switch around the two spaces i.e. To-Space becomes From-Space and vice-versa. Once GC is completed, new allocations happen at the next free address in the From-Space.</p>
<p>The scavenger evacuates live objects to a fresh page.</p>
<p>We quickly run out of space in the young generation with this strategy alone. Objects that survive a second GC are evacuated into the old generation, rather than To-Space.</p>
<p>The final step of scavenging is to update the pointers that reference the original objects, which have been moved. Every copied object leaves a forwarding-address which is used to update the original pointer to point to the new location.</p>
<p>The scavenger evacuates ‘intermediate’ objects to the old generation, and ‘nursery’ objects to a fresh page.</p>
<p>In scavenging we actually do these three steps — marking, evacuating, and pointer-updating — all interleaved, rather than in distinct phases.</p>
</blockquote>
<h4 id="parallel-Mark-Evacuate（Since-V6-2）"><a href="#parallel-Mark-Evacuate（Since-V6-2）" class="headerlink" title="parallel Mark-Evacuate（Since V6.2）"></a>parallel Mark-Evacuate（Since V6.2）</h4><p>基于Major GC的Mark-Sweep-Compact垃圾回收器实现。分为三步（Marking， Copying，Updating pointers）</p>
<p>没有使用sweep机制，仍然使用semispace机制来保证compact特性。</p>
<p>分为多个线程，分别负责一段内存区域；每一个阶段完成进入下一阶段前需要进行线程间同步。</p>
<h5 id="parallel-Scavenge"><a href="#parallel-Scavenge" class="headerlink" title="parallel Scavenge"></a>parallel Scavenge</h5><p>将parallel Mark-Evacuate的三个阶段合并起来，每个内存页维护rememberd set。对象并行处理，新发现的对象被添加到global work list用于gc线程处理。<strong>write barrier确保了当前处理对象不适合gc处理时，不会过早终止</strong></p>
<p>与parallel Scavenge的区别见：[[2025-07-25-parallel Mark-Evaculate vs parallel Scavenge|Parallel Mark-Evaculate vs Parallel Scavenge]]</p>
<h3 id="Orinoco-GC项目名称"><a href="#Orinoco-GC项目名称" class="headerlink" title="Orinoco(GC项目名称)"></a>Orinoco(GC项目名称)</h3><p>介绍一些gc里面的名词</p>
<h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4>

<blockquote>
<p>Parallel is where the main thread and helper threads do a roughly equal amount of work at the same time. This is still a ‘stop-the-world’ approach, but the total pause time is now divided by the number of threads participating (plus some overhead for synchronization). This is the easiest of the three techniques. The JavaScript heap is paused as there is no JavaScript running, so each helper thread just needs to make sure it synchronizes access to any objects that another helper might also want to access.</p>
<p>The main thread and helper threads work on the same task at the same time.</p>
</blockquote>
<h4 id="Incremental"><a href="#Incremental" class="headerlink" title="Incremental"></a>Incremental</h4>

<blockquote>
<p>Incremental is where the main thread does a small amount of work intermittently. We don’t do an entire GC in an incremental pause, just a small slice of the total work required for the GC. This is more difficult, because JavaScript executes between each incremental work segment, meaning that the state of the heap has changed, which might invalidate previous work that was done incrementally. As you can see from the diagram, this does not reduce the amount of time spent on the main thread (in fact, it usually increases it slightly), it just spreads it out over time. This is still a good technique for solving one of our original problems: main thread latency. By allowing JavaScript to run intermittently, but also continue garbage collection tasks, the application can still respond to user input and make progress on animation.</p>
<p>Small chunks of the GC task are interleaved into the main thread execution.</p>
</blockquote>
<h4 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h4>

<blockquote>
<p>Concurrent is when the main thread executes JavaScript constantly, and helper threads do GC work totally in the background. This is the most difficult of the three techniques: anything on the JavaScript heap can change at any time, invalidating work we have done previously. On top of that, there are now read&#x2F;write races to worry about as helper threads and the main thread simultaneously read or modify the same objects. The advantage here is that the main thread is totally free to execute JavaScript — although there is minor overhead due to some synchronization with helper threads.</p>
<p>GC tasks happen entirely in the background. The main thread is free to run JavaScript.</p>
</blockquote>
<h3 id="垃圾回收机制的创新，哪些时候引入的"><a href="#垃圾回收机制的创新，哪些时候引入的" class="headerlink" title="垃圾回收机制的创新，哪些时候引入的"></a>垃圾回收机制的创新，哪些时候引入的</h3><h5 id="Jank-Busters-Part-One（2015）"><a href="#Jank-Busters-Part-One（2015）" class="headerlink" title="Jank Busters Part One（2015）"></a>Jank Busters Part One（2015）</h5><p>原始版本：Chrome 41 -&gt; 46</p>
<p>优化前：</p>


<p>优化后：</p>


<h4 id="Jank-Busters-Part-Two（2016）"><a href="#Jank-Busters-Part-Two（2016）" class="headerlink" title="Jank Busters Part Two（2016）"></a>Jank Busters Part Two（2016）</h4><p><strong>优化1</strong>：实现了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#Generational">generational garbage collector</a>，同时实现parallel处理</p>
<p>优化前：</p>


<p>优化后：</p>


<p><strong>优化2</strong>：更新了跟踪指针方式（rememberd set）</p>




<p><strong>优化3</strong>：black allocation（V8 5.1），对垃圾回收的标记阶段的提升</p>
<h4 id="State-of-GC-in-V8"><a href="#State-of-GC-in-V8" class="headerlink" title="State of GC in V8"></a>State of GC in V8</h4><h5 id="Scavenging"><a href="#Scavenging" class="headerlink" title="Scavenging"></a>Scavenging</h5><p>parallel scavenging</p>


<blockquote>
<p>Today, V8 uses parallel scavenging to distribute work across helper threads during the young generation GC. Each thread receives a number of pointers, which it follows, eagerly evacuating any live objects into To-Space. The scavenging tasks have to synchronize via atomic read&#x2F;write&#x2F;compare-and-swap operations when trying to evacuate an object; another scavenging task may have found the same object via a different path and also try to move it. Whichever helper moved the object successfully then goes back and updates the pointer. It leaves a forwarding pointer so that other workers which reach the object can update other pointers as they find them. For fast synchronization-free allocation of surviving objects, the scavenging tasks use thread-local allocation buffers.</p>
<p>Parallel scavenging distributes scavenging work across multiple helper threads and the main thread.</p>
</blockquote>
<h5 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h5><p>concurrent Marking，concurrent Sweeping &#x2F; parallel compaction + pointer updating</p>


<blockquote>
<p>Major GC in V8 starts with concurrent marking. As the heap approaches a dynamically computed limit, concurrent marking tasks are started. The helpers are each given a number of pointers to follow, and they mark each object they find as they follow all references from discovered objects. Concurrent marking happens entirely in the background while JavaScript is executing on the main thread. <a target="_blank" rel="noopener" href="https://dl.acm.org/citation.cfm?id=2025255">Write barriers</a> are used to keep track of new references between objects that JavaScript creates while the helpers are marking concurrently.</p>
<p>The major GC uses concurrent marking and sweeping, and parallel compaction and pointer updating.</p>
<p>When the concurrent marking is finished, or we reach the dynamic allocation limit, the main thread performs a quick marking finalization step. The main thread pause begins during this phase. This represents the total pause time of the major GC. The main thread scans the roots once again, to ensure that all live objects are marked, and then along with a number of helpers, starts parallel compaction and pointer updating. Not all pages in old-space are eligible for compaction — those that aren’t will be swept using the free-lists mentioned earlier. The main thread starts concurrent sweeping tasks during the pause. These run concurrently to the parallel compaction tasks and to the main thread itself — they can continue even when JavaScript is running on the main thread.</p>
</blockquote>
<h5 id="Idle-time-GC"><a href="#Idle-time-GC" class="headerlink" title="Idle-time GC"></a>Idle-time GC</h5><p>空闲时间gc</p>


<blockquote>
<p>Users of JavaScript don’t have direct access to the garbage collector; it is totally implementation-defined. V8 does however provide a mechanism for the embedder to trigger garbage collection, even if the JavaScript program itself can’t. The GC can post ‘Idle Tasks’ which are optional work that would eventually be triggered anyway. Embedders like Chrome might have some notion of free or idle time. For example in Chrome, at 60 frames per second, the browser has approximately 16.6 ms to render each frame of an animation. If the animation work is completed early, Chrome can choose to run some of these idle tasks that the GC has created in the spare time before the next frame.</p>
<p>Idle GC makes use of free time on the main thread to perform GC work proactively.</p>
<p>For more details, refer to <a target="_blank" rel="noopener" href="https://queue.acm.org/detail.cfm?id=2977741">our in-depth publication on idle-time GC</a>.</p>
</blockquote>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>源码位置在<code>//v8/src/heap/</code>目录下。</p>
<p>需要关注分析的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">some basic utils</span></span><br><span class="line">heap.cc -&gt; heap definition</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">minor gc</span></span><br><span class="line">scavenger.cc -&gt; minor gc scavenger</span><br><span class="line">minor-mark-sweep.cc -&gt; minor gc mark sweep</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">major gc</span></span><br><span class="line">mark-compact.cc -&gt; major gc mark compact</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">some techniques</span></span><br><span class="line">evacuation-allocator.cc -&gt; minor gc evacuation</span><br><span class="line">incremental-marking.cc -&gt; incremental-marking</span><br></pre></td></tr></table></figure>



<img src="/posts/f020ea55/image-20250715215021268.png" class="" title="image-20250715215021268">

<img src="/posts/f020ea55/image-20250715214723482.png" class="" title="image-20250715214723482">

<h4 id="Scavenger-cc"><a href="#Scavenger-cc" class="headerlink" title="Scavenger.cc"></a>Scavenger.cc</h4><h3 id="历史漏洞分析"><a href="#历史漏洞分析" class="headerlink" title="历史漏洞分析"></a>历史漏洞分析</h3><h4 id="Chrome-V8命令执行漏洞（CVE-2022-1310）分析"><a href="#Chrome-V8命令执行漏洞（CVE-2022-1310）分析" class="headerlink" title="Chrome V8命令执行漏洞（CVE-2022-1310）分析"></a>Chrome V8命令执行漏洞（CVE-2022-1310）分析</h4><h4 id="chrome-v8漏洞CVE-2021-37975浅析"><a href="#chrome-v8漏洞CVE-2021-37975浅析" class="headerlink" title="chrome v8漏洞CVE-2021-37975浅析"></a>chrome v8漏洞CVE-2021-37975浅析</h4><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a target="_blank" rel="noopener" href="https://v8.dev/blog/trash-talk">Trash talk: the Orinoco garbage collector</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/688350947">[V8引擎]内存管理和垃圾回收(GC)</a></li>
<li><a target="_blank" rel="noopener" href="https://v8.dev/blog/jank-busters">jank-busters</a></li>
<li><a target="_blank" rel="noopener" href="https://v8.dev/blog/orinoco">orinoco</a></li>
<li><a target="_blank" rel="noopener" href="https://v8.dev/blog/orinoco-parallel-scavenger">Orinoco: young generation garbage collection</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/vuls/339684.html">Chrome V8命令执行漏洞（CVE-2022-1310）分析</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-281657.htm">[原创]chrome v8漏洞CVE-2021-37975浅析</a></li>
</ul>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://eknight-eutopia.github.io">Eutopia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://eknight-eutopia.github.io/posts/f020ea55.html">https://eknight-eutopia.github.io/posts/f020ea55.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://eknight-eutopia.github.io" target="_blank">Small Utopia</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/cover/default_cover%20(30).jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#V8%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">V8内存回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#V8-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%86%E5%8F%B2"><span class="toc-number">1.1.</span> <span class="toc-text">V8 的垃圾回收机制及其历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V8%E9%87%87%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%882019%E5%B9%B4%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">V8采用的垃圾回收算法（2019年）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Major-GC-Full-Mark-Compact"><span class="toc-number">1.2.1.</span> <span class="toc-text">Major GC (Full Mark-Compact)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Marking"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Marking</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sweeping"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Sweeping</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Compaction"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">Compaction</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generational-layout"><span class="toc-number">1.3.</span> <span class="toc-text">Generational layout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC-Scavenger"><span class="toc-number">1.4.</span> <span class="toc-text">Minor GC (Scavenger)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cheney%E2%80%99s-Semispace-Copy"><span class="toc-number">1.4.1.</span> <span class="toc-text">Cheney’s Semispace Copy</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Write-barriers"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Write-barriers</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">三色标记法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parallel-Mark-Evacuate%EF%BC%88Since-V6-2%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">parallel Mark-Evacuate（Since V6.2）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#parallel-Scavenge"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">parallel Scavenge</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Orinoco-GC%E9%A1%B9%E7%9B%AE%E5%90%8D%E7%A7%B0"><span class="toc-number">1.5.</span> <span class="toc-text">Orinoco(GC项目名称)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel"><span class="toc-number">1.5.1.</span> <span class="toc-text">Parallel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Incremental"><span class="toc-number">1.5.2.</span> <span class="toc-text">Incremental</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Concurrent"><span class="toc-number">1.5.3.</span> <span class="toc-text">Concurrent</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%9B%E6%96%B0%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%97%B6%E5%80%99%E5%BC%95%E5%85%A5%E7%9A%84"><span class="toc-number">1.6.</span> <span class="toc-text">垃圾回收机制的创新，哪些时候引入的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Jank-Busters-Part-One%EF%BC%882015%EF%BC%89"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">Jank Busters Part One（2015）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jank-Busters-Part-Two%EF%BC%882016%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">Jank Busters Part Two（2016）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#State-of-GC-in-V8"><span class="toc-number">1.6.2.</span> <span class="toc-text">State of GC in V8</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Scavenging"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">Scavenging</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Major-GC"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">Major GC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Idle-time-GC"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">Idle-time GC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.7.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scavenger-cc"><span class="toc-number">1.7.1.</span> <span class="toc-text">Scavenger.cc</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">1.8.</span> <span class="toc-text">历史漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Chrome-V8%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-1310%EF%BC%89%E5%88%86%E6%9E%90"><span class="toc-number">1.8.1.</span> <span class="toc-text">Chrome V8命令执行漏洞（CVE-2022-1310）分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chrome-v8%E6%BC%8F%E6%B4%9ECVE-2021-37975%E6%B5%85%E6%9E%90"><span class="toc-number">1.8.2.</span> <span class="toc-text">chrome v8漏洞CVE-2021-37975浅析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">1.9.</span> <span class="toc-text">参考文献</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Eutopia</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: '4c4d7e363cc61fad04a9',
      clientSecret: '93995fa6ff1a993b19e99287b2c362230cb33f11',
      repo: 'eknight-eutopia.github.io',
      owner: 'Eknight-Eutopia',
      admin: ['Eknight-Eutopia'],
      id: 'c28e6dca743fd7f46576766e371e3db6',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>