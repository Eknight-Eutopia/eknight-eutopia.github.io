---
title: Parallel Mark-Evaculate vs Parallel Scavenge
top_img: transparent
hidden: true
abbrlink: 
categories:
  - CTF
date:
tags:
---



直接贴下gpt的回答

`Parallel Mark-Evacuate` 和 `Parallel Scavenge` 是两种并行垃圾回收算法，虽然它们都旨在提高垃圾回收的效率，但它们的设计理念和实现方式有明显的不同。以下是两者的主要区别：

---

### **1. 阶段的处理方式**
#### **Parallel Mark-Evacuate**
- **分阶段处理**：该算法将垃圾回收过程分为三个独立的阶段：
  1. **标记阶段**：标记存活对象。
  2. **复制阶段**：将存活对象复制到目标空间（to-space）。
  3. **更新指针阶段**：更新所有对象间的指针以指向新复制的对象。
- **锁步执行**：每个阶段都在所有线程之间同步完成后，才能进入下一个阶段。这意味着虽然每个阶段内是并行的，但阶段之间是严格串行的。
- **特点**：这种方式更接近传统的垃圾回收设计，强调阶段的清晰划分和同步。

#### **Parallel Scavenge**
- **阶段融合**：该算法将标记、复制和更新指针的三个阶段融合在一起，所有操作在同一时间内交替进行。
- **动态任务分配**：通过动态工作窃取（dynamic work stealing）和简单的负载均衡机制，线程可以在处理过程中动态分配任务。
- **特点**：由于阶段间没有严格的同步屏障，工作可以更高效地利用多线程资源，减少了阶段间的等待时间。

---

### **2. 工作分配方式**
#### **Parallel Mark-Evacuate**
- **基于逻辑页面分配工作**：每个线程处理特定的逻辑页面，分配的工作比较静态。
- **本地分配缓冲区（LABs）**：每个线程在复制阶段使用自己的本地分配缓冲区，完成后再合并到全局空间。
- **同步点**：每个阶段完成后需要线程间同步，确保所有线程都完成当前阶段的任务。

#### **Parallel Scavenge**
- **基于动态工作窃取**：线程可以从全局工作列表中窃取任务，分配的工作更加动态。
- **全局工作列表**：新发现的对象会被添加到全局工作列表中，其他线程可以从中获取任务，提升效率。
- **无阶段同步**：由于阶段融合，线程不需要在阶段之间同步，而是直接处理当前任务中的所有操作（标记、复制和更新）。

---

### **3. 适用场景**
#### **Parallel Mark-Evacuate**
- **更适合复杂的垃圾回收需求**：由于阶段清晰分离，更容易调试和扩展。例如，如果需要对某一阶段进行特定优化或修改，这种设计更具灵活性。
- **适用于需要严格阶段性控制的情况**：例如某些实时系统可能更倾向于明确的阶段划分。

#### **Parallel Scavenge**
- **更适合高吞吐量场景**：由于阶段融合和动态任务分配，它能够更高效地利用多线程资源，适合需要最大化垃圾回收性能的场景。
- **适用于年轻代垃圾回收**：由于年轻代的对象生命周期较短，通常更适合采用类似 Halstead’s semispace collector 的算法。

---

### **4. 复杂性与实现成本**
#### **Parallel Mark-Evacuate**
- **实现复杂度较低**：由于阶段分离，逻辑更清晰，容易实现和维护。
- **同步开销较大**：阶段之间的同步可能会带来额外的开销，尤其是在线程数较多时。

#### **Parallel Scavenge**
- **实现复杂度较高**：由于阶段融合和动态工作窃取机制，实现起来更加复杂。
- **更高的资源利用率**：通过动态分配任务和融合阶段，能够更高效地利用多线程资源。

---

### **5. 内存管理**
#### **Parallel Mark-Evacuate**
- **年轻代使用 semispace**：年轻代内存被管理为 semispace，每次垃圾回收时将存活对象复制到 to-space，保持年轻代始终是紧凑的。
- **全局合并本地分配缓冲区**：线程完成复制后需要将本地分配缓冲区的数据合并到全局空间。

#### **Parallel Scavenge**
- **动态维护 remembered sets**：每页维护一个 remembered set，用于记录老年代到年轻代

